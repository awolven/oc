/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.0
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */


#ifndef SWIGCFFI
#define SWIGCFFI
#endif


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif



#ifdef __cplusplus
#  define EXTERN   extern "C"
#else
#  define EXTERN   extern
#endif

#define EXPORT   EXTERN SWIGEXPORT

#include <string.h>



#ifdef __cplusplus
#  define EXTERN   extern "C"
#else
#  define EXTERN   extern
#endif

#define EXPORT   EXTERN SWIGEXPORT

#include <string.h>
#include <stdlib.h>


  EXPORT void (* signal_lisp_error) (const char* message) = 0;
  

#include <Standard_Failure.hxx>
#include <Standard_ErrorHandler.hxx>
  
/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1
#define  SWIG_IOError        	   -2
#define  SWIG_RuntimeError   	   -3
#define  SWIG_IndexError     	   -4
#define  SWIG_TypeError      	   -5
#define  SWIG_DivisionByZero 	   -6
#define  SWIG_OverflowError  	   -7
#define  SWIG_SyntaxError    	   -8
#define  SWIG_ValueError     	   -9
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12
#define  SWIG_NullReferenceError   -13




#include <typeinfo>
#include <stdexcept>


#include <Standard.hxx>
#include <Standard_DefineAlloc.hxx>
#include <Standard_Handle.hxx>
#include <Standard_Transient.hxx>
  

#include <Standard_Transient.hxx>
#include <MMgt_TShared.hxx>
  
SWIGINTERN Standard_Integer Handle_MMgt_TShared_GetRefCount(Handle_MMgt_TShared *self){
    return (*self)->GetRefCount();
  }
EXPORT Standard_Integer _wrap_Handle_MMgt_TShared_GetRefCount (Handle_MMgt_TShared *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_MMgt_TShared *arg1 = (Handle_MMgt_TShared *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_MMgt_TShared_GetRefCount(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Handle_MMgt_TShared_GetRefCount\n  * wrapname: _wrap_Handle_MMgt_TShared_GetRefCount\n  * fulldecl: Standard_Integer Handle_MMgt_TShared::GetRefCount()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN void Handle_MMgt_TShared_IncrementRefCounter(Handle_MMgt_TShared *self){
    (*self)->IncrementRefCounter();
  }
EXPORT void _wrap_Handle_MMgt_TShared_IncrementRefCounter (Handle_MMgt_TShared *larg1) {
  Handle_MMgt_TShared *arg1 = (Handle_MMgt_TShared *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_MMgt_TShared_IncrementRefCounter(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Handle_MMgt_TShared_IncrementRefCounter\n  * wrapname: _wrap_Handle_MMgt_TShared_IncrementRefCounter\n  * fulldecl: void Handle_MMgt_TShared::IncrementRefCounter()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Integer Handle_MMgt_TShared_DecrementRefCounter(Handle_MMgt_TShared *self){
    return (* self)->DecrementRefCounter();
  }
EXPORT Standard_Integer _wrap_Handle_MMgt_TShared_DecrementRefCounter (Handle_MMgt_TShared *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_MMgt_TShared *arg1 = (Handle_MMgt_TShared *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_MMgt_TShared_DecrementRefCounter(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Handle_MMgt_TShared_DecrementRefCounter\n  * wrapname: _wrap_Handle_MMgt_TShared_DecrementRefCounter\n  * fulldecl: Standard_Integer Handle_MMgt_TShared::DecrementRefCounter()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN MMgt_TShared *Handle_MMgt_TShared_get(Handle_MMgt_TShared *self){
    return self->get();
  }
EXPORT MMgt_TShared *_wrap_Handle_MMgt_TShared_get (Handle_MMgt_TShared *larg1) {
  MMgt_TShared * lresult = (MMgt_TShared *)0 ;
  Handle_MMgt_TShared *arg1 = (Handle_MMgt_TShared *) 0 ;
  MMgt_TShared *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (MMgt_TShared *)Handle_MMgt_TShared_get(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Handle_MMgt_TShared_get\n  * wrapname: _wrap_Handle_MMgt_TShared_get\n  * fulldecl: MMgt_TShared * Handle_MMgt_TShared::get()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (MMgt_TShared *)0;
  }
}



#include <gp_XY.hxx>
#include <gp_XYZ.hxx>
#include <gp_Pnt.hxx>
#include <gp_Pnt2d.hxx>
#include <gp_Dir2d.hxx>
#include <gp_Vec2d.hxx>
#include <gp_Ax2d.hxx>
#include <gp_Ax22d.hxx>
#include <gp_Circ2d.hxx>
#include <gp_Elips2d.hxx>
#include <gp_Hypr2d.hxx>
#include <gp_Parab2d.hxx>
#include <gp_Pln.hxx>
#include <gp_Vec.hxx>
#include <gp_Dir.hxx>
#include <gp_Ax3.hxx>
#include <gp_Ax2.hxx>
#include <gp_Ax1.hxx>
#include <gp_Mat2d.hxx>
#include <gp_Mat.hxx>
#include <gp_TrsfForm.hxx>
#include <gp_Trsf2d.hxx>
#include <gp_GTrsf2d.hxx>
#include <gp_Trsf.hxx>
#include <gp_TrsfNLerp.hxx>
#include <gp_GTrsf.hxx>
#include <gp_Lin.hxx>
#include <gp_Circ.hxx>
#include <gp_Elips.hxx>
#include <gp_Cone.hxx>
#include <gp_Cylinder.hxx>
#include <gp_Parab.hxx>
#include <gp_Hypr.hxx>
#include <gp_Torus.hxx>
#include <gp_Sphere.hxx>
#include <gp_Lin2d.hxx>
#include <gp_EulerSequence.hxx>
#include <gp_Quaternion.hxx>
#include <gp_QuaternionNLerp.hxx>
#include <gp_QuaternionSLerp.hxx>

EXPORT gp_XYZ *_wrap_new_gp_XYZ__SWIG_0 () {
  gp_XYZ * lresult = (gp_XYZ *)0 ;
  gp_XYZ *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_XYZ *)new gp_XYZ();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_XYZ\n  * wrapname: _wrap_new_gp_XYZ__SWIG_0\n  * fulldecl: gp_XYZ::gp_XYZ()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_XYZ *)0;
  }
}


EXPORT gp_XYZ *_wrap_new_gp_XYZ__SWIG_1 (Standard_Real larg1, Standard_Real larg2, Standard_Real larg3) {
  gp_XYZ * lresult = (gp_XYZ *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  gp_XYZ *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_XYZ *)new gp_XYZ(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_XYZ\n  * wrapname: _wrap_new_gp_XYZ__SWIG_1\n  * fulldecl: gp_XYZ::gp_XYZ(Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_XYZ *)0;
  }
}


EXPORT void _wrap_gp_XYZ_SetCoord (gp_XYZ *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4) {
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetCoord(arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_SetCoord\n  * wrapname: _wrap_gp_XYZ_SetCoord\n  * fulldecl: void gp_XYZ::SetCoord(Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_XYZ_SetX (gp_XYZ *larg1, Standard_Real larg2) {
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetX(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_SetX\n  * wrapname: _wrap_gp_XYZ_SetX\n  * fulldecl: void gp_XYZ::SetX(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_XYZ_SetY (gp_XYZ *larg1, Standard_Real larg2) {
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetY(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_SetY\n  * wrapname: _wrap_gp_XYZ_SetY\n  * fulldecl: void gp_XYZ::SetY(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_XYZ_SetZ (gp_XYZ *larg1, Standard_Real larg2) {
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetZ(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_SetZ\n  * wrapname: _wrap_gp_XYZ_SetZ\n  * fulldecl: void gp_XYZ::SetZ(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_XYZ_Coord (gp_XYZ *larg1, Standard_Real *larg2, Standard_Real *larg3, Standard_Real *larg4) {
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((gp_XYZ const *)arg1)->Coord(*arg2,*arg3,*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_Coord\n  * wrapname: _wrap_gp_XYZ_Coord\n  * fulldecl: void gp_XYZ::Coord(Standard_Real &,Standard_Real &,Standard_Real &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Real _wrap_gp_XYZ_X (gp_XYZ *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_XYZ const *)arg1)->X();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_X\n  * wrapname: _wrap_gp_XYZ_X\n  * fulldecl: Standard_Real gp_XYZ::X() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_XYZ_Y (gp_XYZ *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_XYZ const *)arg1)->Y();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_Y\n  * wrapname: _wrap_gp_XYZ_Y\n  * fulldecl: Standard_Real gp_XYZ::Y() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_XYZ_Z (gp_XYZ *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_XYZ const *)arg1)->Z();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_Z\n  * wrapname: _wrap_gp_XYZ_Z\n  * fulldecl: Standard_Real gp_XYZ::Z() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_XYZ_Modulus (gp_XYZ *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_XYZ const *)arg1)->Modulus();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_Modulus\n  * wrapname: _wrap_gp_XYZ_Modulus\n  * fulldecl: Standard_Real gp_XYZ::Modulus() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_XYZ_SquareModulus (gp_XYZ *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_XYZ const *)arg1)->SquareModulus();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_SquareModulus\n  * wrapname: _wrap_gp_XYZ_SquareModulus\n  * fulldecl: Standard_Real gp_XYZ::SquareModulus() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT bool _wrap_gp_XYZ_IsEqual (gp_XYZ *larg1, gp_XYZ *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  gp_XYZ *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_XYZ const *)arg1)->IsEqual((gp_XYZ const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_IsEqual\n  * wrapname: _wrap_gp_XYZ_IsEqual\n  * fulldecl: Standard_Boolean gp_XYZ::IsEqual(gp_XYZ const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_gp_XYZ_Add (gp_XYZ *larg1, gp_XYZ *larg2) {
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  gp_XYZ *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Add((gp_XYZ const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_Add\n  * wrapname: _wrap_gp_XYZ_Add\n  * fulldecl: void gp_XYZ::Add(gp_XYZ const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_XYZ *_wrap_gp_XYZ_Added (gp_XYZ *larg1, gp_XYZ *larg2) {
  gp_XYZ * lresult = (gp_XYZ *)0 ;
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  gp_XYZ *arg2 = 0 ;
  gp_XYZ result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_XYZ const *)arg1)->Added((gp_XYZ const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_Added\n  * wrapname: _wrap_gp_XYZ_Added\n  * fulldecl: gp_XYZ gp_XYZ::Added(gp_XYZ const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_XYZ(result);
    return lresult;
  } catch (...) {
    return (gp_XYZ *)0;
  }
}


EXPORT void _wrap_gp_XYZ_Cross (gp_XYZ *larg1, gp_XYZ *larg2) {
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  gp_XYZ *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Cross((gp_XYZ const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_Cross\n  * wrapname: _wrap_gp_XYZ_Cross\n  * fulldecl: void gp_XYZ::Cross(gp_XYZ const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_XYZ *_wrap_gp_XYZ_Crossed (gp_XYZ *larg1, gp_XYZ *larg2) {
  gp_XYZ * lresult = (gp_XYZ *)0 ;
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  gp_XYZ *arg2 = 0 ;
  gp_XYZ result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_XYZ const *)arg1)->Crossed((gp_XYZ const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_Crossed\n  * wrapname: _wrap_gp_XYZ_Crossed\n  * fulldecl: gp_XYZ gp_XYZ::Crossed(gp_XYZ const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_XYZ(result);
    return lresult;
  } catch (...) {
    return (gp_XYZ *)0;
  }
}


EXPORT Standard_Real _wrap_gp_XYZ_CrossMagnitude (gp_XYZ *larg1, gp_XYZ *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  gp_XYZ *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_XYZ const *)arg1)->CrossMagnitude((gp_XYZ const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_CrossMagnitude\n  * wrapname: _wrap_gp_XYZ_CrossMagnitude\n  * fulldecl: Standard_Real gp_XYZ::CrossMagnitude(gp_XYZ const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_XYZ_CrossSquareMagnitude (gp_XYZ *larg1, gp_XYZ *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  gp_XYZ *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_XYZ const *)arg1)->CrossSquareMagnitude((gp_XYZ const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_CrossSquareMagnitude\n  * wrapname: _wrap_gp_XYZ_CrossSquareMagnitude\n  * fulldecl: Standard_Real gp_XYZ::CrossSquareMagnitude(gp_XYZ const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_gp_XYZ_CrossCross (gp_XYZ *larg1, gp_XYZ *larg2, gp_XYZ *larg3) {
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  gp_XYZ *arg2 = 0 ;
  gp_XYZ *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->CrossCross((gp_XYZ const &)*arg2,(gp_XYZ const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_CrossCross\n  * wrapname: _wrap_gp_XYZ_CrossCross\n  * fulldecl: void gp_XYZ::CrossCross(gp_XYZ const &,gp_XYZ const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_XYZ *_wrap_gp_XYZ_CrossCrossed (gp_XYZ *larg1, gp_XYZ *larg2, gp_XYZ *larg3) {
  gp_XYZ * lresult = (gp_XYZ *)0 ;
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  gp_XYZ *arg2 = 0 ;
  gp_XYZ *arg3 = 0 ;
  gp_XYZ result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_XYZ const *)arg1)->CrossCrossed((gp_XYZ const &)*arg2,(gp_XYZ const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_CrossCrossed\n  * wrapname: _wrap_gp_XYZ_CrossCrossed\n  * fulldecl: gp_XYZ gp_XYZ::CrossCrossed(gp_XYZ const &,gp_XYZ const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_XYZ(result);
    return lresult;
  } catch (...) {
    return (gp_XYZ *)0;
  }
}


EXPORT void _wrap_gp_XYZ_Divide (gp_XYZ *larg1, Standard_Real larg2) {
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Divide(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_Divide\n  * wrapname: _wrap_gp_XYZ_Divide\n  * fulldecl: void gp_XYZ::Divide(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_XYZ *_wrap_gp_XYZ_Divided (gp_XYZ *larg1, Standard_Real larg2) {
  gp_XYZ * lresult = (gp_XYZ *)0 ;
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  Standard_Real arg2 ;
  gp_XYZ result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_XYZ const *)arg1)->Divided(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_Divided\n  * wrapname: _wrap_gp_XYZ_Divided\n  * fulldecl: gp_XYZ gp_XYZ::Divided(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_XYZ(result);
    return lresult;
  } catch (...) {
    return (gp_XYZ *)0;
  }
}


EXPORT Standard_Real _wrap_gp_XYZ_Dot (gp_XYZ *larg1, gp_XYZ *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  gp_XYZ *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_XYZ const *)arg1)->Dot((gp_XYZ const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_Dot\n  * wrapname: _wrap_gp_XYZ_Dot\n  * fulldecl: Standard_Real gp_XYZ::Dot(gp_XYZ const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_XYZ_DotCross (gp_XYZ *larg1, gp_XYZ *larg2, gp_XYZ *larg3) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  gp_XYZ *arg2 = 0 ;
  gp_XYZ *arg3 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_XYZ const *)arg1)->DotCross((gp_XYZ const &)*arg2,(gp_XYZ const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_DotCross\n  * wrapname: _wrap_gp_XYZ_DotCross\n  * fulldecl: Standard_Real gp_XYZ::DotCross(gp_XYZ const &,gp_XYZ const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_gp_XYZ_Multiply__SWIG_0 (gp_XYZ *larg1, Standard_Real larg2) {
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Multiply(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_Multiply\n  * wrapname: _wrap_gp_XYZ_Multiply__SWIG_0\n  * fulldecl: void gp_XYZ::Multiply(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_XYZ_Multiply__SWIG_1 (gp_XYZ *larg1, gp_XYZ *larg2) {
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  gp_XYZ *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Multiply((gp_XYZ const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_Multiply\n  * wrapname: _wrap_gp_XYZ_Multiply__SWIG_1\n  * fulldecl: void gp_XYZ::Multiply(gp_XYZ const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_XYZ_Multiply__SWIG_2 (gp_XYZ *larg1, gp_Mat *larg2) {
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  gp_Mat *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Multiply((gp_Mat const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_Multiply\n  * wrapname: _wrap_gp_XYZ_Multiply__SWIG_2\n  * fulldecl: void gp_XYZ::Multiply(gp_Mat const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_XYZ *_wrap_gp_XYZ_Multiplied__SWIG_0 (gp_XYZ *larg1, Standard_Real larg2) {
  gp_XYZ * lresult = (gp_XYZ *)0 ;
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  Standard_Real arg2 ;
  gp_XYZ result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_XYZ const *)arg1)->Multiplied(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_Multiplied\n  * wrapname: _wrap_gp_XYZ_Multiplied__SWIG_0\n  * fulldecl: gp_XYZ gp_XYZ::Multiplied(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_XYZ(result);
    return lresult;
  } catch (...) {
    return (gp_XYZ *)0;
  }
}


EXPORT gp_XYZ *_wrap_gp_XYZ_Multiplied__SWIG_1 (gp_XYZ *larg1, gp_XYZ *larg2) {
  gp_XYZ * lresult = (gp_XYZ *)0 ;
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  gp_XYZ *arg2 = 0 ;
  gp_XYZ result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_XYZ const *)arg1)->Multiplied((gp_XYZ const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_Multiplied\n  * wrapname: _wrap_gp_XYZ_Multiplied__SWIG_1\n  * fulldecl: gp_XYZ gp_XYZ::Multiplied(gp_XYZ const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_XYZ(result);
    return lresult;
  } catch (...) {
    return (gp_XYZ *)0;
  }
}


EXPORT gp_XYZ *_wrap_gp_XYZ_Multiplied__SWIG_2 (gp_XYZ *larg1, gp_Mat *larg2) {
  gp_XYZ * lresult = (gp_XYZ *)0 ;
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  gp_Mat *arg2 = 0 ;
  gp_XYZ result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_XYZ const *)arg1)->Multiplied((gp_Mat const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_Multiplied\n  * wrapname: _wrap_gp_XYZ_Multiplied__SWIG_2\n  * fulldecl: gp_XYZ gp_XYZ::Multiplied(gp_Mat const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_XYZ(result);
    return lresult;
  } catch (...) {
    return (gp_XYZ *)0;
  }
}


EXPORT void _wrap_gp_XYZ_Normalize (gp_XYZ *larg1) {
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Normalize();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_Normalize\n  * wrapname: _wrap_gp_XYZ_Normalize\n  * fulldecl: void gp_XYZ::Normalize()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_XYZ *_wrap_gp_XYZ_Normalized (gp_XYZ *larg1) {
  gp_XYZ * lresult = (gp_XYZ *)0 ;
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  gp_XYZ result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_XYZ const *)arg1)->Normalized();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_Normalized\n  * wrapname: _wrap_gp_XYZ_Normalized\n  * fulldecl: gp_XYZ gp_XYZ::Normalized() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_XYZ(result);
    return lresult;
  } catch (...) {
    return (gp_XYZ *)0;
  }
}


EXPORT void _wrap_gp_XYZ_Reverse (gp_XYZ *larg1) {
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Reverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_Reverse\n  * wrapname: _wrap_gp_XYZ_Reverse\n  * fulldecl: void gp_XYZ::Reverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_XYZ *_wrap_gp_XYZ_Reversed (gp_XYZ *larg1) {
  gp_XYZ * lresult = (gp_XYZ *)0 ;
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  gp_XYZ result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_XYZ const *)arg1)->Reversed();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_Reversed\n  * wrapname: _wrap_gp_XYZ_Reversed\n  * fulldecl: gp_XYZ gp_XYZ::Reversed() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_XYZ(result);
    return lresult;
  } catch (...) {
    return (gp_XYZ *)0;
  }
}


EXPORT void _wrap_gp_XYZ_Subtract (gp_XYZ *larg1, gp_XYZ *larg2) {
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  gp_XYZ *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Subtract((gp_XYZ const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_Subtract\n  * wrapname: _wrap_gp_XYZ_Subtract\n  * fulldecl: void gp_XYZ::Subtract(gp_XYZ const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_XYZ *_wrap_gp_XYZ_Subtracted (gp_XYZ *larg1, gp_XYZ *larg2) {
  gp_XYZ * lresult = (gp_XYZ *)0 ;
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  gp_XYZ *arg2 = 0 ;
  gp_XYZ result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_XYZ const *)arg1)->Subtracted((gp_XYZ const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_Subtracted\n  * wrapname: _wrap_gp_XYZ_Subtracted\n  * fulldecl: gp_XYZ gp_XYZ::Subtracted(gp_XYZ const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_XYZ(result);
    return lresult;
  } catch (...) {
    return (gp_XYZ *)0;
  }
}


EXPORT void _wrap_gp_XYZ_SetLinearForm__SWIG_0 (gp_XYZ *larg1, Standard_Real larg2, gp_XYZ *larg3, Standard_Real larg4, gp_XYZ *larg5, Standard_Real larg6, gp_XYZ *larg7, gp_XYZ *larg8) {
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  Standard_Real arg2 ;
  gp_XYZ *arg3 = 0 ;
  Standard_Real arg4 ;
  gp_XYZ *arg5 = 0 ;
  Standard_Real arg6 ;
  gp_XYZ *arg7 = 0 ;
  gp_XYZ *arg8 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLinearForm(arg2,(gp_XYZ const &)*arg3,arg4,(gp_XYZ const &)*arg5,arg6,(gp_XYZ const &)*arg7,(gp_XYZ const &)*arg8);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_SetLinearForm\n  * wrapname: _wrap_gp_XYZ_SetLinearForm__SWIG_0\n  * fulldecl: void gp_XYZ::SetLinearForm(Standard_Real const,gp_XYZ const &,Standard_Real const,gp_XYZ const &,Standard_Real const,gp_XYZ const &,gp_XYZ const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_XYZ_SetLinearForm__SWIG_1 (gp_XYZ *larg1, Standard_Real larg2, gp_XYZ *larg3, Standard_Real larg4, gp_XYZ *larg5, Standard_Real larg6, gp_XYZ *larg7) {
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  Standard_Real arg2 ;
  gp_XYZ *arg3 = 0 ;
  Standard_Real arg4 ;
  gp_XYZ *arg5 = 0 ;
  Standard_Real arg6 ;
  gp_XYZ *arg7 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLinearForm(arg2,(gp_XYZ const &)*arg3,arg4,(gp_XYZ const &)*arg5,arg6,(gp_XYZ const &)*arg7);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_SetLinearForm\n  * wrapname: _wrap_gp_XYZ_SetLinearForm__SWIG_1\n  * fulldecl: void gp_XYZ::SetLinearForm(Standard_Real const,gp_XYZ const &,Standard_Real const,gp_XYZ const &,Standard_Real const,gp_XYZ const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_XYZ_SetLinearForm__SWIG_2 (gp_XYZ *larg1, Standard_Real larg2, gp_XYZ *larg3, Standard_Real larg4, gp_XYZ *larg5, gp_XYZ *larg6) {
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  Standard_Real arg2 ;
  gp_XYZ *arg3 = 0 ;
  Standard_Real arg4 ;
  gp_XYZ *arg5 = 0 ;
  gp_XYZ *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLinearForm(arg2,(gp_XYZ const &)*arg3,arg4,(gp_XYZ const &)*arg5,(gp_XYZ const &)*arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_SetLinearForm\n  * wrapname: _wrap_gp_XYZ_SetLinearForm__SWIG_2\n  * fulldecl: void gp_XYZ::SetLinearForm(Standard_Real const,gp_XYZ const &,Standard_Real const,gp_XYZ const &,gp_XYZ const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_XYZ_SetLinearForm__SWIG_3 (gp_XYZ *larg1, Standard_Real larg2, gp_XYZ *larg3, Standard_Real larg4, gp_XYZ *larg5) {
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  Standard_Real arg2 ;
  gp_XYZ *arg3 = 0 ;
  Standard_Real arg4 ;
  gp_XYZ *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLinearForm(arg2,(gp_XYZ const &)*arg3,arg4,(gp_XYZ const &)*arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_SetLinearForm\n  * wrapname: _wrap_gp_XYZ_SetLinearForm__SWIG_3\n  * fulldecl: void gp_XYZ::SetLinearForm(Standard_Real const,gp_XYZ const &,Standard_Real const,gp_XYZ const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_XYZ_SetLinearForm__SWIG_4 (gp_XYZ *larg1, Standard_Real larg2, gp_XYZ *larg3, gp_XYZ *larg4) {
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  Standard_Real arg2 ;
  gp_XYZ *arg3 = 0 ;
  gp_XYZ *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLinearForm(arg2,(gp_XYZ const &)*arg3,(gp_XYZ const &)*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_SetLinearForm\n  * wrapname: _wrap_gp_XYZ_SetLinearForm__SWIG_4\n  * fulldecl: void gp_XYZ::SetLinearForm(Standard_Real const,gp_XYZ const &,gp_XYZ const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_XYZ_SetLinearForm__SWIG_5 (gp_XYZ *larg1, gp_XYZ *larg2, gp_XYZ *larg3) {
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  gp_XYZ *arg2 = 0 ;
  gp_XYZ *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLinearForm((gp_XYZ const &)*arg2,(gp_XYZ const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XYZ_SetLinearForm\n  * wrapname: _wrap_gp_XYZ_SetLinearForm__SWIG_5\n  * fulldecl: void gp_XYZ::SetLinearForm(gp_XYZ const &,gp_XYZ const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_gp_XYZ (gp_XYZ *larg1) {
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_XYZ\n  * wrapname: _wrap_delete_gp_XYZ\n  * fulldecl: gp_XYZ::~gp_XYZ()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pnt *_wrap_new_gp_Pnt__SWIG_0 () {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_Pnt *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt *)new gp_Pnt();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Pnt\n  * wrapname: _wrap_new_gp_Pnt__SWIG_0\n  * fulldecl: gp_Pnt::gp_Pnt()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT gp_Pnt *_wrap_new_gp_Pnt__SWIG_1 (gp_XYZ *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_XYZ *arg1 = 0 ;
  gp_Pnt *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt *)new gp_Pnt((gp_XYZ const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Pnt\n  * wrapname: _wrap_new_gp_Pnt__SWIG_1\n  * fulldecl: gp_Pnt::gp_Pnt(gp_XYZ const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT gp_Pnt *_wrap_new_gp_Pnt__SWIG_2 (Standard_Real larg1, Standard_Real larg2, Standard_Real larg3) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  gp_Pnt *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt *)new gp_Pnt(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Pnt\n  * wrapname: _wrap_new_gp_Pnt__SWIG_2\n  * fulldecl: gp_Pnt::gp_Pnt(Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT void _wrap_gp_Pnt_SetCoord (gp_Pnt *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4) {
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetCoord(arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_SetCoord\n  * wrapname: _wrap_gp_Pnt_SetCoord\n  * fulldecl: void gp_Pnt::SetCoord(Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Pnt_SetX (gp_Pnt *larg1, Standard_Real larg2) {
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetX(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_SetX\n  * wrapname: _wrap_gp_Pnt_SetX\n  * fulldecl: void gp_Pnt::SetX(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Pnt_SetY (gp_Pnt *larg1, Standard_Real larg2) {
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetY(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_SetY\n  * wrapname: _wrap_gp_Pnt_SetY\n  * fulldecl: void gp_Pnt::SetY(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Pnt_SetZ (gp_Pnt *larg1, Standard_Real larg2) {
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetZ(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_SetZ\n  * wrapname: _wrap_gp_Pnt_SetZ\n  * fulldecl: void gp_Pnt::SetZ(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Pnt_Coord__SWIG_0 (gp_Pnt *larg1, Standard_Real *larg2, Standard_Real *larg3, Standard_Real *larg4) {
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((gp_Pnt const *)arg1)->Coord(*arg2,*arg3,*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_Coord\n  * wrapname: _wrap_gp_Pnt_Coord__SWIG_0\n  * fulldecl: void gp_Pnt::Coord(Standard_Real &,Standard_Real &,Standard_Real &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Real _wrap_gp_Pnt_X (gp_Pnt *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Pnt const *)arg1)->X();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_X\n  * wrapname: _wrap_gp_Pnt_X\n  * fulldecl: Standard_Real gp_Pnt::X() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Pnt_Y (gp_Pnt *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Pnt const *)arg1)->Y();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_Y\n  * wrapname: _wrap_gp_Pnt_Y\n  * fulldecl: Standard_Real gp_Pnt::Y() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Pnt_Z (gp_Pnt *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Pnt const *)arg1)->Z();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_Z\n  * wrapname: _wrap_gp_Pnt_Z\n  * fulldecl: Standard_Real gp_Pnt::Z() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_XYZ *_wrap_gp_Pnt_Coord__SWIG_1 (gp_Pnt *larg1) {
  gp_XYZ * lresult = (gp_XYZ *)0 ;
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  gp_XYZ *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_XYZ *) &((gp_Pnt const *)arg1)->Coord();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_Coord\n  * wrapname: _wrap_gp_Pnt_Coord__SWIG_1\n  * fulldecl: gp_XYZ const & gp_Pnt::Coord() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_XYZ *)0;
  }
}


EXPORT void _wrap_gp_Pnt_BaryCenter (gp_Pnt *larg1, Standard_Real larg2, gp_Pnt *larg3, Standard_Real larg4) {
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt *arg3 = 0 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->BaryCenter(arg2,(gp_Pnt const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_BaryCenter\n  * wrapname: _wrap_gp_Pnt_BaryCenter\n  * fulldecl: void gp_Pnt::BaryCenter(Standard_Real const,gp_Pnt const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_gp_Pnt_IsEqual (gp_Pnt *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Pnt const *)arg1)->IsEqual((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_IsEqual\n  * wrapname: _wrap_gp_Pnt_IsEqual\n  * fulldecl: Standard_Boolean gp_Pnt::IsEqual(gp_Pnt const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Standard_Real _wrap_gp_Pnt_Distance (gp_Pnt *larg1, gp_Pnt *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Pnt const *)arg1)->Distance((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_Distance\n  * wrapname: _wrap_gp_Pnt_Distance\n  * fulldecl: Standard_Real gp_Pnt::Distance(gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Pnt_SquareDistance (gp_Pnt *larg1, gp_Pnt *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Pnt const *)arg1)->SquareDistance((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_SquareDistance\n  * wrapname: _wrap_gp_Pnt_SquareDistance\n  * fulldecl: Standard_Real gp_Pnt::SquareDistance(gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_gp_Pnt_Mirror__SWIG_0 (gp_Pnt *larg1, gp_Pnt *larg2) {
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_Mirror\n  * wrapname: _wrap_gp_Pnt_Mirror__SWIG_0\n  * fulldecl: void gp_Pnt::Mirror(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pnt *_wrap_gp_Pnt_Mirrored__SWIG_0 (gp_Pnt *larg1, gp_Pnt *larg2) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Pnt const *)arg1)->Mirrored((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_Mirrored\n  * wrapname: _wrap_gp_Pnt_Mirrored__SWIG_0\n  * fulldecl: gp_Pnt gp_Pnt::Mirrored(gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT void _wrap_gp_Pnt_Mirror__SWIG_1 (gp_Pnt *larg1, gp_Ax1 *larg2) {
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_Mirror\n  * wrapname: _wrap_gp_Pnt_Mirror__SWIG_1\n  * fulldecl: void gp_Pnt::Mirror(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pnt *_wrap_gp_Pnt_Mirrored__SWIG_1 (gp_Pnt *larg1, gp_Ax1 *larg2) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Pnt const *)arg1)->Mirrored((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_Mirrored\n  * wrapname: _wrap_gp_Pnt_Mirrored__SWIG_1\n  * fulldecl: gp_Pnt gp_Pnt::Mirrored(gp_Ax1 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT void _wrap_gp_Pnt_Mirror__SWIG_2 (gp_Pnt *larg1, gp_Ax2 *larg2) {
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_Mirror\n  * wrapname: _wrap_gp_Pnt_Mirror__SWIG_2\n  * fulldecl: void gp_Pnt::Mirror(gp_Ax2 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pnt *_wrap_gp_Pnt_Mirrored__SWIG_2 (gp_Pnt *larg1, gp_Ax2 *larg2) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Pnt const *)arg1)->Mirrored((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_Mirrored\n  * wrapname: _wrap_gp_Pnt_Mirrored__SWIG_2\n  * fulldecl: gp_Pnt gp_Pnt::Mirrored(gp_Ax2 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT void _wrap_gp_Pnt_Rotate (gp_Pnt *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Rotate((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_Rotate\n  * wrapname: _wrap_gp_Pnt_Rotate\n  * fulldecl: void gp_Pnt::Rotate(gp_Ax1 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pnt *_wrap_gp_Pnt_Rotated (gp_Pnt *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Pnt result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Pnt const *)arg1)->Rotated((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_Rotated\n  * wrapname: _wrap_gp_Pnt_Rotated\n  * fulldecl: gp_Pnt gp_Pnt::Rotated(gp_Ax1 const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT void _wrap_gp_Pnt_Scale (gp_Pnt *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Scale((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_Scale\n  * wrapname: _wrap_gp_Pnt_Scale\n  * fulldecl: void gp_Pnt::Scale(gp_Pnt const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pnt *_wrap_gp_Pnt_Scaled (gp_Pnt *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Pnt result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Pnt const *)arg1)->Scaled((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_Scaled\n  * wrapname: _wrap_gp_Pnt_Scaled\n  * fulldecl: gp_Pnt gp_Pnt::Scaled(gp_Pnt const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT void _wrap_gp_Pnt_Transform (gp_Pnt *larg1, gp_Trsf *larg2) {
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  gp_Trsf *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Transform((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_Transform\n  * wrapname: _wrap_gp_Pnt_Transform\n  * fulldecl: void gp_Pnt::Transform(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pnt *_wrap_gp_Pnt_Transformed (gp_Pnt *larg1, gp_Trsf *larg2) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  gp_Trsf *arg2 = 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Pnt const *)arg1)->Transformed((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_Transformed\n  * wrapname: _wrap_gp_Pnt_Transformed\n  * fulldecl: gp_Pnt gp_Pnt::Transformed(gp_Trsf const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT void _wrap_gp_Pnt_Translate__SWIG_0 (gp_Pnt *larg1, gp_Vec *larg2) {
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  gp_Vec *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_Translate\n  * wrapname: _wrap_gp_Pnt_Translate__SWIG_0\n  * fulldecl: void gp_Pnt::Translate(gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pnt *_wrap_gp_Pnt_Translated__SWIG_0 (gp_Pnt *larg1, gp_Vec *larg2) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  gp_Vec *arg2 = 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Pnt const *)arg1)->Translated((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_Translated\n  * wrapname: _wrap_gp_Pnt_Translated__SWIG_0\n  * fulldecl: gp_Pnt gp_Pnt::Translated(gp_Vec const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT void _wrap_gp_Pnt_Translate__SWIG_1 (gp_Pnt *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_Translate\n  * wrapname: _wrap_gp_Pnt_Translate__SWIG_1\n  * fulldecl: void gp_Pnt::Translate(gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pnt *_wrap_gp_Pnt_Translated__SWIG_1 (gp_Pnt *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Pnt const *)arg1)->Translated((gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_Translated\n  * wrapname: _wrap_gp_Pnt_Translated__SWIG_1\n  * fulldecl: gp_Pnt gp_Pnt::Translated(gp_Pnt const &,gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT void _wrap_delete_gp_Pnt (gp_Pnt *larg1) {
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Pnt\n  * wrapname: _wrap_delete_gp_Pnt\n  * fulldecl: gp_Pnt::~gp_Pnt()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pnt2d *_wrap_new_gp_Pnt2d__SWIG_0 () {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  gp_Pnt2d *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt2d *)new gp_Pnt2d();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Pnt2d\n  * wrapname: _wrap_new_gp_Pnt2d__SWIG_0\n  * fulldecl: gp_Pnt2d::gp_Pnt2d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT gp_Pnt2d *_wrap_new_gp_Pnt2d__SWIG_1 (gp_XY *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  gp_XY *arg1 = 0 ;
  gp_Pnt2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt2d *)new gp_Pnt2d((gp_XY const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Pnt2d\n  * wrapname: _wrap_new_gp_Pnt2d__SWIG_1\n  * fulldecl: gp_Pnt2d::gp_Pnt2d(gp_XY const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT gp_Pnt2d *_wrap_new_gp_Pnt2d__SWIG_2 (Standard_Real larg1, Standard_Real larg2) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  gp_Pnt2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt2d *)new gp_Pnt2d(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Pnt2d\n  * wrapname: _wrap_new_gp_Pnt2d__SWIG_2\n  * fulldecl: gp_Pnt2d::gp_Pnt2d(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT void _wrap_gp_Pnt2d_SetCoord (gp_Pnt2d *larg1, Standard_Real larg2, Standard_Real larg3) {
  gp_Pnt2d *arg1 = (gp_Pnt2d *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetCoord(arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt2d_SetCoord\n  * wrapname: _wrap_gp_Pnt2d_SetCoord\n  * fulldecl: void gp_Pnt2d::SetCoord(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Pnt2d_SetX (gp_Pnt2d *larg1, Standard_Real larg2) {
  gp_Pnt2d *arg1 = (gp_Pnt2d *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetX(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt2d_SetX\n  * wrapname: _wrap_gp_Pnt2d_SetX\n  * fulldecl: void gp_Pnt2d::SetX(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Pnt2d_SetY (gp_Pnt2d *larg1, Standard_Real larg2) {
  gp_Pnt2d *arg1 = (gp_Pnt2d *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetY(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt2d_SetY\n  * wrapname: _wrap_gp_Pnt2d_SetY\n  * fulldecl: void gp_Pnt2d::SetY(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Real _wrap_gp_Pnt2d_X (gp_Pnt2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Pnt2d *arg1 = (gp_Pnt2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Pnt2d const *)arg1)->X();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt2d_X\n  * wrapname: _wrap_gp_Pnt2d_X\n  * fulldecl: Standard_Real gp_Pnt2d::X() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Pnt2d_Y (gp_Pnt2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Pnt2d *arg1 = (gp_Pnt2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Pnt2d const *)arg1)->Y();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt2d_Y\n  * wrapname: _wrap_gp_Pnt2d_Y\n  * fulldecl: Standard_Real gp_Pnt2d::Y() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_XY *_wrap_gp_Pnt2d_Coord (gp_Pnt2d *larg1) {
  gp_XY * lresult = (gp_XY *)0 ;
  gp_Pnt2d *arg1 = (gp_Pnt2d *) 0 ;
  gp_XY *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_XY *) &((gp_Pnt2d const *)arg1)->Coord();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt2d_Coord\n  * wrapname: _wrap_gp_Pnt2d_Coord\n  * fulldecl: gp_XY const & gp_Pnt2d::Coord() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_XY *)0;
  }
}


EXPORT bool _wrap_gp_Pnt2d_IsEqual (gp_Pnt2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  gp_Pnt2d *arg1 = (gp_Pnt2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Pnt2d const *)arg1)->IsEqual((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt2d_IsEqual\n  * wrapname: _wrap_gp_Pnt2d_IsEqual\n  * fulldecl: Standard_Boolean gp_Pnt2d::IsEqual(gp_Pnt2d const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Standard_Real _wrap_gp_Pnt2d_Distance (gp_Pnt2d *larg1, gp_Pnt2d *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Pnt2d *arg1 = (gp_Pnt2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Pnt2d const *)arg1)->Distance((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt2d_Distance\n  * wrapname: _wrap_gp_Pnt2d_Distance\n  * fulldecl: Standard_Real gp_Pnt2d::Distance(gp_Pnt2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Pnt2d_SquareDistance (gp_Pnt2d *larg1, gp_Pnt2d *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Pnt2d *arg1 = (gp_Pnt2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Pnt2d const *)arg1)->SquareDistance((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt2d_SquareDistance\n  * wrapname: _wrap_gp_Pnt2d_SquareDistance\n  * fulldecl: Standard_Real gp_Pnt2d::SquareDistance(gp_Pnt2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_gp_Pnt2d_Mirror__SWIG_0 (gp_Pnt2d *larg1, gp_Pnt2d *larg2) {
  gp_Pnt2d *arg1 = (gp_Pnt2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt2d_Mirror\n  * wrapname: _wrap_gp_Pnt2d_Mirror__SWIG_0\n  * fulldecl: void gp_Pnt2d::Mirror(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pnt2d *_wrap_gp_Pnt2d_Mirrored__SWIG_0 (gp_Pnt2d *larg1, gp_Pnt2d *larg2) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  gp_Pnt2d *arg1 = (gp_Pnt2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Pnt2d const *)arg1)->Mirrored((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt2d_Mirrored\n  * wrapname: _wrap_gp_Pnt2d_Mirrored__SWIG_0\n  * fulldecl: gp_Pnt2d gp_Pnt2d::Mirrored(gp_Pnt2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT void _wrap_gp_Pnt2d_Mirror__SWIG_1 (gp_Pnt2d *larg1, gp_Ax2d *larg2) {
  gp_Pnt2d *arg1 = (gp_Pnt2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt2d_Mirror\n  * wrapname: _wrap_gp_Pnt2d_Mirror__SWIG_1\n  * fulldecl: void gp_Pnt2d::Mirror(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pnt2d *_wrap_gp_Pnt2d_Mirrored__SWIG_1 (gp_Pnt2d *larg1, gp_Ax2d *larg2) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  gp_Pnt2d *arg1 = (gp_Pnt2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Pnt2d const *)arg1)->Mirrored((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt2d_Mirrored\n  * wrapname: _wrap_gp_Pnt2d_Mirrored__SWIG_1\n  * fulldecl: gp_Pnt2d gp_Pnt2d::Mirrored(gp_Ax2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT void _wrap_gp_Pnt2d_Rotate (gp_Pnt2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Pnt2d *arg1 = (gp_Pnt2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Rotate((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt2d_Rotate\n  * wrapname: _wrap_gp_Pnt2d_Rotate\n  * fulldecl: void gp_Pnt2d::Rotate(gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pnt2d *_wrap_gp_Pnt2d_Rotated (gp_Pnt2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  gp_Pnt2d *arg1 = (gp_Pnt2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Pnt2d const *)arg1)->Rotated((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt2d_Rotated\n  * wrapname: _wrap_gp_Pnt2d_Rotated\n  * fulldecl: gp_Pnt2d gp_Pnt2d::Rotated(gp_Pnt2d const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT void _wrap_gp_Pnt2d_Scale (gp_Pnt2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Pnt2d *arg1 = (gp_Pnt2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Scale((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt2d_Scale\n  * wrapname: _wrap_gp_Pnt2d_Scale\n  * fulldecl: void gp_Pnt2d::Scale(gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pnt2d *_wrap_gp_Pnt2d_Scaled (gp_Pnt2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  gp_Pnt2d *arg1 = (gp_Pnt2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Pnt2d const *)arg1)->Scaled((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt2d_Scaled\n  * wrapname: _wrap_gp_Pnt2d_Scaled\n  * fulldecl: gp_Pnt2d gp_Pnt2d::Scaled(gp_Pnt2d const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT void _wrap_gp_Pnt2d_Transform (gp_Pnt2d *larg1, gp_Trsf2d *larg2) {
  gp_Pnt2d *arg1 = (gp_Pnt2d *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Transform((gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt2d_Transform\n  * wrapname: _wrap_gp_Pnt2d_Transform\n  * fulldecl: void gp_Pnt2d::Transform(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pnt2d *_wrap_gp_Pnt2d_Transformed (gp_Pnt2d *larg1, gp_Trsf2d *larg2) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  gp_Pnt2d *arg1 = (gp_Pnt2d *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Pnt2d const *)arg1)->Transformed((gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt2d_Transformed\n  * wrapname: _wrap_gp_Pnt2d_Transformed\n  * fulldecl: gp_Pnt2d gp_Pnt2d::Transformed(gp_Trsf2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT gp_Pnt2d *_wrap_gp_Pnt2d_Translated__SWIG_0 (gp_Pnt2d *larg1, gp_Vec2d *larg2) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  gp_Pnt2d *arg1 = (gp_Pnt2d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Pnt2d const *)arg1)->Translated((gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt2d_Translated\n  * wrapname: _wrap_gp_Pnt2d_Translated__SWIG_0\n  * fulldecl: gp_Pnt2d gp_Pnt2d::Translated(gp_Vec2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT void _wrap_gp_Pnt2d_Translate (gp_Pnt2d *larg1, gp_Pnt2d *larg2, gp_Pnt2d *larg3) {
  gp_Pnt2d *arg1 = (gp_Pnt2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Pnt2d *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Pnt2d const &)*arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt2d_Translate\n  * wrapname: _wrap_gp_Pnt2d_Translate\n  * fulldecl: void gp_Pnt2d::Translate(gp_Pnt2d const &,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pnt2d *_wrap_gp_Pnt2d_Translated__SWIG_1 (gp_Pnt2d *larg1, gp_Pnt2d *larg2, gp_Pnt2d *larg3) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  gp_Pnt2d *arg1 = (gp_Pnt2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Pnt2d *arg3 = 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Pnt2d const *)arg1)->Translated((gp_Pnt2d const &)*arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt2d_Translated\n  * wrapname: _wrap_gp_Pnt2d_Translated__SWIG_1\n  * fulldecl: gp_Pnt2d gp_Pnt2d::Translated(gp_Pnt2d const &,gp_Pnt2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT void _wrap_delete_gp_Pnt2d (gp_Pnt2d *larg1) {
  gp_Pnt2d *arg1 = (gp_Pnt2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Pnt2d\n  * wrapname: _wrap_delete_gp_Pnt2d\n  * fulldecl: gp_Pnt2d::~gp_Pnt2d()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Dir2d *_wrap_new_gp_Dir2d__SWIG_0 () {
  gp_Dir2d * lresult = (gp_Dir2d *)0 ;
  gp_Dir2d *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Dir2d *)new gp_Dir2d();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Dir2d\n  * wrapname: _wrap_new_gp_Dir2d__SWIG_0\n  * fulldecl: gp_Dir2d::gp_Dir2d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Dir2d *)0;
  }
}


EXPORT gp_Dir2d *_wrap_new_gp_Dir2d__SWIG_1 (gp_Vec2d *larg1) {
  gp_Dir2d * lresult = (gp_Dir2d *)0 ;
  gp_Vec2d *arg1 = 0 ;
  gp_Dir2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Dir2d *)new gp_Dir2d((gp_Vec2d const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Dir2d\n  * wrapname: _wrap_new_gp_Dir2d__SWIG_1\n  * fulldecl: gp_Dir2d::gp_Dir2d(gp_Vec2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Dir2d *)0;
  }
}


EXPORT gp_Dir2d *_wrap_new_gp_Dir2d__SWIG_2 (gp_XY *larg1) {
  gp_Dir2d * lresult = (gp_Dir2d *)0 ;
  gp_XY *arg1 = 0 ;
  gp_Dir2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Dir2d *)new gp_Dir2d((gp_XY const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Dir2d\n  * wrapname: _wrap_new_gp_Dir2d__SWIG_2\n  * fulldecl: gp_Dir2d::gp_Dir2d(gp_XY const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Dir2d *)0;
  }
}


EXPORT gp_Dir2d *_wrap_new_gp_Dir2d__SWIG_3 (Standard_Real larg1, Standard_Real larg2) {
  gp_Dir2d * lresult = (gp_Dir2d *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  gp_Dir2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Dir2d *)new gp_Dir2d(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Dir2d\n  * wrapname: _wrap_new_gp_Dir2d__SWIG_3\n  * fulldecl: gp_Dir2d::gp_Dir2d(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Dir2d *)0;
  }
}


EXPORT void _wrap_gp_Dir2d_SetCoord (gp_Dir2d *larg1, Standard_Real larg2, Standard_Real larg3) {
  gp_Dir2d *arg1 = (gp_Dir2d *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetCoord(arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir2d_SetCoord\n  * wrapname: _wrap_gp_Dir2d_SetCoord\n  * fulldecl: void gp_Dir2d::SetCoord(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Dir2d_SetX (gp_Dir2d *larg1, Standard_Real larg2) {
  gp_Dir2d *arg1 = (gp_Dir2d *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetX(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir2d_SetX\n  * wrapname: _wrap_gp_Dir2d_SetX\n  * fulldecl: void gp_Dir2d::SetX(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Dir2d_SetY (gp_Dir2d *larg1, Standard_Real larg2) {
  gp_Dir2d *arg1 = (gp_Dir2d *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetY(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir2d_SetY\n  * wrapname: _wrap_gp_Dir2d_SetY\n  * fulldecl: void gp_Dir2d::SetY(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Real _wrap_gp_Dir2d_X (gp_Dir2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Dir2d *arg1 = (gp_Dir2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Dir2d const *)arg1)->X();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir2d_X\n  * wrapname: _wrap_gp_Dir2d_X\n  * fulldecl: Standard_Real gp_Dir2d::X() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Dir2d_Y (gp_Dir2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Dir2d *arg1 = (gp_Dir2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Dir2d const *)arg1)->Y();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir2d_Y\n  * wrapname: _wrap_gp_Dir2d_Y\n  * fulldecl: Standard_Real gp_Dir2d::Y() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT bool _wrap_gp_Dir2d_IsEqual (gp_Dir2d *larg1, gp_Dir2d *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  gp_Dir2d *arg1 = (gp_Dir2d *) 0 ;
  gp_Dir2d *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Dir2d const *)arg1)->IsEqual((gp_Dir2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir2d_IsEqual\n  * wrapname: _wrap_gp_Dir2d_IsEqual\n  * fulldecl: Standard_Boolean gp_Dir2d::IsEqual(gp_Dir2d const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_gp_Dir2d_IsNormal (gp_Dir2d *larg1, gp_Dir2d *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  gp_Dir2d *arg1 = (gp_Dir2d *) 0 ;
  gp_Dir2d *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Dir2d const *)arg1)->IsNormal((gp_Dir2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir2d_IsNormal\n  * wrapname: _wrap_gp_Dir2d_IsNormal\n  * fulldecl: Standard_Boolean gp_Dir2d::IsNormal(gp_Dir2d const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_gp_Dir2d_IsOpposite (gp_Dir2d *larg1, gp_Dir2d *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  gp_Dir2d *arg1 = (gp_Dir2d *) 0 ;
  gp_Dir2d *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Dir2d const *)arg1)->IsOpposite((gp_Dir2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir2d_IsOpposite\n  * wrapname: _wrap_gp_Dir2d_IsOpposite\n  * fulldecl: Standard_Boolean gp_Dir2d::IsOpposite(gp_Dir2d const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_gp_Dir2d_IsParallel (gp_Dir2d *larg1, gp_Dir2d *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  gp_Dir2d *arg1 = (gp_Dir2d *) 0 ;
  gp_Dir2d *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Dir2d const *)arg1)->IsParallel((gp_Dir2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir2d_IsParallel\n  * wrapname: _wrap_gp_Dir2d_IsParallel\n  * fulldecl: Standard_Boolean gp_Dir2d::IsParallel(gp_Dir2d const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Standard_Real _wrap_gp_Dir2d_Angle (gp_Dir2d *larg1, gp_Dir2d *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Dir2d *arg1 = (gp_Dir2d *) 0 ;
  gp_Dir2d *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Dir2d const *)arg1)->Angle((gp_Dir2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir2d_Angle\n  * wrapname: _wrap_gp_Dir2d_Angle\n  * fulldecl: Standard_Real gp_Dir2d::Angle(gp_Dir2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Dir2d_Crossed (gp_Dir2d *larg1, gp_Dir2d *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Dir2d *arg1 = (gp_Dir2d *) 0 ;
  gp_Dir2d *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Dir2d const *)arg1)->Crossed((gp_Dir2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir2d_Crossed\n  * wrapname: _wrap_gp_Dir2d_Crossed\n  * fulldecl: Standard_Real gp_Dir2d::Crossed(gp_Dir2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Dir2d_Dot (gp_Dir2d *larg1, gp_Dir2d *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Dir2d *arg1 = (gp_Dir2d *) 0 ;
  gp_Dir2d *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Dir2d const *)arg1)->Dot((gp_Dir2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir2d_Dot\n  * wrapname: _wrap_gp_Dir2d_Dot\n  * fulldecl: Standard_Real gp_Dir2d::Dot(gp_Dir2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_gp_Dir2d_Reverse (gp_Dir2d *larg1) {
  gp_Dir2d *arg1 = (gp_Dir2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Reverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir2d_Reverse\n  * wrapname: _wrap_gp_Dir2d_Reverse\n  * fulldecl: void gp_Dir2d::Reverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Dir2d *_wrap_gp_Dir2d_Reversed (gp_Dir2d *larg1) {
  gp_Dir2d * lresult = (gp_Dir2d *)0 ;
  gp_Dir2d *arg1 = (gp_Dir2d *) 0 ;
  gp_Dir2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Dir2d const *)arg1)->Reversed();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir2d_Reversed\n  * wrapname: _wrap_gp_Dir2d_Reversed\n  * fulldecl: gp_Dir2d gp_Dir2d::Reversed() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Dir2d(result);
    return lresult;
  } catch (...) {
    return (gp_Dir2d *)0;
  }
}


EXPORT void _wrap_gp_Dir2d_Mirror__SWIG_0 (gp_Dir2d *larg1, gp_Dir2d *larg2) {
  gp_Dir2d *arg1 = (gp_Dir2d *) 0 ;
  gp_Dir2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Dir2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir2d_Mirror\n  * wrapname: _wrap_gp_Dir2d_Mirror__SWIG_0\n  * fulldecl: void gp_Dir2d::Mirror(gp_Dir2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Dir2d *_wrap_gp_Dir2d_Mirrored__SWIG_0 (gp_Dir2d *larg1, gp_Dir2d *larg2) {
  gp_Dir2d * lresult = (gp_Dir2d *)0 ;
  gp_Dir2d *arg1 = (gp_Dir2d *) 0 ;
  gp_Dir2d *arg2 = 0 ;
  gp_Dir2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Dir2d const *)arg1)->Mirrored((gp_Dir2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir2d_Mirrored\n  * wrapname: _wrap_gp_Dir2d_Mirrored__SWIG_0\n  * fulldecl: gp_Dir2d gp_Dir2d::Mirrored(gp_Dir2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Dir2d(result);
    return lresult;
  } catch (...) {
    return (gp_Dir2d *)0;
  }
}


EXPORT void _wrap_gp_Dir2d_Mirror__SWIG_1 (gp_Dir2d *larg1, gp_Ax2d *larg2) {
  gp_Dir2d *arg1 = (gp_Dir2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir2d_Mirror\n  * wrapname: _wrap_gp_Dir2d_Mirror__SWIG_1\n  * fulldecl: void gp_Dir2d::Mirror(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Dir2d *_wrap_gp_Dir2d_Mirrored__SWIG_1 (gp_Dir2d *larg1, gp_Ax2d *larg2) {
  gp_Dir2d * lresult = (gp_Dir2d *)0 ;
  gp_Dir2d *arg1 = (gp_Dir2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  gp_Dir2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Dir2d const *)arg1)->Mirrored((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir2d_Mirrored\n  * wrapname: _wrap_gp_Dir2d_Mirrored__SWIG_1\n  * fulldecl: gp_Dir2d gp_Dir2d::Mirrored(gp_Ax2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Dir2d(result);
    return lresult;
  } catch (...) {
    return (gp_Dir2d *)0;
  }
}


EXPORT void _wrap_gp_Dir2d_Rotate (gp_Dir2d *larg1, Standard_Real larg2) {
  gp_Dir2d *arg1 = (gp_Dir2d *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Rotate(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir2d_Rotate\n  * wrapname: _wrap_gp_Dir2d_Rotate\n  * fulldecl: void gp_Dir2d::Rotate(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Dir2d *_wrap_gp_Dir2d_Rotated (gp_Dir2d *larg1, Standard_Real larg2) {
  gp_Dir2d * lresult = (gp_Dir2d *)0 ;
  gp_Dir2d *arg1 = (gp_Dir2d *) 0 ;
  Standard_Real arg2 ;
  gp_Dir2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Dir2d const *)arg1)->Rotated(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir2d_Rotated\n  * wrapname: _wrap_gp_Dir2d_Rotated\n  * fulldecl: gp_Dir2d gp_Dir2d::Rotated(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Dir2d(result);
    return lresult;
  } catch (...) {
    return (gp_Dir2d *)0;
  }
}


EXPORT void _wrap_gp_Dir2d_Transform (gp_Dir2d *larg1, gp_Trsf2d *larg2) {
  gp_Dir2d *arg1 = (gp_Dir2d *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Transform((gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir2d_Transform\n  * wrapname: _wrap_gp_Dir2d_Transform\n  * fulldecl: void gp_Dir2d::Transform(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Dir2d *_wrap_gp_Dir2d_Transformed (gp_Dir2d *larg1, gp_Trsf2d *larg2) {
  gp_Dir2d * lresult = (gp_Dir2d *)0 ;
  gp_Dir2d *arg1 = (gp_Dir2d *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  gp_Dir2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Dir2d const *)arg1)->Transformed((gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir2d_Transformed\n  * wrapname: _wrap_gp_Dir2d_Transformed\n  * fulldecl: gp_Dir2d gp_Dir2d::Transformed(gp_Trsf2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Dir2d(result);
    return lresult;
  } catch (...) {
    return (gp_Dir2d *)0;
  }
}


EXPORT void _wrap_delete_gp_Dir2d (gp_Dir2d *larg1) {
  gp_Dir2d *arg1 = (gp_Dir2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Dir2d\n  * wrapname: _wrap_delete_gp_Dir2d\n  * fulldecl: gp_Dir2d::~gp_Dir2d()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec2d *_wrap_new_gp_Vec2d__SWIG_0 () {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  gp_Vec2d *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Vec2d *)new gp_Vec2d();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Vec2d\n  * wrapname: _wrap_new_gp_Vec2d__SWIG_0\n  * fulldecl: gp_Vec2d::gp_Vec2d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


EXPORT gp_Vec2d *_wrap_new_gp_Vec2d__SWIG_1 (gp_Dir2d *larg1) {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  gp_Dir2d *arg1 = 0 ;
  gp_Vec2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Vec2d *)new gp_Vec2d((gp_Dir2d const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Vec2d\n  * wrapname: _wrap_new_gp_Vec2d__SWIG_1\n  * fulldecl: gp_Vec2d::gp_Vec2d(gp_Dir2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


EXPORT gp_Vec2d *_wrap_new_gp_Vec2d__SWIG_2 (gp_XY *larg1) {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  gp_XY *arg1 = 0 ;
  gp_Vec2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Vec2d *)new gp_Vec2d((gp_XY const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Vec2d\n  * wrapname: _wrap_new_gp_Vec2d__SWIG_2\n  * fulldecl: gp_Vec2d::gp_Vec2d(gp_XY const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


EXPORT gp_Vec2d *_wrap_new_gp_Vec2d__SWIG_3 (Standard_Real larg1, Standard_Real larg2) {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  gp_Vec2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Vec2d *)new gp_Vec2d(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Vec2d\n  * wrapname: _wrap_new_gp_Vec2d__SWIG_3\n  * fulldecl: gp_Vec2d::gp_Vec2d(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


EXPORT gp_Vec2d *_wrap_new_gp_Vec2d__SWIG_4 (gp_Pnt2d *larg1, gp_Pnt2d *larg2) {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  gp_Pnt2d *arg1 = 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Vec2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Vec2d *)new gp_Vec2d((gp_Pnt2d const &)*arg1,(gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Vec2d\n  * wrapname: _wrap_new_gp_Vec2d__SWIG_4\n  * fulldecl: gp_Vec2d::gp_Vec2d(gp_Pnt2d const &,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


EXPORT void _wrap_gp_Vec2d_SetCoord (gp_Vec2d *larg1, Standard_Real larg2, Standard_Real larg3) {
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetCoord(arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_SetCoord\n  * wrapname: _wrap_gp_Vec2d_SetCoord\n  * fulldecl: void gp_Vec2d::SetCoord(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Vec2d_SetX (gp_Vec2d *larg1, Standard_Real larg2) {
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetX(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_SetX\n  * wrapname: _wrap_gp_Vec2d_SetX\n  * fulldecl: void gp_Vec2d::SetX(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Vec2d_SetY (gp_Vec2d *larg1, Standard_Real larg2) {
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetY(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_SetY\n  * wrapname: _wrap_gp_Vec2d_SetY\n  * fulldecl: void gp_Vec2d::SetY(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Real _wrap_gp_Vec2d_X (gp_Vec2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Vec2d const *)arg1)->X();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_X\n  * wrapname: _wrap_gp_Vec2d_X\n  * fulldecl: Standard_Real gp_Vec2d::X() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Vec2d_Y (gp_Vec2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Vec2d const *)arg1)->Y();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_Y\n  * wrapname: _wrap_gp_Vec2d_Y\n  * fulldecl: Standard_Real gp_Vec2d::Y() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT bool _wrap_gp_Vec2d_IsEqual (gp_Vec2d *larg1, gp_Vec2d *larg2, Standard_Real larg3, Standard_Real larg4) {
  bool lresult = (bool)0 ;
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Vec2d const *)arg1)->IsEqual((gp_Vec2d const &)*arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_IsEqual\n  * wrapname: _wrap_gp_Vec2d_IsEqual\n  * fulldecl: Standard_Boolean gp_Vec2d::IsEqual(gp_Vec2d const &,Standard_Real const,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_gp_Vec2d_IsNormal (gp_Vec2d *larg1, gp_Vec2d *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Vec2d const *)arg1)->IsNormal((gp_Vec2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_IsNormal\n  * wrapname: _wrap_gp_Vec2d_IsNormal\n  * fulldecl: Standard_Boolean gp_Vec2d::IsNormal(gp_Vec2d const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_gp_Vec2d_IsOpposite (gp_Vec2d *larg1, gp_Vec2d *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Vec2d const *)arg1)->IsOpposite((gp_Vec2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_IsOpposite\n  * wrapname: _wrap_gp_Vec2d_IsOpposite\n  * fulldecl: Standard_Boolean gp_Vec2d::IsOpposite(gp_Vec2d const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_gp_Vec2d_IsParallel (gp_Vec2d *larg1, gp_Vec2d *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Vec2d const *)arg1)->IsParallel((gp_Vec2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_IsParallel\n  * wrapname: _wrap_gp_Vec2d_IsParallel\n  * fulldecl: Standard_Boolean gp_Vec2d::IsParallel(gp_Vec2d const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Standard_Real _wrap_gp_Vec2d_Angle (gp_Vec2d *larg1, gp_Vec2d *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Vec2d const *)arg1)->Angle((gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_Angle\n  * wrapname: _wrap_gp_Vec2d_Angle\n  * fulldecl: Standard_Real gp_Vec2d::Angle(gp_Vec2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Vec2d_Magnitude (gp_Vec2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Vec2d const *)arg1)->Magnitude();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_Magnitude\n  * wrapname: _wrap_gp_Vec2d_Magnitude\n  * fulldecl: Standard_Real gp_Vec2d::Magnitude() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Vec2d_SquareMagnitude (gp_Vec2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Vec2d const *)arg1)->SquareMagnitude();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_SquareMagnitude\n  * wrapname: _wrap_gp_Vec2d_SquareMagnitude\n  * fulldecl: Standard_Real gp_Vec2d::SquareMagnitude() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_gp_Vec2d_Add (gp_Vec2d *larg1, gp_Vec2d *larg2) {
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Add((gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_Add\n  * wrapname: _wrap_gp_Vec2d_Add\n  * fulldecl: void gp_Vec2d::Add(gp_Vec2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec2d *_wrap_gp_Vec2d_Added (gp_Vec2d *larg1, gp_Vec2d *larg2) {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  gp_Vec2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Vec2d const *)arg1)->Added((gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_Added\n  * wrapname: _wrap_gp_Vec2d_Added\n  * fulldecl: gp_Vec2d gp_Vec2d::Added(gp_Vec2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec2d(result);
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Vec2d_Crossed (gp_Vec2d *larg1, gp_Vec2d *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Vec2d const *)arg1)->Crossed((gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_Crossed\n  * wrapname: _wrap_gp_Vec2d_Crossed\n  * fulldecl: Standard_Real gp_Vec2d::Crossed(gp_Vec2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Vec2d_CrossMagnitude (gp_Vec2d *larg1, gp_Vec2d *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Vec2d const *)arg1)->CrossMagnitude((gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_CrossMagnitude\n  * wrapname: _wrap_gp_Vec2d_CrossMagnitude\n  * fulldecl: Standard_Real gp_Vec2d::CrossMagnitude(gp_Vec2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Vec2d_CrossSquareMagnitude (gp_Vec2d *larg1, gp_Vec2d *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Vec2d const *)arg1)->CrossSquareMagnitude((gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_CrossSquareMagnitude\n  * wrapname: _wrap_gp_Vec2d_CrossSquareMagnitude\n  * fulldecl: Standard_Real gp_Vec2d::CrossSquareMagnitude(gp_Vec2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_gp_Vec2d_Divide (gp_Vec2d *larg1, Standard_Real larg2) {
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Divide(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_Divide\n  * wrapname: _wrap_gp_Vec2d_Divide\n  * fulldecl: void gp_Vec2d::Divide(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec2d *_wrap_gp_Vec2d_Divided (gp_Vec2d *larg1, Standard_Real larg2) {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  Standard_Real arg2 ;
  gp_Vec2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Vec2d const *)arg1)->Divided(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_Divided\n  * wrapname: _wrap_gp_Vec2d_Divided\n  * fulldecl: gp_Vec2d gp_Vec2d::Divided(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec2d(result);
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Vec2d_Dot (gp_Vec2d *larg1, gp_Vec2d *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Vec2d const *)arg1)->Dot((gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_Dot\n  * wrapname: _wrap_gp_Vec2d_Dot\n  * fulldecl: Standard_Real gp_Vec2d::Dot(gp_Vec2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Vec2d *_wrap_gp_Vec2d_GetNormal (gp_Vec2d *larg1) {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  gp_Vec2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Vec2d const *)arg1)->GetNormal();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_GetNormal\n  * wrapname: _wrap_gp_Vec2d_GetNormal\n  * fulldecl: gp_Vec2d gp_Vec2d::GetNormal() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec2d(result);
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


EXPORT void _wrap_gp_Vec2d_Multiply (gp_Vec2d *larg1, Standard_Real larg2) {
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Multiply(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_Multiply\n  * wrapname: _wrap_gp_Vec2d_Multiply\n  * fulldecl: void gp_Vec2d::Multiply(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec2d *_wrap_gp_Vec2d_Multiplied (gp_Vec2d *larg1, Standard_Real larg2) {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  Standard_Real arg2 ;
  gp_Vec2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Vec2d const *)arg1)->Multiplied(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_Multiplied\n  * wrapname: _wrap_gp_Vec2d_Multiplied\n  * fulldecl: gp_Vec2d gp_Vec2d::Multiplied(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec2d(result);
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


EXPORT void _wrap_gp_Vec2d_Normalize (gp_Vec2d *larg1) {
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Normalize();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_Normalize\n  * wrapname: _wrap_gp_Vec2d_Normalize\n  * fulldecl: void gp_Vec2d::Normalize()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec2d *_wrap_gp_Vec2d_Normalized (gp_Vec2d *larg1) {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  gp_Vec2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Vec2d const *)arg1)->Normalized();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_Normalized\n  * wrapname: _wrap_gp_Vec2d_Normalized\n  * fulldecl: gp_Vec2d gp_Vec2d::Normalized() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec2d(result);
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


EXPORT void _wrap_gp_Vec2d_Reverse (gp_Vec2d *larg1) {
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Reverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_Reverse\n  * wrapname: _wrap_gp_Vec2d_Reverse\n  * fulldecl: void gp_Vec2d::Reverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec2d *_wrap_gp_Vec2d_Reversed (gp_Vec2d *larg1) {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  gp_Vec2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Vec2d const *)arg1)->Reversed();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_Reversed\n  * wrapname: _wrap_gp_Vec2d_Reversed\n  * fulldecl: gp_Vec2d gp_Vec2d::Reversed() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec2d(result);
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


EXPORT void _wrap_gp_Vec2d_Subtract (gp_Vec2d *larg1, gp_Vec2d *larg2) {
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Subtract((gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_Subtract\n  * wrapname: _wrap_gp_Vec2d_Subtract\n  * fulldecl: void gp_Vec2d::Subtract(gp_Vec2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec2d *_wrap_gp_Vec2d_Subtracted (gp_Vec2d *larg1, gp_Vec2d *larg2) {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  gp_Vec2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Vec2d const *)arg1)->Subtracted((gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_Subtracted\n  * wrapname: _wrap_gp_Vec2d_Subtracted\n  * fulldecl: gp_Vec2d gp_Vec2d::Subtracted(gp_Vec2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec2d(result);
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


EXPORT void _wrap_gp_Vec2d_SetLinearForm__SWIG_0 (gp_Vec2d *larg1, Standard_Real larg2, gp_Vec2d *larg3, Standard_Real larg4, gp_Vec2d *larg5, gp_Vec2d *larg6) {
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  Standard_Real arg2 ;
  gp_Vec2d *arg3 = 0 ;
  Standard_Real arg4 ;
  gp_Vec2d *arg5 = 0 ;
  gp_Vec2d *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLinearForm(arg2,(gp_Vec2d const &)*arg3,arg4,(gp_Vec2d const &)*arg5,(gp_Vec2d const &)*arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_SetLinearForm\n  * wrapname: _wrap_gp_Vec2d_SetLinearForm__SWIG_0\n  * fulldecl: void gp_Vec2d::SetLinearForm(Standard_Real const,gp_Vec2d const &,Standard_Real const,gp_Vec2d const &,gp_Vec2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Vec2d_SetLinearForm__SWIG_1 (gp_Vec2d *larg1, Standard_Real larg2, gp_Vec2d *larg3, Standard_Real larg4, gp_Vec2d *larg5) {
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  Standard_Real arg2 ;
  gp_Vec2d *arg3 = 0 ;
  Standard_Real arg4 ;
  gp_Vec2d *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLinearForm(arg2,(gp_Vec2d const &)*arg3,arg4,(gp_Vec2d const &)*arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_SetLinearForm\n  * wrapname: _wrap_gp_Vec2d_SetLinearForm__SWIG_1\n  * fulldecl: void gp_Vec2d::SetLinearForm(Standard_Real const,gp_Vec2d const &,Standard_Real const,gp_Vec2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Vec2d_SetLinearForm__SWIG_2 (gp_Vec2d *larg1, Standard_Real larg2, gp_Vec2d *larg3, gp_Vec2d *larg4) {
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  Standard_Real arg2 ;
  gp_Vec2d *arg3 = 0 ;
  gp_Vec2d *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLinearForm(arg2,(gp_Vec2d const &)*arg3,(gp_Vec2d const &)*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_SetLinearForm\n  * wrapname: _wrap_gp_Vec2d_SetLinearForm__SWIG_2\n  * fulldecl: void gp_Vec2d::SetLinearForm(Standard_Real const,gp_Vec2d const &,gp_Vec2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Vec2d_SetLinearForm__SWIG_3 (gp_Vec2d *larg1, gp_Vec2d *larg2, gp_Vec2d *larg3) {
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  gp_Vec2d *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLinearForm((gp_Vec2d const &)*arg2,(gp_Vec2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_SetLinearForm\n  * wrapname: _wrap_gp_Vec2d_SetLinearForm__SWIG_3\n  * fulldecl: void gp_Vec2d::SetLinearForm(gp_Vec2d const &,gp_Vec2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Vec2d_Mirror__SWIG_0 (gp_Vec2d *larg1, gp_Vec2d *larg2) {
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_Mirror\n  * wrapname: _wrap_gp_Vec2d_Mirror__SWIG_0\n  * fulldecl: void gp_Vec2d::Mirror(gp_Vec2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec2d *_wrap_gp_Vec2d_Mirrored__SWIG_0 (gp_Vec2d *larg1, gp_Vec2d *larg2) {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  gp_Vec2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Vec2d const *)arg1)->Mirrored((gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_Mirrored\n  * wrapname: _wrap_gp_Vec2d_Mirrored__SWIG_0\n  * fulldecl: gp_Vec2d gp_Vec2d::Mirrored(gp_Vec2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec2d(result);
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


EXPORT void _wrap_gp_Vec2d_Mirror__SWIG_1 (gp_Vec2d *larg1, gp_Ax2d *larg2) {
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_Mirror\n  * wrapname: _wrap_gp_Vec2d_Mirror__SWIG_1\n  * fulldecl: void gp_Vec2d::Mirror(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec2d *_wrap_gp_Vec2d_Mirrored__SWIG_1 (gp_Vec2d *larg1, gp_Ax2d *larg2) {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  gp_Vec2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Vec2d const *)arg1)->Mirrored((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_Mirrored\n  * wrapname: _wrap_gp_Vec2d_Mirrored__SWIG_1\n  * fulldecl: gp_Vec2d gp_Vec2d::Mirrored(gp_Ax2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec2d(result);
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


EXPORT void _wrap_gp_Vec2d_Rotate (gp_Vec2d *larg1, Standard_Real larg2) {
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Rotate(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_Rotate\n  * wrapname: _wrap_gp_Vec2d_Rotate\n  * fulldecl: void gp_Vec2d::Rotate(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec2d *_wrap_gp_Vec2d_Rotated (gp_Vec2d *larg1, Standard_Real larg2) {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  Standard_Real arg2 ;
  gp_Vec2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Vec2d const *)arg1)->Rotated(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_Rotated\n  * wrapname: _wrap_gp_Vec2d_Rotated\n  * fulldecl: gp_Vec2d gp_Vec2d::Rotated(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec2d(result);
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


EXPORT void _wrap_gp_Vec2d_Scale (gp_Vec2d *larg1, Standard_Real larg2) {
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Scale(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_Scale\n  * wrapname: _wrap_gp_Vec2d_Scale\n  * fulldecl: void gp_Vec2d::Scale(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec2d *_wrap_gp_Vec2d_Scaled (gp_Vec2d *larg1, Standard_Real larg2) {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  Standard_Real arg2 ;
  gp_Vec2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Vec2d const *)arg1)->Scaled(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_Scaled\n  * wrapname: _wrap_gp_Vec2d_Scaled\n  * fulldecl: gp_Vec2d gp_Vec2d::Scaled(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec2d(result);
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


EXPORT void _wrap_gp_Vec2d_Transform (gp_Vec2d *larg1, gp_Trsf2d *larg2) {
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Transform((gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_Transform\n  * wrapname: _wrap_gp_Vec2d_Transform\n  * fulldecl: void gp_Vec2d::Transform(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec2d *_wrap_gp_Vec2d_Transformed (gp_Vec2d *larg1, gp_Trsf2d *larg2) {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  gp_Vec2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Vec2d const *)arg1)->Transformed((gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec2d_Transformed\n  * wrapname: _wrap_gp_Vec2d_Transformed\n  * fulldecl: gp_Vec2d gp_Vec2d::Transformed(gp_Trsf2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec2d(result);
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


EXPORT void _wrap_delete_gp_Vec2d (gp_Vec2d *larg1) {
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Vec2d\n  * wrapname: _wrap_delete_gp_Vec2d\n  * fulldecl: gp_Vec2d::~gp_Vec2d()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax2d *_wrap_new_gp_Ax2d__SWIG_0 () {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  gp_Ax2d *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax2d *)new gp_Ax2d();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax2d\n  * wrapname: _wrap_new_gp_Ax2d__SWIG_0\n  * fulldecl: gp_Ax2d::gp_Ax2d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


EXPORT gp_Ax2d *_wrap_new_gp_Ax2d__SWIG_1 (gp_Pnt2d *larg1, gp_Dir2d *larg2) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  gp_Pnt2d *arg1 = 0 ;
  gp_Dir2d *arg2 = 0 ;
  gp_Ax2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax2d *)new gp_Ax2d((gp_Pnt2d const &)*arg1,(gp_Dir2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax2d\n  * wrapname: _wrap_new_gp_Ax2d__SWIG_1\n  * fulldecl: gp_Ax2d::gp_Ax2d(gp_Pnt2d const &,gp_Dir2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


EXPORT void _wrap_gp_Ax2d_SetLocation (gp_Ax2d *larg1, gp_Pnt2d *larg2) {
  gp_Ax2d *arg1 = (gp_Ax2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLocation((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2d_SetLocation\n  * wrapname: _wrap_gp_Ax2d_SetLocation\n  * fulldecl: void gp_Ax2d::SetLocation(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Ax2d_SetDirection (gp_Ax2d *larg1, gp_Dir2d *larg2) {
  gp_Ax2d *arg1 = (gp_Ax2d *) 0 ;
  gp_Dir2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetDirection((gp_Dir2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2d_SetDirection\n  * wrapname: _wrap_gp_Ax2d_SetDirection\n  * fulldecl: void gp_Ax2d::SetDirection(gp_Dir2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pnt2d *_wrap_gp_Ax2d_Location (gp_Ax2d *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  gp_Ax2d *arg1 = (gp_Ax2d *) 0 ;
  gp_Pnt2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt2d *) &((gp_Ax2d const *)arg1)->Location();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2d_Location\n  * wrapname: _wrap_gp_Ax2d_Location\n  * fulldecl: gp_Pnt2d const & gp_Ax2d::Location() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT gp_Dir2d *_wrap_gp_Ax2d_Direction (gp_Ax2d *larg1) {
  gp_Dir2d * lresult = (gp_Dir2d *)0 ;
  gp_Ax2d *arg1 = (gp_Ax2d *) 0 ;
  gp_Dir2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Dir2d *) &((gp_Ax2d const *)arg1)->Direction();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2d_Direction\n  * wrapname: _wrap_gp_Ax2d_Direction\n  * fulldecl: gp_Dir2d const & gp_Ax2d::Direction() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Dir2d *)0;
  }
}


EXPORT bool _wrap_gp_Ax2d_IsCoaxial (gp_Ax2d *larg1, gp_Ax2d *larg2, Standard_Real larg3, Standard_Real larg4) {
  bool lresult = (bool)0 ;
  gp_Ax2d *arg1 = (gp_Ax2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Ax2d const *)arg1)->IsCoaxial((gp_Ax2d const &)*arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2d_IsCoaxial\n  * wrapname: _wrap_gp_Ax2d_IsCoaxial\n  * fulldecl: Standard_Boolean gp_Ax2d::IsCoaxial(gp_Ax2d const &,Standard_Real const,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_gp_Ax2d_IsNormal (gp_Ax2d *larg1, gp_Ax2d *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  gp_Ax2d *arg1 = (gp_Ax2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Ax2d const *)arg1)->IsNormal((gp_Ax2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2d_IsNormal\n  * wrapname: _wrap_gp_Ax2d_IsNormal\n  * fulldecl: Standard_Boolean gp_Ax2d::IsNormal(gp_Ax2d const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_gp_Ax2d_IsOpposite (gp_Ax2d *larg1, gp_Ax2d *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  gp_Ax2d *arg1 = (gp_Ax2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Ax2d const *)arg1)->IsOpposite((gp_Ax2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2d_IsOpposite\n  * wrapname: _wrap_gp_Ax2d_IsOpposite\n  * fulldecl: Standard_Boolean gp_Ax2d::IsOpposite(gp_Ax2d const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_gp_Ax2d_IsParallel (gp_Ax2d *larg1, gp_Ax2d *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  gp_Ax2d *arg1 = (gp_Ax2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Ax2d const *)arg1)->IsParallel((gp_Ax2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2d_IsParallel\n  * wrapname: _wrap_gp_Ax2d_IsParallel\n  * fulldecl: Standard_Boolean gp_Ax2d::IsParallel(gp_Ax2d const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Standard_Real _wrap_gp_Ax2d_Angle (gp_Ax2d *larg1, gp_Ax2d *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Ax2d *arg1 = (gp_Ax2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Ax2d const *)arg1)->Angle((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2d_Angle\n  * wrapname: _wrap_gp_Ax2d_Angle\n  * fulldecl: Standard_Real gp_Ax2d::Angle(gp_Ax2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_gp_Ax2d_Reverse (gp_Ax2d *larg1) {
  gp_Ax2d *arg1 = (gp_Ax2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Reverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2d_Reverse\n  * wrapname: _wrap_gp_Ax2d_Reverse\n  * fulldecl: void gp_Ax2d::Reverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax2d *_wrap_gp_Ax2d_Reversed (gp_Ax2d *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  gp_Ax2d *arg1 = (gp_Ax2d *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax2d const *)arg1)->Reversed();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2d_Reversed\n  * wrapname: _wrap_gp_Ax2d_Reversed\n  * fulldecl: gp_Ax2d gp_Ax2d::Reversed() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


EXPORT void _wrap_gp_Ax2d_Mirror__SWIG_0 (gp_Ax2d *larg1, gp_Pnt2d *larg2) {
  gp_Ax2d *arg1 = (gp_Ax2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2d_Mirror\n  * wrapname: _wrap_gp_Ax2d_Mirror__SWIG_0\n  * fulldecl: void gp_Ax2d::Mirror(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax2d *_wrap_gp_Ax2d_Mirrored__SWIG_0 (gp_Ax2d *larg1, gp_Pnt2d *larg2) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  gp_Ax2d *arg1 = (gp_Ax2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax2d const *)arg1)->Mirrored((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2d_Mirrored\n  * wrapname: _wrap_gp_Ax2d_Mirrored__SWIG_0\n  * fulldecl: gp_Ax2d gp_Ax2d::Mirrored(gp_Pnt2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


EXPORT void _wrap_gp_Ax2d_Mirror__SWIG_1 (gp_Ax2d *larg1, gp_Ax2d *larg2) {
  gp_Ax2d *arg1 = (gp_Ax2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2d_Mirror\n  * wrapname: _wrap_gp_Ax2d_Mirror__SWIG_1\n  * fulldecl: void gp_Ax2d::Mirror(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax2d *_wrap_gp_Ax2d_Mirrored__SWIG_1 (gp_Ax2d *larg1, gp_Ax2d *larg2) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  gp_Ax2d *arg1 = (gp_Ax2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax2d const *)arg1)->Mirrored((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2d_Mirrored\n  * wrapname: _wrap_gp_Ax2d_Mirrored__SWIG_1\n  * fulldecl: gp_Ax2d gp_Ax2d::Mirrored(gp_Ax2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


EXPORT void _wrap_gp_Ax2d_Rotate (gp_Ax2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Ax2d *arg1 = (gp_Ax2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Rotate((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2d_Rotate\n  * wrapname: _wrap_gp_Ax2d_Rotate\n  * fulldecl: void gp_Ax2d::Rotate(gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax2d *_wrap_gp_Ax2d_Rotated (gp_Ax2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  gp_Ax2d *arg1 = (gp_Ax2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax2d const *)arg1)->Rotated((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2d_Rotated\n  * wrapname: _wrap_gp_Ax2d_Rotated\n  * fulldecl: gp_Ax2d gp_Ax2d::Rotated(gp_Pnt2d const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


EXPORT void _wrap_gp_Ax2d_Scale (gp_Ax2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Ax2d *arg1 = (gp_Ax2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Scale((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2d_Scale\n  * wrapname: _wrap_gp_Ax2d_Scale\n  * fulldecl: void gp_Ax2d::Scale(gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax2d *_wrap_gp_Ax2d_Scaled (gp_Ax2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  gp_Ax2d *arg1 = (gp_Ax2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax2d const *)arg1)->Scaled((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2d_Scaled\n  * wrapname: _wrap_gp_Ax2d_Scaled\n  * fulldecl: gp_Ax2d gp_Ax2d::Scaled(gp_Pnt2d const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


EXPORT void _wrap_gp_Ax2d_Transform (gp_Ax2d *larg1, gp_Trsf2d *larg2) {
  gp_Ax2d *arg1 = (gp_Ax2d *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Transform((gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2d_Transform\n  * wrapname: _wrap_gp_Ax2d_Transform\n  * fulldecl: void gp_Ax2d::Transform(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax2d *_wrap_gp_Ax2d_Transformed (gp_Ax2d *larg1, gp_Trsf2d *larg2) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  gp_Ax2d *arg1 = (gp_Ax2d *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax2d const *)arg1)->Transformed((gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2d_Transformed\n  * wrapname: _wrap_gp_Ax2d_Transformed\n  * fulldecl: gp_Ax2d gp_Ax2d::Transformed(gp_Trsf2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


EXPORT void _wrap_gp_Ax2d_Translate__SWIG_0 (gp_Ax2d *larg1, gp_Vec2d *larg2) {
  gp_Ax2d *arg1 = (gp_Ax2d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2d_Translate\n  * wrapname: _wrap_gp_Ax2d_Translate__SWIG_0\n  * fulldecl: void gp_Ax2d::Translate(gp_Vec2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax2d *_wrap_gp_Ax2d_Translated__SWIG_0 (gp_Ax2d *larg1, gp_Vec2d *larg2) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  gp_Ax2d *arg1 = (gp_Ax2d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax2d const *)arg1)->Translated((gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2d_Translated\n  * wrapname: _wrap_gp_Ax2d_Translated__SWIG_0\n  * fulldecl: gp_Ax2d gp_Ax2d::Translated(gp_Vec2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


EXPORT void _wrap_gp_Ax2d_Translate__SWIG_1 (gp_Ax2d *larg1, gp_Pnt2d *larg2, gp_Pnt2d *larg3) {
  gp_Ax2d *arg1 = (gp_Ax2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Pnt2d *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Pnt2d const &)*arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2d_Translate\n  * wrapname: _wrap_gp_Ax2d_Translate__SWIG_1\n  * fulldecl: void gp_Ax2d::Translate(gp_Pnt2d const &,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax2d *_wrap_gp_Ax2d_Translated__SWIG_1 (gp_Ax2d *larg1, gp_Pnt2d *larg2, gp_Pnt2d *larg3) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  gp_Ax2d *arg1 = (gp_Ax2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Pnt2d *arg3 = 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax2d const *)arg1)->Translated((gp_Pnt2d const &)*arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2d_Translated\n  * wrapname: _wrap_gp_Ax2d_Translated__SWIG_1\n  * fulldecl: gp_Ax2d gp_Ax2d::Translated(gp_Pnt2d const &,gp_Pnt2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


EXPORT void _wrap_delete_gp_Ax2d (gp_Ax2d *larg1) {
  gp_Ax2d *arg1 = (gp_Ax2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Ax2d\n  * wrapname: _wrap_delete_gp_Ax2d\n  * fulldecl: gp_Ax2d::~gp_Ax2d()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax22d *_wrap_new_gp_Ax22d__SWIG_0 () {
  gp_Ax22d * lresult = (gp_Ax22d *)0 ;
  gp_Ax22d *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax22d *)new gp_Ax22d();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax22d\n  * wrapname: _wrap_new_gp_Ax22d__SWIG_0\n  * fulldecl: gp_Ax22d::gp_Ax22d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax22d *)0;
  }
}


EXPORT gp_Ax22d *_wrap_new_gp_Ax22d__SWIG_1 (gp_Pnt2d *larg1, gp_Dir2d *larg2, gp_Dir2d *larg3) {
  gp_Ax22d * lresult = (gp_Ax22d *)0 ;
  gp_Pnt2d *arg1 = 0 ;
  gp_Dir2d *arg2 = 0 ;
  gp_Dir2d *arg3 = 0 ;
  gp_Ax22d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax22d *)new gp_Ax22d((gp_Pnt2d const &)*arg1,(gp_Dir2d const &)*arg2,(gp_Dir2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax22d\n  * wrapname: _wrap_new_gp_Ax22d__SWIG_1\n  * fulldecl: gp_Ax22d::gp_Ax22d(gp_Pnt2d const &,gp_Dir2d const &,gp_Dir2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax22d *)0;
  }
}


EXPORT gp_Ax22d *_wrap_new_gp_Ax22d__SWIG_2 (gp_Pnt2d *larg1, gp_Dir2d *larg2, bool larg3) {
  gp_Ax22d * lresult = (gp_Ax22d *)0 ;
  gp_Pnt2d *arg1 = 0 ;
  gp_Dir2d *arg2 = 0 ;
  Standard_Boolean arg3 ;
  gp_Ax22d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax22d *)new gp_Ax22d((gp_Pnt2d const &)*arg1,(gp_Dir2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax22d\n  * wrapname: _wrap_new_gp_Ax22d__SWIG_2\n  * fulldecl: gp_Ax22d::gp_Ax22d(gp_Pnt2d const &,gp_Dir2d const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax22d *)0;
  }
}


EXPORT gp_Ax22d *_wrap_new_gp_Ax22d__SWIG_3 (gp_Pnt2d *larg1, gp_Dir2d *larg2) {
  gp_Ax22d * lresult = (gp_Ax22d *)0 ;
  gp_Pnt2d *arg1 = 0 ;
  gp_Dir2d *arg2 = 0 ;
  gp_Ax22d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax22d *)new gp_Ax22d((gp_Pnt2d const &)*arg1,(gp_Dir2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax22d\n  * wrapname: _wrap_new_gp_Ax22d__SWIG_3\n  * fulldecl: gp_Ax22d::gp_Ax22d(gp_Pnt2d const &,gp_Dir2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax22d *)0;
  }
}


EXPORT gp_Ax22d *_wrap_new_gp_Ax22d__SWIG_4 (gp_Ax2d *larg1, bool larg2) {
  gp_Ax22d * lresult = (gp_Ax22d *)0 ;
  gp_Ax2d *arg1 = 0 ;
  Standard_Boolean arg2 ;
  gp_Ax22d *result = 0 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax22d *)new gp_Ax22d((gp_Ax2d const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax22d\n  * wrapname: _wrap_new_gp_Ax22d__SWIG_4\n  * fulldecl: gp_Ax22d::gp_Ax22d(gp_Ax2d const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax22d *)0;
  }
}


EXPORT gp_Ax22d *_wrap_new_gp_Ax22d__SWIG_5 (gp_Ax2d *larg1) {
  gp_Ax22d * lresult = (gp_Ax22d *)0 ;
  gp_Ax2d *arg1 = 0 ;
  gp_Ax22d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax22d *)new gp_Ax22d((gp_Ax2d const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax22d\n  * wrapname: _wrap_new_gp_Ax22d__SWIG_5\n  * fulldecl: gp_Ax22d::gp_Ax22d(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax22d *)0;
  }
}


EXPORT void _wrap_gp_Ax22d_SetAxis (gp_Ax22d *larg1, gp_Ax22d *larg2) {
  gp_Ax22d *arg1 = (gp_Ax22d *) 0 ;
  gp_Ax22d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetAxis((gp_Ax22d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax22d_SetAxis\n  * wrapname: _wrap_gp_Ax22d_SetAxis\n  * fulldecl: void gp_Ax22d::SetAxis(gp_Ax22d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Ax22d_SetXAxis (gp_Ax22d *larg1, gp_Ax2d *larg2) {
  gp_Ax22d *arg1 = (gp_Ax22d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetXAxis((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax22d_SetXAxis\n  * wrapname: _wrap_gp_Ax22d_SetXAxis\n  * fulldecl: void gp_Ax22d::SetXAxis(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Ax22d_SetYAxis (gp_Ax22d *larg1, gp_Ax2d *larg2) {
  gp_Ax22d *arg1 = (gp_Ax22d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetYAxis((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax22d_SetYAxis\n  * wrapname: _wrap_gp_Ax22d_SetYAxis\n  * fulldecl: void gp_Ax22d::SetYAxis(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Ax22d_SetLocation (gp_Ax22d *larg1, gp_Pnt2d *larg2) {
  gp_Ax22d *arg1 = (gp_Ax22d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLocation((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax22d_SetLocation\n  * wrapname: _wrap_gp_Ax22d_SetLocation\n  * fulldecl: void gp_Ax22d::SetLocation(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Ax22d_SetXDirection (gp_Ax22d *larg1, gp_Dir2d *larg2) {
  gp_Ax22d *arg1 = (gp_Ax22d *) 0 ;
  gp_Dir2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetXDirection((gp_Dir2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax22d_SetXDirection\n  * wrapname: _wrap_gp_Ax22d_SetXDirection\n  * fulldecl: void gp_Ax22d::SetXDirection(gp_Dir2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Ax22d_SetYDirection (gp_Ax22d *larg1, gp_Dir2d *larg2) {
  gp_Ax22d *arg1 = (gp_Ax22d *) 0 ;
  gp_Dir2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetYDirection((gp_Dir2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax22d_SetYDirection\n  * wrapname: _wrap_gp_Ax22d_SetYDirection\n  * fulldecl: void gp_Ax22d::SetYDirection(gp_Dir2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax2d *_wrap_gp_Ax22d_XAxis (gp_Ax22d *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  gp_Ax22d *arg1 = (gp_Ax22d *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax22d const *)arg1)->XAxis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax22d_XAxis\n  * wrapname: _wrap_gp_Ax22d_XAxis\n  * fulldecl: gp_Ax2d gp_Ax22d::XAxis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


EXPORT gp_Ax2d *_wrap_gp_Ax22d_YAxis (gp_Ax22d *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  gp_Ax22d *arg1 = (gp_Ax22d *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax22d const *)arg1)->YAxis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax22d_YAxis\n  * wrapname: _wrap_gp_Ax22d_YAxis\n  * fulldecl: gp_Ax2d gp_Ax22d::YAxis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


EXPORT gp_Pnt2d *_wrap_gp_Ax22d_Location (gp_Ax22d *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  gp_Ax22d *arg1 = (gp_Ax22d *) 0 ;
  gp_Pnt2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt2d *) &((gp_Ax22d const *)arg1)->Location();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax22d_Location\n  * wrapname: _wrap_gp_Ax22d_Location\n  * fulldecl: gp_Pnt2d const & gp_Ax22d::Location() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT gp_Dir2d *_wrap_gp_Ax22d_XDirection (gp_Ax22d *larg1) {
  gp_Dir2d * lresult = (gp_Dir2d *)0 ;
  gp_Ax22d *arg1 = (gp_Ax22d *) 0 ;
  gp_Dir2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Dir2d *) &((gp_Ax22d const *)arg1)->XDirection();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax22d_XDirection\n  * wrapname: _wrap_gp_Ax22d_XDirection\n  * fulldecl: gp_Dir2d const & gp_Ax22d::XDirection() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Dir2d *)0;
  }
}


EXPORT gp_Dir2d *_wrap_gp_Ax22d_YDirection (gp_Ax22d *larg1) {
  gp_Dir2d * lresult = (gp_Dir2d *)0 ;
  gp_Ax22d *arg1 = (gp_Ax22d *) 0 ;
  gp_Dir2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Dir2d *) &((gp_Ax22d const *)arg1)->YDirection();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax22d_YDirection\n  * wrapname: _wrap_gp_Ax22d_YDirection\n  * fulldecl: gp_Dir2d const & gp_Ax22d::YDirection() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Dir2d *)0;
  }
}


EXPORT void _wrap_gp_Ax22d_Mirror__SWIG_0 (gp_Ax22d *larg1, gp_Pnt2d *larg2) {
  gp_Ax22d *arg1 = (gp_Ax22d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax22d_Mirror\n  * wrapname: _wrap_gp_Ax22d_Mirror__SWIG_0\n  * fulldecl: void gp_Ax22d::Mirror(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax22d *_wrap_gp_Ax22d_Mirrored__SWIG_0 (gp_Ax22d *larg1, gp_Pnt2d *larg2) {
  gp_Ax22d * lresult = (gp_Ax22d *)0 ;
  gp_Ax22d *arg1 = (gp_Ax22d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Ax22d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax22d const *)arg1)->Mirrored((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax22d_Mirrored\n  * wrapname: _wrap_gp_Ax22d_Mirrored__SWIG_0\n  * fulldecl: gp_Ax22d gp_Ax22d::Mirrored(gp_Pnt2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax22d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax22d *)0;
  }
}


EXPORT void _wrap_gp_Ax22d_Mirror__SWIG_1 (gp_Ax22d *larg1, gp_Ax2d *larg2) {
  gp_Ax22d *arg1 = (gp_Ax22d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax22d_Mirror\n  * wrapname: _wrap_gp_Ax22d_Mirror__SWIG_1\n  * fulldecl: void gp_Ax22d::Mirror(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax22d *_wrap_gp_Ax22d_Mirrored__SWIG_1 (gp_Ax22d *larg1, gp_Ax2d *larg2) {
  gp_Ax22d * lresult = (gp_Ax22d *)0 ;
  gp_Ax22d *arg1 = (gp_Ax22d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  gp_Ax22d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax22d const *)arg1)->Mirrored((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax22d_Mirrored\n  * wrapname: _wrap_gp_Ax22d_Mirrored__SWIG_1\n  * fulldecl: gp_Ax22d gp_Ax22d::Mirrored(gp_Ax2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax22d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax22d *)0;
  }
}


EXPORT void _wrap_gp_Ax22d_Rotate (gp_Ax22d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Ax22d *arg1 = (gp_Ax22d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Rotate((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax22d_Rotate\n  * wrapname: _wrap_gp_Ax22d_Rotate\n  * fulldecl: void gp_Ax22d::Rotate(gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax22d *_wrap_gp_Ax22d_Rotated (gp_Ax22d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Ax22d * lresult = (gp_Ax22d *)0 ;
  gp_Ax22d *arg1 = (gp_Ax22d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Ax22d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax22d const *)arg1)->Rotated((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax22d_Rotated\n  * wrapname: _wrap_gp_Ax22d_Rotated\n  * fulldecl: gp_Ax22d gp_Ax22d::Rotated(gp_Pnt2d const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax22d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax22d *)0;
  }
}


EXPORT void _wrap_gp_Ax22d_Scale (gp_Ax22d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Ax22d *arg1 = (gp_Ax22d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Scale((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax22d_Scale\n  * wrapname: _wrap_gp_Ax22d_Scale\n  * fulldecl: void gp_Ax22d::Scale(gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax22d *_wrap_gp_Ax22d_Scaled (gp_Ax22d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Ax22d * lresult = (gp_Ax22d *)0 ;
  gp_Ax22d *arg1 = (gp_Ax22d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Ax22d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax22d const *)arg1)->Scaled((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax22d_Scaled\n  * wrapname: _wrap_gp_Ax22d_Scaled\n  * fulldecl: gp_Ax22d gp_Ax22d::Scaled(gp_Pnt2d const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax22d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax22d *)0;
  }
}


EXPORT void _wrap_gp_Ax22d_Transform (gp_Ax22d *larg1, gp_Trsf2d *larg2) {
  gp_Ax22d *arg1 = (gp_Ax22d *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Transform((gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax22d_Transform\n  * wrapname: _wrap_gp_Ax22d_Transform\n  * fulldecl: void gp_Ax22d::Transform(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax22d *_wrap_gp_Ax22d_Transformed (gp_Ax22d *larg1, gp_Trsf2d *larg2) {
  gp_Ax22d * lresult = (gp_Ax22d *)0 ;
  gp_Ax22d *arg1 = (gp_Ax22d *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  gp_Ax22d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax22d const *)arg1)->Transformed((gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax22d_Transformed\n  * wrapname: _wrap_gp_Ax22d_Transformed\n  * fulldecl: gp_Ax22d gp_Ax22d::Transformed(gp_Trsf2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax22d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax22d *)0;
  }
}


EXPORT void _wrap_gp_Ax22d_Translate__SWIG_0 (gp_Ax22d *larg1, gp_Vec2d *larg2) {
  gp_Ax22d *arg1 = (gp_Ax22d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax22d_Translate\n  * wrapname: _wrap_gp_Ax22d_Translate__SWIG_0\n  * fulldecl: void gp_Ax22d::Translate(gp_Vec2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax22d *_wrap_gp_Ax22d_Translated__SWIG_0 (gp_Ax22d *larg1, gp_Vec2d *larg2) {
  gp_Ax22d * lresult = (gp_Ax22d *)0 ;
  gp_Ax22d *arg1 = (gp_Ax22d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  gp_Ax22d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax22d const *)arg1)->Translated((gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax22d_Translated\n  * wrapname: _wrap_gp_Ax22d_Translated__SWIG_0\n  * fulldecl: gp_Ax22d gp_Ax22d::Translated(gp_Vec2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax22d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax22d *)0;
  }
}


EXPORT void _wrap_gp_Ax22d_Translate__SWIG_1 (gp_Ax22d *larg1, gp_Pnt2d *larg2, gp_Pnt2d *larg3) {
  gp_Ax22d *arg1 = (gp_Ax22d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Pnt2d *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Pnt2d const &)*arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax22d_Translate\n  * wrapname: _wrap_gp_Ax22d_Translate__SWIG_1\n  * fulldecl: void gp_Ax22d::Translate(gp_Pnt2d const &,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax22d *_wrap_gp_Ax22d_Translated__SWIG_1 (gp_Ax22d *larg1, gp_Pnt2d *larg2, gp_Pnt2d *larg3) {
  gp_Ax22d * lresult = (gp_Ax22d *)0 ;
  gp_Ax22d *arg1 = (gp_Ax22d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Pnt2d *arg3 = 0 ;
  gp_Ax22d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax22d const *)arg1)->Translated((gp_Pnt2d const &)*arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax22d_Translated\n  * wrapname: _wrap_gp_Ax22d_Translated__SWIG_1\n  * fulldecl: gp_Ax22d gp_Ax22d::Translated(gp_Pnt2d const &,gp_Pnt2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax22d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax22d *)0;
  }
}


EXPORT void _wrap_delete_gp_Ax22d (gp_Ax22d *larg1) {
  gp_Ax22d *arg1 = (gp_Ax22d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Ax22d\n  * wrapname: _wrap_delete_gp_Ax22d\n  * fulldecl: gp_Ax22d::~gp_Ax22d()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Circ2d *_wrap_new_gp_Circ2d__SWIG_0 () {
  gp_Circ2d * lresult = (gp_Circ2d *)0 ;
  gp_Circ2d *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Circ2d *)new gp_Circ2d();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Circ2d\n  * wrapname: _wrap_new_gp_Circ2d__SWIG_0\n  * fulldecl: gp_Circ2d::gp_Circ2d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Circ2d *)0;
  }
}


EXPORT gp_Circ2d *_wrap_new_gp_Circ2d__SWIG_1 (gp_Ax2d *larg1, Standard_Real larg2, bool larg3) {
  gp_Circ2d * lresult = (gp_Circ2d *)0 ;
  gp_Ax2d *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Boolean arg3 ;
  gp_Circ2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Circ2d *)new gp_Circ2d((gp_Ax2d const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Circ2d\n  * wrapname: _wrap_new_gp_Circ2d__SWIG_1\n  * fulldecl: gp_Circ2d::gp_Circ2d(gp_Ax2d const &,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Circ2d *)0;
  }
}


EXPORT gp_Circ2d *_wrap_new_gp_Circ2d__SWIG_2 (gp_Ax2d *larg1, Standard_Real larg2) {
  gp_Circ2d * lresult = (gp_Circ2d *)0 ;
  gp_Ax2d *arg1 = 0 ;
  Standard_Real arg2 ;
  gp_Circ2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Circ2d *)new gp_Circ2d((gp_Ax2d const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Circ2d\n  * wrapname: _wrap_new_gp_Circ2d__SWIG_2\n  * fulldecl: gp_Circ2d::gp_Circ2d(gp_Ax2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Circ2d *)0;
  }
}


EXPORT gp_Circ2d *_wrap_new_gp_Circ2d__SWIG_3 (gp_Ax22d *larg1, Standard_Real larg2) {
  gp_Circ2d * lresult = (gp_Circ2d *)0 ;
  gp_Ax22d *arg1 = 0 ;
  Standard_Real arg2 ;
  gp_Circ2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Circ2d *)new gp_Circ2d((gp_Ax22d const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Circ2d\n  * wrapname: _wrap_new_gp_Circ2d__SWIG_3\n  * fulldecl: gp_Circ2d::gp_Circ2d(gp_Ax22d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Circ2d *)0;
  }
}


EXPORT void _wrap_gp_Circ2d_SetLocation (gp_Circ2d *larg1, gp_Pnt2d *larg2) {
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLocation((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_SetLocation\n  * wrapname: _wrap_gp_Circ2d_SetLocation\n  * fulldecl: void gp_Circ2d::SetLocation(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Circ2d_SetXAxis (gp_Circ2d *larg1, gp_Ax2d *larg2) {
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetXAxis((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_SetXAxis\n  * wrapname: _wrap_gp_Circ2d_SetXAxis\n  * fulldecl: void gp_Circ2d::SetXAxis(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Circ2d_SetAxis (gp_Circ2d *larg1, gp_Ax22d *larg2) {
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  gp_Ax22d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetAxis((gp_Ax22d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_SetAxis\n  * wrapname: _wrap_gp_Circ2d_SetAxis\n  * fulldecl: void gp_Circ2d::SetAxis(gp_Ax22d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Circ2d_SetYAxis (gp_Circ2d *larg1, gp_Ax2d *larg2) {
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetYAxis((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_SetYAxis\n  * wrapname: _wrap_gp_Circ2d_SetYAxis\n  * fulldecl: void gp_Circ2d::SetYAxis(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Circ2d_SetRadius (gp_Circ2d *larg1, Standard_Real larg2) {
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetRadius(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_SetRadius\n  * wrapname: _wrap_gp_Circ2d_SetRadius\n  * fulldecl: void gp_Circ2d::SetRadius(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Real _wrap_gp_Circ2d_Area (gp_Circ2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Circ2d const *)arg1)->Area();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_Area\n  * wrapname: _wrap_gp_Circ2d_Area\n  * fulldecl: Standard_Real gp_Circ2d::Area() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_gp_Circ2d_Coefficients (gp_Circ2d *larg1, Standard_Real *larg2, Standard_Real *larg3, Standard_Real *larg4, Standard_Real *larg5, Standard_Real *larg6, Standard_Real *larg7) {
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  Standard_Real *arg5 = 0 ;
  Standard_Real *arg6 = 0 ;
  Standard_Real *arg7 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((gp_Circ2d const *)arg1)->Coefficients(*arg2,*arg3,*arg4,*arg5,*arg6,*arg7);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_Coefficients\n  * wrapname: _wrap_gp_Circ2d_Coefficients\n  * fulldecl: void gp_Circ2d::Coefficients(Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_gp_Circ2d_Contains (gp_Circ2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Circ2d const *)arg1)->Contains((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_Contains\n  * wrapname: _wrap_gp_Circ2d_Contains\n  * fulldecl: Standard_Boolean gp_Circ2d::Contains(gp_Pnt2d const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Standard_Real _wrap_gp_Circ2d_Distance (gp_Circ2d *larg1, gp_Pnt2d *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Circ2d const *)arg1)->Distance((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_Distance\n  * wrapname: _wrap_gp_Circ2d_Distance\n  * fulldecl: Standard_Real gp_Circ2d::Distance(gp_Pnt2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Circ2d_SquareDistance (gp_Circ2d *larg1, gp_Pnt2d *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Circ2d const *)arg1)->SquareDistance((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_SquareDistance\n  * wrapname: _wrap_gp_Circ2d_SquareDistance\n  * fulldecl: Standard_Real gp_Circ2d::SquareDistance(gp_Pnt2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Circ2d_Length (gp_Circ2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Circ2d const *)arg1)->Length();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_Length\n  * wrapname: _wrap_gp_Circ2d_Length\n  * fulldecl: Standard_Real gp_Circ2d::Length() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Pnt2d *_wrap_gp_Circ2d_Location (gp_Circ2d *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  gp_Pnt2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt2d *) &((gp_Circ2d const *)arg1)->Location();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_Location\n  * wrapname: _wrap_gp_Circ2d_Location\n  * fulldecl: gp_Pnt2d const & gp_Circ2d::Location() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Circ2d_Radius (gp_Circ2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Circ2d const *)arg1)->Radius();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_Radius\n  * wrapname: _wrap_gp_Circ2d_Radius\n  * fulldecl: Standard_Real gp_Circ2d::Radius() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Ax22d *_wrap_gp_Circ2d_Axis (gp_Circ2d *larg1) {
  gp_Ax22d * lresult = (gp_Ax22d *)0 ;
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  gp_Ax22d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax22d *) &((gp_Circ2d const *)arg1)->Axis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_Axis\n  * wrapname: _wrap_gp_Circ2d_Axis\n  * fulldecl: gp_Ax22d const & gp_Circ2d::Axis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax22d *)0;
  }
}


EXPORT gp_Ax22d *_wrap_gp_Circ2d_Position (gp_Circ2d *larg1) {
  gp_Ax22d * lresult = (gp_Ax22d *)0 ;
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  gp_Ax22d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax22d *) &((gp_Circ2d const *)arg1)->Position();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_Position\n  * wrapname: _wrap_gp_Circ2d_Position\n  * fulldecl: gp_Ax22d const & gp_Circ2d::Position() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax22d *)0;
  }
}


EXPORT gp_Ax2d *_wrap_gp_Circ2d_XAxis (gp_Circ2d *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Circ2d const *)arg1)->XAxis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_XAxis\n  * wrapname: _wrap_gp_Circ2d_XAxis\n  * fulldecl: gp_Ax2d gp_Circ2d::XAxis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


EXPORT gp_Ax2d *_wrap_gp_Circ2d_YAxis (gp_Circ2d *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Circ2d const *)arg1)->YAxis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_YAxis\n  * wrapname: _wrap_gp_Circ2d_YAxis\n  * fulldecl: gp_Ax2d gp_Circ2d::YAxis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


EXPORT void _wrap_gp_Circ2d_Reverse (gp_Circ2d *larg1) {
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Reverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_Reverse\n  * wrapname: _wrap_gp_Circ2d_Reverse\n  * fulldecl: void gp_Circ2d::Reverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Circ2d *_wrap_gp_Circ2d_Reversed (gp_Circ2d *larg1) {
  gp_Circ2d * lresult = (gp_Circ2d *)0 ;
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  gp_Circ2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Circ2d const *)arg1)->Reversed();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_Reversed\n  * wrapname: _wrap_gp_Circ2d_Reversed\n  * fulldecl: gp_Circ2d gp_Circ2d::Reversed() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Circ2d(result);
    return lresult;
  } catch (...) {
    return (gp_Circ2d *)0;
  }
}


EXPORT bool _wrap_gp_Circ2d_IsDirect (gp_Circ2d *larg1) {
  bool lresult = (bool)0 ;
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Circ2d const *)arg1)->IsDirect();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_IsDirect\n  * wrapname: _wrap_gp_Circ2d_IsDirect\n  * fulldecl: Standard_Boolean gp_Circ2d::IsDirect() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_gp_Circ2d_Mirror__SWIG_0 (gp_Circ2d *larg1, gp_Pnt2d *larg2) {
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_Mirror\n  * wrapname: _wrap_gp_Circ2d_Mirror__SWIG_0\n  * fulldecl: void gp_Circ2d::Mirror(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Circ2d *_wrap_gp_Circ2d_Mirrored__SWIG_0 (gp_Circ2d *larg1, gp_Pnt2d *larg2) {
  gp_Circ2d * lresult = (gp_Circ2d *)0 ;
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Circ2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Circ2d const *)arg1)->Mirrored((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_Mirrored\n  * wrapname: _wrap_gp_Circ2d_Mirrored__SWIG_0\n  * fulldecl: gp_Circ2d gp_Circ2d::Mirrored(gp_Pnt2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Circ2d(result);
    return lresult;
  } catch (...) {
    return (gp_Circ2d *)0;
  }
}


EXPORT void _wrap_gp_Circ2d_Mirror__SWIG_1 (gp_Circ2d *larg1, gp_Ax2d *larg2) {
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_Mirror\n  * wrapname: _wrap_gp_Circ2d_Mirror__SWIG_1\n  * fulldecl: void gp_Circ2d::Mirror(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Circ2d *_wrap_gp_Circ2d_Mirrored__SWIG_1 (gp_Circ2d *larg1, gp_Ax2d *larg2) {
  gp_Circ2d * lresult = (gp_Circ2d *)0 ;
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  gp_Circ2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Circ2d const *)arg1)->Mirrored((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_Mirrored\n  * wrapname: _wrap_gp_Circ2d_Mirrored__SWIG_1\n  * fulldecl: gp_Circ2d gp_Circ2d::Mirrored(gp_Ax2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Circ2d(result);
    return lresult;
  } catch (...) {
    return (gp_Circ2d *)0;
  }
}


EXPORT void _wrap_gp_Circ2d_Rotate (gp_Circ2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Rotate((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_Rotate\n  * wrapname: _wrap_gp_Circ2d_Rotate\n  * fulldecl: void gp_Circ2d::Rotate(gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Circ2d *_wrap_gp_Circ2d_Rotated (gp_Circ2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Circ2d * lresult = (gp_Circ2d *)0 ;
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Circ2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Circ2d const *)arg1)->Rotated((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_Rotated\n  * wrapname: _wrap_gp_Circ2d_Rotated\n  * fulldecl: gp_Circ2d gp_Circ2d::Rotated(gp_Pnt2d const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Circ2d(result);
    return lresult;
  } catch (...) {
    return (gp_Circ2d *)0;
  }
}


EXPORT void _wrap_gp_Circ2d_Scale (gp_Circ2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Scale((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_Scale\n  * wrapname: _wrap_gp_Circ2d_Scale\n  * fulldecl: void gp_Circ2d::Scale(gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Circ2d *_wrap_gp_Circ2d_Scaled (gp_Circ2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Circ2d * lresult = (gp_Circ2d *)0 ;
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Circ2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Circ2d const *)arg1)->Scaled((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_Scaled\n  * wrapname: _wrap_gp_Circ2d_Scaled\n  * fulldecl: gp_Circ2d gp_Circ2d::Scaled(gp_Pnt2d const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Circ2d(result);
    return lresult;
  } catch (...) {
    return (gp_Circ2d *)0;
  }
}


EXPORT void _wrap_gp_Circ2d_Transform (gp_Circ2d *larg1, gp_Trsf2d *larg2) {
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Transform((gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_Transform\n  * wrapname: _wrap_gp_Circ2d_Transform\n  * fulldecl: void gp_Circ2d::Transform(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Circ2d *_wrap_gp_Circ2d_Transformed (gp_Circ2d *larg1, gp_Trsf2d *larg2) {
  gp_Circ2d * lresult = (gp_Circ2d *)0 ;
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  gp_Circ2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Circ2d const *)arg1)->Transformed((gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_Transformed\n  * wrapname: _wrap_gp_Circ2d_Transformed\n  * fulldecl: gp_Circ2d gp_Circ2d::Transformed(gp_Trsf2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Circ2d(result);
    return lresult;
  } catch (...) {
    return (gp_Circ2d *)0;
  }
}


EXPORT void _wrap_gp_Circ2d_Translate__SWIG_0 (gp_Circ2d *larg1, gp_Vec2d *larg2) {
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_Translate\n  * wrapname: _wrap_gp_Circ2d_Translate__SWIG_0\n  * fulldecl: void gp_Circ2d::Translate(gp_Vec2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Circ2d *_wrap_gp_Circ2d_Translated__SWIG_0 (gp_Circ2d *larg1, gp_Vec2d *larg2) {
  gp_Circ2d * lresult = (gp_Circ2d *)0 ;
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  gp_Circ2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Circ2d const *)arg1)->Translated((gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_Translated\n  * wrapname: _wrap_gp_Circ2d_Translated__SWIG_0\n  * fulldecl: gp_Circ2d gp_Circ2d::Translated(gp_Vec2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Circ2d(result);
    return lresult;
  } catch (...) {
    return (gp_Circ2d *)0;
  }
}


EXPORT void _wrap_gp_Circ2d_Translate__SWIG_1 (gp_Circ2d *larg1, gp_Pnt2d *larg2, gp_Pnt2d *larg3) {
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Pnt2d *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Pnt2d const &)*arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_Translate\n  * wrapname: _wrap_gp_Circ2d_Translate__SWIG_1\n  * fulldecl: void gp_Circ2d::Translate(gp_Pnt2d const &,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Circ2d *_wrap_gp_Circ2d_Translated__SWIG_1 (gp_Circ2d *larg1, gp_Pnt2d *larg2, gp_Pnt2d *larg3) {
  gp_Circ2d * lresult = (gp_Circ2d *)0 ;
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Pnt2d *arg3 = 0 ;
  gp_Circ2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Circ2d const *)arg1)->Translated((gp_Pnt2d const &)*arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ2d_Translated\n  * wrapname: _wrap_gp_Circ2d_Translated__SWIG_1\n  * fulldecl: gp_Circ2d gp_Circ2d::Translated(gp_Pnt2d const &,gp_Pnt2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Circ2d(result);
    return lresult;
  } catch (...) {
    return (gp_Circ2d *)0;
  }
}


EXPORT void _wrap_delete_gp_Circ2d (gp_Circ2d *larg1) {
  gp_Circ2d *arg1 = (gp_Circ2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Circ2d\n  * wrapname: _wrap_delete_gp_Circ2d\n  * fulldecl: gp_Circ2d::~gp_Circ2d()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Elips2d *_wrap_new_gp_Elips2d__SWIG_0 () {
  gp_Elips2d * lresult = (gp_Elips2d *)0 ;
  gp_Elips2d *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Elips2d *)new gp_Elips2d();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Elips2d\n  * wrapname: _wrap_new_gp_Elips2d__SWIG_0\n  * fulldecl: gp_Elips2d::gp_Elips2d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Elips2d *)0;
  }
}


EXPORT gp_Elips2d *_wrap_new_gp_Elips2d__SWIG_1 (gp_Ax2d *larg1, Standard_Real larg2, Standard_Real larg3, bool larg4) {
  gp_Elips2d * lresult = (gp_Elips2d *)0 ;
  gp_Ax2d *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Boolean arg4 ;
  gp_Elips2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Elips2d *)new gp_Elips2d((gp_Ax2d const &)*arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Elips2d\n  * wrapname: _wrap_new_gp_Elips2d__SWIG_1\n  * fulldecl: gp_Elips2d::gp_Elips2d(gp_Ax2d const &,Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Elips2d *)0;
  }
}


EXPORT gp_Elips2d *_wrap_new_gp_Elips2d__SWIG_2 (gp_Ax2d *larg1, Standard_Real larg2, Standard_Real larg3) {
  gp_Elips2d * lresult = (gp_Elips2d *)0 ;
  gp_Ax2d *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  gp_Elips2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Elips2d *)new gp_Elips2d((gp_Ax2d const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Elips2d\n  * wrapname: _wrap_new_gp_Elips2d__SWIG_2\n  * fulldecl: gp_Elips2d::gp_Elips2d(gp_Ax2d const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Elips2d *)0;
  }
}


EXPORT gp_Elips2d *_wrap_new_gp_Elips2d__SWIG_3 (gp_Ax22d *larg1, Standard_Real larg2, Standard_Real larg3) {
  gp_Elips2d * lresult = (gp_Elips2d *)0 ;
  gp_Ax22d *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  gp_Elips2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Elips2d *)new gp_Elips2d((gp_Ax22d const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Elips2d\n  * wrapname: _wrap_new_gp_Elips2d__SWIG_3\n  * fulldecl: gp_Elips2d::gp_Elips2d(gp_Ax22d const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Elips2d *)0;
  }
}


EXPORT void _wrap_gp_Elips2d_SetLocation (gp_Elips2d *larg1, gp_Pnt2d *larg2) {
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLocation((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_SetLocation\n  * wrapname: _wrap_gp_Elips2d_SetLocation\n  * fulldecl: void gp_Elips2d::SetLocation(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Elips2d_SetMajorRadius (gp_Elips2d *larg1, Standard_Real larg2) {
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetMajorRadius(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_SetMajorRadius\n  * wrapname: _wrap_gp_Elips2d_SetMajorRadius\n  * fulldecl: void gp_Elips2d::SetMajorRadius(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Elips2d_SetMinorRadius (gp_Elips2d *larg1, Standard_Real larg2) {
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetMinorRadius(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_SetMinorRadius\n  * wrapname: _wrap_gp_Elips2d_SetMinorRadius\n  * fulldecl: void gp_Elips2d::SetMinorRadius(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Elips2d_SetAxis (gp_Elips2d *larg1, gp_Ax22d *larg2) {
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  gp_Ax22d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetAxis((gp_Ax22d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_SetAxis\n  * wrapname: _wrap_gp_Elips2d_SetAxis\n  * fulldecl: void gp_Elips2d::SetAxis(gp_Ax22d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Elips2d_SetXAxis (gp_Elips2d *larg1, gp_Ax2d *larg2) {
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetXAxis((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_SetXAxis\n  * wrapname: _wrap_gp_Elips2d_SetXAxis\n  * fulldecl: void gp_Elips2d::SetXAxis(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Elips2d_SetYAxis (gp_Elips2d *larg1, gp_Ax2d *larg2) {
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetYAxis((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_SetYAxis\n  * wrapname: _wrap_gp_Elips2d_SetYAxis\n  * fulldecl: void gp_Elips2d::SetYAxis(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Real _wrap_gp_Elips2d_Area (gp_Elips2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Elips2d const *)arg1)->Area();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_Area\n  * wrapname: _wrap_gp_Elips2d_Area\n  * fulldecl: Standard_Real gp_Elips2d::Area() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_gp_Elips2d_Coefficients (gp_Elips2d *larg1, Standard_Real *larg2, Standard_Real *larg3, Standard_Real *larg4, Standard_Real *larg5, Standard_Real *larg6, Standard_Real *larg7) {
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  Standard_Real *arg5 = 0 ;
  Standard_Real *arg6 = 0 ;
  Standard_Real *arg7 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((gp_Elips2d const *)arg1)->Coefficients(*arg2,*arg3,*arg4,*arg5,*arg6,*arg7);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_Coefficients\n  * wrapname: _wrap_gp_Elips2d_Coefficients\n  * fulldecl: void gp_Elips2d::Coefficients(Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax2d *_wrap_gp_Elips2d_Directrix1 (gp_Elips2d *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Elips2d const *)arg1)->Directrix1();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_Directrix1\n  * wrapname: _wrap_gp_Elips2d_Directrix1\n  * fulldecl: gp_Ax2d gp_Elips2d::Directrix1() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


EXPORT gp_Ax2d *_wrap_gp_Elips2d_Directrix2 (gp_Elips2d *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Elips2d const *)arg1)->Directrix2();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_Directrix2\n  * wrapname: _wrap_gp_Elips2d_Directrix2\n  * fulldecl: gp_Ax2d gp_Elips2d::Directrix2() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Elips2d_Eccentricity (gp_Elips2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Elips2d const *)arg1)->Eccentricity();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_Eccentricity\n  * wrapname: _wrap_gp_Elips2d_Eccentricity\n  * fulldecl: Standard_Real gp_Elips2d::Eccentricity() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Elips2d_Focal (gp_Elips2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Elips2d const *)arg1)->Focal();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_Focal\n  * wrapname: _wrap_gp_Elips2d_Focal\n  * fulldecl: Standard_Real gp_Elips2d::Focal() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Pnt2d *_wrap_gp_Elips2d_Focus1 (gp_Elips2d *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Elips2d const *)arg1)->Focus1();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_Focus1\n  * wrapname: _wrap_gp_Elips2d_Focus1\n  * fulldecl: gp_Pnt2d gp_Elips2d::Focus1() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT gp_Pnt2d *_wrap_gp_Elips2d_Focus2 (gp_Elips2d *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Elips2d const *)arg1)->Focus2();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_Focus2\n  * wrapname: _wrap_gp_Elips2d_Focus2\n  * fulldecl: gp_Pnt2d gp_Elips2d::Focus2() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT gp_Pnt2d *_wrap_gp_Elips2d_Location (gp_Elips2d *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  gp_Pnt2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt2d *) &((gp_Elips2d const *)arg1)->Location();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_Location\n  * wrapname: _wrap_gp_Elips2d_Location\n  * fulldecl: gp_Pnt2d const & gp_Elips2d::Location() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Elips2d_MajorRadius (gp_Elips2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Elips2d const *)arg1)->MajorRadius();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_MajorRadius\n  * wrapname: _wrap_gp_Elips2d_MajorRadius\n  * fulldecl: Standard_Real gp_Elips2d::MajorRadius() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Elips2d_MinorRadius (gp_Elips2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Elips2d const *)arg1)->MinorRadius();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_MinorRadius\n  * wrapname: _wrap_gp_Elips2d_MinorRadius\n  * fulldecl: Standard_Real gp_Elips2d::MinorRadius() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Elips2d_Parameter (gp_Elips2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Elips2d const *)arg1)->Parameter();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_Parameter\n  * wrapname: _wrap_gp_Elips2d_Parameter\n  * fulldecl: Standard_Real gp_Elips2d::Parameter() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Ax22d *_wrap_gp_Elips2d_Axis (gp_Elips2d *larg1) {
  gp_Ax22d * lresult = (gp_Ax22d *)0 ;
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  gp_Ax22d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax22d *) &((gp_Elips2d const *)arg1)->Axis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_Axis\n  * wrapname: _wrap_gp_Elips2d_Axis\n  * fulldecl: gp_Ax22d const & gp_Elips2d::Axis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax22d *)0;
  }
}


EXPORT gp_Ax2d *_wrap_gp_Elips2d_XAxis (gp_Elips2d *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Elips2d const *)arg1)->XAxis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_XAxis\n  * wrapname: _wrap_gp_Elips2d_XAxis\n  * fulldecl: gp_Ax2d gp_Elips2d::XAxis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


EXPORT gp_Ax2d *_wrap_gp_Elips2d_YAxis (gp_Elips2d *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Elips2d const *)arg1)->YAxis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_YAxis\n  * wrapname: _wrap_gp_Elips2d_YAxis\n  * fulldecl: gp_Ax2d gp_Elips2d::YAxis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


EXPORT void _wrap_gp_Elips2d_Reverse (gp_Elips2d *larg1) {
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Reverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_Reverse\n  * wrapname: _wrap_gp_Elips2d_Reverse\n  * fulldecl: void gp_Elips2d::Reverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_gp_Elips2d_IsDirect (gp_Elips2d *larg1) {
  bool lresult = (bool)0 ;
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Elips2d const *)arg1)->IsDirect();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_IsDirect\n  * wrapname: _wrap_gp_Elips2d_IsDirect\n  * fulldecl: Standard_Boolean gp_Elips2d::IsDirect() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_gp_Elips2d_Mirror__SWIG_0 (gp_Elips2d *larg1, gp_Pnt2d *larg2) {
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_Mirror\n  * wrapname: _wrap_gp_Elips2d_Mirror__SWIG_0\n  * fulldecl: void gp_Elips2d::Mirror(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Elips2d *_wrap_gp_Elips2d_Mirrored__SWIG_0 (gp_Elips2d *larg1, gp_Pnt2d *larg2) {
  gp_Elips2d * lresult = (gp_Elips2d *)0 ;
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Elips2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Elips2d const *)arg1)->Mirrored((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_Mirrored\n  * wrapname: _wrap_gp_Elips2d_Mirrored__SWIG_0\n  * fulldecl: gp_Elips2d gp_Elips2d::Mirrored(gp_Pnt2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Elips2d(result);
    return lresult;
  } catch (...) {
    return (gp_Elips2d *)0;
  }
}


EXPORT void _wrap_gp_Elips2d_Mirror__SWIG_1 (gp_Elips2d *larg1, gp_Ax2d *larg2) {
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_Mirror\n  * wrapname: _wrap_gp_Elips2d_Mirror__SWIG_1\n  * fulldecl: void gp_Elips2d::Mirror(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Elips2d *_wrap_gp_Elips2d_Mirrored__SWIG_1 (gp_Elips2d *larg1, gp_Ax2d *larg2) {
  gp_Elips2d * lresult = (gp_Elips2d *)0 ;
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  gp_Elips2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Elips2d const *)arg1)->Mirrored((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_Mirrored\n  * wrapname: _wrap_gp_Elips2d_Mirrored__SWIG_1\n  * fulldecl: gp_Elips2d gp_Elips2d::Mirrored(gp_Ax2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Elips2d(result);
    return lresult;
  } catch (...) {
    return (gp_Elips2d *)0;
  }
}


EXPORT void _wrap_gp_Elips2d_Rotate (gp_Elips2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Rotate((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_Rotate\n  * wrapname: _wrap_gp_Elips2d_Rotate\n  * fulldecl: void gp_Elips2d::Rotate(gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Elips2d *_wrap_gp_Elips2d_Rotated (gp_Elips2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Elips2d * lresult = (gp_Elips2d *)0 ;
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Elips2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Elips2d const *)arg1)->Rotated((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_Rotated\n  * wrapname: _wrap_gp_Elips2d_Rotated\n  * fulldecl: gp_Elips2d gp_Elips2d::Rotated(gp_Pnt2d const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Elips2d(result);
    return lresult;
  } catch (...) {
    return (gp_Elips2d *)0;
  }
}


EXPORT void _wrap_gp_Elips2d_Scale (gp_Elips2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Scale((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_Scale\n  * wrapname: _wrap_gp_Elips2d_Scale\n  * fulldecl: void gp_Elips2d::Scale(gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Elips2d *_wrap_gp_Elips2d_Scaled (gp_Elips2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Elips2d * lresult = (gp_Elips2d *)0 ;
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Elips2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Elips2d const *)arg1)->Scaled((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_Scaled\n  * wrapname: _wrap_gp_Elips2d_Scaled\n  * fulldecl: gp_Elips2d gp_Elips2d::Scaled(gp_Pnt2d const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Elips2d(result);
    return lresult;
  } catch (...) {
    return (gp_Elips2d *)0;
  }
}


EXPORT void _wrap_gp_Elips2d_Transform (gp_Elips2d *larg1, gp_Trsf2d *larg2) {
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Transform((gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_Transform\n  * wrapname: _wrap_gp_Elips2d_Transform\n  * fulldecl: void gp_Elips2d::Transform(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Elips2d *_wrap_gp_Elips2d_Transformed (gp_Elips2d *larg1, gp_Trsf2d *larg2) {
  gp_Elips2d * lresult = (gp_Elips2d *)0 ;
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  gp_Elips2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Elips2d const *)arg1)->Transformed((gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_Transformed\n  * wrapname: _wrap_gp_Elips2d_Transformed\n  * fulldecl: gp_Elips2d gp_Elips2d::Transformed(gp_Trsf2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Elips2d(result);
    return lresult;
  } catch (...) {
    return (gp_Elips2d *)0;
  }
}


EXPORT void _wrap_gp_Elips2d_Translate__SWIG_0 (gp_Elips2d *larg1, gp_Vec2d *larg2) {
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_Translate\n  * wrapname: _wrap_gp_Elips2d_Translate__SWIG_0\n  * fulldecl: void gp_Elips2d::Translate(gp_Vec2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Elips2d *_wrap_gp_Elips2d_Translated__SWIG_0 (gp_Elips2d *larg1, gp_Vec2d *larg2) {
  gp_Elips2d * lresult = (gp_Elips2d *)0 ;
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  gp_Elips2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Elips2d const *)arg1)->Translated((gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_Translated\n  * wrapname: _wrap_gp_Elips2d_Translated__SWIG_0\n  * fulldecl: gp_Elips2d gp_Elips2d::Translated(gp_Vec2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Elips2d(result);
    return lresult;
  } catch (...) {
    return (gp_Elips2d *)0;
  }
}


EXPORT void _wrap_gp_Elips2d_Translate__SWIG_1 (gp_Elips2d *larg1, gp_Pnt2d *larg2, gp_Pnt2d *larg3) {
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Pnt2d *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Pnt2d const &)*arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_Translate\n  * wrapname: _wrap_gp_Elips2d_Translate__SWIG_1\n  * fulldecl: void gp_Elips2d::Translate(gp_Pnt2d const &,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Elips2d *_wrap_gp_Elips2d_Translated__SWIG_1 (gp_Elips2d *larg1, gp_Pnt2d *larg2, gp_Pnt2d *larg3) {
  gp_Elips2d * lresult = (gp_Elips2d *)0 ;
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Pnt2d *arg3 = 0 ;
  gp_Elips2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Elips2d const *)arg1)->Translated((gp_Pnt2d const &)*arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips2d_Translated\n  * wrapname: _wrap_gp_Elips2d_Translated__SWIG_1\n  * fulldecl: gp_Elips2d gp_Elips2d::Translated(gp_Pnt2d const &,gp_Pnt2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Elips2d(result);
    return lresult;
  } catch (...) {
    return (gp_Elips2d *)0;
  }
}


EXPORT void _wrap_delete_gp_Elips2d (gp_Elips2d *larg1) {
  gp_Elips2d *arg1 = (gp_Elips2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Elips2d\n  * wrapname: _wrap_delete_gp_Elips2d\n  * fulldecl: gp_Elips2d::~gp_Elips2d()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Hypr2d *_wrap_new_gp_Hypr2d__SWIG_0 () {
  gp_Hypr2d * lresult = (gp_Hypr2d *)0 ;
  gp_Hypr2d *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Hypr2d *)new gp_Hypr2d();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Hypr2d\n  * wrapname: _wrap_new_gp_Hypr2d__SWIG_0\n  * fulldecl: gp_Hypr2d::gp_Hypr2d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Hypr2d *)0;
  }
}


EXPORT gp_Hypr2d *_wrap_new_gp_Hypr2d__SWIG_1 (gp_Ax2d *larg1, Standard_Real larg2, Standard_Real larg3, bool larg4) {
  gp_Hypr2d * lresult = (gp_Hypr2d *)0 ;
  gp_Ax2d *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Boolean arg4 ;
  gp_Hypr2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Hypr2d *)new gp_Hypr2d((gp_Ax2d const &)*arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Hypr2d\n  * wrapname: _wrap_new_gp_Hypr2d__SWIG_1\n  * fulldecl: gp_Hypr2d::gp_Hypr2d(gp_Ax2d const &,Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Hypr2d *)0;
  }
}


EXPORT gp_Hypr2d *_wrap_new_gp_Hypr2d__SWIG_2 (gp_Ax2d *larg1, Standard_Real larg2, Standard_Real larg3) {
  gp_Hypr2d * lresult = (gp_Hypr2d *)0 ;
  gp_Ax2d *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  gp_Hypr2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Hypr2d *)new gp_Hypr2d((gp_Ax2d const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Hypr2d\n  * wrapname: _wrap_new_gp_Hypr2d__SWIG_2\n  * fulldecl: gp_Hypr2d::gp_Hypr2d(gp_Ax2d const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Hypr2d *)0;
  }
}


EXPORT gp_Hypr2d *_wrap_new_gp_Hypr2d__SWIG_3 (gp_Ax22d *larg1, Standard_Real larg2, Standard_Real larg3) {
  gp_Hypr2d * lresult = (gp_Hypr2d *)0 ;
  gp_Ax22d *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  gp_Hypr2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Hypr2d *)new gp_Hypr2d((gp_Ax22d const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Hypr2d\n  * wrapname: _wrap_new_gp_Hypr2d__SWIG_3\n  * fulldecl: gp_Hypr2d::gp_Hypr2d(gp_Ax22d const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Hypr2d *)0;
  }
}


EXPORT void _wrap_gp_Hypr2d_SetLocation (gp_Hypr2d *larg1, gp_Pnt2d *larg2) {
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLocation((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_SetLocation\n  * wrapname: _wrap_gp_Hypr2d_SetLocation\n  * fulldecl: void gp_Hypr2d::SetLocation(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Hypr2d_SetMajorRadius (gp_Hypr2d *larg1, Standard_Real larg2) {
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetMajorRadius(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_SetMajorRadius\n  * wrapname: _wrap_gp_Hypr2d_SetMajorRadius\n  * fulldecl: void gp_Hypr2d::SetMajorRadius(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Hypr2d_SetMinorRadius (gp_Hypr2d *larg1, Standard_Real larg2) {
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetMinorRadius(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_SetMinorRadius\n  * wrapname: _wrap_gp_Hypr2d_SetMinorRadius\n  * fulldecl: void gp_Hypr2d::SetMinorRadius(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Hypr2d_SetAxis (gp_Hypr2d *larg1, gp_Ax22d *larg2) {
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Ax22d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetAxis((gp_Ax22d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_SetAxis\n  * wrapname: _wrap_gp_Hypr2d_SetAxis\n  * fulldecl: void gp_Hypr2d::SetAxis(gp_Ax22d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Hypr2d_SetXAxis (gp_Hypr2d *larg1, gp_Ax2d *larg2) {
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetXAxis((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_SetXAxis\n  * wrapname: _wrap_gp_Hypr2d_SetXAxis\n  * fulldecl: void gp_Hypr2d::SetXAxis(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Hypr2d_SetYAxis (gp_Hypr2d *larg1, gp_Ax2d *larg2) {
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetYAxis((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_SetYAxis\n  * wrapname: _wrap_gp_Hypr2d_SetYAxis\n  * fulldecl: void gp_Hypr2d::SetYAxis(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax2d *_wrap_gp_Hypr2d_Asymptote1 (gp_Hypr2d *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr2d const *)arg1)->Asymptote1();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_Asymptote1\n  * wrapname: _wrap_gp_Hypr2d_Asymptote1\n  * fulldecl: gp_Ax2d gp_Hypr2d::Asymptote1() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


EXPORT gp_Ax2d *_wrap_gp_Hypr2d_Asymptote2 (gp_Hypr2d *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr2d const *)arg1)->Asymptote2();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_Asymptote2\n  * wrapname: _wrap_gp_Hypr2d_Asymptote2\n  * fulldecl: gp_Ax2d gp_Hypr2d::Asymptote2() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


EXPORT void _wrap_gp_Hypr2d_Coefficients (gp_Hypr2d *larg1, Standard_Real *larg2, Standard_Real *larg3, Standard_Real *larg4, Standard_Real *larg5, Standard_Real *larg6, Standard_Real *larg7) {
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  Standard_Real *arg5 = 0 ;
  Standard_Real *arg6 = 0 ;
  Standard_Real *arg7 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((gp_Hypr2d const *)arg1)->Coefficients(*arg2,*arg3,*arg4,*arg5,*arg6,*arg7);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_Coefficients\n  * wrapname: _wrap_gp_Hypr2d_Coefficients\n  * fulldecl: void gp_Hypr2d::Coefficients(Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Hypr2d *_wrap_gp_Hypr2d_ConjugateBranch1 (gp_Hypr2d *larg1) {
  gp_Hypr2d * lresult = (gp_Hypr2d *)0 ;
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Hypr2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr2d const *)arg1)->ConjugateBranch1();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_ConjugateBranch1\n  * wrapname: _wrap_gp_Hypr2d_ConjugateBranch1\n  * fulldecl: gp_Hypr2d gp_Hypr2d::ConjugateBranch1() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr2d(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr2d *)0;
  }
}


EXPORT gp_Hypr2d *_wrap_gp_Hypr2d_ConjugateBranch2 (gp_Hypr2d *larg1) {
  gp_Hypr2d * lresult = (gp_Hypr2d *)0 ;
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Hypr2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr2d const *)arg1)->ConjugateBranch2();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_ConjugateBranch2\n  * wrapname: _wrap_gp_Hypr2d_ConjugateBranch2\n  * fulldecl: gp_Hypr2d gp_Hypr2d::ConjugateBranch2() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr2d(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr2d *)0;
  }
}


EXPORT gp_Ax2d *_wrap_gp_Hypr2d_Directrix1 (gp_Hypr2d *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr2d const *)arg1)->Directrix1();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_Directrix1\n  * wrapname: _wrap_gp_Hypr2d_Directrix1\n  * fulldecl: gp_Ax2d gp_Hypr2d::Directrix1() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


EXPORT gp_Ax2d *_wrap_gp_Hypr2d_Directrix2 (gp_Hypr2d *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr2d const *)arg1)->Directrix2();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_Directrix2\n  * wrapname: _wrap_gp_Hypr2d_Directrix2\n  * fulldecl: gp_Ax2d gp_Hypr2d::Directrix2() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Hypr2d_Eccentricity (gp_Hypr2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Hypr2d const *)arg1)->Eccentricity();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_Eccentricity\n  * wrapname: _wrap_gp_Hypr2d_Eccentricity\n  * fulldecl: Standard_Real gp_Hypr2d::Eccentricity() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Hypr2d_Focal (gp_Hypr2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Hypr2d const *)arg1)->Focal();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_Focal\n  * wrapname: _wrap_gp_Hypr2d_Focal\n  * fulldecl: Standard_Real gp_Hypr2d::Focal() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Pnt2d *_wrap_gp_Hypr2d_Focus1 (gp_Hypr2d *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr2d const *)arg1)->Focus1();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_Focus1\n  * wrapname: _wrap_gp_Hypr2d_Focus1\n  * fulldecl: gp_Pnt2d gp_Hypr2d::Focus1() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT gp_Pnt2d *_wrap_gp_Hypr2d_Focus2 (gp_Hypr2d *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr2d const *)arg1)->Focus2();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_Focus2\n  * wrapname: _wrap_gp_Hypr2d_Focus2\n  * fulldecl: gp_Pnt2d gp_Hypr2d::Focus2() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT gp_Pnt2d *_wrap_gp_Hypr2d_Location (gp_Hypr2d *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Pnt2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt2d *) &((gp_Hypr2d const *)arg1)->Location();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_Location\n  * wrapname: _wrap_gp_Hypr2d_Location\n  * fulldecl: gp_Pnt2d const & gp_Hypr2d::Location() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Hypr2d_MajorRadius (gp_Hypr2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Hypr2d const *)arg1)->MajorRadius();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_MajorRadius\n  * wrapname: _wrap_gp_Hypr2d_MajorRadius\n  * fulldecl: Standard_Real gp_Hypr2d::MajorRadius() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Hypr2d_MinorRadius (gp_Hypr2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Hypr2d const *)arg1)->MinorRadius();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_MinorRadius\n  * wrapname: _wrap_gp_Hypr2d_MinorRadius\n  * fulldecl: Standard_Real gp_Hypr2d::MinorRadius() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Hypr2d *_wrap_gp_Hypr2d_OtherBranch (gp_Hypr2d *larg1) {
  gp_Hypr2d * lresult = (gp_Hypr2d *)0 ;
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Hypr2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr2d const *)arg1)->OtherBranch();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_OtherBranch\n  * wrapname: _wrap_gp_Hypr2d_OtherBranch\n  * fulldecl: gp_Hypr2d gp_Hypr2d::OtherBranch() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr2d(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr2d *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Hypr2d_Parameter (gp_Hypr2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Hypr2d const *)arg1)->Parameter();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_Parameter\n  * wrapname: _wrap_gp_Hypr2d_Parameter\n  * fulldecl: Standard_Real gp_Hypr2d::Parameter() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Ax22d *_wrap_gp_Hypr2d_Axis (gp_Hypr2d *larg1) {
  gp_Ax22d * lresult = (gp_Ax22d *)0 ;
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Ax22d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax22d *) &((gp_Hypr2d const *)arg1)->Axis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_Axis\n  * wrapname: _wrap_gp_Hypr2d_Axis\n  * fulldecl: gp_Ax22d const & gp_Hypr2d::Axis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax22d *)0;
  }
}


EXPORT gp_Ax2d *_wrap_gp_Hypr2d_XAxis (gp_Hypr2d *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr2d const *)arg1)->XAxis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_XAxis\n  * wrapname: _wrap_gp_Hypr2d_XAxis\n  * fulldecl: gp_Ax2d gp_Hypr2d::XAxis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


EXPORT gp_Ax2d *_wrap_gp_Hypr2d_YAxis (gp_Hypr2d *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr2d const *)arg1)->YAxis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_YAxis\n  * wrapname: _wrap_gp_Hypr2d_YAxis\n  * fulldecl: gp_Ax2d gp_Hypr2d::YAxis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


EXPORT void _wrap_gp_Hypr2d_Reverse (gp_Hypr2d *larg1) {
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Reverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_Reverse\n  * wrapname: _wrap_gp_Hypr2d_Reverse\n  * fulldecl: void gp_Hypr2d::Reverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Hypr2d *_wrap_gp_Hypr2d_Reversed (gp_Hypr2d *larg1) {
  gp_Hypr2d * lresult = (gp_Hypr2d *)0 ;
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Hypr2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr2d const *)arg1)->Reversed();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_Reversed\n  * wrapname: _wrap_gp_Hypr2d_Reversed\n  * fulldecl: gp_Hypr2d gp_Hypr2d::Reversed() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr2d(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr2d *)0;
  }
}


EXPORT bool _wrap_gp_Hypr2d_IsDirect (gp_Hypr2d *larg1) {
  bool lresult = (bool)0 ;
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Hypr2d const *)arg1)->IsDirect();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_IsDirect\n  * wrapname: _wrap_gp_Hypr2d_IsDirect\n  * fulldecl: Standard_Boolean gp_Hypr2d::IsDirect() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_gp_Hypr2d_Mirror__SWIG_0 (gp_Hypr2d *larg1, gp_Pnt2d *larg2) {
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_Mirror\n  * wrapname: _wrap_gp_Hypr2d_Mirror__SWIG_0\n  * fulldecl: void gp_Hypr2d::Mirror(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Hypr2d *_wrap_gp_Hypr2d_Mirrored__SWIG_0 (gp_Hypr2d *larg1, gp_Pnt2d *larg2) {
  gp_Hypr2d * lresult = (gp_Hypr2d *)0 ;
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Hypr2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr2d const *)arg1)->Mirrored((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_Mirrored\n  * wrapname: _wrap_gp_Hypr2d_Mirrored__SWIG_0\n  * fulldecl: gp_Hypr2d gp_Hypr2d::Mirrored(gp_Pnt2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr2d(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr2d *)0;
  }
}


EXPORT void _wrap_gp_Hypr2d_Mirror__SWIG_1 (gp_Hypr2d *larg1, gp_Ax2d *larg2) {
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_Mirror\n  * wrapname: _wrap_gp_Hypr2d_Mirror__SWIG_1\n  * fulldecl: void gp_Hypr2d::Mirror(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Hypr2d *_wrap_gp_Hypr2d_Mirrored__SWIG_1 (gp_Hypr2d *larg1, gp_Ax2d *larg2) {
  gp_Hypr2d * lresult = (gp_Hypr2d *)0 ;
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  gp_Hypr2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr2d const *)arg1)->Mirrored((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_Mirrored\n  * wrapname: _wrap_gp_Hypr2d_Mirrored__SWIG_1\n  * fulldecl: gp_Hypr2d gp_Hypr2d::Mirrored(gp_Ax2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr2d(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr2d *)0;
  }
}


EXPORT void _wrap_gp_Hypr2d_Rotate (gp_Hypr2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Rotate((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_Rotate\n  * wrapname: _wrap_gp_Hypr2d_Rotate\n  * fulldecl: void gp_Hypr2d::Rotate(gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Hypr2d *_wrap_gp_Hypr2d_Rotated (gp_Hypr2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Hypr2d * lresult = (gp_Hypr2d *)0 ;
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Hypr2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr2d const *)arg1)->Rotated((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_Rotated\n  * wrapname: _wrap_gp_Hypr2d_Rotated\n  * fulldecl: gp_Hypr2d gp_Hypr2d::Rotated(gp_Pnt2d const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr2d(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr2d *)0;
  }
}


EXPORT void _wrap_gp_Hypr2d_Scale (gp_Hypr2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Scale((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_Scale\n  * wrapname: _wrap_gp_Hypr2d_Scale\n  * fulldecl: void gp_Hypr2d::Scale(gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Hypr2d *_wrap_gp_Hypr2d_Scaled (gp_Hypr2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Hypr2d * lresult = (gp_Hypr2d *)0 ;
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Hypr2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr2d const *)arg1)->Scaled((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_Scaled\n  * wrapname: _wrap_gp_Hypr2d_Scaled\n  * fulldecl: gp_Hypr2d gp_Hypr2d::Scaled(gp_Pnt2d const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr2d(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr2d *)0;
  }
}


EXPORT void _wrap_gp_Hypr2d_Transform (gp_Hypr2d *larg1, gp_Trsf2d *larg2) {
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Transform((gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_Transform\n  * wrapname: _wrap_gp_Hypr2d_Transform\n  * fulldecl: void gp_Hypr2d::Transform(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Hypr2d *_wrap_gp_Hypr2d_Transformed (gp_Hypr2d *larg1, gp_Trsf2d *larg2) {
  gp_Hypr2d * lresult = (gp_Hypr2d *)0 ;
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  gp_Hypr2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr2d const *)arg1)->Transformed((gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_Transformed\n  * wrapname: _wrap_gp_Hypr2d_Transformed\n  * fulldecl: gp_Hypr2d gp_Hypr2d::Transformed(gp_Trsf2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr2d(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr2d *)0;
  }
}


EXPORT void _wrap_gp_Hypr2d_Translate__SWIG_0 (gp_Hypr2d *larg1, gp_Vec2d *larg2) {
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_Translate\n  * wrapname: _wrap_gp_Hypr2d_Translate__SWIG_0\n  * fulldecl: void gp_Hypr2d::Translate(gp_Vec2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Hypr2d *_wrap_gp_Hypr2d_Translated__SWIG_0 (gp_Hypr2d *larg1, gp_Vec2d *larg2) {
  gp_Hypr2d * lresult = (gp_Hypr2d *)0 ;
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  gp_Hypr2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr2d const *)arg1)->Translated((gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_Translated\n  * wrapname: _wrap_gp_Hypr2d_Translated__SWIG_0\n  * fulldecl: gp_Hypr2d gp_Hypr2d::Translated(gp_Vec2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr2d(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr2d *)0;
  }
}


EXPORT void _wrap_gp_Hypr2d_Translate__SWIG_1 (gp_Hypr2d *larg1, gp_Pnt2d *larg2, gp_Pnt2d *larg3) {
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Pnt2d *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Pnt2d const &)*arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_Translate\n  * wrapname: _wrap_gp_Hypr2d_Translate__SWIG_1\n  * fulldecl: void gp_Hypr2d::Translate(gp_Pnt2d const &,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Hypr2d *_wrap_gp_Hypr2d_Translated__SWIG_1 (gp_Hypr2d *larg1, gp_Pnt2d *larg2, gp_Pnt2d *larg3) {
  gp_Hypr2d * lresult = (gp_Hypr2d *)0 ;
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Pnt2d *arg3 = 0 ;
  gp_Hypr2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr2d const *)arg1)->Translated((gp_Pnt2d const &)*arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr2d_Translated\n  * wrapname: _wrap_gp_Hypr2d_Translated__SWIG_1\n  * fulldecl: gp_Hypr2d gp_Hypr2d::Translated(gp_Pnt2d const &,gp_Pnt2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr2d(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr2d *)0;
  }
}


EXPORT void _wrap_delete_gp_Hypr2d (gp_Hypr2d *larg1) {
  gp_Hypr2d *arg1 = (gp_Hypr2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Hypr2d\n  * wrapname: _wrap_delete_gp_Hypr2d\n  * fulldecl: gp_Hypr2d::~gp_Hypr2d()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Parab2d *_wrap_new_gp_Parab2d__SWIG_0 () {
  gp_Parab2d * lresult = (gp_Parab2d *)0 ;
  gp_Parab2d *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Parab2d *)new gp_Parab2d();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Parab2d\n  * wrapname: _wrap_new_gp_Parab2d__SWIG_0\n  * fulldecl: gp_Parab2d::gp_Parab2d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Parab2d *)0;
  }
}


EXPORT gp_Parab2d *_wrap_new_gp_Parab2d__SWIG_1 (gp_Ax2d *larg1, Standard_Real larg2, bool larg3) {
  gp_Parab2d * lresult = (gp_Parab2d *)0 ;
  gp_Ax2d *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Boolean arg3 ;
  gp_Parab2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Parab2d *)new gp_Parab2d((gp_Ax2d const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Parab2d\n  * wrapname: _wrap_new_gp_Parab2d__SWIG_1\n  * fulldecl: gp_Parab2d::gp_Parab2d(gp_Ax2d const &,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Parab2d *)0;
  }
}


EXPORT gp_Parab2d *_wrap_new_gp_Parab2d__SWIG_2 (gp_Ax2d *larg1, Standard_Real larg2) {
  gp_Parab2d * lresult = (gp_Parab2d *)0 ;
  gp_Ax2d *arg1 = 0 ;
  Standard_Real arg2 ;
  gp_Parab2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Parab2d *)new gp_Parab2d((gp_Ax2d const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Parab2d\n  * wrapname: _wrap_new_gp_Parab2d__SWIG_2\n  * fulldecl: gp_Parab2d::gp_Parab2d(gp_Ax2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Parab2d *)0;
  }
}


EXPORT gp_Parab2d *_wrap_new_gp_Parab2d__SWIG_3 (gp_Ax22d *larg1, Standard_Real larg2) {
  gp_Parab2d * lresult = (gp_Parab2d *)0 ;
  gp_Ax22d *arg1 = 0 ;
  Standard_Real arg2 ;
  gp_Parab2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Parab2d *)new gp_Parab2d((gp_Ax22d const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Parab2d\n  * wrapname: _wrap_new_gp_Parab2d__SWIG_3\n  * fulldecl: gp_Parab2d::gp_Parab2d(gp_Ax22d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Parab2d *)0;
  }
}


EXPORT gp_Parab2d *_wrap_new_gp_Parab2d__SWIG_4 (gp_Ax2d *larg1, gp_Pnt2d *larg2, bool larg3) {
  gp_Parab2d * lresult = (gp_Parab2d *)0 ;
  gp_Ax2d *arg1 = 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Boolean arg3 ;
  gp_Parab2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Parab2d *)new gp_Parab2d((gp_Ax2d const &)*arg1,(gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Parab2d\n  * wrapname: _wrap_new_gp_Parab2d__SWIG_4\n  * fulldecl: gp_Parab2d::gp_Parab2d(gp_Ax2d const &,gp_Pnt2d const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Parab2d *)0;
  }
}


EXPORT gp_Parab2d *_wrap_new_gp_Parab2d__SWIG_5 (gp_Ax2d *larg1, gp_Pnt2d *larg2) {
  gp_Parab2d * lresult = (gp_Parab2d *)0 ;
  gp_Ax2d *arg1 = 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Parab2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Parab2d *)new gp_Parab2d((gp_Ax2d const &)*arg1,(gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Parab2d\n  * wrapname: _wrap_new_gp_Parab2d__SWIG_5\n  * fulldecl: gp_Parab2d::gp_Parab2d(gp_Ax2d const &,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Parab2d *)0;
  }
}


EXPORT void _wrap_gp_Parab2d_SetFocal (gp_Parab2d *larg1, Standard_Real larg2) {
  gp_Parab2d *arg1 = (gp_Parab2d *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetFocal(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab2d_SetFocal\n  * wrapname: _wrap_gp_Parab2d_SetFocal\n  * fulldecl: void gp_Parab2d::SetFocal(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Parab2d_SetLocation (gp_Parab2d *larg1, gp_Pnt2d *larg2) {
  gp_Parab2d *arg1 = (gp_Parab2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLocation((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab2d_SetLocation\n  * wrapname: _wrap_gp_Parab2d_SetLocation\n  * fulldecl: void gp_Parab2d::SetLocation(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Parab2d_SetMirrorAxis (gp_Parab2d *larg1, gp_Ax2d *larg2) {
  gp_Parab2d *arg1 = (gp_Parab2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetMirrorAxis((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab2d_SetMirrorAxis\n  * wrapname: _wrap_gp_Parab2d_SetMirrorAxis\n  * fulldecl: void gp_Parab2d::SetMirrorAxis(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Parab2d_SetAxis (gp_Parab2d *larg1, gp_Ax22d *larg2) {
  gp_Parab2d *arg1 = (gp_Parab2d *) 0 ;
  gp_Ax22d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetAxis((gp_Ax22d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab2d_SetAxis\n  * wrapname: _wrap_gp_Parab2d_SetAxis\n  * fulldecl: void gp_Parab2d::SetAxis(gp_Ax22d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Parab2d_Coefficients (gp_Parab2d *larg1, Standard_Real *larg2, Standard_Real *larg3, Standard_Real *larg4, Standard_Real *larg5, Standard_Real *larg6, Standard_Real *larg7) {
  gp_Parab2d *arg1 = (gp_Parab2d *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  Standard_Real *arg5 = 0 ;
  Standard_Real *arg6 = 0 ;
  Standard_Real *arg7 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((gp_Parab2d const *)arg1)->Coefficients(*arg2,*arg3,*arg4,*arg5,*arg6,*arg7);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab2d_Coefficients\n  * wrapname: _wrap_gp_Parab2d_Coefficients\n  * fulldecl: void gp_Parab2d::Coefficients(Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax2d *_wrap_gp_Parab2d_Directrix (gp_Parab2d *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  gp_Parab2d *arg1 = (gp_Parab2d *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Parab2d const *)arg1)->Directrix();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab2d_Directrix\n  * wrapname: _wrap_gp_Parab2d_Directrix\n  * fulldecl: gp_Ax2d gp_Parab2d::Directrix() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Parab2d_Focal (gp_Parab2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Parab2d *arg1 = (gp_Parab2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Parab2d const *)arg1)->Focal();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab2d_Focal\n  * wrapname: _wrap_gp_Parab2d_Focal\n  * fulldecl: Standard_Real gp_Parab2d::Focal() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Pnt2d *_wrap_gp_Parab2d_Focus (gp_Parab2d *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  gp_Parab2d *arg1 = (gp_Parab2d *) 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Parab2d const *)arg1)->Focus();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab2d_Focus\n  * wrapname: _wrap_gp_Parab2d_Focus\n  * fulldecl: gp_Pnt2d gp_Parab2d::Focus() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT gp_Pnt2d *_wrap_gp_Parab2d_Location (gp_Parab2d *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  gp_Parab2d *arg1 = (gp_Parab2d *) 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Parab2d const *)arg1)->Location();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab2d_Location\n  * wrapname: _wrap_gp_Parab2d_Location\n  * fulldecl: gp_Pnt2d gp_Parab2d::Location() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT gp_Ax2d *_wrap_gp_Parab2d_MirrorAxis (gp_Parab2d *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  gp_Parab2d *arg1 = (gp_Parab2d *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Parab2d const *)arg1)->MirrorAxis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab2d_MirrorAxis\n  * wrapname: _wrap_gp_Parab2d_MirrorAxis\n  * fulldecl: gp_Ax2d gp_Parab2d::MirrorAxis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


EXPORT gp_Ax22d *_wrap_gp_Parab2d_Axis (gp_Parab2d *larg1) {
  gp_Ax22d * lresult = (gp_Ax22d *)0 ;
  gp_Parab2d *arg1 = (gp_Parab2d *) 0 ;
  gp_Ax22d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Parab2d const *)arg1)->Axis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab2d_Axis\n  * wrapname: _wrap_gp_Parab2d_Axis\n  * fulldecl: gp_Ax22d gp_Parab2d::Axis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax22d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax22d *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Parab2d_Parameter (gp_Parab2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Parab2d *arg1 = (gp_Parab2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Parab2d const *)arg1)->Parameter();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab2d_Parameter\n  * wrapname: _wrap_gp_Parab2d_Parameter\n  * fulldecl: Standard_Real gp_Parab2d::Parameter() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_gp_Parab2d_Reverse (gp_Parab2d *larg1) {
  gp_Parab2d *arg1 = (gp_Parab2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Reverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab2d_Reverse\n  * wrapname: _wrap_gp_Parab2d_Reverse\n  * fulldecl: void gp_Parab2d::Reverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Parab2d *_wrap_gp_Parab2d_Reversed (gp_Parab2d *larg1) {
  gp_Parab2d * lresult = (gp_Parab2d *)0 ;
  gp_Parab2d *arg1 = (gp_Parab2d *) 0 ;
  gp_Parab2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Parab2d const *)arg1)->Reversed();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab2d_Reversed\n  * wrapname: _wrap_gp_Parab2d_Reversed\n  * fulldecl: gp_Parab2d gp_Parab2d::Reversed() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Parab2d(result);
    return lresult;
  } catch (...) {
    return (gp_Parab2d *)0;
  }
}


EXPORT bool _wrap_gp_Parab2d_IsDirect (gp_Parab2d *larg1) {
  bool lresult = (bool)0 ;
  gp_Parab2d *arg1 = (gp_Parab2d *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Parab2d const *)arg1)->IsDirect();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab2d_IsDirect\n  * wrapname: _wrap_gp_Parab2d_IsDirect\n  * fulldecl: Standard_Boolean gp_Parab2d::IsDirect() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_gp_Parab2d_Mirror__SWIG_0 (gp_Parab2d *larg1, gp_Pnt2d *larg2) {
  gp_Parab2d *arg1 = (gp_Parab2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab2d_Mirror\n  * wrapname: _wrap_gp_Parab2d_Mirror__SWIG_0\n  * fulldecl: void gp_Parab2d::Mirror(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Parab2d *_wrap_gp_Parab2d_Mirrored (gp_Parab2d *larg1, gp_Pnt2d *larg2) {
  gp_Parab2d * lresult = (gp_Parab2d *)0 ;
  gp_Parab2d *arg1 = (gp_Parab2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Parab2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Parab2d const *)arg1)->Mirrored((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab2d_Mirrored\n  * wrapname: _wrap_gp_Parab2d_Mirrored\n  * fulldecl: gp_Parab2d gp_Parab2d::Mirrored(gp_Pnt2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Parab2d(result);
    return lresult;
  } catch (...) {
    return (gp_Parab2d *)0;
  }
}


EXPORT void _wrap_gp_Parab2d_Mirror__SWIG_1 (gp_Parab2d *larg1, gp_Ax2d *larg2) {
  gp_Parab2d *arg1 = (gp_Parab2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab2d_Mirror\n  * wrapname: _wrap_gp_Parab2d_Mirror__SWIG_1\n  * fulldecl: void gp_Parab2d::Mirror(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Parab2d_Rotate (gp_Parab2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Parab2d *arg1 = (gp_Parab2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Rotate((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab2d_Rotate\n  * wrapname: _wrap_gp_Parab2d_Rotate\n  * fulldecl: void gp_Parab2d::Rotate(gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Parab2d *_wrap_gp_Parab2d_Rotated (gp_Parab2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Parab2d * lresult = (gp_Parab2d *)0 ;
  gp_Parab2d *arg1 = (gp_Parab2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Parab2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Parab2d const *)arg1)->Rotated((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab2d_Rotated\n  * wrapname: _wrap_gp_Parab2d_Rotated\n  * fulldecl: gp_Parab2d gp_Parab2d::Rotated(gp_Pnt2d const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Parab2d(result);
    return lresult;
  } catch (...) {
    return (gp_Parab2d *)0;
  }
}


EXPORT void _wrap_gp_Parab2d_Scale (gp_Parab2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Parab2d *arg1 = (gp_Parab2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Scale((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab2d_Scale\n  * wrapname: _wrap_gp_Parab2d_Scale\n  * fulldecl: void gp_Parab2d::Scale(gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Parab2d *_wrap_gp_Parab2d_Scaled (gp_Parab2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Parab2d * lresult = (gp_Parab2d *)0 ;
  gp_Parab2d *arg1 = (gp_Parab2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Parab2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Parab2d const *)arg1)->Scaled((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab2d_Scaled\n  * wrapname: _wrap_gp_Parab2d_Scaled\n  * fulldecl: gp_Parab2d gp_Parab2d::Scaled(gp_Pnt2d const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Parab2d(result);
    return lresult;
  } catch (...) {
    return (gp_Parab2d *)0;
  }
}


EXPORT void _wrap_gp_Parab2d_Transform (gp_Parab2d *larg1, gp_Trsf2d *larg2) {
  gp_Parab2d *arg1 = (gp_Parab2d *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Transform((gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab2d_Transform\n  * wrapname: _wrap_gp_Parab2d_Transform\n  * fulldecl: void gp_Parab2d::Transform(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Parab2d *_wrap_gp_Parab2d_Transformed (gp_Parab2d *larg1, gp_Trsf2d *larg2) {
  gp_Parab2d * lresult = (gp_Parab2d *)0 ;
  gp_Parab2d *arg1 = (gp_Parab2d *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  gp_Parab2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Parab2d const *)arg1)->Transformed((gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab2d_Transformed\n  * wrapname: _wrap_gp_Parab2d_Transformed\n  * fulldecl: gp_Parab2d gp_Parab2d::Transformed(gp_Trsf2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Parab2d(result);
    return lresult;
  } catch (...) {
    return (gp_Parab2d *)0;
  }
}


EXPORT gp_Parab2d *_wrap_gp_Parab2d_Translated__SWIG_0 (gp_Parab2d *larg1, gp_Vec2d *larg2) {
  gp_Parab2d * lresult = (gp_Parab2d *)0 ;
  gp_Parab2d *arg1 = (gp_Parab2d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  gp_Parab2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Parab2d const *)arg1)->Translated((gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab2d_Translated\n  * wrapname: _wrap_gp_Parab2d_Translated__SWIG_0\n  * fulldecl: gp_Parab2d gp_Parab2d::Translated(gp_Vec2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Parab2d(result);
    return lresult;
  } catch (...) {
    return (gp_Parab2d *)0;
  }
}


EXPORT void _wrap_gp_Parab2d_Translate (gp_Parab2d *larg1, gp_Pnt2d *larg2, gp_Pnt2d *larg3) {
  gp_Parab2d *arg1 = (gp_Parab2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Pnt2d *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Pnt2d const &)*arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab2d_Translate\n  * wrapname: _wrap_gp_Parab2d_Translate\n  * fulldecl: void gp_Parab2d::Translate(gp_Pnt2d const &,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Parab2d *_wrap_gp_Parab2d_Translated__SWIG_1 (gp_Parab2d *larg1, gp_Pnt2d *larg2, gp_Pnt2d *larg3) {
  gp_Parab2d * lresult = (gp_Parab2d *)0 ;
  gp_Parab2d *arg1 = (gp_Parab2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Pnt2d *arg3 = 0 ;
  gp_Parab2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Parab2d const *)arg1)->Translated((gp_Pnt2d const &)*arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab2d_Translated\n  * wrapname: _wrap_gp_Parab2d_Translated__SWIG_1\n  * fulldecl: gp_Parab2d gp_Parab2d::Translated(gp_Pnt2d const &,gp_Pnt2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Parab2d(result);
    return lresult;
  } catch (...) {
    return (gp_Parab2d *)0;
  }
}


EXPORT void _wrap_delete_gp_Parab2d (gp_Parab2d *larg1) {
  gp_Parab2d *arg1 = (gp_Parab2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Parab2d\n  * wrapname: _wrap_delete_gp_Parab2d\n  * fulldecl: gp_Parab2d::~gp_Parab2d()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pln *_wrap_new_gp_Pln__SWIG_0 (gp_Ax3 *larg1) {
  gp_Pln * lresult = (gp_Pln *)0 ;
  gp_Ax3 *arg1 = 0 ;
  gp_Pln *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pln *)new gp_Pln((gp_Ax3 const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Pln\n  * wrapname: _wrap_new_gp_Pln__SWIG_0\n  * fulldecl: gp_Pln::gp_Pln(gp_Ax3 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pln *)0;
  }
}


EXPORT gp_Pln *_wrap_new_gp_Pln__SWIG_1 (gp_Pnt *larg1, gp_Dir *larg2) {
  gp_Pln * lresult = (gp_Pln *)0 ;
  gp_Pnt *arg1 = 0 ;
  gp_Dir *arg2 = 0 ;
  gp_Pln *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pln *)new gp_Pln((gp_Pnt const &)*arg1,(gp_Dir const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Pln\n  * wrapname: _wrap_new_gp_Pln__SWIG_1\n  * fulldecl: gp_Pln::gp_Pln(gp_Pnt const &,gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pln *)0;
  }
}


EXPORT gp_Pln *_wrap_new_gp_Pln__SWIG_2 (Standard_Real larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4) {
  gp_Pln * lresult = (gp_Pln *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  gp_Pln *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pln *)new gp_Pln(arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Pln\n  * wrapname: _wrap_new_gp_Pln__SWIG_2\n  * fulldecl: gp_Pln::gp_Pln(Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pln *)0;
  }
}


EXPORT void _wrap_gp_Pln_Coefficients (gp_Pln *larg1, Standard_Real *larg2, Standard_Real *larg3, Standard_Real *larg4, Standard_Real *larg5) {
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  Standard_Real *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((gp_Pln const *)arg1)->Coefficients(*arg2,*arg3,*arg4,*arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_Coefficients\n  * wrapname: _wrap_gp_Pln_Coefficients\n  * fulldecl: void gp_Pln::Coefficients(Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Pln_SetAxis (gp_Pln *larg1, gp_Ax1 *larg2) {
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetAxis((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_SetAxis\n  * wrapname: _wrap_gp_Pln_SetAxis\n  * fulldecl: void gp_Pln::SetAxis(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Pln_SetLocation (gp_Pln *larg1, gp_Pnt *larg2) {
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLocation((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_SetLocation\n  * wrapname: _wrap_gp_Pln_SetLocation\n  * fulldecl: void gp_Pln::SetLocation(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Pln_SetPosition (gp_Pln *larg1, gp_Ax3 *larg2) {
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Ax3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetPosition((gp_Ax3 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_SetPosition\n  * wrapname: _wrap_gp_Pln_SetPosition\n  * fulldecl: void gp_Pln::SetPosition(gp_Ax3 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Pln_UReverse (gp_Pln *larg1) {
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->UReverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_UReverse\n  * wrapname: _wrap_gp_Pln_UReverse\n  * fulldecl: void gp_Pln::UReverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Pln_VReverse (gp_Pln *larg1) {
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->VReverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_VReverse\n  * wrapname: _wrap_gp_Pln_VReverse\n  * fulldecl: void gp_Pln::VReverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_gp_Pln_Direct (gp_Pln *larg1) {
  bool lresult = (bool)0 ;
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Pln const *)arg1)->Direct();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_Direct\n  * wrapname: _wrap_gp_Pln_Direct\n  * fulldecl: Standard_Boolean gp_Pln::Direct() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Pln_Axis (gp_Pln *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Ax1 *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax1 *) &((gp_Pln const *)arg1)->Axis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_Axis\n  * wrapname: _wrap_gp_Pln_Axis\n  * fulldecl: gp_Ax1 const & gp_Pln::Axis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT gp_Pnt *_wrap_gp_Pln_Location (gp_Pln *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Pnt *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt *) &((gp_Pln const *)arg1)->Location();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_Location\n  * wrapname: _wrap_gp_Pln_Location\n  * fulldecl: gp_Pnt const & gp_Pln::Location() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT gp_Ax3 *_wrap_gp_Pln_Position (gp_Pln *larg1) {
  gp_Ax3 * lresult = (gp_Ax3 *)0 ;
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Ax3 *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax3 *) &((gp_Pln const *)arg1)->Position();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_Position\n  * wrapname: _wrap_gp_Pln_Position\n  * fulldecl: gp_Ax3 const & gp_Pln::Position() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax3 *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Pln_Distance__SWIG_0 (gp_Pln *larg1, gp_Pnt *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Pln const *)arg1)->Distance((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_Distance\n  * wrapname: _wrap_gp_Pln_Distance__SWIG_0\n  * fulldecl: Standard_Real gp_Pln::Distance(gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Pln_Distance__SWIG_1 (gp_Pln *larg1, gp_Lin *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Lin *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Pln const *)arg1)->Distance((gp_Lin const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_Distance\n  * wrapname: _wrap_gp_Pln_Distance__SWIG_1\n  * fulldecl: Standard_Real gp_Pln::Distance(gp_Lin const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Pln_Distance__SWIG_2 (gp_Pln *larg1, gp_Pln *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Pln *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Pln const *)arg1)->Distance((gp_Pln const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_Distance\n  * wrapname: _wrap_gp_Pln_Distance__SWIG_2\n  * fulldecl: Standard_Real gp_Pln::Distance(gp_Pln const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Pln_SquareDistance__SWIG_0 (gp_Pln *larg1, gp_Pnt *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Pln const *)arg1)->SquareDistance((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_SquareDistance\n  * wrapname: _wrap_gp_Pln_SquareDistance__SWIG_0\n  * fulldecl: Standard_Real gp_Pln::SquareDistance(gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Pln_SquareDistance__SWIG_1 (gp_Pln *larg1, gp_Lin *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Lin *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Pln const *)arg1)->SquareDistance((gp_Lin const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_SquareDistance\n  * wrapname: _wrap_gp_Pln_SquareDistance__SWIG_1\n  * fulldecl: Standard_Real gp_Pln::SquareDistance(gp_Lin const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Pln_SquareDistance__SWIG_2 (gp_Pln *larg1, gp_Pln *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Pln *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Pln const *)arg1)->SquareDistance((gp_Pln const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_SquareDistance\n  * wrapname: _wrap_gp_Pln_SquareDistance__SWIG_2\n  * fulldecl: Standard_Real gp_Pln::SquareDistance(gp_Pln const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Pln_XAxis (gp_Pln *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Pln const *)arg1)->XAxis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_XAxis\n  * wrapname: _wrap_gp_Pln_XAxis\n  * fulldecl: gp_Ax1 gp_Pln::XAxis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Pln_YAxis (gp_Pln *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Pln const *)arg1)->YAxis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_YAxis\n  * wrapname: _wrap_gp_Pln_YAxis\n  * fulldecl: gp_Ax1 gp_Pln::YAxis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT bool _wrap_gp_Pln_Contains__SWIG_0 (gp_Pln *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Pln const *)arg1)->Contains((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_Contains\n  * wrapname: _wrap_gp_Pln_Contains__SWIG_0\n  * fulldecl: Standard_Boolean gp_Pln::Contains(gp_Pnt const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_gp_Pln_Contains__SWIG_1 (gp_Pln *larg1, gp_Lin *larg2, Standard_Real larg3, Standard_Real larg4) {
  bool lresult = (bool)0 ;
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Lin *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Pln const *)arg1)->Contains((gp_Lin const &)*arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_Contains\n  * wrapname: _wrap_gp_Pln_Contains__SWIG_1\n  * fulldecl: Standard_Boolean gp_Pln::Contains(gp_Lin const &,Standard_Real const,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_gp_Pln_Mirror__SWIG_0 (gp_Pln *larg1, gp_Pnt *larg2) {
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_Mirror\n  * wrapname: _wrap_gp_Pln_Mirror__SWIG_0\n  * fulldecl: void gp_Pln::Mirror(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pln *_wrap_gp_Pln_Mirrored__SWIG_0 (gp_Pln *larg1, gp_Pnt *larg2) {
  gp_Pln * lresult = (gp_Pln *)0 ;
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Pnt *arg2 = 0 ;
  SwigValueWrapper< gp_Pln > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Pln const *)arg1)->Mirrored((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_Mirrored\n  * wrapname: _wrap_gp_Pln_Mirrored__SWIG_0\n  * fulldecl: gp_Pln gp_Pln::Mirrored(gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pln(result);
    return lresult;
  } catch (...) {
    return (gp_Pln *)0;
  }
}


EXPORT void _wrap_gp_Pln_Mirror__SWIG_1 (gp_Pln *larg1, gp_Ax1 *larg2) {
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_Mirror\n  * wrapname: _wrap_gp_Pln_Mirror__SWIG_1\n  * fulldecl: void gp_Pln::Mirror(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pln *_wrap_gp_Pln_Mirrored__SWIG_1 (gp_Pln *larg1, gp_Ax1 *larg2) {
  gp_Pln * lresult = (gp_Pln *)0 ;
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  SwigValueWrapper< gp_Pln > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Pln const *)arg1)->Mirrored((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_Mirrored\n  * wrapname: _wrap_gp_Pln_Mirrored__SWIG_1\n  * fulldecl: gp_Pln gp_Pln::Mirrored(gp_Ax1 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pln(result);
    return lresult;
  } catch (...) {
    return (gp_Pln *)0;
  }
}


EXPORT void _wrap_gp_Pln_Mirror__SWIG_2 (gp_Pln *larg1, gp_Ax2 *larg2) {
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_Mirror\n  * wrapname: _wrap_gp_Pln_Mirror__SWIG_2\n  * fulldecl: void gp_Pln::Mirror(gp_Ax2 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pln *_wrap_gp_Pln_Mirrored__SWIG_2 (gp_Pln *larg1, gp_Ax2 *larg2) {
  gp_Pln * lresult = (gp_Pln *)0 ;
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  SwigValueWrapper< gp_Pln > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Pln const *)arg1)->Mirrored((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_Mirrored\n  * wrapname: _wrap_gp_Pln_Mirrored__SWIG_2\n  * fulldecl: gp_Pln gp_Pln::Mirrored(gp_Ax2 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pln(result);
    return lresult;
  } catch (...) {
    return (gp_Pln *)0;
  }
}


EXPORT void _wrap_gp_Pln_Rotate (gp_Pln *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Rotate((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_Rotate\n  * wrapname: _wrap_gp_Pln_Rotate\n  * fulldecl: void gp_Pln::Rotate(gp_Ax1 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pln *_wrap_gp_Pln_Rotated (gp_Pln *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Pln * lresult = (gp_Pln *)0 ;
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  SwigValueWrapper< gp_Pln > result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Pln const *)arg1)->Rotated((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_Rotated\n  * wrapname: _wrap_gp_Pln_Rotated\n  * fulldecl: gp_Pln gp_Pln::Rotated(gp_Ax1 const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pln(result);
    return lresult;
  } catch (...) {
    return (gp_Pln *)0;
  }
}


EXPORT void _wrap_gp_Pln_Scale (gp_Pln *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Scale((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_Scale\n  * wrapname: _wrap_gp_Pln_Scale\n  * fulldecl: void gp_Pln::Scale(gp_Pnt const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pln *_wrap_gp_Pln_Scaled (gp_Pln *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  gp_Pln * lresult = (gp_Pln *)0 ;
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  SwigValueWrapper< gp_Pln > result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Pln const *)arg1)->Scaled((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_Scaled\n  * wrapname: _wrap_gp_Pln_Scaled\n  * fulldecl: gp_Pln gp_Pln::Scaled(gp_Pnt const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pln(result);
    return lresult;
  } catch (...) {
    return (gp_Pln *)0;
  }
}


EXPORT void _wrap_gp_Pln_Transform (gp_Pln *larg1, gp_Trsf *larg2) {
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Trsf *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Transform((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_Transform\n  * wrapname: _wrap_gp_Pln_Transform\n  * fulldecl: void gp_Pln::Transform(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pln *_wrap_gp_Pln_Transformed (gp_Pln *larg1, gp_Trsf *larg2) {
  gp_Pln * lresult = (gp_Pln *)0 ;
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Trsf *arg2 = 0 ;
  SwigValueWrapper< gp_Pln > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Pln const *)arg1)->Transformed((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_Transformed\n  * wrapname: _wrap_gp_Pln_Transformed\n  * fulldecl: gp_Pln gp_Pln::Transformed(gp_Trsf const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pln(result);
    return lresult;
  } catch (...) {
    return (gp_Pln *)0;
  }
}


EXPORT void _wrap_gp_Pln_Translate__SWIG_0 (gp_Pln *larg1, gp_Vec *larg2) {
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Vec *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_Translate\n  * wrapname: _wrap_gp_Pln_Translate__SWIG_0\n  * fulldecl: void gp_Pln::Translate(gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pln *_wrap_gp_Pln_Translated__SWIG_0 (gp_Pln *larg1, gp_Vec *larg2) {
  gp_Pln * lresult = (gp_Pln *)0 ;
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Vec *arg2 = 0 ;
  SwigValueWrapper< gp_Pln > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Pln const *)arg1)->Translated((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_Translated\n  * wrapname: _wrap_gp_Pln_Translated__SWIG_0\n  * fulldecl: gp_Pln gp_Pln::Translated(gp_Vec const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pln(result);
    return lresult;
  } catch (...) {
    return (gp_Pln *)0;
  }
}


EXPORT void _wrap_gp_Pln_Translate__SWIG_1 (gp_Pln *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_Translate\n  * wrapname: _wrap_gp_Pln_Translate__SWIG_1\n  * fulldecl: void gp_Pln::Translate(gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pln *_wrap_gp_Pln_Translated__SWIG_1 (gp_Pln *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  gp_Pln * lresult = (gp_Pln *)0 ;
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  SwigValueWrapper< gp_Pln > result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Pln const *)arg1)->Translated((gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pln_Translated\n  * wrapname: _wrap_gp_Pln_Translated__SWIG_1\n  * fulldecl: gp_Pln gp_Pln::Translated(gp_Pnt const &,gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pln(result);
    return lresult;
  } catch (...) {
    return (gp_Pln *)0;
  }
}


EXPORT void _wrap_delete_gp_Pln (gp_Pln *larg1) {
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Pln\n  * wrapname: _wrap_delete_gp_Pln\n  * fulldecl: gp_Pln::~gp_Pln()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec *_wrap_new_gp_Vec__SWIG_0 () {
  gp_Vec * lresult = (gp_Vec *)0 ;
  gp_Vec *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Vec *)new gp_Vec();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Vec\n  * wrapname: _wrap_new_gp_Vec__SWIG_0\n  * fulldecl: gp_Vec::gp_Vec()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Vec *)0;
  }
}


EXPORT gp_Vec *_wrap_new_gp_Vec__SWIG_1 (gp_Dir *larg1) {
  gp_Vec * lresult = (gp_Vec *)0 ;
  gp_Dir *arg1 = 0 ;
  gp_Vec *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Vec *)new gp_Vec((gp_Dir const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Vec\n  * wrapname: _wrap_new_gp_Vec__SWIG_1\n  * fulldecl: gp_Vec::gp_Vec(gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Vec *)0;
  }
}


EXPORT gp_Vec *_wrap_new_gp_Vec__SWIG_2 (gp_XYZ *larg1) {
  gp_Vec * lresult = (gp_Vec *)0 ;
  gp_XYZ *arg1 = 0 ;
  gp_Vec *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Vec *)new gp_Vec((gp_XYZ const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Vec\n  * wrapname: _wrap_new_gp_Vec__SWIG_2\n  * fulldecl: gp_Vec::gp_Vec(gp_XYZ const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Vec *)0;
  }
}


EXPORT gp_Vec *_wrap_new_gp_Vec__SWIG_3 (Standard_Real larg1, Standard_Real larg2, Standard_Real larg3) {
  gp_Vec * lresult = (gp_Vec *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  gp_Vec *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Vec *)new gp_Vec(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Vec\n  * wrapname: _wrap_new_gp_Vec__SWIG_3\n  * fulldecl: gp_Vec::gp_Vec(Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Vec *)0;
  }
}


EXPORT gp_Vec *_wrap_new_gp_Vec__SWIG_4 (gp_Pnt *larg1, gp_Pnt *larg2) {
  gp_Vec * lresult = (gp_Vec *)0 ;
  gp_Pnt *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Vec *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Vec *)new gp_Vec((gp_Pnt const &)*arg1,(gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Vec\n  * wrapname: _wrap_new_gp_Vec__SWIG_4\n  * fulldecl: gp_Vec::gp_Vec(gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Vec *)0;
  }
}


EXPORT void _wrap_gp_Vec_SetCoord (gp_Vec *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4) {
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetCoord(arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_SetCoord\n  * wrapname: _wrap_gp_Vec_SetCoord\n  * fulldecl: void gp_Vec::SetCoord(Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Vec_SetX (gp_Vec *larg1, Standard_Real larg2) {
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetX(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_SetX\n  * wrapname: _wrap_gp_Vec_SetX\n  * fulldecl: void gp_Vec::SetX(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Vec_SetY (gp_Vec *larg1, Standard_Real larg2) {
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetY(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_SetY\n  * wrapname: _wrap_gp_Vec_SetY\n  * fulldecl: void gp_Vec::SetY(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Vec_SetZ (gp_Vec *larg1, Standard_Real larg2) {
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetZ(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_SetZ\n  * wrapname: _wrap_gp_Vec_SetZ\n  * fulldecl: void gp_Vec::SetZ(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Real _wrap_gp_Vec_X (gp_Vec *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Vec const *)arg1)->X();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_X\n  * wrapname: _wrap_gp_Vec_X\n  * fulldecl: Standard_Real gp_Vec::X() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Vec_Y (gp_Vec *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Vec const *)arg1)->Y();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Y\n  * wrapname: _wrap_gp_Vec_Y\n  * fulldecl: Standard_Real gp_Vec::Y() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Vec_Z (gp_Vec *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Vec const *)arg1)->Z();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Z\n  * wrapname: _wrap_gp_Vec_Z\n  * fulldecl: Standard_Real gp_Vec::Z() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT bool _wrap_gp_Vec_IsEqual (gp_Vec *larg1, gp_Vec *larg2, Standard_Real larg3, Standard_Real larg4) {
  bool lresult = (bool)0 ;
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Vec *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Vec const *)arg1)->IsEqual((gp_Vec const &)*arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_IsEqual\n  * wrapname: _wrap_gp_Vec_IsEqual\n  * fulldecl: Standard_Boolean gp_Vec::IsEqual(gp_Vec const &,Standard_Real const,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_gp_Vec_IsNormal (gp_Vec *larg1, gp_Vec *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Vec *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Vec const *)arg1)->IsNormal((gp_Vec const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_IsNormal\n  * wrapname: _wrap_gp_Vec_IsNormal\n  * fulldecl: Standard_Boolean gp_Vec::IsNormal(gp_Vec const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_gp_Vec_IsOpposite (gp_Vec *larg1, gp_Vec *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Vec *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Vec const *)arg1)->IsOpposite((gp_Vec const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_IsOpposite\n  * wrapname: _wrap_gp_Vec_IsOpposite\n  * fulldecl: Standard_Boolean gp_Vec::IsOpposite(gp_Vec const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_gp_Vec_IsParallel (gp_Vec *larg1, gp_Vec *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Vec *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Vec const *)arg1)->IsParallel((gp_Vec const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_IsParallel\n  * wrapname: _wrap_gp_Vec_IsParallel\n  * fulldecl: Standard_Boolean gp_Vec::IsParallel(gp_Vec const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Standard_Real _wrap_gp_Vec_Angle (gp_Vec *larg1, gp_Vec *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Vec *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Vec const *)arg1)->Angle((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Angle\n  * wrapname: _wrap_gp_Vec_Angle\n  * fulldecl: Standard_Real gp_Vec::Angle(gp_Vec const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Vec_AngleWithRef (gp_Vec *larg1, gp_Vec *larg2, gp_Vec *larg3) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Vec *arg2 = 0 ;
  gp_Vec *arg3 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Vec const *)arg1)->AngleWithRef((gp_Vec const &)*arg2,(gp_Vec const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_AngleWithRef\n  * wrapname: _wrap_gp_Vec_AngleWithRef\n  * fulldecl: Standard_Real gp_Vec::AngleWithRef(gp_Vec const &,gp_Vec const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Vec_Magnitude (gp_Vec *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Vec const *)arg1)->Magnitude();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Magnitude\n  * wrapname: _wrap_gp_Vec_Magnitude\n  * fulldecl: Standard_Real gp_Vec::Magnitude() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Vec_SquareMagnitude (gp_Vec *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Vec const *)arg1)->SquareMagnitude();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_SquareMagnitude\n  * wrapname: _wrap_gp_Vec_SquareMagnitude\n  * fulldecl: Standard_Real gp_Vec::SquareMagnitude() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_gp_Vec_Add (gp_Vec *larg1, gp_Vec *larg2) {
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Vec *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Add((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Add\n  * wrapname: _wrap_gp_Vec_Add\n  * fulldecl: void gp_Vec::Add(gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec *_wrap_gp_Vec_Added (gp_Vec *larg1, gp_Vec *larg2) {
  gp_Vec * lresult = (gp_Vec *)0 ;
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Vec *arg2 = 0 ;
  gp_Vec result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Vec const *)arg1)->Added((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Added\n  * wrapname: _wrap_gp_Vec_Added\n  * fulldecl: gp_Vec gp_Vec::Added(gp_Vec const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec(result);
    return lresult;
  } catch (...) {
    return (gp_Vec *)0;
  }
}


EXPORT void _wrap_gp_Vec_Subtract (gp_Vec *larg1, gp_Vec *larg2) {
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Vec *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Subtract((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Subtract\n  * wrapname: _wrap_gp_Vec_Subtract\n  * fulldecl: void gp_Vec::Subtract(gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec *_wrap_gp_Vec_Subtracted (gp_Vec *larg1, gp_Vec *larg2) {
  gp_Vec * lresult = (gp_Vec *)0 ;
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Vec *arg2 = 0 ;
  gp_Vec result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Vec const *)arg1)->Subtracted((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Subtracted\n  * wrapname: _wrap_gp_Vec_Subtracted\n  * fulldecl: gp_Vec gp_Vec::Subtracted(gp_Vec const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec(result);
    return lresult;
  } catch (...) {
    return (gp_Vec *)0;
  }
}


EXPORT void _wrap_gp_Vec_Multiply (gp_Vec *larg1, Standard_Real larg2) {
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Multiply(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Multiply\n  * wrapname: _wrap_gp_Vec_Multiply\n  * fulldecl: void gp_Vec::Multiply(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec *_wrap_gp_Vec_Multiplied (gp_Vec *larg1, Standard_Real larg2) {
  gp_Vec * lresult = (gp_Vec *)0 ;
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  Standard_Real arg2 ;
  gp_Vec result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Vec const *)arg1)->Multiplied(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Multiplied\n  * wrapname: _wrap_gp_Vec_Multiplied\n  * fulldecl: gp_Vec gp_Vec::Multiplied(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec(result);
    return lresult;
  } catch (...) {
    return (gp_Vec *)0;
  }
}


EXPORT void _wrap_gp_Vec_Divide (gp_Vec *larg1, Standard_Real larg2) {
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Divide(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Divide\n  * wrapname: _wrap_gp_Vec_Divide\n  * fulldecl: void gp_Vec::Divide(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec *_wrap_gp_Vec_Divided (gp_Vec *larg1, Standard_Real larg2) {
  gp_Vec * lresult = (gp_Vec *)0 ;
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  Standard_Real arg2 ;
  gp_Vec result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Vec const *)arg1)->Divided(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Divided\n  * wrapname: _wrap_gp_Vec_Divided\n  * fulldecl: gp_Vec gp_Vec::Divided(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec(result);
    return lresult;
  } catch (...) {
    return (gp_Vec *)0;
  }
}


EXPORT void _wrap_gp_Vec_Cross (gp_Vec *larg1, gp_Vec *larg2) {
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Vec *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Cross((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Cross\n  * wrapname: _wrap_gp_Vec_Cross\n  * fulldecl: void gp_Vec::Cross(gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec *_wrap_gp_Vec_Crossed (gp_Vec *larg1, gp_Vec *larg2) {
  gp_Vec * lresult = (gp_Vec *)0 ;
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Vec *arg2 = 0 ;
  gp_Vec result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Vec const *)arg1)->Crossed((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Crossed\n  * wrapname: _wrap_gp_Vec_Crossed\n  * fulldecl: gp_Vec gp_Vec::Crossed(gp_Vec const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec(result);
    return lresult;
  } catch (...) {
    return (gp_Vec *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Vec_CrossMagnitude (gp_Vec *larg1, gp_Vec *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Vec *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Vec const *)arg1)->CrossMagnitude((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_CrossMagnitude\n  * wrapname: _wrap_gp_Vec_CrossMagnitude\n  * fulldecl: Standard_Real gp_Vec::CrossMagnitude(gp_Vec const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Vec_CrossSquareMagnitude (gp_Vec *larg1, gp_Vec *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Vec *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Vec const *)arg1)->CrossSquareMagnitude((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_CrossSquareMagnitude\n  * wrapname: _wrap_gp_Vec_CrossSquareMagnitude\n  * fulldecl: Standard_Real gp_Vec::CrossSquareMagnitude(gp_Vec const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_gp_Vec_CrossCross (gp_Vec *larg1, gp_Vec *larg2, gp_Vec *larg3) {
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Vec *arg2 = 0 ;
  gp_Vec *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->CrossCross((gp_Vec const &)*arg2,(gp_Vec const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_CrossCross\n  * wrapname: _wrap_gp_Vec_CrossCross\n  * fulldecl: void gp_Vec::CrossCross(gp_Vec const &,gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec *_wrap_gp_Vec_CrossCrossed (gp_Vec *larg1, gp_Vec *larg2, gp_Vec *larg3) {
  gp_Vec * lresult = (gp_Vec *)0 ;
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Vec *arg2 = 0 ;
  gp_Vec *arg3 = 0 ;
  gp_Vec result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Vec const *)arg1)->CrossCrossed((gp_Vec const &)*arg2,(gp_Vec const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_CrossCrossed\n  * wrapname: _wrap_gp_Vec_CrossCrossed\n  * fulldecl: gp_Vec gp_Vec::CrossCrossed(gp_Vec const &,gp_Vec const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec(result);
    return lresult;
  } catch (...) {
    return (gp_Vec *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Vec_Dot (gp_Vec *larg1, gp_Vec *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Vec *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Vec const *)arg1)->Dot((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Dot\n  * wrapname: _wrap_gp_Vec_Dot\n  * fulldecl: Standard_Real gp_Vec::Dot(gp_Vec const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Vec_DotCross (gp_Vec *larg1, gp_Vec *larg2, gp_Vec *larg3) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Vec *arg2 = 0 ;
  gp_Vec *arg3 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Vec const *)arg1)->DotCross((gp_Vec const &)*arg2,(gp_Vec const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_DotCross\n  * wrapname: _wrap_gp_Vec_DotCross\n  * fulldecl: Standard_Real gp_Vec::DotCross(gp_Vec const &,gp_Vec const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_gp_Vec_Normalize (gp_Vec *larg1) {
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Normalize();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Normalize\n  * wrapname: _wrap_gp_Vec_Normalize\n  * fulldecl: void gp_Vec::Normalize()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec *_wrap_gp_Vec_Normalized (gp_Vec *larg1) {
  gp_Vec * lresult = (gp_Vec *)0 ;
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Vec result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Vec const *)arg1)->Normalized();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Normalized\n  * wrapname: _wrap_gp_Vec_Normalized\n  * fulldecl: gp_Vec gp_Vec::Normalized() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec(result);
    return lresult;
  } catch (...) {
    return (gp_Vec *)0;
  }
}


EXPORT void _wrap_gp_Vec_Reverse (gp_Vec *larg1) {
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Reverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Reverse\n  * wrapname: _wrap_gp_Vec_Reverse\n  * fulldecl: void gp_Vec::Reverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec *_wrap_gp_Vec_Reversed (gp_Vec *larg1) {
  gp_Vec * lresult = (gp_Vec *)0 ;
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Vec result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Vec const *)arg1)->Reversed();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Reversed\n  * wrapname: _wrap_gp_Vec_Reversed\n  * fulldecl: gp_Vec gp_Vec::Reversed() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec(result);
    return lresult;
  } catch (...) {
    return (gp_Vec *)0;
  }
}


EXPORT void _wrap_gp_Vec_SetLinearForm__SWIG_0 (gp_Vec *larg1, Standard_Real larg2, gp_Vec *larg3, Standard_Real larg4, gp_Vec *larg5, Standard_Real larg6, gp_Vec *larg7, gp_Vec *larg8) {
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  Standard_Real arg2 ;
  gp_Vec *arg3 = 0 ;
  Standard_Real arg4 ;
  gp_Vec *arg5 = 0 ;
  Standard_Real arg6 ;
  gp_Vec *arg7 = 0 ;
  gp_Vec *arg8 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLinearForm(arg2,(gp_Vec const &)*arg3,arg4,(gp_Vec const &)*arg5,arg6,(gp_Vec const &)*arg7,(gp_Vec const &)*arg8);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_SetLinearForm\n  * wrapname: _wrap_gp_Vec_SetLinearForm__SWIG_0\n  * fulldecl: void gp_Vec::SetLinearForm(Standard_Real const,gp_Vec const &,Standard_Real const,gp_Vec const &,Standard_Real const,gp_Vec const &,gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Vec_SetLinearForm__SWIG_1 (gp_Vec *larg1, Standard_Real larg2, gp_Vec *larg3, Standard_Real larg4, gp_Vec *larg5, Standard_Real larg6, gp_Vec *larg7) {
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  Standard_Real arg2 ;
  gp_Vec *arg3 = 0 ;
  Standard_Real arg4 ;
  gp_Vec *arg5 = 0 ;
  Standard_Real arg6 ;
  gp_Vec *arg7 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLinearForm(arg2,(gp_Vec const &)*arg3,arg4,(gp_Vec const &)*arg5,arg6,(gp_Vec const &)*arg7);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_SetLinearForm\n  * wrapname: _wrap_gp_Vec_SetLinearForm__SWIG_1\n  * fulldecl: void gp_Vec::SetLinearForm(Standard_Real const,gp_Vec const &,Standard_Real const,gp_Vec const &,Standard_Real const,gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Vec_SetLinearForm__SWIG_2 (gp_Vec *larg1, Standard_Real larg2, gp_Vec *larg3, Standard_Real larg4, gp_Vec *larg5, gp_Vec *larg6) {
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  Standard_Real arg2 ;
  gp_Vec *arg3 = 0 ;
  Standard_Real arg4 ;
  gp_Vec *arg5 = 0 ;
  gp_Vec *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLinearForm(arg2,(gp_Vec const &)*arg3,arg4,(gp_Vec const &)*arg5,(gp_Vec const &)*arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_SetLinearForm\n  * wrapname: _wrap_gp_Vec_SetLinearForm__SWIG_2\n  * fulldecl: void gp_Vec::SetLinearForm(Standard_Real const,gp_Vec const &,Standard_Real const,gp_Vec const &,gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Vec_SetLinearForm__SWIG_3 (gp_Vec *larg1, Standard_Real larg2, gp_Vec *larg3, Standard_Real larg4, gp_Vec *larg5) {
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  Standard_Real arg2 ;
  gp_Vec *arg3 = 0 ;
  Standard_Real arg4 ;
  gp_Vec *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLinearForm(arg2,(gp_Vec const &)*arg3,arg4,(gp_Vec const &)*arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_SetLinearForm\n  * wrapname: _wrap_gp_Vec_SetLinearForm__SWIG_3\n  * fulldecl: void gp_Vec::SetLinearForm(Standard_Real const,gp_Vec const &,Standard_Real const,gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Vec_SetLinearForm__SWIG_4 (gp_Vec *larg1, Standard_Real larg2, gp_Vec *larg3, gp_Vec *larg4) {
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  Standard_Real arg2 ;
  gp_Vec *arg3 = 0 ;
  gp_Vec *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLinearForm(arg2,(gp_Vec const &)*arg3,(gp_Vec const &)*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_SetLinearForm\n  * wrapname: _wrap_gp_Vec_SetLinearForm__SWIG_4\n  * fulldecl: void gp_Vec::SetLinearForm(Standard_Real const,gp_Vec const &,gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Vec_SetLinearForm__SWIG_5 (gp_Vec *larg1, gp_Vec *larg2, gp_Vec *larg3) {
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Vec *arg2 = 0 ;
  gp_Vec *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLinearForm((gp_Vec const &)*arg2,(gp_Vec const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_SetLinearForm\n  * wrapname: _wrap_gp_Vec_SetLinearForm__SWIG_5\n  * fulldecl: void gp_Vec::SetLinearForm(gp_Vec const &,gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Vec_Mirror__SWIG_0 (gp_Vec *larg1, gp_Vec *larg2) {
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Vec *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Mirror\n  * wrapname: _wrap_gp_Vec_Mirror__SWIG_0\n  * fulldecl: void gp_Vec::Mirror(gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec *_wrap_gp_Vec_Mirrored__SWIG_0 (gp_Vec *larg1, gp_Vec *larg2) {
  gp_Vec * lresult = (gp_Vec *)0 ;
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Vec *arg2 = 0 ;
  gp_Vec result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Vec const *)arg1)->Mirrored((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Mirrored\n  * wrapname: _wrap_gp_Vec_Mirrored__SWIG_0\n  * fulldecl: gp_Vec gp_Vec::Mirrored(gp_Vec const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec(result);
    return lresult;
  } catch (...) {
    return (gp_Vec *)0;
  }
}


EXPORT void _wrap_gp_Vec_Mirror__SWIG_1 (gp_Vec *larg1, gp_Ax1 *larg2) {
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Mirror\n  * wrapname: _wrap_gp_Vec_Mirror__SWIG_1\n  * fulldecl: void gp_Vec::Mirror(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec *_wrap_gp_Vec_Mirrored__SWIG_1 (gp_Vec *larg1, gp_Ax1 *larg2) {
  gp_Vec * lresult = (gp_Vec *)0 ;
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  gp_Vec result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Vec const *)arg1)->Mirrored((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Mirrored\n  * wrapname: _wrap_gp_Vec_Mirrored__SWIG_1\n  * fulldecl: gp_Vec gp_Vec::Mirrored(gp_Ax1 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec(result);
    return lresult;
  } catch (...) {
    return (gp_Vec *)0;
  }
}


EXPORT void _wrap_gp_Vec_Mirror__SWIG_2 (gp_Vec *larg1, gp_Ax2 *larg2) {
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Mirror\n  * wrapname: _wrap_gp_Vec_Mirror__SWIG_2\n  * fulldecl: void gp_Vec::Mirror(gp_Ax2 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec *_wrap_gp_Vec_Mirrored__SWIG_2 (gp_Vec *larg1, gp_Ax2 *larg2) {
  gp_Vec * lresult = (gp_Vec *)0 ;
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  gp_Vec result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Vec const *)arg1)->Mirrored((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Mirrored\n  * wrapname: _wrap_gp_Vec_Mirrored__SWIG_2\n  * fulldecl: gp_Vec gp_Vec::Mirrored(gp_Ax2 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec(result);
    return lresult;
  } catch (...) {
    return (gp_Vec *)0;
  }
}


EXPORT void _wrap_gp_Vec_Rotate (gp_Vec *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Rotate((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Rotate\n  * wrapname: _wrap_gp_Vec_Rotate\n  * fulldecl: void gp_Vec::Rotate(gp_Ax1 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec *_wrap_gp_Vec_Rotated (gp_Vec *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Vec * lresult = (gp_Vec *)0 ;
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Vec result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Vec const *)arg1)->Rotated((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Rotated\n  * wrapname: _wrap_gp_Vec_Rotated\n  * fulldecl: gp_Vec gp_Vec::Rotated(gp_Ax1 const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec(result);
    return lresult;
  } catch (...) {
    return (gp_Vec *)0;
  }
}


EXPORT void _wrap_gp_Vec_Scale (gp_Vec *larg1, Standard_Real larg2) {
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Scale(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Scale\n  * wrapname: _wrap_gp_Vec_Scale\n  * fulldecl: void gp_Vec::Scale(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec *_wrap_gp_Vec_Scaled (gp_Vec *larg1, Standard_Real larg2) {
  gp_Vec * lresult = (gp_Vec *)0 ;
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  Standard_Real arg2 ;
  gp_Vec result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Vec const *)arg1)->Scaled(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Scaled\n  * wrapname: _wrap_gp_Vec_Scaled\n  * fulldecl: gp_Vec gp_Vec::Scaled(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec(result);
    return lresult;
  } catch (...) {
    return (gp_Vec *)0;
  }
}


EXPORT void _wrap_gp_Vec_Transform (gp_Vec *larg1, gp_Trsf *larg2) {
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Trsf *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Transform((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Transform\n  * wrapname: _wrap_gp_Vec_Transform\n  * fulldecl: void gp_Vec::Transform(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec *_wrap_gp_Vec_Transformed (gp_Vec *larg1, gp_Trsf *larg2) {
  gp_Vec * lresult = (gp_Vec *)0 ;
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  gp_Trsf *arg2 = 0 ;
  gp_Vec result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Vec const *)arg1)->Transformed((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Vec_Transformed\n  * wrapname: _wrap_gp_Vec_Transformed\n  * fulldecl: gp_Vec gp_Vec::Transformed(gp_Trsf const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec(result);
    return lresult;
  } catch (...) {
    return (gp_Vec *)0;
  }
}


EXPORT void _wrap_delete_gp_Vec (gp_Vec *larg1) {
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Vec\n  * wrapname: _wrap_delete_gp_Vec\n  * fulldecl: gp_Vec::~gp_Vec()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Dir *_wrap_new_gp_Dir__SWIG_0 () {
  gp_Dir * lresult = (gp_Dir *)0 ;
  gp_Dir *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Dir *)new gp_Dir();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Dir\n  * wrapname: _wrap_new_gp_Dir__SWIG_0\n  * fulldecl: gp_Dir::gp_Dir()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Dir *)0;
  }
}


EXPORT gp_Dir *_wrap_new_gp_Dir__SWIG_1 (gp_Vec *larg1) {
  gp_Dir * lresult = (gp_Dir *)0 ;
  gp_Vec *arg1 = 0 ;
  gp_Dir *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Dir *)new gp_Dir((gp_Vec const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Dir\n  * wrapname: _wrap_new_gp_Dir__SWIG_1\n  * fulldecl: gp_Dir::gp_Dir(gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Dir *)0;
  }
}


EXPORT gp_Dir *_wrap_new_gp_Dir__SWIG_2 (gp_XYZ *larg1) {
  gp_Dir * lresult = (gp_Dir *)0 ;
  gp_XYZ *arg1 = 0 ;
  gp_Dir *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Dir *)new gp_Dir((gp_XYZ const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Dir\n  * wrapname: _wrap_new_gp_Dir__SWIG_2\n  * fulldecl: gp_Dir::gp_Dir(gp_XYZ const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Dir *)0;
  }
}


EXPORT gp_Dir *_wrap_new_gp_Dir__SWIG_3 (Standard_Real larg1, Standard_Real larg2, Standard_Real larg3) {
  gp_Dir * lresult = (gp_Dir *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  gp_Dir *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Dir *)new gp_Dir(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Dir\n  * wrapname: _wrap_new_gp_Dir__SWIG_3\n  * fulldecl: gp_Dir::gp_Dir(Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Dir *)0;
  }
}


EXPORT void _wrap_gp_Dir_SetCoord (gp_Dir *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4) {
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetCoord(arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_SetCoord\n  * wrapname: _wrap_gp_Dir_SetCoord\n  * fulldecl: void gp_Dir::SetCoord(Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Dir_SetX (gp_Dir *larg1, Standard_Real larg2) {
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetX(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_SetX\n  * wrapname: _wrap_gp_Dir_SetX\n  * fulldecl: void gp_Dir::SetX(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Dir_SetY (gp_Dir *larg1, Standard_Real larg2) {
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetY(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_SetY\n  * wrapname: _wrap_gp_Dir_SetY\n  * fulldecl: void gp_Dir::SetY(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Dir_SetZ (gp_Dir *larg1, Standard_Real larg2) {
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetZ(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_SetZ\n  * wrapname: _wrap_gp_Dir_SetZ\n  * fulldecl: void gp_Dir::SetZ(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Real _wrap_gp_Dir_X (gp_Dir *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Dir const *)arg1)->X();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_X\n  * wrapname: _wrap_gp_Dir_X\n  * fulldecl: Standard_Real gp_Dir::X() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Dir_Y (gp_Dir *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Dir const *)arg1)->Y();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_Y\n  * wrapname: _wrap_gp_Dir_Y\n  * fulldecl: Standard_Real gp_Dir::Y() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Dir_Z (gp_Dir *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Dir const *)arg1)->Z();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_Z\n  * wrapname: _wrap_gp_Dir_Z\n  * fulldecl: Standard_Real gp_Dir::Z() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT bool _wrap_gp_Dir_IsEqual (gp_Dir *larg1, gp_Dir *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  gp_Dir *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Dir const *)arg1)->IsEqual((gp_Dir const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_IsEqual\n  * wrapname: _wrap_gp_Dir_IsEqual\n  * fulldecl: Standard_Boolean gp_Dir::IsEqual(gp_Dir const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_gp_Dir_IsNormal (gp_Dir *larg1, gp_Dir *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  gp_Dir *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Dir const *)arg1)->IsNormal((gp_Dir const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_IsNormal\n  * wrapname: _wrap_gp_Dir_IsNormal\n  * fulldecl: Standard_Boolean gp_Dir::IsNormal(gp_Dir const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_gp_Dir_IsOpposite (gp_Dir *larg1, gp_Dir *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  gp_Dir *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Dir const *)arg1)->IsOpposite((gp_Dir const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_IsOpposite\n  * wrapname: _wrap_gp_Dir_IsOpposite\n  * fulldecl: Standard_Boolean gp_Dir::IsOpposite(gp_Dir const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_gp_Dir_IsParallel (gp_Dir *larg1, gp_Dir *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  gp_Dir *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Dir const *)arg1)->IsParallel((gp_Dir const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_IsParallel\n  * wrapname: _wrap_gp_Dir_IsParallel\n  * fulldecl: Standard_Boolean gp_Dir::IsParallel(gp_Dir const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Standard_Real _wrap_gp_Dir_Angle (gp_Dir *larg1, gp_Dir *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  gp_Dir *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Dir const *)arg1)->Angle((gp_Dir const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_Angle\n  * wrapname: _wrap_gp_Dir_Angle\n  * fulldecl: Standard_Real gp_Dir::Angle(gp_Dir const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Dir_AngleWithRef (gp_Dir *larg1, gp_Dir *larg2, gp_Dir *larg3) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  gp_Dir *arg2 = 0 ;
  gp_Dir *arg3 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Dir const *)arg1)->AngleWithRef((gp_Dir const &)*arg2,(gp_Dir const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_AngleWithRef\n  * wrapname: _wrap_gp_Dir_AngleWithRef\n  * fulldecl: Standard_Real gp_Dir::AngleWithRef(gp_Dir const &,gp_Dir const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_gp_Dir_Cross (gp_Dir *larg1, gp_Dir *larg2) {
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  gp_Dir *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Cross((gp_Dir const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_Cross\n  * wrapname: _wrap_gp_Dir_Cross\n  * fulldecl: void gp_Dir::Cross(gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Dir *_wrap_gp_Dir_Crossed (gp_Dir *larg1, gp_Dir *larg2) {
  gp_Dir * lresult = (gp_Dir *)0 ;
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  gp_Dir *arg2 = 0 ;
  gp_Dir result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Dir const *)arg1)->Crossed((gp_Dir const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_Crossed\n  * wrapname: _wrap_gp_Dir_Crossed\n  * fulldecl: gp_Dir gp_Dir::Crossed(gp_Dir const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Dir(result);
    return lresult;
  } catch (...) {
    return (gp_Dir *)0;
  }
}


EXPORT void _wrap_gp_Dir_CrossCross (gp_Dir *larg1, gp_Dir *larg2, gp_Dir *larg3) {
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  gp_Dir *arg2 = 0 ;
  gp_Dir *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->CrossCross((gp_Dir const &)*arg2,(gp_Dir const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_CrossCross\n  * wrapname: _wrap_gp_Dir_CrossCross\n  * fulldecl: void gp_Dir::CrossCross(gp_Dir const &,gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Dir *_wrap_gp_Dir_CrossCrossed (gp_Dir *larg1, gp_Dir *larg2, gp_Dir *larg3) {
  gp_Dir * lresult = (gp_Dir *)0 ;
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  gp_Dir *arg2 = 0 ;
  gp_Dir *arg3 = 0 ;
  gp_Dir result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Dir const *)arg1)->CrossCrossed((gp_Dir const &)*arg2,(gp_Dir const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_CrossCrossed\n  * wrapname: _wrap_gp_Dir_CrossCrossed\n  * fulldecl: gp_Dir gp_Dir::CrossCrossed(gp_Dir const &,gp_Dir const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Dir(result);
    return lresult;
  } catch (...) {
    return (gp_Dir *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Dir_Dot (gp_Dir *larg1, gp_Dir *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  gp_Dir *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Dir const *)arg1)->Dot((gp_Dir const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_Dot\n  * wrapname: _wrap_gp_Dir_Dot\n  * fulldecl: Standard_Real gp_Dir::Dot(gp_Dir const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Dir_DotCross (gp_Dir *larg1, gp_Dir *larg2, gp_Dir *larg3) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  gp_Dir *arg2 = 0 ;
  gp_Dir *arg3 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Dir const *)arg1)->DotCross((gp_Dir const &)*arg2,(gp_Dir const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_DotCross\n  * wrapname: _wrap_gp_Dir_DotCross\n  * fulldecl: Standard_Real gp_Dir::DotCross(gp_Dir const &,gp_Dir const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_gp_Dir_Reverse (gp_Dir *larg1) {
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Reverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_Reverse\n  * wrapname: _wrap_gp_Dir_Reverse\n  * fulldecl: void gp_Dir::Reverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Dir *_wrap_gp_Dir_Reversed (gp_Dir *larg1) {
  gp_Dir * lresult = (gp_Dir *)0 ;
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  gp_Dir result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Dir const *)arg1)->Reversed();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_Reversed\n  * wrapname: _wrap_gp_Dir_Reversed\n  * fulldecl: gp_Dir gp_Dir::Reversed() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Dir(result);
    return lresult;
  } catch (...) {
    return (gp_Dir *)0;
  }
}


EXPORT void _wrap_gp_Dir_Mirror__SWIG_0 (gp_Dir *larg1, gp_Dir *larg2) {
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  gp_Dir *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Dir const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_Mirror\n  * wrapname: _wrap_gp_Dir_Mirror__SWIG_0\n  * fulldecl: void gp_Dir::Mirror(gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Dir *_wrap_gp_Dir_Mirrored__SWIG_0 (gp_Dir *larg1, gp_Dir *larg2) {
  gp_Dir * lresult = (gp_Dir *)0 ;
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  gp_Dir *arg2 = 0 ;
  gp_Dir result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Dir const *)arg1)->Mirrored((gp_Dir const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_Mirrored\n  * wrapname: _wrap_gp_Dir_Mirrored__SWIG_0\n  * fulldecl: gp_Dir gp_Dir::Mirrored(gp_Dir const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Dir(result);
    return lresult;
  } catch (...) {
    return (gp_Dir *)0;
  }
}


EXPORT void _wrap_gp_Dir_Mirror__SWIG_1 (gp_Dir *larg1, gp_Ax1 *larg2) {
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_Mirror\n  * wrapname: _wrap_gp_Dir_Mirror__SWIG_1\n  * fulldecl: void gp_Dir::Mirror(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Dir *_wrap_gp_Dir_Mirrored__SWIG_1 (gp_Dir *larg1, gp_Ax1 *larg2) {
  gp_Dir * lresult = (gp_Dir *)0 ;
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  gp_Dir result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Dir const *)arg1)->Mirrored((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_Mirrored\n  * wrapname: _wrap_gp_Dir_Mirrored__SWIG_1\n  * fulldecl: gp_Dir gp_Dir::Mirrored(gp_Ax1 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Dir(result);
    return lresult;
  } catch (...) {
    return (gp_Dir *)0;
  }
}


EXPORT void _wrap_gp_Dir_Mirror__SWIG_2 (gp_Dir *larg1, gp_Ax2 *larg2) {
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_Mirror\n  * wrapname: _wrap_gp_Dir_Mirror__SWIG_2\n  * fulldecl: void gp_Dir::Mirror(gp_Ax2 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Dir *_wrap_gp_Dir_Mirrored__SWIG_2 (gp_Dir *larg1, gp_Ax2 *larg2) {
  gp_Dir * lresult = (gp_Dir *)0 ;
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  gp_Dir result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Dir const *)arg1)->Mirrored((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_Mirrored\n  * wrapname: _wrap_gp_Dir_Mirrored__SWIG_2\n  * fulldecl: gp_Dir gp_Dir::Mirrored(gp_Ax2 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Dir(result);
    return lresult;
  } catch (...) {
    return (gp_Dir *)0;
  }
}


EXPORT void _wrap_gp_Dir_Rotate (gp_Dir *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Rotate((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_Rotate\n  * wrapname: _wrap_gp_Dir_Rotate\n  * fulldecl: void gp_Dir::Rotate(gp_Ax1 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Dir *_wrap_gp_Dir_Rotated (gp_Dir *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Dir * lresult = (gp_Dir *)0 ;
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Dir result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Dir const *)arg1)->Rotated((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_Rotated\n  * wrapname: _wrap_gp_Dir_Rotated\n  * fulldecl: gp_Dir gp_Dir::Rotated(gp_Ax1 const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Dir(result);
    return lresult;
  } catch (...) {
    return (gp_Dir *)0;
  }
}


EXPORT void _wrap_gp_Dir_Transform (gp_Dir *larg1, gp_Trsf *larg2) {
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  gp_Trsf *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Transform((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_Transform\n  * wrapname: _wrap_gp_Dir_Transform\n  * fulldecl: void gp_Dir::Transform(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Dir *_wrap_gp_Dir_Transformed (gp_Dir *larg1, gp_Trsf *larg2) {
  gp_Dir * lresult = (gp_Dir *)0 ;
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  gp_Trsf *arg2 = 0 ;
  gp_Dir result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Dir const *)arg1)->Transformed((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Dir_Transformed\n  * wrapname: _wrap_gp_Dir_Transformed\n  * fulldecl: gp_Dir gp_Dir::Transformed(gp_Trsf const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Dir(result);
    return lresult;
  } catch (...) {
    return (gp_Dir *)0;
  }
}


EXPORT void _wrap_delete_gp_Dir (gp_Dir *larg1) {
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Dir\n  * wrapname: _wrap_delete_gp_Dir\n  * fulldecl: gp_Dir::~gp_Dir()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax3 *_wrap_new_gp_Ax3__SWIG_0 () {
  gp_Ax3 * lresult = (gp_Ax3 *)0 ;
  gp_Ax3 *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax3 *)new gp_Ax3();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax3\n  * wrapname: _wrap_new_gp_Ax3__SWIG_0\n  * fulldecl: gp_Ax3::gp_Ax3()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax3 *)0;
  }
}


EXPORT gp_Ax3 *_wrap_new_gp_Ax3__SWIG_1 (gp_Ax2 *larg1) {
  gp_Ax3 * lresult = (gp_Ax3 *)0 ;
  gp_Ax2 *arg1 = 0 ;
  gp_Ax3 *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax3 *)new gp_Ax3((gp_Ax2 const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax3\n  * wrapname: _wrap_new_gp_Ax3__SWIG_1\n  * fulldecl: gp_Ax3::gp_Ax3(gp_Ax2 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax3 *)0;
  }
}


EXPORT gp_Ax3 *_wrap_new_gp_Ax3__SWIG_2 (gp_Pnt *larg1, gp_Dir *larg2, gp_Dir *larg3) {
  gp_Ax3 * lresult = (gp_Ax3 *)0 ;
  gp_Pnt *arg1 = 0 ;
  gp_Dir *arg2 = 0 ;
  gp_Dir *arg3 = 0 ;
  gp_Ax3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax3 *)new gp_Ax3((gp_Pnt const &)*arg1,(gp_Dir const &)*arg2,(gp_Dir const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax3\n  * wrapname: _wrap_new_gp_Ax3__SWIG_2\n  * fulldecl: gp_Ax3::gp_Ax3(gp_Pnt const &,gp_Dir const &,gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax3 *)0;
  }
}


EXPORT gp_Ax3 *_wrap_new_gp_Ax3__SWIG_3 (gp_Pnt *larg1, gp_Dir *larg2) {
  gp_Ax3 * lresult = (gp_Ax3 *)0 ;
  gp_Pnt *arg1 = 0 ;
  gp_Dir *arg2 = 0 ;
  gp_Ax3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax3 *)new gp_Ax3((gp_Pnt const &)*arg1,(gp_Dir const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax3\n  * wrapname: _wrap_new_gp_Ax3__SWIG_3\n  * fulldecl: gp_Ax3::gp_Ax3(gp_Pnt const &,gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax3 *)0;
  }
}


EXPORT void _wrap_gp_Ax3_XReverse (gp_Ax3 *larg1) {
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->XReverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_XReverse\n  * wrapname: _wrap_gp_Ax3_XReverse\n  * fulldecl: void gp_Ax3::XReverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Ax3_YReverse (gp_Ax3 *larg1) {
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->YReverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_YReverse\n  * wrapname: _wrap_gp_Ax3_YReverse\n  * fulldecl: void gp_Ax3::YReverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Ax3_ZReverse (gp_Ax3 *larg1) {
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->ZReverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_ZReverse\n  * wrapname: _wrap_gp_Ax3_ZReverse\n  * fulldecl: void gp_Ax3::ZReverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Ax3_SetAxis (gp_Ax3 *larg1, gp_Ax1 *larg2) {
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetAxis((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_SetAxis\n  * wrapname: _wrap_gp_Ax3_SetAxis\n  * fulldecl: void gp_Ax3::SetAxis(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Ax3_SetDirection (gp_Ax3 *larg1, gp_Dir *larg2) {
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  gp_Dir *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetDirection((gp_Dir const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_SetDirection\n  * wrapname: _wrap_gp_Ax3_SetDirection\n  * fulldecl: void gp_Ax3::SetDirection(gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Ax3_SetLocation (gp_Ax3 *larg1, gp_Pnt *larg2) {
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLocation((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_SetLocation\n  * wrapname: _wrap_gp_Ax3_SetLocation\n  * fulldecl: void gp_Ax3::SetLocation(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Ax3_SetXDirection (gp_Ax3 *larg1, gp_Dir *larg2) {
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  gp_Dir *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetXDirection((gp_Dir const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_SetXDirection\n  * wrapname: _wrap_gp_Ax3_SetXDirection\n  * fulldecl: void gp_Ax3::SetXDirection(gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Ax3_SetYDirection (gp_Ax3 *larg1, gp_Dir *larg2) {
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  gp_Dir *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetYDirection((gp_Dir const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_SetYDirection\n  * wrapname: _wrap_gp_Ax3_SetYDirection\n  * fulldecl: void gp_Ax3::SetYDirection(gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Real _wrap_gp_Ax3_Angle (gp_Ax3 *larg1, gp_Ax3 *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  gp_Ax3 *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Ax3 const *)arg1)->Angle((gp_Ax3 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_Angle\n  * wrapname: _wrap_gp_Ax3_Angle\n  * fulldecl: Standard_Real gp_Ax3::Angle(gp_Ax3 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Ax3_Axis (gp_Ax3 *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  gp_Ax1 *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax1 *) &((gp_Ax3 const *)arg1)->Axis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_Axis\n  * wrapname: _wrap_gp_Ax3_Axis\n  * fulldecl: gp_Ax1 const & gp_Ax3::Axis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT gp_Ax2 *_wrap_gp_Ax3_Ax2 (gp_Ax3 *larg1) {
  gp_Ax2 * lresult = (gp_Ax2 *)0 ;
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  gp_Ax2 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax3 const *)arg1)->Ax2();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_Ax2\n  * wrapname: _wrap_gp_Ax3_Ax2\n  * fulldecl: gp_Ax2 gp_Ax3::Ax2() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2 *)0;
  }
}


EXPORT gp_Dir *_wrap_gp_Ax3_Direction (gp_Ax3 *larg1) {
  gp_Dir * lresult = (gp_Dir *)0 ;
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  gp_Dir *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Dir *) &((gp_Ax3 const *)arg1)->Direction();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_Direction\n  * wrapname: _wrap_gp_Ax3_Direction\n  * fulldecl: gp_Dir const & gp_Ax3::Direction() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Dir *)0;
  }
}


EXPORT gp_Pnt *_wrap_gp_Ax3_Location (gp_Ax3 *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  gp_Pnt *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt *) &((gp_Ax3 const *)arg1)->Location();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_Location\n  * wrapname: _wrap_gp_Ax3_Location\n  * fulldecl: gp_Pnt const & gp_Ax3::Location() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT gp_Dir *_wrap_gp_Ax3_XDirection (gp_Ax3 *larg1) {
  gp_Dir * lresult = (gp_Dir *)0 ;
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  gp_Dir *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Dir *) &((gp_Ax3 const *)arg1)->XDirection();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_XDirection\n  * wrapname: _wrap_gp_Ax3_XDirection\n  * fulldecl: gp_Dir const & gp_Ax3::XDirection() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Dir *)0;
  }
}


EXPORT gp_Dir *_wrap_gp_Ax3_YDirection (gp_Ax3 *larg1) {
  gp_Dir * lresult = (gp_Dir *)0 ;
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  gp_Dir *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Dir *) &((gp_Ax3 const *)arg1)->YDirection();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_YDirection\n  * wrapname: _wrap_gp_Ax3_YDirection\n  * fulldecl: gp_Dir const & gp_Ax3::YDirection() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Dir *)0;
  }
}


EXPORT bool _wrap_gp_Ax3_Direct (gp_Ax3 *larg1) {
  bool lresult = (bool)0 ;
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Ax3 const *)arg1)->Direct();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_Direct\n  * wrapname: _wrap_gp_Ax3_Direct\n  * fulldecl: Standard_Boolean gp_Ax3::Direct() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_gp_Ax3_IsCoplanar__SWIG_0 (gp_Ax3 *larg1, gp_Ax3 *larg2, Standard_Real larg3, Standard_Real larg4) {
  bool lresult = (bool)0 ;
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  gp_Ax3 *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Ax3 const *)arg1)->IsCoplanar((gp_Ax3 const &)*arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_IsCoplanar\n  * wrapname: _wrap_gp_Ax3_IsCoplanar__SWIG_0\n  * fulldecl: Standard_Boolean gp_Ax3::IsCoplanar(gp_Ax3 const &,Standard_Real const,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_gp_Ax3_IsCoplanar__SWIG_1 (gp_Ax3 *larg1, gp_Ax1 *larg2, Standard_Real larg3, Standard_Real larg4) {
  bool lresult = (bool)0 ;
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Ax3 const *)arg1)->IsCoplanar((gp_Ax1 const &)*arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_IsCoplanar\n  * wrapname: _wrap_gp_Ax3_IsCoplanar__SWIG_1\n  * fulldecl: Standard_Boolean gp_Ax3::IsCoplanar(gp_Ax1 const &,Standard_Real const,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_gp_Ax3_Mirror__SWIG_0 (gp_Ax3 *larg1, gp_Pnt *larg2) {
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_Mirror\n  * wrapname: _wrap_gp_Ax3_Mirror__SWIG_0\n  * fulldecl: void gp_Ax3::Mirror(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax3 *_wrap_gp_Ax3_Mirrored__SWIG_0 (gp_Ax3 *larg1, gp_Pnt *larg2) {
  gp_Ax3 * lresult = (gp_Ax3 *)0 ;
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Ax3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax3 const *)arg1)->Mirrored((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_Mirrored\n  * wrapname: _wrap_gp_Ax3_Mirrored__SWIG_0\n  * fulldecl: gp_Ax3 gp_Ax3::Mirrored(gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax3(result);
    return lresult;
  } catch (...) {
    return (gp_Ax3 *)0;
  }
}


EXPORT void _wrap_gp_Ax3_Mirror__SWIG_1 (gp_Ax3 *larg1, gp_Ax1 *larg2) {
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_Mirror\n  * wrapname: _wrap_gp_Ax3_Mirror__SWIG_1\n  * fulldecl: void gp_Ax3::Mirror(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax3 *_wrap_gp_Ax3_Mirrored__SWIG_1 (gp_Ax3 *larg1, gp_Ax1 *larg2) {
  gp_Ax3 * lresult = (gp_Ax3 *)0 ;
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  gp_Ax3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax3 const *)arg1)->Mirrored((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_Mirrored\n  * wrapname: _wrap_gp_Ax3_Mirrored__SWIG_1\n  * fulldecl: gp_Ax3 gp_Ax3::Mirrored(gp_Ax1 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax3(result);
    return lresult;
  } catch (...) {
    return (gp_Ax3 *)0;
  }
}


EXPORT void _wrap_gp_Ax3_Mirror__SWIG_2 (gp_Ax3 *larg1, gp_Ax2 *larg2) {
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_Mirror\n  * wrapname: _wrap_gp_Ax3_Mirror__SWIG_2\n  * fulldecl: void gp_Ax3::Mirror(gp_Ax2 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax3 *_wrap_gp_Ax3_Mirrored__SWIG_2 (gp_Ax3 *larg1, gp_Ax2 *larg2) {
  gp_Ax3 * lresult = (gp_Ax3 *)0 ;
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  gp_Ax3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax3 const *)arg1)->Mirrored((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_Mirrored\n  * wrapname: _wrap_gp_Ax3_Mirrored__SWIG_2\n  * fulldecl: gp_Ax3 gp_Ax3::Mirrored(gp_Ax2 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax3(result);
    return lresult;
  } catch (...) {
    return (gp_Ax3 *)0;
  }
}


EXPORT void _wrap_gp_Ax3_Rotate (gp_Ax3 *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Rotate((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_Rotate\n  * wrapname: _wrap_gp_Ax3_Rotate\n  * fulldecl: void gp_Ax3::Rotate(gp_Ax1 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax3 *_wrap_gp_Ax3_Rotated (gp_Ax3 *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Ax3 * lresult = (gp_Ax3 *)0 ;
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Ax3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax3 const *)arg1)->Rotated((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_Rotated\n  * wrapname: _wrap_gp_Ax3_Rotated\n  * fulldecl: gp_Ax3 gp_Ax3::Rotated(gp_Ax1 const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax3(result);
    return lresult;
  } catch (...) {
    return (gp_Ax3 *)0;
  }
}


EXPORT void _wrap_gp_Ax3_Scale (gp_Ax3 *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Scale((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_Scale\n  * wrapname: _wrap_gp_Ax3_Scale\n  * fulldecl: void gp_Ax3::Scale(gp_Pnt const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax3 *_wrap_gp_Ax3_Scaled (gp_Ax3 *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  gp_Ax3 * lresult = (gp_Ax3 *)0 ;
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Ax3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax3 const *)arg1)->Scaled((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_Scaled\n  * wrapname: _wrap_gp_Ax3_Scaled\n  * fulldecl: gp_Ax3 gp_Ax3::Scaled(gp_Pnt const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax3(result);
    return lresult;
  } catch (...) {
    return (gp_Ax3 *)0;
  }
}


EXPORT void _wrap_gp_Ax3_Transform (gp_Ax3 *larg1, gp_Trsf *larg2) {
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  gp_Trsf *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Transform((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_Transform\n  * wrapname: _wrap_gp_Ax3_Transform\n  * fulldecl: void gp_Ax3::Transform(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax3 *_wrap_gp_Ax3_Transformed (gp_Ax3 *larg1, gp_Trsf *larg2) {
  gp_Ax3 * lresult = (gp_Ax3 *)0 ;
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  gp_Trsf *arg2 = 0 ;
  gp_Ax3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax3 const *)arg1)->Transformed((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_Transformed\n  * wrapname: _wrap_gp_Ax3_Transformed\n  * fulldecl: gp_Ax3 gp_Ax3::Transformed(gp_Trsf const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax3(result);
    return lresult;
  } catch (...) {
    return (gp_Ax3 *)0;
  }
}


EXPORT void _wrap_gp_Ax3_Translate__SWIG_0 (gp_Ax3 *larg1, gp_Vec *larg2) {
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  gp_Vec *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_Translate\n  * wrapname: _wrap_gp_Ax3_Translate__SWIG_0\n  * fulldecl: void gp_Ax3::Translate(gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax3 *_wrap_gp_Ax3_Translated__SWIG_0 (gp_Ax3 *larg1, gp_Vec *larg2) {
  gp_Ax3 * lresult = (gp_Ax3 *)0 ;
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  gp_Vec *arg2 = 0 ;
  gp_Ax3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax3 const *)arg1)->Translated((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_Translated\n  * wrapname: _wrap_gp_Ax3_Translated__SWIG_0\n  * fulldecl: gp_Ax3 gp_Ax3::Translated(gp_Vec const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax3(result);
    return lresult;
  } catch (...) {
    return (gp_Ax3 *)0;
  }
}


EXPORT void _wrap_gp_Ax3_Translate__SWIG_1 (gp_Ax3 *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_Translate\n  * wrapname: _wrap_gp_Ax3_Translate__SWIG_1\n  * fulldecl: void gp_Ax3::Translate(gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax3 *_wrap_gp_Ax3_Translated__SWIG_1 (gp_Ax3 *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  gp_Ax3 * lresult = (gp_Ax3 *)0 ;
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  gp_Ax3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax3 const *)arg1)->Translated((gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax3_Translated\n  * wrapname: _wrap_gp_Ax3_Translated__SWIG_1\n  * fulldecl: gp_Ax3 gp_Ax3::Translated(gp_Pnt const &,gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax3(result);
    return lresult;
  } catch (...) {
    return (gp_Ax3 *)0;
  }
}


EXPORT void _wrap_delete_gp_Ax3 (gp_Ax3 *larg1) {
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Ax3\n  * wrapname: _wrap_delete_gp_Ax3\n  * fulldecl: gp_Ax3::~gp_Ax3()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax2 *_wrap_new_gp_Ax2__SWIG_0 () {
  gp_Ax2 * lresult = (gp_Ax2 *)0 ;
  gp_Ax2 *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax2 *)new gp_Ax2();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax2\n  * wrapname: _wrap_new_gp_Ax2__SWIG_0\n  * fulldecl: gp_Ax2::gp_Ax2()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax2 *)0;
  }
}


EXPORT gp_Ax2 *_wrap_new_gp_Ax2__SWIG_1 (gp_Pnt *larg1, gp_Dir *larg2, gp_Dir *larg3) {
  gp_Ax2 * lresult = (gp_Ax2 *)0 ;
  gp_Pnt *arg1 = 0 ;
  gp_Dir *arg2 = 0 ;
  gp_Dir *arg3 = 0 ;
  gp_Ax2 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax2 *)new gp_Ax2((gp_Pnt const &)*arg1,(gp_Dir const &)*arg2,(gp_Dir const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax2\n  * wrapname: _wrap_new_gp_Ax2__SWIG_1\n  * fulldecl: gp_Ax2::gp_Ax2(gp_Pnt const &,gp_Dir const &,gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax2 *)0;
  }
}


EXPORT gp_Ax2 *_wrap_new_gp_Ax2__SWIG_2 (gp_Pnt *larg1, gp_Dir *larg2) {
  gp_Ax2 * lresult = (gp_Ax2 *)0 ;
  gp_Pnt *arg1 = 0 ;
  gp_Dir *arg2 = 0 ;
  gp_Ax2 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax2 *)new gp_Ax2((gp_Pnt const &)*arg1,(gp_Dir const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax2\n  * wrapname: _wrap_new_gp_Ax2__SWIG_2\n  * fulldecl: gp_Ax2::gp_Ax2(gp_Pnt const &,gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax2 *)0;
  }
}


EXPORT void _wrap_gp_Ax2_SetAxis (gp_Ax2 *larg1, gp_Ax1 *larg2) {
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetAxis((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2_SetAxis\n  * wrapname: _wrap_gp_Ax2_SetAxis\n  * fulldecl: void gp_Ax2::SetAxis(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Ax2_SetDirection (gp_Ax2 *larg1, gp_Dir *larg2) {
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  gp_Dir *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetDirection((gp_Dir const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2_SetDirection\n  * wrapname: _wrap_gp_Ax2_SetDirection\n  * fulldecl: void gp_Ax2::SetDirection(gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Ax2_SetLocation (gp_Ax2 *larg1, gp_Pnt *larg2) {
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLocation((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2_SetLocation\n  * wrapname: _wrap_gp_Ax2_SetLocation\n  * fulldecl: void gp_Ax2::SetLocation(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Ax2_SetXDirection (gp_Ax2 *larg1, gp_Dir *larg2) {
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  gp_Dir *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetXDirection((gp_Dir const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2_SetXDirection\n  * wrapname: _wrap_gp_Ax2_SetXDirection\n  * fulldecl: void gp_Ax2::SetXDirection(gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Ax2_SetYDirection (gp_Ax2 *larg1, gp_Dir *larg2) {
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  gp_Dir *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetYDirection((gp_Dir const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2_SetYDirection\n  * wrapname: _wrap_gp_Ax2_SetYDirection\n  * fulldecl: void gp_Ax2::SetYDirection(gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Real _wrap_gp_Ax2_Angle (gp_Ax2 *larg1, gp_Ax2 *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Ax2 const *)arg1)->Angle((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2_Angle\n  * wrapname: _wrap_gp_Ax2_Angle\n  * fulldecl: Standard_Real gp_Ax2::Angle(gp_Ax2 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Ax2_Axis (gp_Ax2 *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  gp_Ax1 *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax1 *) &((gp_Ax2 const *)arg1)->Axis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2_Axis\n  * wrapname: _wrap_gp_Ax2_Axis\n  * fulldecl: gp_Ax1 const & gp_Ax2::Axis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT gp_Dir *_wrap_gp_Ax2_Direction (gp_Ax2 *larg1) {
  gp_Dir * lresult = (gp_Dir *)0 ;
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  gp_Dir *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Dir *) &((gp_Ax2 const *)arg1)->Direction();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2_Direction\n  * wrapname: _wrap_gp_Ax2_Direction\n  * fulldecl: gp_Dir const & gp_Ax2::Direction() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Dir *)0;
  }
}


EXPORT gp_Pnt *_wrap_gp_Ax2_Location (gp_Ax2 *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  gp_Pnt *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt *) &((gp_Ax2 const *)arg1)->Location();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2_Location\n  * wrapname: _wrap_gp_Ax2_Location\n  * fulldecl: gp_Pnt const & gp_Ax2::Location() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT gp_Dir *_wrap_gp_Ax2_XDirection (gp_Ax2 *larg1) {
  gp_Dir * lresult = (gp_Dir *)0 ;
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  gp_Dir *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Dir *) &((gp_Ax2 const *)arg1)->XDirection();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2_XDirection\n  * wrapname: _wrap_gp_Ax2_XDirection\n  * fulldecl: gp_Dir const & gp_Ax2::XDirection() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Dir *)0;
  }
}


EXPORT gp_Dir *_wrap_gp_Ax2_YDirection (gp_Ax2 *larg1) {
  gp_Dir * lresult = (gp_Dir *)0 ;
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  gp_Dir *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Dir *) &((gp_Ax2 const *)arg1)->YDirection();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2_YDirection\n  * wrapname: _wrap_gp_Ax2_YDirection\n  * fulldecl: gp_Dir const & gp_Ax2::YDirection() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Dir *)0;
  }
}


EXPORT bool _wrap_gp_Ax2_IsCoplanar__SWIG_0 (gp_Ax2 *larg1, gp_Ax2 *larg2, Standard_Real larg3, Standard_Real larg4) {
  bool lresult = (bool)0 ;
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Ax2 const *)arg1)->IsCoplanar((gp_Ax2 const &)*arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2_IsCoplanar\n  * wrapname: _wrap_gp_Ax2_IsCoplanar__SWIG_0\n  * fulldecl: Standard_Boolean gp_Ax2::IsCoplanar(gp_Ax2 const &,Standard_Real const,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_gp_Ax2_IsCoplanar__SWIG_1 (gp_Ax2 *larg1, gp_Ax1 *larg2, Standard_Real larg3, Standard_Real larg4) {
  bool lresult = (bool)0 ;
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Ax2 const *)arg1)->IsCoplanar((gp_Ax1 const &)*arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2_IsCoplanar\n  * wrapname: _wrap_gp_Ax2_IsCoplanar__SWIG_1\n  * fulldecl: Standard_Boolean gp_Ax2::IsCoplanar(gp_Ax1 const &,Standard_Real const,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_gp_Ax2_Mirror__SWIG_0 (gp_Ax2 *larg1, gp_Pnt *larg2) {
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2_Mirror\n  * wrapname: _wrap_gp_Ax2_Mirror__SWIG_0\n  * fulldecl: void gp_Ax2::Mirror(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax2 *_wrap_gp_Ax2_Mirrored__SWIG_0 (gp_Ax2 *larg1, gp_Pnt *larg2) {
  gp_Ax2 * lresult = (gp_Ax2 *)0 ;
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Ax2 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax2 const *)arg1)->Mirrored((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2_Mirrored\n  * wrapname: _wrap_gp_Ax2_Mirrored__SWIG_0\n  * fulldecl: gp_Ax2 gp_Ax2::Mirrored(gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2 *)0;
  }
}


EXPORT void _wrap_gp_Ax2_Mirror__SWIG_1 (gp_Ax2 *larg1, gp_Ax1 *larg2) {
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2_Mirror\n  * wrapname: _wrap_gp_Ax2_Mirror__SWIG_1\n  * fulldecl: void gp_Ax2::Mirror(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax2 *_wrap_gp_Ax2_Mirrored__SWIG_1 (gp_Ax2 *larg1, gp_Ax1 *larg2) {
  gp_Ax2 * lresult = (gp_Ax2 *)0 ;
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  gp_Ax2 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax2 const *)arg1)->Mirrored((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2_Mirrored\n  * wrapname: _wrap_gp_Ax2_Mirrored__SWIG_1\n  * fulldecl: gp_Ax2 gp_Ax2::Mirrored(gp_Ax1 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2 *)0;
  }
}


EXPORT void _wrap_gp_Ax2_Mirror__SWIG_2 (gp_Ax2 *larg1, gp_Ax2 *larg2) {
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2_Mirror\n  * wrapname: _wrap_gp_Ax2_Mirror__SWIG_2\n  * fulldecl: void gp_Ax2::Mirror(gp_Ax2 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax2 *_wrap_gp_Ax2_Mirrored__SWIG_2 (gp_Ax2 *larg1, gp_Ax2 *larg2) {
  gp_Ax2 * lresult = (gp_Ax2 *)0 ;
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  gp_Ax2 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax2 const *)arg1)->Mirrored((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2_Mirrored\n  * wrapname: _wrap_gp_Ax2_Mirrored__SWIG_2\n  * fulldecl: gp_Ax2 gp_Ax2::Mirrored(gp_Ax2 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2 *)0;
  }
}


EXPORT void _wrap_gp_Ax2_Rotate (gp_Ax2 *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Rotate((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2_Rotate\n  * wrapname: _wrap_gp_Ax2_Rotate\n  * fulldecl: void gp_Ax2::Rotate(gp_Ax1 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax2 *_wrap_gp_Ax2_Rotated (gp_Ax2 *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Ax2 * lresult = (gp_Ax2 *)0 ;
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Ax2 result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax2 const *)arg1)->Rotated((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2_Rotated\n  * wrapname: _wrap_gp_Ax2_Rotated\n  * fulldecl: gp_Ax2 gp_Ax2::Rotated(gp_Ax1 const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2 *)0;
  }
}


EXPORT void _wrap_gp_Ax2_Scale (gp_Ax2 *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Scale((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2_Scale\n  * wrapname: _wrap_gp_Ax2_Scale\n  * fulldecl: void gp_Ax2::Scale(gp_Pnt const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax2 *_wrap_gp_Ax2_Scaled (gp_Ax2 *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  gp_Ax2 * lresult = (gp_Ax2 *)0 ;
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Ax2 result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax2 const *)arg1)->Scaled((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2_Scaled\n  * wrapname: _wrap_gp_Ax2_Scaled\n  * fulldecl: gp_Ax2 gp_Ax2::Scaled(gp_Pnt const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2 *)0;
  }
}


EXPORT void _wrap_gp_Ax2_Transform (gp_Ax2 *larg1, gp_Trsf *larg2) {
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  gp_Trsf *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Transform((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2_Transform\n  * wrapname: _wrap_gp_Ax2_Transform\n  * fulldecl: void gp_Ax2::Transform(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax2 *_wrap_gp_Ax2_Transformed (gp_Ax2 *larg1, gp_Trsf *larg2) {
  gp_Ax2 * lresult = (gp_Ax2 *)0 ;
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  gp_Trsf *arg2 = 0 ;
  gp_Ax2 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax2 const *)arg1)->Transformed((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2_Transformed\n  * wrapname: _wrap_gp_Ax2_Transformed\n  * fulldecl: gp_Ax2 gp_Ax2::Transformed(gp_Trsf const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2 *)0;
  }
}


EXPORT void _wrap_gp_Ax2_Translate__SWIG_0 (gp_Ax2 *larg1, gp_Vec *larg2) {
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  gp_Vec *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2_Translate\n  * wrapname: _wrap_gp_Ax2_Translate__SWIG_0\n  * fulldecl: void gp_Ax2::Translate(gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax2 *_wrap_gp_Ax2_Translated__SWIG_0 (gp_Ax2 *larg1, gp_Vec *larg2) {
  gp_Ax2 * lresult = (gp_Ax2 *)0 ;
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  gp_Vec *arg2 = 0 ;
  gp_Ax2 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax2 const *)arg1)->Translated((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2_Translated\n  * wrapname: _wrap_gp_Ax2_Translated__SWIG_0\n  * fulldecl: gp_Ax2 gp_Ax2::Translated(gp_Vec const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2 *)0;
  }
}


EXPORT void _wrap_gp_Ax2_Translate__SWIG_1 (gp_Ax2 *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2_Translate\n  * wrapname: _wrap_gp_Ax2_Translate__SWIG_1\n  * fulldecl: void gp_Ax2::Translate(gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax2 *_wrap_gp_Ax2_Translated__SWIG_1 (gp_Ax2 *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  gp_Ax2 * lresult = (gp_Ax2 *)0 ;
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  gp_Ax2 result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax2 const *)arg1)->Translated((gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax2_Translated\n  * wrapname: _wrap_gp_Ax2_Translated__SWIG_1\n  * fulldecl: gp_Ax2 gp_Ax2::Translated(gp_Pnt const &,gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2 *)0;
  }
}


EXPORT void _wrap_delete_gp_Ax2 (gp_Ax2 *larg1) {
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Ax2\n  * wrapname: _wrap_delete_gp_Ax2\n  * fulldecl: gp_Ax2::~gp_Ax2()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax1 *_wrap_new_gp_Ax1__SWIG_0 () {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Ax1 *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax1 *)new gp_Ax1();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax1\n  * wrapname: _wrap_new_gp_Ax1__SWIG_0\n  * fulldecl: gp_Ax1::gp_Ax1()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT gp_Ax1 *_wrap_new_gp_Ax1__SWIG_1 (gp_Pnt *larg1, gp_Dir *larg2) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Pnt *arg1 = 0 ;
  gp_Dir *arg2 = 0 ;
  gp_Ax1 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax1 *)new gp_Ax1((gp_Pnt const &)*arg1,(gp_Dir const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax1\n  * wrapname: _wrap_new_gp_Ax1__SWIG_1\n  * fulldecl: gp_Ax1::gp_Ax1(gp_Pnt const &,gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT void _wrap_gp_Ax1_SetDirection (gp_Ax1 *larg1, gp_Dir *larg2) {
  gp_Ax1 *arg1 = (gp_Ax1 *) 0 ;
  gp_Dir *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetDirection((gp_Dir const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax1_SetDirection\n  * wrapname: _wrap_gp_Ax1_SetDirection\n  * fulldecl: void gp_Ax1::SetDirection(gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Ax1_SetLocation (gp_Ax1 *larg1, gp_Pnt *larg2) {
  gp_Ax1 *arg1 = (gp_Ax1 *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLocation((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax1_SetLocation\n  * wrapname: _wrap_gp_Ax1_SetLocation\n  * fulldecl: void gp_Ax1::SetLocation(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Dir *_wrap_gp_Ax1_Direction (gp_Ax1 *larg1) {
  gp_Dir * lresult = (gp_Dir *)0 ;
  gp_Ax1 *arg1 = (gp_Ax1 *) 0 ;
  gp_Dir *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Dir *) &((gp_Ax1 const *)arg1)->Direction();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax1_Direction\n  * wrapname: _wrap_gp_Ax1_Direction\n  * fulldecl: gp_Dir const & gp_Ax1::Direction() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Dir *)0;
  }
}


EXPORT gp_Pnt *_wrap_gp_Ax1_Location (gp_Ax1 *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_Ax1 *arg1 = (gp_Ax1 *) 0 ;
  gp_Pnt *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt *) &((gp_Ax1 const *)arg1)->Location();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax1_Location\n  * wrapname: _wrap_gp_Ax1_Location\n  * fulldecl: gp_Pnt const & gp_Ax1::Location() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT bool _wrap_gp_Ax1_IsCoaxial (gp_Ax1 *larg1, gp_Ax1 *larg2, Standard_Real larg3, Standard_Real larg4) {
  bool lresult = (bool)0 ;
  gp_Ax1 *arg1 = (gp_Ax1 *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Ax1 const *)arg1)->IsCoaxial((gp_Ax1 const &)*arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax1_IsCoaxial\n  * wrapname: _wrap_gp_Ax1_IsCoaxial\n  * fulldecl: Standard_Boolean gp_Ax1::IsCoaxial(gp_Ax1 const &,Standard_Real const,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_gp_Ax1_IsNormal (gp_Ax1 *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  gp_Ax1 *arg1 = (gp_Ax1 *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Ax1 const *)arg1)->IsNormal((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax1_IsNormal\n  * wrapname: _wrap_gp_Ax1_IsNormal\n  * fulldecl: Standard_Boolean gp_Ax1::IsNormal(gp_Ax1 const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_gp_Ax1_IsOpposite (gp_Ax1 *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  gp_Ax1 *arg1 = (gp_Ax1 *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Ax1 const *)arg1)->IsOpposite((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax1_IsOpposite\n  * wrapname: _wrap_gp_Ax1_IsOpposite\n  * fulldecl: Standard_Boolean gp_Ax1::IsOpposite(gp_Ax1 const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_gp_Ax1_IsParallel (gp_Ax1 *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  gp_Ax1 *arg1 = (gp_Ax1 *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Ax1 const *)arg1)->IsParallel((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax1_IsParallel\n  * wrapname: _wrap_gp_Ax1_IsParallel\n  * fulldecl: Standard_Boolean gp_Ax1::IsParallel(gp_Ax1 const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Standard_Real _wrap_gp_Ax1_Angle (gp_Ax1 *larg1, gp_Ax1 *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Ax1 *arg1 = (gp_Ax1 *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Ax1 const *)arg1)->Angle((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax1_Angle\n  * wrapname: _wrap_gp_Ax1_Angle\n  * fulldecl: Standard_Real gp_Ax1::Angle(gp_Ax1 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_gp_Ax1_Reverse (gp_Ax1 *larg1) {
  gp_Ax1 *arg1 = (gp_Ax1 *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Reverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax1_Reverse\n  * wrapname: _wrap_gp_Ax1_Reverse\n  * fulldecl: void gp_Ax1::Reverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax1 *_wrap_gp_Ax1_Reversed (gp_Ax1 *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Ax1 *arg1 = (gp_Ax1 *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax1 const *)arg1)->Reversed();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax1_Reversed\n  * wrapname: _wrap_gp_Ax1_Reversed\n  * fulldecl: gp_Ax1 gp_Ax1::Reversed() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT void _wrap_gp_Ax1_Mirror__SWIG_0 (gp_Ax1 *larg1, gp_Pnt *larg2) {
  gp_Ax1 *arg1 = (gp_Ax1 *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax1_Mirror\n  * wrapname: _wrap_gp_Ax1_Mirror__SWIG_0\n  * fulldecl: void gp_Ax1::Mirror(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax1 *_wrap_gp_Ax1_Mirrored__SWIG_0 (gp_Ax1 *larg1, gp_Pnt *larg2) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Ax1 *arg1 = (gp_Ax1 *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax1 const *)arg1)->Mirrored((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax1_Mirrored\n  * wrapname: _wrap_gp_Ax1_Mirrored__SWIG_0\n  * fulldecl: gp_Ax1 gp_Ax1::Mirrored(gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT void _wrap_gp_Ax1_Mirror__SWIG_1 (gp_Ax1 *larg1, gp_Ax1 *larg2) {
  gp_Ax1 *arg1 = (gp_Ax1 *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax1_Mirror\n  * wrapname: _wrap_gp_Ax1_Mirror__SWIG_1\n  * fulldecl: void gp_Ax1::Mirror(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax1 *_wrap_gp_Ax1_Mirrored__SWIG_1 (gp_Ax1 *larg1, gp_Ax1 *larg2) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Ax1 *arg1 = (gp_Ax1 *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax1 const *)arg1)->Mirrored((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax1_Mirrored\n  * wrapname: _wrap_gp_Ax1_Mirrored__SWIG_1\n  * fulldecl: gp_Ax1 gp_Ax1::Mirrored(gp_Ax1 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT void _wrap_gp_Ax1_Mirror__SWIG_2 (gp_Ax1 *larg1, gp_Ax2 *larg2) {
  gp_Ax1 *arg1 = (gp_Ax1 *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax1_Mirror\n  * wrapname: _wrap_gp_Ax1_Mirror__SWIG_2\n  * fulldecl: void gp_Ax1::Mirror(gp_Ax2 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax1 *_wrap_gp_Ax1_Mirrored__SWIG_2 (gp_Ax1 *larg1, gp_Ax2 *larg2) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Ax1 *arg1 = (gp_Ax1 *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax1 const *)arg1)->Mirrored((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax1_Mirrored\n  * wrapname: _wrap_gp_Ax1_Mirrored__SWIG_2\n  * fulldecl: gp_Ax1 gp_Ax1::Mirrored(gp_Ax2 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT void _wrap_gp_Ax1_Rotate (gp_Ax1 *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Ax1 *arg1 = (gp_Ax1 *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Rotate((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax1_Rotate\n  * wrapname: _wrap_gp_Ax1_Rotate\n  * fulldecl: void gp_Ax1::Rotate(gp_Ax1 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax1 *_wrap_gp_Ax1_Rotated (gp_Ax1 *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Ax1 *arg1 = (gp_Ax1 *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax1 const *)arg1)->Rotated((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax1_Rotated\n  * wrapname: _wrap_gp_Ax1_Rotated\n  * fulldecl: gp_Ax1 gp_Ax1::Rotated(gp_Ax1 const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT void _wrap_gp_Ax1_Scale (gp_Ax1 *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  gp_Ax1 *arg1 = (gp_Ax1 *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Scale((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax1_Scale\n  * wrapname: _wrap_gp_Ax1_Scale\n  * fulldecl: void gp_Ax1::Scale(gp_Pnt const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax1 *_wrap_gp_Ax1_Scaled (gp_Ax1 *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Ax1 *arg1 = (gp_Ax1 *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax1 const *)arg1)->Scaled((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax1_Scaled\n  * wrapname: _wrap_gp_Ax1_Scaled\n  * fulldecl: gp_Ax1 gp_Ax1::Scaled(gp_Pnt const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT void _wrap_gp_Ax1_Transform (gp_Ax1 *larg1, gp_Trsf *larg2) {
  gp_Ax1 *arg1 = (gp_Ax1 *) 0 ;
  gp_Trsf *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Transform((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax1_Transform\n  * wrapname: _wrap_gp_Ax1_Transform\n  * fulldecl: void gp_Ax1::Transform(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax1 *_wrap_gp_Ax1_Transformed (gp_Ax1 *larg1, gp_Trsf *larg2) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Ax1 *arg1 = (gp_Ax1 *) 0 ;
  gp_Trsf *arg2 = 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax1 const *)arg1)->Transformed((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax1_Transformed\n  * wrapname: _wrap_gp_Ax1_Transformed\n  * fulldecl: gp_Ax1 gp_Ax1::Transformed(gp_Trsf const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT void _wrap_gp_Ax1_Translate__SWIG_0 (gp_Ax1 *larg1, gp_Vec *larg2) {
  gp_Ax1 *arg1 = (gp_Ax1 *) 0 ;
  gp_Vec *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax1_Translate\n  * wrapname: _wrap_gp_Ax1_Translate__SWIG_0\n  * fulldecl: void gp_Ax1::Translate(gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax1 *_wrap_gp_Ax1_Translated__SWIG_0 (gp_Ax1 *larg1, gp_Vec *larg2) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Ax1 *arg1 = (gp_Ax1 *) 0 ;
  gp_Vec *arg2 = 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax1 const *)arg1)->Translated((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax1_Translated\n  * wrapname: _wrap_gp_Ax1_Translated__SWIG_0\n  * fulldecl: gp_Ax1 gp_Ax1::Translated(gp_Vec const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT void _wrap_gp_Ax1_Translate__SWIG_1 (gp_Ax1 *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  gp_Ax1 *arg1 = (gp_Ax1 *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax1_Translate\n  * wrapname: _wrap_gp_Ax1_Translate__SWIG_1\n  * fulldecl: void gp_Ax1::Translate(gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax1 *_wrap_gp_Ax1_Translated__SWIG_1 (gp_Ax1 *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Ax1 *arg1 = (gp_Ax1 *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Ax1 const *)arg1)->Translated((gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Ax1_Translated\n  * wrapname: _wrap_gp_Ax1_Translated__SWIG_1\n  * fulldecl: gp_Ax1 gp_Ax1::Translated(gp_Pnt const &,gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT void _wrap_delete_gp_Ax1 (gp_Ax1 *larg1) {
  gp_Ax1 *arg1 = (gp_Ax1 *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Ax1\n  * wrapname: _wrap_delete_gp_Ax1\n  * fulldecl: gp_Ax1::~gp_Ax1()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Trsf2d *_wrap_new_gp_Trsf2d__SWIG_0 () {
  gp_Trsf2d * lresult = (gp_Trsf2d *)0 ;
  gp_Trsf2d *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Trsf2d *)new gp_Trsf2d();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Trsf2d\n  * wrapname: _wrap_new_gp_Trsf2d__SWIG_0\n  * fulldecl: gp_Trsf2d::gp_Trsf2d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Trsf2d *)0;
  }
}


EXPORT gp_Trsf2d *_wrap_new_gp_Trsf2d__SWIG_1 (gp_Trsf *larg1) {
  gp_Trsf2d * lresult = (gp_Trsf2d *)0 ;
  gp_Trsf *arg1 = 0 ;
  gp_Trsf2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Trsf2d *)new gp_Trsf2d((gp_Trsf const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Trsf2d\n  * wrapname: _wrap_new_gp_Trsf2d__SWIG_1\n  * fulldecl: gp_Trsf2d::gp_Trsf2d(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Trsf2d *)0;
  }
}


EXPORT void _wrap_gp_Trsf2d_SetMirror__SWIG_0 (gp_Trsf2d *larg1, gp_Pnt2d *larg2) {
  gp_Trsf2d *arg1 = (gp_Trsf2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetMirror((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf2d_SetMirror\n  * wrapname: _wrap_gp_Trsf2d_SetMirror__SWIG_0\n  * fulldecl: void gp_Trsf2d::SetMirror(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf2d_SetMirror__SWIG_1 (gp_Trsf2d *larg1, gp_Ax2d *larg2) {
  gp_Trsf2d *arg1 = (gp_Trsf2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetMirror((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf2d_SetMirror\n  * wrapname: _wrap_gp_Trsf2d_SetMirror__SWIG_1\n  * fulldecl: void gp_Trsf2d::SetMirror(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf2d_SetRotation (gp_Trsf2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Trsf2d *arg1 = (gp_Trsf2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetRotation((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf2d_SetRotation\n  * wrapname: _wrap_gp_Trsf2d_SetRotation\n  * fulldecl: void gp_Trsf2d::SetRotation(gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf2d_SetScale (gp_Trsf2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Trsf2d *arg1 = (gp_Trsf2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetScale((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf2d_SetScale\n  * wrapname: _wrap_gp_Trsf2d_SetScale\n  * fulldecl: void gp_Trsf2d::SetScale(gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf2d_SetTransformation__SWIG_0 (gp_Trsf2d *larg1, gp_Ax2d *larg2, gp_Ax2d *larg3) {
  gp_Trsf2d *arg1 = (gp_Trsf2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  gp_Ax2d *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetTransformation((gp_Ax2d const &)*arg2,(gp_Ax2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf2d_SetTransformation\n  * wrapname: _wrap_gp_Trsf2d_SetTransformation__SWIG_0\n  * fulldecl: void gp_Trsf2d::SetTransformation(gp_Ax2d const &,gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf2d_SetTransformation__SWIG_1 (gp_Trsf2d *larg1, gp_Ax2d *larg2) {
  gp_Trsf2d *arg1 = (gp_Trsf2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetTransformation((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf2d_SetTransformation\n  * wrapname: _wrap_gp_Trsf2d_SetTransformation__SWIG_1\n  * fulldecl: void gp_Trsf2d::SetTransformation(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf2d_SetTranslation__SWIG_0 (gp_Trsf2d *larg1, gp_Vec2d *larg2) {
  gp_Trsf2d *arg1 = (gp_Trsf2d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetTranslation((gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf2d_SetTranslation\n  * wrapname: _wrap_gp_Trsf2d_SetTranslation__SWIG_0\n  * fulldecl: void gp_Trsf2d::SetTranslation(gp_Vec2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf2d_SetTranslation__SWIG_1 (gp_Trsf2d *larg1, gp_Pnt2d *larg2, gp_Pnt2d *larg3) {
  gp_Trsf2d *arg1 = (gp_Trsf2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Pnt2d *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetTranslation((gp_Pnt2d const &)*arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf2d_SetTranslation\n  * wrapname: _wrap_gp_Trsf2d_SetTranslation__SWIG_1\n  * fulldecl: void gp_Trsf2d::SetTranslation(gp_Pnt2d const &,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf2d_SetTranslationPart (gp_Trsf2d *larg1, gp_Vec2d *larg2) {
  gp_Trsf2d *arg1 = (gp_Trsf2d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetTranslationPart((gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf2d_SetTranslationPart\n  * wrapname: _wrap_gp_Trsf2d_SetTranslationPart\n  * fulldecl: void gp_Trsf2d::SetTranslationPart(gp_Vec2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf2d_SetScaleFactor (gp_Trsf2d *larg1, Standard_Real larg2) {
  gp_Trsf2d *arg1 = (gp_Trsf2d *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetScaleFactor(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf2d_SetScaleFactor\n  * wrapname: _wrap_gp_Trsf2d_SetScaleFactor\n  * fulldecl: void gp_Trsf2d::SetScaleFactor(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_gp_Trsf2d_IsNegative (gp_Trsf2d *larg1) {
  bool lresult = (bool)0 ;
  gp_Trsf2d *arg1 = (gp_Trsf2d *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Trsf2d const *)arg1)->IsNegative();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf2d_IsNegative\n  * wrapname: _wrap_gp_Trsf2d_IsNegative\n  * fulldecl: Standard_Boolean gp_Trsf2d::IsNegative() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT gp_TrsfForm _wrap_gp_Trsf2d_Form (gp_Trsf2d *larg1) {
  gp_TrsfForm lresult = (gp_TrsfForm)0 ;
  gp_Trsf2d *arg1 = (gp_Trsf2d *) 0 ;
  gp_TrsfForm result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_TrsfForm)((gp_Trsf2d const *)arg1)->Form();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf2d_Form\n  * wrapname: _wrap_gp_Trsf2d_Form\n  * fulldecl: gp_TrsfForm gp_Trsf2d::Form() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_TrsfForm)0;
  }
}


EXPORT Standard_Real _wrap_gp_Trsf2d_ScaleFactor (gp_Trsf2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Trsf2d *arg1 = (gp_Trsf2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Trsf2d const *)arg1)->ScaleFactor();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf2d_ScaleFactor\n  * wrapname: _wrap_gp_Trsf2d_ScaleFactor\n  * fulldecl: Standard_Real gp_Trsf2d::ScaleFactor() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_XY *_wrap_gp_Trsf2d_TranslationPart (gp_Trsf2d *larg1) {
  gp_XY * lresult = (gp_XY *)0 ;
  gp_Trsf2d *arg1 = (gp_Trsf2d *) 0 ;
  gp_XY *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_XY *) &((gp_Trsf2d const *)arg1)->TranslationPart();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf2d_TranslationPart\n  * wrapname: _wrap_gp_Trsf2d_TranslationPart\n  * fulldecl: gp_XY const & gp_Trsf2d::TranslationPart() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_XY *)0;
  }
}


EXPORT gp_Mat2d *_wrap_gp_Trsf2d_VectorialPart (gp_Trsf2d *larg1) {
  gp_Mat2d * lresult = (gp_Mat2d *)0 ;
  gp_Trsf2d *arg1 = (gp_Trsf2d *) 0 ;
  gp_Mat2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Trsf2d const *)arg1)->VectorialPart();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf2d_VectorialPart\n  * wrapname: _wrap_gp_Trsf2d_VectorialPart\n  * fulldecl: gp_Mat2d gp_Trsf2d::VectorialPart() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Mat2d(result);
    return lresult;
  } catch (...) {
    return (gp_Mat2d *)0;
  }
}


EXPORT gp_Mat2d *_wrap_gp_Trsf2d_HVectorialPart (gp_Trsf2d *larg1) {
  gp_Mat2d * lresult = (gp_Mat2d *)0 ;
  gp_Trsf2d *arg1 = (gp_Trsf2d *) 0 ;
  gp_Mat2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Mat2d *) &((gp_Trsf2d const *)arg1)->HVectorialPart();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf2d_HVectorialPart\n  * wrapname: _wrap_gp_Trsf2d_HVectorialPart\n  * fulldecl: gp_Mat2d & gp_Trsf2d::HVectorialPart() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Mat2d *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Trsf2d_RotationPart (gp_Trsf2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Trsf2d *arg1 = (gp_Trsf2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Trsf2d const *)arg1)->RotationPart();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf2d_RotationPart\n  * wrapname: _wrap_gp_Trsf2d_RotationPart\n  * fulldecl: Standard_Real gp_Trsf2d::RotationPart() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Trsf2d_Value (gp_Trsf2d *larg1, Standard_Integer larg2, Standard_Integer larg3) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Trsf2d *arg1 = (gp_Trsf2d *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Trsf2d const *)arg1)->Value(arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf2d_Value\n  * wrapname: _wrap_gp_Trsf2d_Value\n  * fulldecl: Standard_Real gp_Trsf2d::Value(Standard_Integer const,Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_gp_Trsf2d_Invert (gp_Trsf2d *larg1) {
  gp_Trsf2d *arg1 = (gp_Trsf2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Invert();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf2d_Invert\n  * wrapname: _wrap_gp_Trsf2d_Invert\n  * fulldecl: void gp_Trsf2d::Invert()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Trsf2d *_wrap_gp_Trsf2d_Inverted (gp_Trsf2d *larg1) {
  gp_Trsf2d * lresult = (gp_Trsf2d *)0 ;
  gp_Trsf2d *arg1 = (gp_Trsf2d *) 0 ;
  gp_Trsf2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Trsf2d const *)arg1)->Inverted();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf2d_Inverted\n  * wrapname: _wrap_gp_Trsf2d_Inverted\n  * fulldecl: gp_Trsf2d gp_Trsf2d::Inverted() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Trsf2d(result);
    return lresult;
  } catch (...) {
    return (gp_Trsf2d *)0;
  }
}


EXPORT gp_Trsf2d *_wrap_gp_Trsf2d_Multiplied (gp_Trsf2d *larg1, gp_Trsf2d *larg2) {
  gp_Trsf2d * lresult = (gp_Trsf2d *)0 ;
  gp_Trsf2d *arg1 = (gp_Trsf2d *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  gp_Trsf2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Trsf2d const *)arg1)->Multiplied((gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf2d_Multiplied\n  * wrapname: _wrap_gp_Trsf2d_Multiplied\n  * fulldecl: gp_Trsf2d gp_Trsf2d::Multiplied(gp_Trsf2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Trsf2d(result);
    return lresult;
  } catch (...) {
    return (gp_Trsf2d *)0;
  }
}


EXPORT void _wrap_gp_Trsf2d_Multiply (gp_Trsf2d *larg1, gp_Trsf2d *larg2) {
  gp_Trsf2d *arg1 = (gp_Trsf2d *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Multiply((gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf2d_Multiply\n  * wrapname: _wrap_gp_Trsf2d_Multiply\n  * fulldecl: void gp_Trsf2d::Multiply(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf2d_PreMultiply (gp_Trsf2d *larg1, gp_Trsf2d *larg2) {
  gp_Trsf2d *arg1 = (gp_Trsf2d *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->PreMultiply((gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf2d_PreMultiply\n  * wrapname: _wrap_gp_Trsf2d_PreMultiply\n  * fulldecl: void gp_Trsf2d::PreMultiply(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf2d_Power (gp_Trsf2d *larg1, Standard_Integer larg2) {
  gp_Trsf2d *arg1 = (gp_Trsf2d *) 0 ;
  Standard_Integer arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Power(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf2d_Power\n  * wrapname: _wrap_gp_Trsf2d_Power\n  * fulldecl: void gp_Trsf2d::Power(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Trsf2d *_wrap_gp_Trsf2d_Powered (gp_Trsf2d *larg1, Standard_Integer larg2) {
  gp_Trsf2d * lresult = (gp_Trsf2d *)0 ;
  gp_Trsf2d *arg1 = (gp_Trsf2d *) 0 ;
  Standard_Integer arg2 ;
  gp_Trsf2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (arg1)->Powered(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf2d_Powered\n  * wrapname: _wrap_gp_Trsf2d_Powered\n  * fulldecl: gp_Trsf2d gp_Trsf2d::Powered(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Trsf2d(result);
    return lresult;
  } catch (...) {
    return (gp_Trsf2d *)0;
  }
}


EXPORT void _wrap_gp_Trsf2d_Transforms__SWIG_0 (gp_Trsf2d *larg1, Standard_Real *larg2, Standard_Real *larg3) {
  gp_Trsf2d *arg1 = (gp_Trsf2d *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((gp_Trsf2d const *)arg1)->Transforms(*arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf2d_Transforms\n  * wrapname: _wrap_gp_Trsf2d_Transforms__SWIG_0\n  * fulldecl: void gp_Trsf2d::Transforms(Standard_Real &,Standard_Real &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf2d_Transforms__SWIG_1 (gp_Trsf2d *larg1, gp_XY *larg2) {
  gp_Trsf2d *arg1 = (gp_Trsf2d *) 0 ;
  gp_XY *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((gp_Trsf2d const *)arg1)->Transforms(*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf2d_Transforms\n  * wrapname: _wrap_gp_Trsf2d_Transforms__SWIG_1\n  * fulldecl: void gp_Trsf2d::Transforms(gp_XY &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf2d_SetValues (gp_Trsf2d *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5, Standard_Real larg6, Standard_Real larg7) {
  gp_Trsf2d *arg1 = (gp_Trsf2d *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  Standard_Real arg6 ;
  Standard_Real arg7 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetValues(arg2,arg3,arg4,arg5,arg6,arg7);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf2d_SetValues\n  * wrapname: _wrap_gp_Trsf2d_SetValues\n  * fulldecl: void gp_Trsf2d::SetValues(Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_gp_Trsf2d (gp_Trsf2d *larg1) {
  gp_Trsf2d *arg1 = (gp_Trsf2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Trsf2d\n  * wrapname: _wrap_delete_gp_Trsf2d\n  * fulldecl: gp_Trsf2d::~gp_Trsf2d()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_GTrsf2d *_wrap_new_gp_GTrsf2d__SWIG_0 () {
  gp_GTrsf2d * lresult = (gp_GTrsf2d *)0 ;
  gp_GTrsf2d *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_GTrsf2d *)new gp_GTrsf2d();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_GTrsf2d\n  * wrapname: _wrap_new_gp_GTrsf2d__SWIG_0\n  * fulldecl: gp_GTrsf2d::gp_GTrsf2d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_GTrsf2d *)0;
  }
}


EXPORT gp_GTrsf2d *_wrap_new_gp_GTrsf2d__SWIG_1 (gp_Trsf2d *larg1) {
  gp_GTrsf2d * lresult = (gp_GTrsf2d *)0 ;
  gp_Trsf2d *arg1 = 0 ;
  gp_GTrsf2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_GTrsf2d *)new gp_GTrsf2d((gp_Trsf2d const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_GTrsf2d\n  * wrapname: _wrap_new_gp_GTrsf2d__SWIG_1\n  * fulldecl: gp_GTrsf2d::gp_GTrsf2d(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_GTrsf2d *)0;
  }
}


EXPORT gp_GTrsf2d *_wrap_new_gp_GTrsf2d__SWIG_2 (gp_Mat2d *larg1, gp_XY *larg2) {
  gp_GTrsf2d * lresult = (gp_GTrsf2d *)0 ;
  gp_Mat2d *arg1 = 0 ;
  gp_XY *arg2 = 0 ;
  gp_GTrsf2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_GTrsf2d *)new gp_GTrsf2d((gp_Mat2d const &)*arg1,(gp_XY const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_GTrsf2d\n  * wrapname: _wrap_new_gp_GTrsf2d__SWIG_2\n  * fulldecl: gp_GTrsf2d::gp_GTrsf2d(gp_Mat2d const &,gp_XY const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_GTrsf2d *)0;
  }
}


EXPORT void _wrap_gp_GTrsf2d_SetAffinity (gp_GTrsf2d *larg1, gp_Ax2d *larg2, Standard_Real larg3) {
  gp_GTrsf2d *arg1 = (gp_GTrsf2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetAffinity((gp_Ax2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf2d_SetAffinity\n  * wrapname: _wrap_gp_GTrsf2d_SetAffinity\n  * fulldecl: void gp_GTrsf2d::SetAffinity(gp_Ax2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_GTrsf2d_SetValue (gp_GTrsf2d *larg1, Standard_Integer larg2, Standard_Integer larg3, Standard_Real larg4) {
  gp_GTrsf2d *arg1 = (gp_GTrsf2d *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetValue(arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf2d_SetValue\n  * wrapname: _wrap_gp_GTrsf2d_SetValue\n  * fulldecl: void gp_GTrsf2d::SetValue(Standard_Integer const,Standard_Integer const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_GTrsf2d_SetTranslationPart (gp_GTrsf2d *larg1, gp_XY *larg2) {
  gp_GTrsf2d *arg1 = (gp_GTrsf2d *) 0 ;
  gp_XY *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetTranslationPart((gp_XY const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf2d_SetTranslationPart\n  * wrapname: _wrap_gp_GTrsf2d_SetTranslationPart\n  * fulldecl: void gp_GTrsf2d::SetTranslationPart(gp_XY const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_GTrsf2d_SetTrsf2d (gp_GTrsf2d *larg1, gp_Trsf2d *larg2) {
  gp_GTrsf2d *arg1 = (gp_GTrsf2d *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetTrsf2d((gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf2d_SetTrsf2d\n  * wrapname: _wrap_gp_GTrsf2d_SetTrsf2d\n  * fulldecl: void gp_GTrsf2d::SetTrsf2d(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_GTrsf2d_SetVectorialPart (gp_GTrsf2d *larg1, gp_Mat2d *larg2) {
  gp_GTrsf2d *arg1 = (gp_GTrsf2d *) 0 ;
  gp_Mat2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetVectorialPart((gp_Mat2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf2d_SetVectorialPart\n  * wrapname: _wrap_gp_GTrsf2d_SetVectorialPart\n  * fulldecl: void gp_GTrsf2d::SetVectorialPart(gp_Mat2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_gp_GTrsf2d_IsNegative (gp_GTrsf2d *larg1) {
  bool lresult = (bool)0 ;
  gp_GTrsf2d *arg1 = (gp_GTrsf2d *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_GTrsf2d const *)arg1)->IsNegative();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf2d_IsNegative\n  * wrapname: _wrap_gp_GTrsf2d_IsNegative\n  * fulldecl: Standard_Boolean gp_GTrsf2d::IsNegative() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_gp_GTrsf2d_IsSingular (gp_GTrsf2d *larg1) {
  bool lresult = (bool)0 ;
  gp_GTrsf2d *arg1 = (gp_GTrsf2d *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_GTrsf2d const *)arg1)->IsSingular();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf2d_IsSingular\n  * wrapname: _wrap_gp_GTrsf2d_IsSingular\n  * fulldecl: Standard_Boolean gp_GTrsf2d::IsSingular() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT gp_TrsfForm _wrap_gp_GTrsf2d_Form (gp_GTrsf2d *larg1) {
  gp_TrsfForm lresult = (gp_TrsfForm)0 ;
  gp_GTrsf2d *arg1 = (gp_GTrsf2d *) 0 ;
  gp_TrsfForm result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_TrsfForm)((gp_GTrsf2d const *)arg1)->Form();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf2d_Form\n  * wrapname: _wrap_gp_GTrsf2d_Form\n  * fulldecl: gp_TrsfForm gp_GTrsf2d::Form() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_TrsfForm)0;
  }
}


EXPORT gp_XY *_wrap_gp_GTrsf2d_TranslationPart (gp_GTrsf2d *larg1) {
  gp_XY * lresult = (gp_XY *)0 ;
  gp_GTrsf2d *arg1 = (gp_GTrsf2d *) 0 ;
  gp_XY *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_XY *) &((gp_GTrsf2d const *)arg1)->TranslationPart();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf2d_TranslationPart\n  * wrapname: _wrap_gp_GTrsf2d_TranslationPart\n  * fulldecl: gp_XY const & gp_GTrsf2d::TranslationPart() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_XY *)0;
  }
}


EXPORT gp_Mat2d *_wrap_gp_GTrsf2d_VectorialPart (gp_GTrsf2d *larg1) {
  gp_Mat2d * lresult = (gp_Mat2d *)0 ;
  gp_GTrsf2d *arg1 = (gp_GTrsf2d *) 0 ;
  gp_Mat2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Mat2d *) &((gp_GTrsf2d const *)arg1)->VectorialPart();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf2d_VectorialPart\n  * wrapname: _wrap_gp_GTrsf2d_VectorialPart\n  * fulldecl: gp_Mat2d const & gp_GTrsf2d::VectorialPart() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Mat2d *)0;
  }
}


EXPORT Standard_Real _wrap_gp_GTrsf2d_Value (gp_GTrsf2d *larg1, Standard_Integer larg2, Standard_Integer larg3) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_GTrsf2d *arg1 = (gp_GTrsf2d *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_GTrsf2d const *)arg1)->Value(arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf2d_Value\n  * wrapname: _wrap_gp_GTrsf2d_Value\n  * fulldecl: Standard_Real gp_GTrsf2d::Value(Standard_Integer const,Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_gp_GTrsf2d_Invert (gp_GTrsf2d *larg1) {
  gp_GTrsf2d *arg1 = (gp_GTrsf2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Invert();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf2d_Invert\n  * wrapname: _wrap_gp_GTrsf2d_Invert\n  * fulldecl: void gp_GTrsf2d::Invert()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_GTrsf2d *_wrap_gp_GTrsf2d_Inverted (gp_GTrsf2d *larg1) {
  gp_GTrsf2d * lresult = (gp_GTrsf2d *)0 ;
  gp_GTrsf2d *arg1 = (gp_GTrsf2d *) 0 ;
  gp_GTrsf2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_GTrsf2d const *)arg1)->Inverted();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf2d_Inverted\n  * wrapname: _wrap_gp_GTrsf2d_Inverted\n  * fulldecl: gp_GTrsf2d gp_GTrsf2d::Inverted() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_GTrsf2d(result);
    return lresult;
  } catch (...) {
    return (gp_GTrsf2d *)0;
  }
}


EXPORT gp_GTrsf2d *_wrap_gp_GTrsf2d_Multiplied (gp_GTrsf2d *larg1, gp_GTrsf2d *larg2) {
  gp_GTrsf2d * lresult = (gp_GTrsf2d *)0 ;
  gp_GTrsf2d *arg1 = (gp_GTrsf2d *) 0 ;
  gp_GTrsf2d *arg2 = 0 ;
  gp_GTrsf2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_GTrsf2d const *)arg1)->Multiplied((gp_GTrsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf2d_Multiplied\n  * wrapname: _wrap_gp_GTrsf2d_Multiplied\n  * fulldecl: gp_GTrsf2d gp_GTrsf2d::Multiplied(gp_GTrsf2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_GTrsf2d(result);
    return lresult;
  } catch (...) {
    return (gp_GTrsf2d *)0;
  }
}


EXPORT void _wrap_gp_GTrsf2d_Multiply (gp_GTrsf2d *larg1, gp_GTrsf2d *larg2) {
  gp_GTrsf2d *arg1 = (gp_GTrsf2d *) 0 ;
  gp_GTrsf2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Multiply((gp_GTrsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf2d_Multiply\n  * wrapname: _wrap_gp_GTrsf2d_Multiply\n  * fulldecl: void gp_GTrsf2d::Multiply(gp_GTrsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_GTrsf2d_PreMultiply (gp_GTrsf2d *larg1, gp_GTrsf2d *larg2) {
  gp_GTrsf2d *arg1 = (gp_GTrsf2d *) 0 ;
  gp_GTrsf2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->PreMultiply((gp_GTrsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf2d_PreMultiply\n  * wrapname: _wrap_gp_GTrsf2d_PreMultiply\n  * fulldecl: void gp_GTrsf2d::PreMultiply(gp_GTrsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_GTrsf2d_Power (gp_GTrsf2d *larg1, Standard_Integer larg2) {
  gp_GTrsf2d *arg1 = (gp_GTrsf2d *) 0 ;
  Standard_Integer arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Power(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf2d_Power\n  * wrapname: _wrap_gp_GTrsf2d_Power\n  * fulldecl: void gp_GTrsf2d::Power(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_GTrsf2d *_wrap_gp_GTrsf2d_Powered (gp_GTrsf2d *larg1, Standard_Integer larg2) {
  gp_GTrsf2d * lresult = (gp_GTrsf2d *)0 ;
  gp_GTrsf2d *arg1 = (gp_GTrsf2d *) 0 ;
  Standard_Integer arg2 ;
  gp_GTrsf2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_GTrsf2d const *)arg1)->Powered(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf2d_Powered\n  * wrapname: _wrap_gp_GTrsf2d_Powered\n  * fulldecl: gp_GTrsf2d gp_GTrsf2d::Powered(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_GTrsf2d(result);
    return lresult;
  } catch (...) {
    return (gp_GTrsf2d *)0;
  }
}


EXPORT void _wrap_gp_GTrsf2d_Transforms__SWIG_0 (gp_GTrsf2d *larg1, gp_XY *larg2) {
  gp_GTrsf2d *arg1 = (gp_GTrsf2d *) 0 ;
  gp_XY *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((gp_GTrsf2d const *)arg1)->Transforms(*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf2d_Transforms\n  * wrapname: _wrap_gp_GTrsf2d_Transforms__SWIG_0\n  * fulldecl: void gp_GTrsf2d::Transforms(gp_XY &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_XY *_wrap_gp_GTrsf2d_Transformed (gp_GTrsf2d *larg1, gp_XY *larg2) {
  gp_XY * lresult = (gp_XY *)0 ;
  gp_GTrsf2d *arg1 = (gp_GTrsf2d *) 0 ;
  gp_XY *arg2 = 0 ;
  gp_XY result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_GTrsf2d const *)arg1)->Transformed((gp_XY const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf2d_Transformed\n  * wrapname: _wrap_gp_GTrsf2d_Transformed\n  * fulldecl: gp_XY gp_GTrsf2d::Transformed(gp_XY const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_XY(result);
    return lresult;
  } catch (...) {
    return (gp_XY *)0;
  }
}


EXPORT void _wrap_gp_GTrsf2d_Transforms__SWIG_1 (gp_GTrsf2d *larg1, Standard_Real *larg2, Standard_Real *larg3) {
  gp_GTrsf2d *arg1 = (gp_GTrsf2d *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((gp_GTrsf2d const *)arg1)->Transforms(*arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf2d_Transforms\n  * wrapname: _wrap_gp_GTrsf2d_Transforms__SWIG_1\n  * fulldecl: void gp_GTrsf2d::Transforms(Standard_Real &,Standard_Real &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Trsf2d *_wrap_gp_GTrsf2d_Trsf2d (gp_GTrsf2d *larg1) {
  gp_Trsf2d * lresult = (gp_Trsf2d *)0 ;
  gp_GTrsf2d *arg1 = (gp_GTrsf2d *) 0 ;
  gp_Trsf2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_GTrsf2d const *)arg1)->Trsf2d();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf2d_Trsf2d\n  * wrapname: _wrap_gp_GTrsf2d_Trsf2d\n  * fulldecl: gp_Trsf2d gp_GTrsf2d::Trsf2d() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Trsf2d(result);
    return lresult;
  } catch (...) {
    return (gp_Trsf2d *)0;
  }
}


EXPORT void _wrap_delete_gp_GTrsf2d (gp_GTrsf2d *larg1) {
  gp_GTrsf2d *arg1 = (gp_GTrsf2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_GTrsf2d\n  * wrapname: _wrap_delete_gp_GTrsf2d\n  * fulldecl: gp_GTrsf2d::~gp_GTrsf2d()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Trsf *_wrap_new_gp_Trsf__SWIG_0 () {
  gp_Trsf * lresult = (gp_Trsf *)0 ;
  gp_Trsf *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Trsf *)new gp_Trsf();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Trsf\n  * wrapname: _wrap_new_gp_Trsf__SWIG_0\n  * fulldecl: gp_Trsf::gp_Trsf()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Trsf *)0;
  }
}


EXPORT gp_Trsf *_wrap_new_gp_Trsf__SWIG_1 (gp_Trsf2d *larg1) {
  gp_Trsf * lresult = (gp_Trsf *)0 ;
  gp_Trsf2d *arg1 = 0 ;
  gp_Trsf *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Trsf *)new gp_Trsf((gp_Trsf2d const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Trsf\n  * wrapname: _wrap_new_gp_Trsf__SWIG_1\n  * fulldecl: gp_Trsf::gp_Trsf(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Trsf *)0;
  }
}


EXPORT void _wrap_gp_Trsf_SetMirror__SWIG_0 (gp_Trsf *larg1, gp_Pnt *larg2) {
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetMirror((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_SetMirror\n  * wrapname: _wrap_gp_Trsf_SetMirror__SWIG_0\n  * fulldecl: void gp_Trsf::SetMirror(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf_SetMirror__SWIG_1 (gp_Trsf *larg1, gp_Ax1 *larg2) {
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetMirror((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_SetMirror\n  * wrapname: _wrap_gp_Trsf_SetMirror__SWIG_1\n  * fulldecl: void gp_Trsf::SetMirror(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf_SetMirror__SWIG_2 (gp_Trsf *larg1, gp_Ax2 *larg2) {
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetMirror((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_SetMirror\n  * wrapname: _wrap_gp_Trsf_SetMirror__SWIG_2\n  * fulldecl: void gp_Trsf::SetMirror(gp_Ax2 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf_SetRotation__SWIG_0 (gp_Trsf *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetRotation((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_SetRotation\n  * wrapname: _wrap_gp_Trsf_SetRotation__SWIG_0\n  * fulldecl: void gp_Trsf::SetRotation(gp_Ax1 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf_SetRotation__SWIG_1 (gp_Trsf *larg1, gp_Quaternion *larg2) {
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  gp_Quaternion *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetRotation((gp_Quaternion const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_SetRotation\n  * wrapname: _wrap_gp_Trsf_SetRotation__SWIG_1\n  * fulldecl: void gp_Trsf::SetRotation(gp_Quaternion const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf_SetScale (gp_Trsf *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetScale((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_SetScale\n  * wrapname: _wrap_gp_Trsf_SetScale\n  * fulldecl: void gp_Trsf::SetScale(gp_Pnt const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf_SetDisplacement (gp_Trsf *larg1, gp_Ax3 *larg2, gp_Ax3 *larg3) {
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  gp_Ax3 *arg2 = 0 ;
  gp_Ax3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetDisplacement((gp_Ax3 const &)*arg2,(gp_Ax3 const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_SetDisplacement\n  * wrapname: _wrap_gp_Trsf_SetDisplacement\n  * fulldecl: void gp_Trsf::SetDisplacement(gp_Ax3 const &,gp_Ax3 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf_SetTransformation__SWIG_0 (gp_Trsf *larg1, gp_Ax3 *larg2, gp_Ax3 *larg3) {
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  gp_Ax3 *arg2 = 0 ;
  gp_Ax3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetTransformation((gp_Ax3 const &)*arg2,(gp_Ax3 const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_SetTransformation\n  * wrapname: _wrap_gp_Trsf_SetTransformation__SWIG_0\n  * fulldecl: void gp_Trsf::SetTransformation(gp_Ax3 const &,gp_Ax3 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf_SetTransformation__SWIG_1 (gp_Trsf *larg1, gp_Ax3 *larg2) {
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  gp_Ax3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetTransformation((gp_Ax3 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_SetTransformation\n  * wrapname: _wrap_gp_Trsf_SetTransformation__SWIG_1\n  * fulldecl: void gp_Trsf::SetTransformation(gp_Ax3 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf_SetTransformation__SWIG_2 (gp_Trsf *larg1, gp_Quaternion *larg2, gp_Vec *larg3) {
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  gp_Quaternion *arg2 = 0 ;
  gp_Vec *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetTransformation((gp_Quaternion const &)*arg2,(gp_Vec const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_SetTransformation\n  * wrapname: _wrap_gp_Trsf_SetTransformation__SWIG_2\n  * fulldecl: void gp_Trsf::SetTransformation(gp_Quaternion const &,gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf_SetTranslation__SWIG_0 (gp_Trsf *larg1, gp_Vec *larg2) {
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  gp_Vec *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetTranslation((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_SetTranslation\n  * wrapname: _wrap_gp_Trsf_SetTranslation__SWIG_0\n  * fulldecl: void gp_Trsf::SetTranslation(gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf_SetTranslation__SWIG_1 (gp_Trsf *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetTranslation((gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_SetTranslation\n  * wrapname: _wrap_gp_Trsf_SetTranslation__SWIG_1\n  * fulldecl: void gp_Trsf::SetTranslation(gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf_SetTranslationPart (gp_Trsf *larg1, gp_Vec *larg2) {
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  gp_Vec *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetTranslationPart((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_SetTranslationPart\n  * wrapname: _wrap_gp_Trsf_SetTranslationPart\n  * fulldecl: void gp_Trsf::SetTranslationPart(gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf_SetScaleFactor (gp_Trsf *larg1, Standard_Real larg2) {
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetScaleFactor(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_SetScaleFactor\n  * wrapname: _wrap_gp_Trsf_SetScaleFactor\n  * fulldecl: void gp_Trsf::SetScaleFactor(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf_SetForm (gp_Trsf *larg1, gp_TrsfForm larg2) {
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  gp_TrsfForm arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetForm(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_SetForm\n  * wrapname: _wrap_gp_Trsf_SetForm\n  * fulldecl: void gp_Trsf::SetForm(gp_TrsfForm const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf_SetValues (gp_Trsf *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5, Standard_Real larg6, Standard_Real larg7, Standard_Real larg8, Standard_Real larg9, Standard_Real larg10, Standard_Real larg11, Standard_Real larg12, Standard_Real larg13) {
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  Standard_Real arg6 ;
  Standard_Real arg7 ;
  Standard_Real arg8 ;
  Standard_Real arg9 ;
  Standard_Real arg10 ;
  Standard_Real arg11 ;
  Standard_Real arg12 ;
  Standard_Real arg13 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  arg11 = larg11;
  arg12 = larg12;
  arg13 = larg13;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetValues(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_SetValues\n  * wrapname: _wrap_gp_Trsf_SetValues\n  * fulldecl: void gp_Trsf::SetValues(Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_gp_Trsf_IsNegative (gp_Trsf *larg1) {
  bool lresult = (bool)0 ;
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Trsf const *)arg1)->IsNegative();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_IsNegative\n  * wrapname: _wrap_gp_Trsf_IsNegative\n  * fulldecl: Standard_Boolean gp_Trsf::IsNegative() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT gp_TrsfForm _wrap_gp_Trsf_Form (gp_Trsf *larg1) {
  gp_TrsfForm lresult = (gp_TrsfForm)0 ;
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  gp_TrsfForm result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_TrsfForm)((gp_Trsf const *)arg1)->Form();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_Form\n  * wrapname: _wrap_gp_Trsf_Form\n  * fulldecl: gp_TrsfForm gp_Trsf::Form() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_TrsfForm)0;
  }
}


EXPORT Standard_Real _wrap_gp_Trsf_ScaleFactor (gp_Trsf *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Trsf const *)arg1)->ScaleFactor();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_ScaleFactor\n  * wrapname: _wrap_gp_Trsf_ScaleFactor\n  * fulldecl: Standard_Real gp_Trsf::ScaleFactor() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_XYZ *_wrap_gp_Trsf_TranslationPart (gp_Trsf *larg1) {
  gp_XYZ * lresult = (gp_XYZ *)0 ;
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  gp_XYZ *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_XYZ *) &((gp_Trsf const *)arg1)->TranslationPart();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_TranslationPart\n  * wrapname: _wrap_gp_Trsf_TranslationPart\n  * fulldecl: gp_XYZ const & gp_Trsf::TranslationPart() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_XYZ *)0;
  }
}


EXPORT bool _wrap_gp_Trsf_GetRotation__SWIG_0 (gp_Trsf *larg1, gp_XYZ *larg2, Standard_Real *larg3) {
  bool lresult = (bool)0 ;
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  gp_XYZ *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Trsf const *)arg1)->GetRotation(*arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_GetRotation\n  * wrapname: _wrap_gp_Trsf_GetRotation__SWIG_0\n  * fulldecl: Standard_Boolean gp_Trsf::GetRotation(gp_XYZ &,Standard_Real &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT gp_Quaternion *_wrap_gp_Trsf_GetRotation__SWIG_1 (gp_Trsf *larg1) {
  gp_Quaternion * lresult = (gp_Quaternion *)0 ;
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  gp_Quaternion result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Trsf const *)arg1)->GetRotation();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_GetRotation\n  * wrapname: _wrap_gp_Trsf_GetRotation__SWIG_1\n  * fulldecl: gp_Quaternion gp_Trsf::GetRotation() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Quaternion(result);
    return lresult;
  } catch (...) {
    return (gp_Quaternion *)0;
  }
}


EXPORT gp_Mat *_wrap_gp_Trsf_VectorialPart (gp_Trsf *larg1) {
  gp_Mat * lresult = (gp_Mat *)0 ;
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  gp_Mat result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Trsf const *)arg1)->VectorialPart();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_VectorialPart\n  * wrapname: _wrap_gp_Trsf_VectorialPart\n  * fulldecl: gp_Mat gp_Trsf::VectorialPart() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Mat(result);
    return lresult;
  } catch (...) {
    return (gp_Mat *)0;
  }
}


EXPORT gp_Mat *_wrap_gp_Trsf_HVectorialPart (gp_Trsf *larg1) {
  gp_Mat * lresult = (gp_Mat *)0 ;
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  gp_Mat *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Mat *) &((gp_Trsf const *)arg1)->HVectorialPart();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_HVectorialPart\n  * wrapname: _wrap_gp_Trsf_HVectorialPart\n  * fulldecl: gp_Mat & gp_Trsf::HVectorialPart() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Mat *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Trsf_Value (gp_Trsf *larg1, Standard_Integer larg2, Standard_Integer larg3) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Trsf const *)arg1)->Value(arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_Value\n  * wrapname: _wrap_gp_Trsf_Value\n  * fulldecl: Standard_Real gp_Trsf::Value(Standard_Integer const,Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_gp_Trsf_Invert (gp_Trsf *larg1) {
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Invert();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_Invert\n  * wrapname: _wrap_gp_Trsf_Invert\n  * fulldecl: void gp_Trsf::Invert()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Trsf *_wrap_gp_Trsf_Inverted (gp_Trsf *larg1) {
  gp_Trsf * lresult = (gp_Trsf *)0 ;
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  gp_Trsf result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Trsf const *)arg1)->Inverted();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_Inverted\n  * wrapname: _wrap_gp_Trsf_Inverted\n  * fulldecl: gp_Trsf gp_Trsf::Inverted() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Trsf(result);
    return lresult;
  } catch (...) {
    return (gp_Trsf *)0;
  }
}


EXPORT gp_Trsf *_wrap_gp_Trsf_Multiplied (gp_Trsf *larg1, gp_Trsf *larg2) {
  gp_Trsf * lresult = (gp_Trsf *)0 ;
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  gp_Trsf *arg2 = 0 ;
  gp_Trsf result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Trsf const *)arg1)->Multiplied((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_Multiplied\n  * wrapname: _wrap_gp_Trsf_Multiplied\n  * fulldecl: gp_Trsf gp_Trsf::Multiplied(gp_Trsf const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Trsf(result);
    return lresult;
  } catch (...) {
    return (gp_Trsf *)0;
  }
}


EXPORT void _wrap_gp_Trsf_Multiply (gp_Trsf *larg1, gp_Trsf *larg2) {
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  gp_Trsf *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Multiply((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_Multiply\n  * wrapname: _wrap_gp_Trsf_Multiply\n  * fulldecl: void gp_Trsf::Multiply(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf_PreMultiply (gp_Trsf *larg1, gp_Trsf *larg2) {
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  gp_Trsf *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->PreMultiply((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_PreMultiply\n  * wrapname: _wrap_gp_Trsf_PreMultiply\n  * fulldecl: void gp_Trsf::PreMultiply(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf_Power (gp_Trsf *larg1, Standard_Integer larg2) {
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  Standard_Integer arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Power(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_Power\n  * wrapname: _wrap_gp_Trsf_Power\n  * fulldecl: void gp_Trsf::Power(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Trsf *_wrap_gp_Trsf_Powered (gp_Trsf *larg1, Standard_Integer larg2) {
  gp_Trsf * lresult = (gp_Trsf *)0 ;
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  Standard_Integer arg2 ;
  gp_Trsf result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Trsf const *)arg1)->Powered(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_Powered\n  * wrapname: _wrap_gp_Trsf_Powered\n  * fulldecl: gp_Trsf gp_Trsf::Powered(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Trsf(result);
    return lresult;
  } catch (...) {
    return (gp_Trsf *)0;
  }
}


EXPORT void _wrap_gp_Trsf_Transforms__SWIG_0 (gp_Trsf *larg1, Standard_Real *larg2, Standard_Real *larg3, Standard_Real *larg4) {
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((gp_Trsf const *)arg1)->Transforms(*arg2,*arg3,*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_Transforms\n  * wrapname: _wrap_gp_Trsf_Transforms__SWIG_0\n  * fulldecl: void gp_Trsf::Transforms(Standard_Real &,Standard_Real &,Standard_Real &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf_Transforms__SWIG_1 (gp_Trsf *larg1, gp_XYZ *larg2) {
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  gp_XYZ *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((gp_Trsf const *)arg1)->Transforms(*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_Transforms\n  * wrapname: _wrap_gp_Trsf_Transforms__SWIG_1\n  * fulldecl: void gp_Trsf::Transforms(gp_XYZ &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_gp_Trsf (gp_Trsf *larg1) {
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Trsf\n  * wrapname: _wrap_delete_gp_Trsf\n  * fulldecl: gp_Trsf::~gp_Trsf()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_TrsfNLerp *_wrap_new_gp_TrsfNLerp__SWIG_0 () {
  gp_TrsfNLerp * lresult = (gp_TrsfNLerp *)0 ;
  gp_TrsfNLerp *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_TrsfNLerp *)new gp_TrsfNLerp();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_TrsfNLerp\n  * wrapname: _wrap_new_gp_TrsfNLerp__SWIG_0\n  * fulldecl: gp_TrsfNLerp::gp_TrsfNLerp()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_TrsfNLerp *)0;
  }
}


EXPORT gp_TrsfNLerp *_wrap_new_gp_TrsfNLerp__SWIG_1 (gp_Trsf *larg1, gp_Trsf *larg2) {
  gp_TrsfNLerp * lresult = (gp_TrsfNLerp *)0 ;
  gp_Trsf *arg1 = 0 ;
  gp_Trsf *arg2 = 0 ;
  gp_TrsfNLerp *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_TrsfNLerp *)new gp_TrsfNLerp((gp_Trsf const &)*arg1,(gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_TrsfNLerp\n  * wrapname: _wrap_new_gp_TrsfNLerp__SWIG_1\n  * fulldecl: gp_TrsfNLerp::gp_TrsfNLerp(gp_Trsf const &,gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_TrsfNLerp *)0;
  }
}


EXPORT void _wrap_gp_TrsfNLerp_Init (gp_TrsfNLerp *larg1, gp_Trsf *larg2, gp_Trsf *larg3) {
  gp_TrsfNLerp *arg1 = (gp_TrsfNLerp *) 0 ;
  gp_Trsf *arg2 = 0 ;
  gp_Trsf *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init((gp_Trsf const &)*arg2,(gp_Trsf const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_TrsfNLerp_Init\n  * wrapname: _wrap_gp_TrsfNLerp_Init\n  * fulldecl: void gp_TrsfNLerp::Init(gp_Trsf const &,gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_TrsfNLerp_Interpolate (gp_TrsfNLerp *larg1, double larg2, gp_Trsf *larg3) {
  gp_TrsfNLerp *arg1 = (gp_TrsfNLerp *) 0 ;
  double arg2 ;
  gp_Trsf *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Interpolate(arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_TrsfNLerp_Interpolate\n  * wrapname: _wrap_gp_TrsfNLerp_Interpolate\n  * fulldecl: void gp_TrsfNLerp::Interpolate(double,gp_Trsf &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_gp_TrsfNLerp (gp_TrsfNLerp *larg1) {
  gp_TrsfNLerp *arg1 = (gp_TrsfNLerp *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_TrsfNLerp\n  * wrapname: _wrap_delete_gp_TrsfNLerp\n  * fulldecl: gp_TrsfNLerp::~gp_TrsfNLerp()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_GTrsf *_wrap_new_gp_GTrsf__SWIG_0 () {
  gp_GTrsf * lresult = (gp_GTrsf *)0 ;
  gp_GTrsf *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_GTrsf *)new gp_GTrsf();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_GTrsf\n  * wrapname: _wrap_new_gp_GTrsf__SWIG_0\n  * fulldecl: gp_GTrsf::gp_GTrsf()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_GTrsf *)0;
  }
}


EXPORT gp_GTrsf *_wrap_new_gp_GTrsf__SWIG_1 (gp_Trsf *larg1) {
  gp_GTrsf * lresult = (gp_GTrsf *)0 ;
  gp_Trsf *arg1 = 0 ;
  gp_GTrsf *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_GTrsf *)new gp_GTrsf((gp_Trsf const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_GTrsf\n  * wrapname: _wrap_new_gp_GTrsf__SWIG_1\n  * fulldecl: gp_GTrsf::gp_GTrsf(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_GTrsf *)0;
  }
}


EXPORT gp_GTrsf *_wrap_new_gp_GTrsf__SWIG_2 (gp_Mat *larg1, gp_XYZ *larg2) {
  gp_GTrsf * lresult = (gp_GTrsf *)0 ;
  gp_Mat *arg1 = 0 ;
  gp_XYZ *arg2 = 0 ;
  gp_GTrsf *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_GTrsf *)new gp_GTrsf((gp_Mat const &)*arg1,(gp_XYZ const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_GTrsf\n  * wrapname: _wrap_new_gp_GTrsf__SWIG_2\n  * fulldecl: gp_GTrsf::gp_GTrsf(gp_Mat const &,gp_XYZ const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_GTrsf *)0;
  }
}


EXPORT void _wrap_gp_GTrsf_SetAffinity__SWIG_0 (gp_GTrsf *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_GTrsf *arg1 = (gp_GTrsf *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetAffinity((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf_SetAffinity\n  * wrapname: _wrap_gp_GTrsf_SetAffinity__SWIG_0\n  * fulldecl: void gp_GTrsf::SetAffinity(gp_Ax1 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_GTrsf_SetAffinity__SWIG_1 (gp_GTrsf *larg1, gp_Ax2 *larg2, Standard_Real larg3) {
  gp_GTrsf *arg1 = (gp_GTrsf *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetAffinity((gp_Ax2 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf_SetAffinity\n  * wrapname: _wrap_gp_GTrsf_SetAffinity__SWIG_1\n  * fulldecl: void gp_GTrsf::SetAffinity(gp_Ax2 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_GTrsf_SetValue (gp_GTrsf *larg1, Standard_Integer larg2, Standard_Integer larg3, Standard_Real larg4) {
  gp_GTrsf *arg1 = (gp_GTrsf *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetValue(arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf_SetValue\n  * wrapname: _wrap_gp_GTrsf_SetValue\n  * fulldecl: void gp_GTrsf::SetValue(Standard_Integer const,Standard_Integer const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_GTrsf_SetVectorialPart (gp_GTrsf *larg1, gp_Mat *larg2) {
  gp_GTrsf *arg1 = (gp_GTrsf *) 0 ;
  gp_Mat *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetVectorialPart((gp_Mat const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf_SetVectorialPart\n  * wrapname: _wrap_gp_GTrsf_SetVectorialPart\n  * fulldecl: void gp_GTrsf::SetVectorialPart(gp_Mat const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_GTrsf_SetTranslationPart (gp_GTrsf *larg1, gp_XYZ *larg2) {
  gp_GTrsf *arg1 = (gp_GTrsf *) 0 ;
  gp_XYZ *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetTranslationPart((gp_XYZ const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf_SetTranslationPart\n  * wrapname: _wrap_gp_GTrsf_SetTranslationPart\n  * fulldecl: void gp_GTrsf::SetTranslationPart(gp_XYZ const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_GTrsf_SetTrsf (gp_GTrsf *larg1, gp_Trsf *larg2) {
  gp_GTrsf *arg1 = (gp_GTrsf *) 0 ;
  gp_Trsf *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetTrsf((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf_SetTrsf\n  * wrapname: _wrap_gp_GTrsf_SetTrsf\n  * fulldecl: void gp_GTrsf::SetTrsf(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_gp_GTrsf_IsNegative (gp_GTrsf *larg1) {
  bool lresult = (bool)0 ;
  gp_GTrsf *arg1 = (gp_GTrsf *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_GTrsf const *)arg1)->IsNegative();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf_IsNegative\n  * wrapname: _wrap_gp_GTrsf_IsNegative\n  * fulldecl: Standard_Boolean gp_GTrsf::IsNegative() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_gp_GTrsf_IsSingular (gp_GTrsf *larg1) {
  bool lresult = (bool)0 ;
  gp_GTrsf *arg1 = (gp_GTrsf *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_GTrsf const *)arg1)->IsSingular();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf_IsSingular\n  * wrapname: _wrap_gp_GTrsf_IsSingular\n  * fulldecl: Standard_Boolean gp_GTrsf::IsSingular() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT gp_TrsfForm _wrap_gp_GTrsf_Form (gp_GTrsf *larg1) {
  gp_TrsfForm lresult = (gp_TrsfForm)0 ;
  gp_GTrsf *arg1 = (gp_GTrsf *) 0 ;
  gp_TrsfForm result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_TrsfForm)((gp_GTrsf const *)arg1)->Form();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf_Form\n  * wrapname: _wrap_gp_GTrsf_Form\n  * fulldecl: gp_TrsfForm gp_GTrsf::Form() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_TrsfForm)0;
  }
}


EXPORT void _wrap_gp_GTrsf_SetForm (gp_GTrsf *larg1) {
  gp_GTrsf *arg1 = (gp_GTrsf *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetForm();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf_SetForm\n  * wrapname: _wrap_gp_GTrsf_SetForm\n  * fulldecl: void gp_GTrsf::SetForm()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_XYZ *_wrap_gp_GTrsf_TranslationPart (gp_GTrsf *larg1) {
  gp_XYZ * lresult = (gp_XYZ *)0 ;
  gp_GTrsf *arg1 = (gp_GTrsf *) 0 ;
  gp_XYZ *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_XYZ *) &((gp_GTrsf const *)arg1)->TranslationPart();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf_TranslationPart\n  * wrapname: _wrap_gp_GTrsf_TranslationPart\n  * fulldecl: gp_XYZ const & gp_GTrsf::TranslationPart() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_XYZ *)0;
  }
}


EXPORT gp_Mat *_wrap_gp_GTrsf_VectorialPart (gp_GTrsf *larg1) {
  gp_Mat * lresult = (gp_Mat *)0 ;
  gp_GTrsf *arg1 = (gp_GTrsf *) 0 ;
  gp_Mat *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Mat *) &((gp_GTrsf const *)arg1)->VectorialPart();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf_VectorialPart\n  * wrapname: _wrap_gp_GTrsf_VectorialPart\n  * fulldecl: gp_Mat const & gp_GTrsf::VectorialPart() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Mat *)0;
  }
}


EXPORT Standard_Real _wrap_gp_GTrsf_Value (gp_GTrsf *larg1, Standard_Integer larg2, Standard_Integer larg3) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_GTrsf *arg1 = (gp_GTrsf *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_GTrsf const *)arg1)->Value(arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf_Value\n  * wrapname: _wrap_gp_GTrsf_Value\n  * fulldecl: Standard_Real gp_GTrsf::Value(Standard_Integer const,Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_gp_GTrsf_Invert (gp_GTrsf *larg1) {
  gp_GTrsf *arg1 = (gp_GTrsf *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Invert();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf_Invert\n  * wrapname: _wrap_gp_GTrsf_Invert\n  * fulldecl: void gp_GTrsf::Invert()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_GTrsf *_wrap_gp_GTrsf_Inverted (gp_GTrsf *larg1) {
  gp_GTrsf * lresult = (gp_GTrsf *)0 ;
  gp_GTrsf *arg1 = (gp_GTrsf *) 0 ;
  gp_GTrsf result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_GTrsf const *)arg1)->Inverted();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf_Inverted\n  * wrapname: _wrap_gp_GTrsf_Inverted\n  * fulldecl: gp_GTrsf gp_GTrsf::Inverted() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_GTrsf(result);
    return lresult;
  } catch (...) {
    return (gp_GTrsf *)0;
  }
}


EXPORT gp_GTrsf *_wrap_gp_GTrsf_Multiplied (gp_GTrsf *larg1, gp_GTrsf *larg2) {
  gp_GTrsf * lresult = (gp_GTrsf *)0 ;
  gp_GTrsf *arg1 = (gp_GTrsf *) 0 ;
  gp_GTrsf *arg2 = 0 ;
  gp_GTrsf result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_GTrsf const *)arg1)->Multiplied((gp_GTrsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf_Multiplied\n  * wrapname: _wrap_gp_GTrsf_Multiplied\n  * fulldecl: gp_GTrsf gp_GTrsf::Multiplied(gp_GTrsf const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_GTrsf(result);
    return lresult;
  } catch (...) {
    return (gp_GTrsf *)0;
  }
}


EXPORT void _wrap_gp_GTrsf_Multiply (gp_GTrsf *larg1, gp_GTrsf *larg2) {
  gp_GTrsf *arg1 = (gp_GTrsf *) 0 ;
  gp_GTrsf *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Multiply((gp_GTrsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf_Multiply\n  * wrapname: _wrap_gp_GTrsf_Multiply\n  * fulldecl: void gp_GTrsf::Multiply(gp_GTrsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_GTrsf_PreMultiply (gp_GTrsf *larg1, gp_GTrsf *larg2) {
  gp_GTrsf *arg1 = (gp_GTrsf *) 0 ;
  gp_GTrsf *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->PreMultiply((gp_GTrsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf_PreMultiply\n  * wrapname: _wrap_gp_GTrsf_PreMultiply\n  * fulldecl: void gp_GTrsf::PreMultiply(gp_GTrsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_GTrsf_Power (gp_GTrsf *larg1, Standard_Integer larg2) {
  gp_GTrsf *arg1 = (gp_GTrsf *) 0 ;
  Standard_Integer arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Power(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf_Power\n  * wrapname: _wrap_gp_GTrsf_Power\n  * fulldecl: void gp_GTrsf::Power(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_GTrsf *_wrap_gp_GTrsf_Powered (gp_GTrsf *larg1, Standard_Integer larg2) {
  gp_GTrsf * lresult = (gp_GTrsf *)0 ;
  gp_GTrsf *arg1 = (gp_GTrsf *) 0 ;
  Standard_Integer arg2 ;
  gp_GTrsf result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_GTrsf const *)arg1)->Powered(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf_Powered\n  * wrapname: _wrap_gp_GTrsf_Powered\n  * fulldecl: gp_GTrsf gp_GTrsf::Powered(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_GTrsf(result);
    return lresult;
  } catch (...) {
    return (gp_GTrsf *)0;
  }
}


EXPORT void _wrap_gp_GTrsf_Transforms__SWIG_0 (gp_GTrsf *larg1, gp_XYZ *larg2) {
  gp_GTrsf *arg1 = (gp_GTrsf *) 0 ;
  gp_XYZ *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((gp_GTrsf const *)arg1)->Transforms(*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf_Transforms\n  * wrapname: _wrap_gp_GTrsf_Transforms__SWIG_0\n  * fulldecl: void gp_GTrsf::Transforms(gp_XYZ &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_GTrsf_Transforms__SWIG_1 (gp_GTrsf *larg1, Standard_Real *larg2, Standard_Real *larg3, Standard_Real *larg4) {
  gp_GTrsf *arg1 = (gp_GTrsf *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((gp_GTrsf const *)arg1)->Transforms(*arg2,*arg3,*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf_Transforms\n  * wrapname: _wrap_gp_GTrsf_Transforms__SWIG_1\n  * fulldecl: void gp_GTrsf::Transforms(Standard_Real &,Standard_Real &,Standard_Real &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Trsf *_wrap_gp_GTrsf_Trsf (gp_GTrsf *larg1) {
  gp_Trsf * lresult = (gp_Trsf *)0 ;
  gp_GTrsf *arg1 = (gp_GTrsf *) 0 ;
  gp_Trsf result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_GTrsf const *)arg1)->Trsf();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_GTrsf_Trsf\n  * wrapname: _wrap_gp_GTrsf_Trsf\n  * fulldecl: gp_Trsf gp_GTrsf::Trsf() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Trsf(result);
    return lresult;
  } catch (...) {
    return (gp_Trsf *)0;
  }
}


EXPORT void _wrap_delete_gp_GTrsf (gp_GTrsf *larg1) {
  gp_GTrsf *arg1 = (gp_GTrsf *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_GTrsf\n  * wrapname: _wrap_delete_gp_GTrsf\n  * fulldecl: gp_GTrsf::~gp_GTrsf()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Circ *_wrap_new_gp_Circ__SWIG_0 () {
  gp_Circ * lresult = (gp_Circ *)0 ;
  gp_Circ *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Circ *)new gp_Circ();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Circ\n  * wrapname: _wrap_new_gp_Circ__SWIG_0\n  * fulldecl: gp_Circ::gp_Circ()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Circ *)0;
  }
}


EXPORT gp_Circ *_wrap_new_gp_Circ__SWIG_1 (gp_Ax2 *larg1, Standard_Real larg2) {
  gp_Circ * lresult = (gp_Circ *)0 ;
  gp_Ax2 *arg1 = 0 ;
  Standard_Real arg2 ;
  gp_Circ *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Circ *)new gp_Circ((gp_Ax2 const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Circ\n  * wrapname: _wrap_new_gp_Circ__SWIG_1\n  * fulldecl: gp_Circ::gp_Circ(gp_Ax2 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Circ *)0;
  }
}


EXPORT void _wrap_gp_Circ_SetAxis (gp_Circ *larg1, gp_Ax1 *larg2) {
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetAxis((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_SetAxis\n  * wrapname: _wrap_gp_Circ_SetAxis\n  * fulldecl: void gp_Circ::SetAxis(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Circ_SetLocation (gp_Circ *larg1, gp_Pnt *larg2) {
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLocation((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_SetLocation\n  * wrapname: _wrap_gp_Circ_SetLocation\n  * fulldecl: void gp_Circ::SetLocation(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Circ_SetPosition (gp_Circ *larg1, gp_Ax2 *larg2) {
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetPosition((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_SetPosition\n  * wrapname: _wrap_gp_Circ_SetPosition\n  * fulldecl: void gp_Circ::SetPosition(gp_Ax2 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Circ_SetRadius (gp_Circ *larg1, Standard_Real larg2) {
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetRadius(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_SetRadius\n  * wrapname: _wrap_gp_Circ_SetRadius\n  * fulldecl: void gp_Circ::SetRadius(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Real _wrap_gp_Circ_Area (gp_Circ *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Circ const *)arg1)->Area();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_Area\n  * wrapname: _wrap_gp_Circ_Area\n  * fulldecl: Standard_Real gp_Circ::Area() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Circ_Axis (gp_Circ *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  gp_Ax1 *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax1 *) &((gp_Circ const *)arg1)->Axis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_Axis\n  * wrapname: _wrap_gp_Circ_Axis\n  * fulldecl: gp_Ax1 const & gp_Circ::Axis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Circ_Length (gp_Circ *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Circ const *)arg1)->Length();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_Length\n  * wrapname: _wrap_gp_Circ_Length\n  * fulldecl: Standard_Real gp_Circ::Length() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Pnt *_wrap_gp_Circ_Location (gp_Circ *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  gp_Pnt *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt *) &((gp_Circ const *)arg1)->Location();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_Location\n  * wrapname: _wrap_gp_Circ_Location\n  * fulldecl: gp_Pnt const & gp_Circ::Location() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT gp_Ax2 *_wrap_gp_Circ_Position (gp_Circ *larg1) {
  gp_Ax2 * lresult = (gp_Ax2 *)0 ;
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  gp_Ax2 *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax2 *) &((gp_Circ const *)arg1)->Position();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_Position\n  * wrapname: _wrap_gp_Circ_Position\n  * fulldecl: gp_Ax2 const & gp_Circ::Position() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax2 *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Circ_Radius (gp_Circ *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Circ const *)arg1)->Radius();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_Radius\n  * wrapname: _wrap_gp_Circ_Radius\n  * fulldecl: Standard_Real gp_Circ::Radius() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Circ_XAxis (gp_Circ *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Circ const *)arg1)->XAxis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_XAxis\n  * wrapname: _wrap_gp_Circ_XAxis\n  * fulldecl: gp_Ax1 gp_Circ::XAxis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Circ_YAxis (gp_Circ *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Circ const *)arg1)->YAxis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_YAxis\n  * wrapname: _wrap_gp_Circ_YAxis\n  * fulldecl: gp_Ax1 gp_Circ::YAxis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Circ_Distance (gp_Circ *larg1, gp_Pnt *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Circ const *)arg1)->Distance((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_Distance\n  * wrapname: _wrap_gp_Circ_Distance\n  * fulldecl: Standard_Real gp_Circ::Distance(gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Circ_SquareDistance (gp_Circ *larg1, gp_Pnt *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Circ const *)arg1)->SquareDistance((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_SquareDistance\n  * wrapname: _wrap_gp_Circ_SquareDistance\n  * fulldecl: Standard_Real gp_Circ::SquareDistance(gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT bool _wrap_gp_Circ_Contains (gp_Circ *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Circ const *)arg1)->Contains((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_Contains\n  * wrapname: _wrap_gp_Circ_Contains\n  * fulldecl: Standard_Boolean gp_Circ::Contains(gp_Pnt const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_gp_Circ_Mirror__SWIG_0 (gp_Circ *larg1, gp_Pnt *larg2) {
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_Mirror\n  * wrapname: _wrap_gp_Circ_Mirror__SWIG_0\n  * fulldecl: void gp_Circ::Mirror(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Circ *_wrap_gp_Circ_Mirrored__SWIG_0 (gp_Circ *larg1, gp_Pnt *larg2) {
  gp_Circ * lresult = (gp_Circ *)0 ;
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Circ result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Circ const *)arg1)->Mirrored((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_Mirrored\n  * wrapname: _wrap_gp_Circ_Mirrored__SWIG_0\n  * fulldecl: gp_Circ gp_Circ::Mirrored(gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Circ(result);
    return lresult;
  } catch (...) {
    return (gp_Circ *)0;
  }
}


EXPORT void _wrap_gp_Circ_Mirror__SWIG_1 (gp_Circ *larg1, gp_Ax1 *larg2) {
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_Mirror\n  * wrapname: _wrap_gp_Circ_Mirror__SWIG_1\n  * fulldecl: void gp_Circ::Mirror(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Circ *_wrap_gp_Circ_Mirrored__SWIG_1 (gp_Circ *larg1, gp_Ax1 *larg2) {
  gp_Circ * lresult = (gp_Circ *)0 ;
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  gp_Circ result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Circ const *)arg1)->Mirrored((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_Mirrored\n  * wrapname: _wrap_gp_Circ_Mirrored__SWIG_1\n  * fulldecl: gp_Circ gp_Circ::Mirrored(gp_Ax1 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Circ(result);
    return lresult;
  } catch (...) {
    return (gp_Circ *)0;
  }
}


EXPORT void _wrap_gp_Circ_Mirror__SWIG_2 (gp_Circ *larg1, gp_Ax2 *larg2) {
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_Mirror\n  * wrapname: _wrap_gp_Circ_Mirror__SWIG_2\n  * fulldecl: void gp_Circ::Mirror(gp_Ax2 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Circ *_wrap_gp_Circ_Mirrored__SWIG_2 (gp_Circ *larg1, gp_Ax2 *larg2) {
  gp_Circ * lresult = (gp_Circ *)0 ;
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  gp_Circ result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Circ const *)arg1)->Mirrored((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_Mirrored\n  * wrapname: _wrap_gp_Circ_Mirrored__SWIG_2\n  * fulldecl: gp_Circ gp_Circ::Mirrored(gp_Ax2 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Circ(result);
    return lresult;
  } catch (...) {
    return (gp_Circ *)0;
  }
}


EXPORT void _wrap_gp_Circ_Rotate (gp_Circ *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Rotate((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_Rotate\n  * wrapname: _wrap_gp_Circ_Rotate\n  * fulldecl: void gp_Circ::Rotate(gp_Ax1 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Circ *_wrap_gp_Circ_Rotated (gp_Circ *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Circ * lresult = (gp_Circ *)0 ;
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Circ result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Circ const *)arg1)->Rotated((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_Rotated\n  * wrapname: _wrap_gp_Circ_Rotated\n  * fulldecl: gp_Circ gp_Circ::Rotated(gp_Ax1 const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Circ(result);
    return lresult;
  } catch (...) {
    return (gp_Circ *)0;
  }
}


EXPORT void _wrap_gp_Circ_Scale (gp_Circ *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Scale((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_Scale\n  * wrapname: _wrap_gp_Circ_Scale\n  * fulldecl: void gp_Circ::Scale(gp_Pnt const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Circ *_wrap_gp_Circ_Scaled (gp_Circ *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  gp_Circ * lresult = (gp_Circ *)0 ;
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Circ result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Circ const *)arg1)->Scaled((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_Scaled\n  * wrapname: _wrap_gp_Circ_Scaled\n  * fulldecl: gp_Circ gp_Circ::Scaled(gp_Pnt const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Circ(result);
    return lresult;
  } catch (...) {
    return (gp_Circ *)0;
  }
}


EXPORT void _wrap_gp_Circ_Transform (gp_Circ *larg1, gp_Trsf *larg2) {
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  gp_Trsf *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Transform((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_Transform\n  * wrapname: _wrap_gp_Circ_Transform\n  * fulldecl: void gp_Circ::Transform(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Circ *_wrap_gp_Circ_Transformed (gp_Circ *larg1, gp_Trsf *larg2) {
  gp_Circ * lresult = (gp_Circ *)0 ;
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  gp_Trsf *arg2 = 0 ;
  gp_Circ result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Circ const *)arg1)->Transformed((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_Transformed\n  * wrapname: _wrap_gp_Circ_Transformed\n  * fulldecl: gp_Circ gp_Circ::Transformed(gp_Trsf const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Circ(result);
    return lresult;
  } catch (...) {
    return (gp_Circ *)0;
  }
}


EXPORT void _wrap_gp_Circ_Translate__SWIG_0 (gp_Circ *larg1, gp_Vec *larg2) {
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  gp_Vec *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_Translate\n  * wrapname: _wrap_gp_Circ_Translate__SWIG_0\n  * fulldecl: void gp_Circ::Translate(gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Circ *_wrap_gp_Circ_Translated__SWIG_0 (gp_Circ *larg1, gp_Vec *larg2) {
  gp_Circ * lresult = (gp_Circ *)0 ;
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  gp_Vec *arg2 = 0 ;
  gp_Circ result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Circ const *)arg1)->Translated((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_Translated\n  * wrapname: _wrap_gp_Circ_Translated__SWIG_0\n  * fulldecl: gp_Circ gp_Circ::Translated(gp_Vec const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Circ(result);
    return lresult;
  } catch (...) {
    return (gp_Circ *)0;
  }
}


EXPORT void _wrap_gp_Circ_Translate__SWIG_1 (gp_Circ *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_Translate\n  * wrapname: _wrap_gp_Circ_Translate__SWIG_1\n  * fulldecl: void gp_Circ::Translate(gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Circ *_wrap_gp_Circ_Translated__SWIG_1 (gp_Circ *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  gp_Circ * lresult = (gp_Circ *)0 ;
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  gp_Circ result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Circ const *)arg1)->Translated((gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Circ_Translated\n  * wrapname: _wrap_gp_Circ_Translated__SWIG_1\n  * fulldecl: gp_Circ gp_Circ::Translated(gp_Pnt const &,gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Circ(result);
    return lresult;
  } catch (...) {
    return (gp_Circ *)0;
  }
}


EXPORT void _wrap_delete_gp_Circ (gp_Circ *larg1) {
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Circ\n  * wrapname: _wrap_delete_gp_Circ\n  * fulldecl: gp_Circ::~gp_Circ()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Elips *_wrap_new_gp_Elips__SWIG_0 () {
  gp_Elips * lresult = (gp_Elips *)0 ;
  gp_Elips *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Elips *)new gp_Elips();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Elips\n  * wrapname: _wrap_new_gp_Elips__SWIG_0\n  * fulldecl: gp_Elips::gp_Elips()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Elips *)0;
  }
}


EXPORT gp_Elips *_wrap_new_gp_Elips__SWIG_1 (gp_Ax2 *larg1, Standard_Real larg2, Standard_Real larg3) {
  gp_Elips * lresult = (gp_Elips *)0 ;
  gp_Ax2 *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  gp_Elips *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Elips *)new gp_Elips((gp_Ax2 const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Elips\n  * wrapname: _wrap_new_gp_Elips__SWIG_1\n  * fulldecl: gp_Elips::gp_Elips(gp_Ax2 const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Elips *)0;
  }
}


EXPORT void _wrap_gp_Elips_SetAxis (gp_Elips *larg1, gp_Ax1 *larg2) {
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetAxis((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_SetAxis\n  * wrapname: _wrap_gp_Elips_SetAxis\n  * fulldecl: void gp_Elips::SetAxis(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Elips_SetLocation (gp_Elips *larg1, gp_Pnt *larg2) {
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLocation((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_SetLocation\n  * wrapname: _wrap_gp_Elips_SetLocation\n  * fulldecl: void gp_Elips::SetLocation(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Elips_SetMajorRadius (gp_Elips *larg1, Standard_Real larg2) {
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetMajorRadius(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_SetMajorRadius\n  * wrapname: _wrap_gp_Elips_SetMajorRadius\n  * fulldecl: void gp_Elips::SetMajorRadius(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Elips_SetMinorRadius (gp_Elips *larg1, Standard_Real larg2) {
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetMinorRadius(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_SetMinorRadius\n  * wrapname: _wrap_gp_Elips_SetMinorRadius\n  * fulldecl: void gp_Elips::SetMinorRadius(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Elips_SetPosition (gp_Elips *larg1, gp_Ax2 *larg2) {
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetPosition((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_SetPosition\n  * wrapname: _wrap_gp_Elips_SetPosition\n  * fulldecl: void gp_Elips::SetPosition(gp_Ax2 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Real _wrap_gp_Elips_Area (gp_Elips *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Elips const *)arg1)->Area();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_Area\n  * wrapname: _wrap_gp_Elips_Area\n  * fulldecl: Standard_Real gp_Elips::Area() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Elips_Axis (gp_Elips *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  gp_Ax1 *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax1 *) &((gp_Elips const *)arg1)->Axis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_Axis\n  * wrapname: _wrap_gp_Elips_Axis\n  * fulldecl: gp_Ax1 const & gp_Elips::Axis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Elips_Directrix1 (gp_Elips *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Elips const *)arg1)->Directrix1();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_Directrix1\n  * wrapname: _wrap_gp_Elips_Directrix1\n  * fulldecl: gp_Ax1 gp_Elips::Directrix1() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Elips_Directrix2 (gp_Elips *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Elips const *)arg1)->Directrix2();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_Directrix2\n  * wrapname: _wrap_gp_Elips_Directrix2\n  * fulldecl: gp_Ax1 gp_Elips::Directrix2() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Elips_Eccentricity (gp_Elips *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Elips const *)arg1)->Eccentricity();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_Eccentricity\n  * wrapname: _wrap_gp_Elips_Eccentricity\n  * fulldecl: Standard_Real gp_Elips::Eccentricity() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Elips_Focal (gp_Elips *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Elips const *)arg1)->Focal();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_Focal\n  * wrapname: _wrap_gp_Elips_Focal\n  * fulldecl: Standard_Real gp_Elips::Focal() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Pnt *_wrap_gp_Elips_Focus1 (gp_Elips *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Elips const *)arg1)->Focus1();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_Focus1\n  * wrapname: _wrap_gp_Elips_Focus1\n  * fulldecl: gp_Pnt gp_Elips::Focus1() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT gp_Pnt *_wrap_gp_Elips_Focus2 (gp_Elips *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Elips const *)arg1)->Focus2();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_Focus2\n  * wrapname: _wrap_gp_Elips_Focus2\n  * fulldecl: gp_Pnt gp_Elips::Focus2() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT gp_Pnt *_wrap_gp_Elips_Location (gp_Elips *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  gp_Pnt *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt *) &((gp_Elips const *)arg1)->Location();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_Location\n  * wrapname: _wrap_gp_Elips_Location\n  * fulldecl: gp_Pnt const & gp_Elips::Location() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Elips_MajorRadius (gp_Elips *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Elips const *)arg1)->MajorRadius();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_MajorRadius\n  * wrapname: _wrap_gp_Elips_MajorRadius\n  * fulldecl: Standard_Real gp_Elips::MajorRadius() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Elips_MinorRadius (gp_Elips *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Elips const *)arg1)->MinorRadius();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_MinorRadius\n  * wrapname: _wrap_gp_Elips_MinorRadius\n  * fulldecl: Standard_Real gp_Elips::MinorRadius() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Elips_Parameter (gp_Elips *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Elips const *)arg1)->Parameter();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_Parameter\n  * wrapname: _wrap_gp_Elips_Parameter\n  * fulldecl: Standard_Real gp_Elips::Parameter() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Ax2 *_wrap_gp_Elips_Position (gp_Elips *larg1) {
  gp_Ax2 * lresult = (gp_Ax2 *)0 ;
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  gp_Ax2 *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax2 *) &((gp_Elips const *)arg1)->Position();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_Position\n  * wrapname: _wrap_gp_Elips_Position\n  * fulldecl: gp_Ax2 const & gp_Elips::Position() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax2 *)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Elips_XAxis (gp_Elips *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Elips const *)arg1)->XAxis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_XAxis\n  * wrapname: _wrap_gp_Elips_XAxis\n  * fulldecl: gp_Ax1 gp_Elips::XAxis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Elips_YAxis (gp_Elips *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Elips const *)arg1)->YAxis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_YAxis\n  * wrapname: _wrap_gp_Elips_YAxis\n  * fulldecl: gp_Ax1 gp_Elips::YAxis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT void _wrap_gp_Elips_Mirror__SWIG_0 (gp_Elips *larg1, gp_Pnt *larg2) {
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_Mirror\n  * wrapname: _wrap_gp_Elips_Mirror__SWIG_0\n  * fulldecl: void gp_Elips::Mirror(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Elips *_wrap_gp_Elips_Mirrored__SWIG_0 (gp_Elips *larg1, gp_Pnt *larg2) {
  gp_Elips * lresult = (gp_Elips *)0 ;
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Elips result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Elips const *)arg1)->Mirrored((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_Mirrored\n  * wrapname: _wrap_gp_Elips_Mirrored__SWIG_0\n  * fulldecl: gp_Elips gp_Elips::Mirrored(gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Elips(result);
    return lresult;
  } catch (...) {
    return (gp_Elips *)0;
  }
}


EXPORT void _wrap_gp_Elips_Mirror__SWIG_1 (gp_Elips *larg1, gp_Ax1 *larg2) {
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_Mirror\n  * wrapname: _wrap_gp_Elips_Mirror__SWIG_1\n  * fulldecl: void gp_Elips::Mirror(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Elips *_wrap_gp_Elips_Mirrored__SWIG_1 (gp_Elips *larg1, gp_Ax1 *larg2) {
  gp_Elips * lresult = (gp_Elips *)0 ;
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  gp_Elips result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Elips const *)arg1)->Mirrored((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_Mirrored\n  * wrapname: _wrap_gp_Elips_Mirrored__SWIG_1\n  * fulldecl: gp_Elips gp_Elips::Mirrored(gp_Ax1 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Elips(result);
    return lresult;
  } catch (...) {
    return (gp_Elips *)0;
  }
}


EXPORT void _wrap_gp_Elips_Mirror__SWIG_2 (gp_Elips *larg1, gp_Ax2 *larg2) {
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_Mirror\n  * wrapname: _wrap_gp_Elips_Mirror__SWIG_2\n  * fulldecl: void gp_Elips::Mirror(gp_Ax2 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Elips *_wrap_gp_Elips_Mirrored__SWIG_2 (gp_Elips *larg1, gp_Ax2 *larg2) {
  gp_Elips * lresult = (gp_Elips *)0 ;
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  gp_Elips result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Elips const *)arg1)->Mirrored((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_Mirrored\n  * wrapname: _wrap_gp_Elips_Mirrored__SWIG_2\n  * fulldecl: gp_Elips gp_Elips::Mirrored(gp_Ax2 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Elips(result);
    return lresult;
  } catch (...) {
    return (gp_Elips *)0;
  }
}


EXPORT void _wrap_gp_Elips_Rotate (gp_Elips *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Rotate((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_Rotate\n  * wrapname: _wrap_gp_Elips_Rotate\n  * fulldecl: void gp_Elips::Rotate(gp_Ax1 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Elips *_wrap_gp_Elips_Rotated (gp_Elips *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Elips * lresult = (gp_Elips *)0 ;
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Elips result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Elips const *)arg1)->Rotated((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_Rotated\n  * wrapname: _wrap_gp_Elips_Rotated\n  * fulldecl: gp_Elips gp_Elips::Rotated(gp_Ax1 const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Elips(result);
    return lresult;
  } catch (...) {
    return (gp_Elips *)0;
  }
}


EXPORT void _wrap_gp_Elips_Scale (gp_Elips *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Scale((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_Scale\n  * wrapname: _wrap_gp_Elips_Scale\n  * fulldecl: void gp_Elips::Scale(gp_Pnt const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Elips *_wrap_gp_Elips_Scaled (gp_Elips *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  gp_Elips * lresult = (gp_Elips *)0 ;
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Elips result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Elips const *)arg1)->Scaled((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_Scaled\n  * wrapname: _wrap_gp_Elips_Scaled\n  * fulldecl: gp_Elips gp_Elips::Scaled(gp_Pnt const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Elips(result);
    return lresult;
  } catch (...) {
    return (gp_Elips *)0;
  }
}


EXPORT void _wrap_gp_Elips_Transform (gp_Elips *larg1, gp_Trsf *larg2) {
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  gp_Trsf *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Transform((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_Transform\n  * wrapname: _wrap_gp_Elips_Transform\n  * fulldecl: void gp_Elips::Transform(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Elips *_wrap_gp_Elips_Transformed (gp_Elips *larg1, gp_Trsf *larg2) {
  gp_Elips * lresult = (gp_Elips *)0 ;
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  gp_Trsf *arg2 = 0 ;
  gp_Elips result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Elips const *)arg1)->Transformed((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_Transformed\n  * wrapname: _wrap_gp_Elips_Transformed\n  * fulldecl: gp_Elips gp_Elips::Transformed(gp_Trsf const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Elips(result);
    return lresult;
  } catch (...) {
    return (gp_Elips *)0;
  }
}


EXPORT void _wrap_gp_Elips_Translate__SWIG_0 (gp_Elips *larg1, gp_Vec *larg2) {
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  gp_Vec *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_Translate\n  * wrapname: _wrap_gp_Elips_Translate__SWIG_0\n  * fulldecl: void gp_Elips::Translate(gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Elips *_wrap_gp_Elips_Translated__SWIG_0 (gp_Elips *larg1, gp_Vec *larg2) {
  gp_Elips * lresult = (gp_Elips *)0 ;
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  gp_Vec *arg2 = 0 ;
  gp_Elips result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Elips const *)arg1)->Translated((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_Translated\n  * wrapname: _wrap_gp_Elips_Translated__SWIG_0\n  * fulldecl: gp_Elips gp_Elips::Translated(gp_Vec const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Elips(result);
    return lresult;
  } catch (...) {
    return (gp_Elips *)0;
  }
}


EXPORT void _wrap_gp_Elips_Translate__SWIG_1 (gp_Elips *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_Translate\n  * wrapname: _wrap_gp_Elips_Translate__SWIG_1\n  * fulldecl: void gp_Elips::Translate(gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Elips *_wrap_gp_Elips_Translated__SWIG_1 (gp_Elips *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  gp_Elips * lresult = (gp_Elips *)0 ;
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  gp_Elips result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Elips const *)arg1)->Translated((gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Elips_Translated\n  * wrapname: _wrap_gp_Elips_Translated__SWIG_1\n  * fulldecl: gp_Elips gp_Elips::Translated(gp_Pnt const &,gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Elips(result);
    return lresult;
  } catch (...) {
    return (gp_Elips *)0;
  }
}


EXPORT void _wrap_delete_gp_Elips (gp_Elips *larg1) {
  gp_Elips *arg1 = (gp_Elips *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Elips\n  * wrapname: _wrap_delete_gp_Elips\n  * fulldecl: gp_Elips::~gp_Elips()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Cone *_wrap_new_gp_Cone__SWIG_0 () {
  gp_Cone * lresult = (gp_Cone *)0 ;
  gp_Cone *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Cone *)new gp_Cone();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Cone\n  * wrapname: _wrap_new_gp_Cone__SWIG_0\n  * fulldecl: gp_Cone::gp_Cone()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Cone *)0;
  }
}


EXPORT gp_Cone *_wrap_new_gp_Cone__SWIG_1 (gp_Ax3 *larg1, Standard_Real larg2, Standard_Real larg3) {
  gp_Cone * lresult = (gp_Cone *)0 ;
  gp_Ax3 *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  gp_Cone *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Cone *)new gp_Cone((gp_Ax3 const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Cone\n  * wrapname: _wrap_new_gp_Cone__SWIG_1\n  * fulldecl: gp_Cone::gp_Cone(gp_Ax3 const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Cone *)0;
  }
}


EXPORT void _wrap_gp_Cone_SetAxis (gp_Cone *larg1, gp_Ax1 *larg2) {
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetAxis((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_SetAxis\n  * wrapname: _wrap_gp_Cone_SetAxis\n  * fulldecl: void gp_Cone::SetAxis(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Cone_SetLocation (gp_Cone *larg1, gp_Pnt *larg2) {
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLocation((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_SetLocation\n  * wrapname: _wrap_gp_Cone_SetLocation\n  * fulldecl: void gp_Cone::SetLocation(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Cone_SetPosition (gp_Cone *larg1, gp_Ax3 *larg2) {
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  gp_Ax3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetPosition((gp_Ax3 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_SetPosition\n  * wrapname: _wrap_gp_Cone_SetPosition\n  * fulldecl: void gp_Cone::SetPosition(gp_Ax3 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Cone_SetRadius (gp_Cone *larg1, Standard_Real larg2) {
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetRadius(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_SetRadius\n  * wrapname: _wrap_gp_Cone_SetRadius\n  * fulldecl: void gp_Cone::SetRadius(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Cone_SetSemiAngle (gp_Cone *larg1, Standard_Real larg2) {
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetSemiAngle(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_SetSemiAngle\n  * wrapname: _wrap_gp_Cone_SetSemiAngle\n  * fulldecl: void gp_Cone::SetSemiAngle(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pnt *_wrap_gp_Cone_Apex (gp_Cone *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Cone const *)arg1)->Apex();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_Apex\n  * wrapname: _wrap_gp_Cone_Apex\n  * fulldecl: gp_Pnt gp_Cone::Apex() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT void _wrap_gp_Cone_UReverse (gp_Cone *larg1) {
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->UReverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_UReverse\n  * wrapname: _wrap_gp_Cone_UReverse\n  * fulldecl: void gp_Cone::UReverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Cone_VReverse (gp_Cone *larg1) {
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->VReverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_VReverse\n  * wrapname: _wrap_gp_Cone_VReverse\n  * fulldecl: void gp_Cone::VReverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_gp_Cone_Direct (gp_Cone *larg1) {
  bool lresult = (bool)0 ;
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Cone const *)arg1)->Direct();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_Direct\n  * wrapname: _wrap_gp_Cone_Direct\n  * fulldecl: Standard_Boolean gp_Cone::Direct() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Cone_Axis (gp_Cone *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  gp_Ax1 *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax1 *) &((gp_Cone const *)arg1)->Axis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_Axis\n  * wrapname: _wrap_gp_Cone_Axis\n  * fulldecl: gp_Ax1 const & gp_Cone::Axis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT void _wrap_gp_Cone_Coefficients (gp_Cone *larg1, Standard_Real *larg2, Standard_Real *larg3, Standard_Real *larg4, Standard_Real *larg5, Standard_Real *larg6, Standard_Real *larg7, Standard_Real *larg8, Standard_Real *larg9, Standard_Real *larg10, Standard_Real *larg11) {
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  Standard_Real *arg5 = 0 ;
  Standard_Real *arg6 = 0 ;
  Standard_Real *arg7 = 0 ;
  Standard_Real *arg8 = 0 ;
  Standard_Real *arg9 = 0 ;
  Standard_Real *arg10 = 0 ;
  Standard_Real *arg11 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  arg11 = larg11;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((gp_Cone const *)arg1)->Coefficients(*arg2,*arg3,*arg4,*arg5,*arg6,*arg7,*arg8,*arg9,*arg10,*arg11);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_Coefficients\n  * wrapname: _wrap_gp_Cone_Coefficients\n  * fulldecl: void gp_Cone::Coefficients(Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pnt *_wrap_gp_Cone_Location (gp_Cone *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  gp_Pnt *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt *) &((gp_Cone const *)arg1)->Location();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_Location\n  * wrapname: _wrap_gp_Cone_Location\n  * fulldecl: gp_Pnt const & gp_Cone::Location() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT gp_Ax3 *_wrap_gp_Cone_Position (gp_Cone *larg1) {
  gp_Ax3 * lresult = (gp_Ax3 *)0 ;
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  gp_Ax3 *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax3 *) &((gp_Cone const *)arg1)->Position();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_Position\n  * wrapname: _wrap_gp_Cone_Position\n  * fulldecl: gp_Ax3 const & gp_Cone::Position() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax3 *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Cone_RefRadius (gp_Cone *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Cone const *)arg1)->RefRadius();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_RefRadius\n  * wrapname: _wrap_gp_Cone_RefRadius\n  * fulldecl: Standard_Real gp_Cone::RefRadius() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Cone_SemiAngle (gp_Cone *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Cone const *)arg1)->SemiAngle();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_SemiAngle\n  * wrapname: _wrap_gp_Cone_SemiAngle\n  * fulldecl: Standard_Real gp_Cone::SemiAngle() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Cone_XAxis (gp_Cone *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Cone const *)arg1)->XAxis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_XAxis\n  * wrapname: _wrap_gp_Cone_XAxis\n  * fulldecl: gp_Ax1 gp_Cone::XAxis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Cone_YAxis (gp_Cone *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Cone const *)arg1)->YAxis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_YAxis\n  * wrapname: _wrap_gp_Cone_YAxis\n  * fulldecl: gp_Ax1 gp_Cone::YAxis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT void _wrap_gp_Cone_Mirror__SWIG_0 (gp_Cone *larg1, gp_Pnt *larg2) {
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_Mirror\n  * wrapname: _wrap_gp_Cone_Mirror__SWIG_0\n  * fulldecl: void gp_Cone::Mirror(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Cone *_wrap_gp_Cone_Mirrored__SWIG_0 (gp_Cone *larg1, gp_Pnt *larg2) {
  gp_Cone * lresult = (gp_Cone *)0 ;
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Cone result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Cone const *)arg1)->Mirrored((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_Mirrored\n  * wrapname: _wrap_gp_Cone_Mirrored__SWIG_0\n  * fulldecl: gp_Cone gp_Cone::Mirrored(gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Cone(result);
    return lresult;
  } catch (...) {
    return (gp_Cone *)0;
  }
}


EXPORT void _wrap_gp_Cone_Mirror__SWIG_1 (gp_Cone *larg1, gp_Ax1 *larg2) {
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_Mirror\n  * wrapname: _wrap_gp_Cone_Mirror__SWIG_1\n  * fulldecl: void gp_Cone::Mirror(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Cone *_wrap_gp_Cone_Mirrored__SWIG_1 (gp_Cone *larg1, gp_Ax1 *larg2) {
  gp_Cone * lresult = (gp_Cone *)0 ;
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  gp_Cone result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Cone const *)arg1)->Mirrored((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_Mirrored\n  * wrapname: _wrap_gp_Cone_Mirrored__SWIG_1\n  * fulldecl: gp_Cone gp_Cone::Mirrored(gp_Ax1 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Cone(result);
    return lresult;
  } catch (...) {
    return (gp_Cone *)0;
  }
}


EXPORT void _wrap_gp_Cone_Mirror__SWIG_2 (gp_Cone *larg1, gp_Ax2 *larg2) {
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_Mirror\n  * wrapname: _wrap_gp_Cone_Mirror__SWIG_2\n  * fulldecl: void gp_Cone::Mirror(gp_Ax2 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Cone *_wrap_gp_Cone_Mirrored__SWIG_2 (gp_Cone *larg1, gp_Ax2 *larg2) {
  gp_Cone * lresult = (gp_Cone *)0 ;
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  gp_Cone result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Cone const *)arg1)->Mirrored((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_Mirrored\n  * wrapname: _wrap_gp_Cone_Mirrored__SWIG_2\n  * fulldecl: gp_Cone gp_Cone::Mirrored(gp_Ax2 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Cone(result);
    return lresult;
  } catch (...) {
    return (gp_Cone *)0;
  }
}


EXPORT void _wrap_gp_Cone_Rotate (gp_Cone *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Rotate((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_Rotate\n  * wrapname: _wrap_gp_Cone_Rotate\n  * fulldecl: void gp_Cone::Rotate(gp_Ax1 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Cone *_wrap_gp_Cone_Rotated (gp_Cone *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Cone * lresult = (gp_Cone *)0 ;
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Cone result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Cone const *)arg1)->Rotated((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_Rotated\n  * wrapname: _wrap_gp_Cone_Rotated\n  * fulldecl: gp_Cone gp_Cone::Rotated(gp_Ax1 const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Cone(result);
    return lresult;
  } catch (...) {
    return (gp_Cone *)0;
  }
}


EXPORT void _wrap_gp_Cone_Scale (gp_Cone *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Scale((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_Scale\n  * wrapname: _wrap_gp_Cone_Scale\n  * fulldecl: void gp_Cone::Scale(gp_Pnt const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Cone *_wrap_gp_Cone_Scaled (gp_Cone *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  gp_Cone * lresult = (gp_Cone *)0 ;
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Cone result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Cone const *)arg1)->Scaled((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_Scaled\n  * wrapname: _wrap_gp_Cone_Scaled\n  * fulldecl: gp_Cone gp_Cone::Scaled(gp_Pnt const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Cone(result);
    return lresult;
  } catch (...) {
    return (gp_Cone *)0;
  }
}


EXPORT void _wrap_gp_Cone_Transform (gp_Cone *larg1, gp_Trsf *larg2) {
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  gp_Trsf *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Transform((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_Transform\n  * wrapname: _wrap_gp_Cone_Transform\n  * fulldecl: void gp_Cone::Transform(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Cone *_wrap_gp_Cone_Transformed (gp_Cone *larg1, gp_Trsf *larg2) {
  gp_Cone * lresult = (gp_Cone *)0 ;
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  gp_Trsf *arg2 = 0 ;
  gp_Cone result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Cone const *)arg1)->Transformed((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_Transformed\n  * wrapname: _wrap_gp_Cone_Transformed\n  * fulldecl: gp_Cone gp_Cone::Transformed(gp_Trsf const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Cone(result);
    return lresult;
  } catch (...) {
    return (gp_Cone *)0;
  }
}


EXPORT void _wrap_gp_Cone_Translate__SWIG_0 (gp_Cone *larg1, gp_Vec *larg2) {
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  gp_Vec *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_Translate\n  * wrapname: _wrap_gp_Cone_Translate__SWIG_0\n  * fulldecl: void gp_Cone::Translate(gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Cone *_wrap_gp_Cone_Translated__SWIG_0 (gp_Cone *larg1, gp_Vec *larg2) {
  gp_Cone * lresult = (gp_Cone *)0 ;
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  gp_Vec *arg2 = 0 ;
  gp_Cone result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Cone const *)arg1)->Translated((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_Translated\n  * wrapname: _wrap_gp_Cone_Translated__SWIG_0\n  * fulldecl: gp_Cone gp_Cone::Translated(gp_Vec const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Cone(result);
    return lresult;
  } catch (...) {
    return (gp_Cone *)0;
  }
}


EXPORT void _wrap_gp_Cone_Translate__SWIG_1 (gp_Cone *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_Translate\n  * wrapname: _wrap_gp_Cone_Translate__SWIG_1\n  * fulldecl: void gp_Cone::Translate(gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Cone *_wrap_gp_Cone_Translated__SWIG_1 (gp_Cone *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  gp_Cone * lresult = (gp_Cone *)0 ;
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  gp_Cone result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Cone const *)arg1)->Translated((gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cone_Translated\n  * wrapname: _wrap_gp_Cone_Translated__SWIG_1\n  * fulldecl: gp_Cone gp_Cone::Translated(gp_Pnt const &,gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Cone(result);
    return lresult;
  } catch (...) {
    return (gp_Cone *)0;
  }
}


EXPORT void _wrap_delete_gp_Cone (gp_Cone *larg1) {
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Cone\n  * wrapname: _wrap_delete_gp_Cone\n  * fulldecl: gp_Cone::~gp_Cone()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Cylinder *_wrap_new_gp_Cylinder__SWIG_0 () {
  gp_Cylinder * lresult = (gp_Cylinder *)0 ;
  gp_Cylinder *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Cylinder *)new gp_Cylinder();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Cylinder\n  * wrapname: _wrap_new_gp_Cylinder__SWIG_0\n  * fulldecl: gp_Cylinder::gp_Cylinder()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Cylinder *)0;
  }
}


EXPORT gp_Cylinder *_wrap_new_gp_Cylinder__SWIG_1 (gp_Ax3 *larg1, Standard_Real larg2) {
  gp_Cylinder * lresult = (gp_Cylinder *)0 ;
  gp_Ax3 *arg1 = 0 ;
  Standard_Real arg2 ;
  gp_Cylinder *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Cylinder *)new gp_Cylinder((gp_Ax3 const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Cylinder\n  * wrapname: _wrap_new_gp_Cylinder__SWIG_1\n  * fulldecl: gp_Cylinder::gp_Cylinder(gp_Ax3 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Cylinder *)0;
  }
}


EXPORT void _wrap_gp_Cylinder_SetAxis (gp_Cylinder *larg1, gp_Ax1 *larg2) {
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetAxis((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cylinder_SetAxis\n  * wrapname: _wrap_gp_Cylinder_SetAxis\n  * fulldecl: void gp_Cylinder::SetAxis(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Cylinder_SetLocation (gp_Cylinder *larg1, gp_Pnt *larg2) {
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLocation((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cylinder_SetLocation\n  * wrapname: _wrap_gp_Cylinder_SetLocation\n  * fulldecl: void gp_Cylinder::SetLocation(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Cylinder_SetPosition (gp_Cylinder *larg1, gp_Ax3 *larg2) {
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  gp_Ax3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetPosition((gp_Ax3 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cylinder_SetPosition\n  * wrapname: _wrap_gp_Cylinder_SetPosition\n  * fulldecl: void gp_Cylinder::SetPosition(gp_Ax3 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Cylinder_SetRadius (gp_Cylinder *larg1, Standard_Real larg2) {
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetRadius(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cylinder_SetRadius\n  * wrapname: _wrap_gp_Cylinder_SetRadius\n  * fulldecl: void gp_Cylinder::SetRadius(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Cylinder_UReverse (gp_Cylinder *larg1) {
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->UReverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cylinder_UReverse\n  * wrapname: _wrap_gp_Cylinder_UReverse\n  * fulldecl: void gp_Cylinder::UReverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Cylinder_VReverse (gp_Cylinder *larg1) {
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->VReverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cylinder_VReverse\n  * wrapname: _wrap_gp_Cylinder_VReverse\n  * fulldecl: void gp_Cylinder::VReverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_gp_Cylinder_Direct (gp_Cylinder *larg1) {
  bool lresult = (bool)0 ;
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Cylinder const *)arg1)->Direct();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cylinder_Direct\n  * wrapname: _wrap_gp_Cylinder_Direct\n  * fulldecl: Standard_Boolean gp_Cylinder::Direct() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Cylinder_Axis (gp_Cylinder *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  gp_Ax1 *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax1 *) &((gp_Cylinder const *)arg1)->Axis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cylinder_Axis\n  * wrapname: _wrap_gp_Cylinder_Axis\n  * fulldecl: gp_Ax1 const & gp_Cylinder::Axis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT void _wrap_gp_Cylinder_Coefficients (gp_Cylinder *larg1, Standard_Real *larg2, Standard_Real *larg3, Standard_Real *larg4, Standard_Real *larg5, Standard_Real *larg6, Standard_Real *larg7, Standard_Real *larg8, Standard_Real *larg9, Standard_Real *larg10, Standard_Real *larg11) {
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  Standard_Real *arg5 = 0 ;
  Standard_Real *arg6 = 0 ;
  Standard_Real *arg7 = 0 ;
  Standard_Real *arg8 = 0 ;
  Standard_Real *arg9 = 0 ;
  Standard_Real *arg10 = 0 ;
  Standard_Real *arg11 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  arg11 = larg11;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((gp_Cylinder const *)arg1)->Coefficients(*arg2,*arg3,*arg4,*arg5,*arg6,*arg7,*arg8,*arg9,*arg10,*arg11);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cylinder_Coefficients\n  * wrapname: _wrap_gp_Cylinder_Coefficients\n  * fulldecl: void gp_Cylinder::Coefficients(Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pnt *_wrap_gp_Cylinder_Location (gp_Cylinder *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  gp_Pnt *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt *) &((gp_Cylinder const *)arg1)->Location();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cylinder_Location\n  * wrapname: _wrap_gp_Cylinder_Location\n  * fulldecl: gp_Pnt const & gp_Cylinder::Location() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT gp_Ax3 *_wrap_gp_Cylinder_Position (gp_Cylinder *larg1) {
  gp_Ax3 * lresult = (gp_Ax3 *)0 ;
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  gp_Ax3 *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax3 *) &((gp_Cylinder const *)arg1)->Position();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cylinder_Position\n  * wrapname: _wrap_gp_Cylinder_Position\n  * fulldecl: gp_Ax3 const & gp_Cylinder::Position() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax3 *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Cylinder_Radius (gp_Cylinder *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Cylinder const *)arg1)->Radius();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cylinder_Radius\n  * wrapname: _wrap_gp_Cylinder_Radius\n  * fulldecl: Standard_Real gp_Cylinder::Radius() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Cylinder_XAxis (gp_Cylinder *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Cylinder const *)arg1)->XAxis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cylinder_XAxis\n  * wrapname: _wrap_gp_Cylinder_XAxis\n  * fulldecl: gp_Ax1 gp_Cylinder::XAxis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Cylinder_YAxis (gp_Cylinder *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Cylinder const *)arg1)->YAxis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cylinder_YAxis\n  * wrapname: _wrap_gp_Cylinder_YAxis\n  * fulldecl: gp_Ax1 gp_Cylinder::YAxis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT void _wrap_gp_Cylinder_Mirror__SWIG_0 (gp_Cylinder *larg1, gp_Pnt *larg2) {
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cylinder_Mirror\n  * wrapname: _wrap_gp_Cylinder_Mirror__SWIG_0\n  * fulldecl: void gp_Cylinder::Mirror(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Cylinder *_wrap_gp_Cylinder_Mirrored__SWIG_0 (gp_Cylinder *larg1, gp_Pnt *larg2) {
  gp_Cylinder * lresult = (gp_Cylinder *)0 ;
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Cylinder result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Cylinder const *)arg1)->Mirrored((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cylinder_Mirrored\n  * wrapname: _wrap_gp_Cylinder_Mirrored__SWIG_0\n  * fulldecl: gp_Cylinder gp_Cylinder::Mirrored(gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Cylinder(result);
    return lresult;
  } catch (...) {
    return (gp_Cylinder *)0;
  }
}


EXPORT void _wrap_gp_Cylinder_Mirror__SWIG_1 (gp_Cylinder *larg1, gp_Ax1 *larg2) {
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cylinder_Mirror\n  * wrapname: _wrap_gp_Cylinder_Mirror__SWIG_1\n  * fulldecl: void gp_Cylinder::Mirror(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Cylinder *_wrap_gp_Cylinder_Mirrored__SWIG_1 (gp_Cylinder *larg1, gp_Ax1 *larg2) {
  gp_Cylinder * lresult = (gp_Cylinder *)0 ;
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  gp_Cylinder result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Cylinder const *)arg1)->Mirrored((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cylinder_Mirrored\n  * wrapname: _wrap_gp_Cylinder_Mirrored__SWIG_1\n  * fulldecl: gp_Cylinder gp_Cylinder::Mirrored(gp_Ax1 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Cylinder(result);
    return lresult;
  } catch (...) {
    return (gp_Cylinder *)0;
  }
}


EXPORT void _wrap_gp_Cylinder_Mirror__SWIG_2 (gp_Cylinder *larg1, gp_Ax2 *larg2) {
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cylinder_Mirror\n  * wrapname: _wrap_gp_Cylinder_Mirror__SWIG_2\n  * fulldecl: void gp_Cylinder::Mirror(gp_Ax2 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Cylinder *_wrap_gp_Cylinder_Mirrored__SWIG_2 (gp_Cylinder *larg1, gp_Ax2 *larg2) {
  gp_Cylinder * lresult = (gp_Cylinder *)0 ;
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  gp_Cylinder result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Cylinder const *)arg1)->Mirrored((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cylinder_Mirrored\n  * wrapname: _wrap_gp_Cylinder_Mirrored__SWIG_2\n  * fulldecl: gp_Cylinder gp_Cylinder::Mirrored(gp_Ax2 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Cylinder(result);
    return lresult;
  } catch (...) {
    return (gp_Cylinder *)0;
  }
}


EXPORT void _wrap_gp_Cylinder_Rotate (gp_Cylinder *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Rotate((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cylinder_Rotate\n  * wrapname: _wrap_gp_Cylinder_Rotate\n  * fulldecl: void gp_Cylinder::Rotate(gp_Ax1 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Cylinder *_wrap_gp_Cylinder_Rotated (gp_Cylinder *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Cylinder * lresult = (gp_Cylinder *)0 ;
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Cylinder result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Cylinder const *)arg1)->Rotated((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cylinder_Rotated\n  * wrapname: _wrap_gp_Cylinder_Rotated\n  * fulldecl: gp_Cylinder gp_Cylinder::Rotated(gp_Ax1 const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Cylinder(result);
    return lresult;
  } catch (...) {
    return (gp_Cylinder *)0;
  }
}


EXPORT gp_Cylinder *_wrap_gp_Cylinder_Scaled (gp_Cylinder *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  gp_Cylinder * lresult = (gp_Cylinder *)0 ;
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Cylinder result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Cylinder const *)arg1)->Scaled((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cylinder_Scaled\n  * wrapname: _wrap_gp_Cylinder_Scaled\n  * fulldecl: gp_Cylinder gp_Cylinder::Scaled(gp_Pnt const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Cylinder(result);
    return lresult;
  } catch (...) {
    return (gp_Cylinder *)0;
  }
}


EXPORT void _wrap_gp_Cylinder_Transform (gp_Cylinder *larg1, gp_Trsf *larg2) {
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  gp_Trsf *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Transform((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cylinder_Transform\n  * wrapname: _wrap_gp_Cylinder_Transform\n  * fulldecl: void gp_Cylinder::Transform(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Cylinder *_wrap_gp_Cylinder_Transformed (gp_Cylinder *larg1, gp_Trsf *larg2) {
  gp_Cylinder * lresult = (gp_Cylinder *)0 ;
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  gp_Trsf *arg2 = 0 ;
  gp_Cylinder result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Cylinder const *)arg1)->Transformed((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cylinder_Transformed\n  * wrapname: _wrap_gp_Cylinder_Transformed\n  * fulldecl: gp_Cylinder gp_Cylinder::Transformed(gp_Trsf const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Cylinder(result);
    return lresult;
  } catch (...) {
    return (gp_Cylinder *)0;
  }
}


EXPORT void _wrap_gp_Cylinder_Translate__SWIG_0 (gp_Cylinder *larg1, gp_Vec *larg2) {
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  gp_Vec *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cylinder_Translate\n  * wrapname: _wrap_gp_Cylinder_Translate__SWIG_0\n  * fulldecl: void gp_Cylinder::Translate(gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Cylinder *_wrap_gp_Cylinder_Translated__SWIG_0 (gp_Cylinder *larg1, gp_Vec *larg2) {
  gp_Cylinder * lresult = (gp_Cylinder *)0 ;
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  gp_Vec *arg2 = 0 ;
  gp_Cylinder result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Cylinder const *)arg1)->Translated((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cylinder_Translated\n  * wrapname: _wrap_gp_Cylinder_Translated__SWIG_0\n  * fulldecl: gp_Cylinder gp_Cylinder::Translated(gp_Vec const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Cylinder(result);
    return lresult;
  } catch (...) {
    return (gp_Cylinder *)0;
  }
}


EXPORT void _wrap_gp_Cylinder_Translate__SWIG_1 (gp_Cylinder *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cylinder_Translate\n  * wrapname: _wrap_gp_Cylinder_Translate__SWIG_1\n  * fulldecl: void gp_Cylinder::Translate(gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Cylinder *_wrap_gp_Cylinder_Translated__SWIG_1 (gp_Cylinder *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  gp_Cylinder * lresult = (gp_Cylinder *)0 ;
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  gp_Cylinder result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Cylinder const *)arg1)->Translated((gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Cylinder_Translated\n  * wrapname: _wrap_gp_Cylinder_Translated__SWIG_1\n  * fulldecl: gp_Cylinder gp_Cylinder::Translated(gp_Pnt const &,gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Cylinder(result);
    return lresult;
  } catch (...) {
    return (gp_Cylinder *)0;
  }
}


EXPORT void _wrap_delete_gp_Cylinder (gp_Cylinder *larg1) {
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Cylinder\n  * wrapname: _wrap_delete_gp_Cylinder\n  * fulldecl: gp_Cylinder::~gp_Cylinder()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Parab *_wrap_new_gp_Parab__SWIG_0 () {
  gp_Parab * lresult = (gp_Parab *)0 ;
  gp_Parab *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Parab *)new gp_Parab();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Parab\n  * wrapname: _wrap_new_gp_Parab__SWIG_0\n  * fulldecl: gp_Parab::gp_Parab()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Parab *)0;
  }
}


EXPORT gp_Parab *_wrap_new_gp_Parab__SWIG_1 (gp_Ax2 *larg1, Standard_Real larg2) {
  gp_Parab * lresult = (gp_Parab *)0 ;
  gp_Ax2 *arg1 = 0 ;
  Standard_Real arg2 ;
  gp_Parab *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Parab *)new gp_Parab((gp_Ax2 const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Parab\n  * wrapname: _wrap_new_gp_Parab__SWIG_1\n  * fulldecl: gp_Parab::gp_Parab(gp_Ax2 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Parab *)0;
  }
}


EXPORT gp_Parab *_wrap_new_gp_Parab__SWIG_2 (gp_Ax1 *larg1, gp_Pnt *larg2) {
  gp_Parab * lresult = (gp_Parab *)0 ;
  gp_Ax1 *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Parab *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Parab *)new gp_Parab((gp_Ax1 const &)*arg1,(gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Parab\n  * wrapname: _wrap_new_gp_Parab__SWIG_2\n  * fulldecl: gp_Parab::gp_Parab(gp_Ax1 const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Parab *)0;
  }
}


EXPORT void _wrap_gp_Parab_SetAxis (gp_Parab *larg1, gp_Ax1 *larg2) {
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetAxis((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab_SetAxis\n  * wrapname: _wrap_gp_Parab_SetAxis\n  * fulldecl: void gp_Parab::SetAxis(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Parab_SetFocal (gp_Parab *larg1, Standard_Real larg2) {
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetFocal(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab_SetFocal\n  * wrapname: _wrap_gp_Parab_SetFocal\n  * fulldecl: void gp_Parab::SetFocal(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Parab_SetLocation (gp_Parab *larg1, gp_Pnt *larg2) {
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLocation((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab_SetLocation\n  * wrapname: _wrap_gp_Parab_SetLocation\n  * fulldecl: void gp_Parab::SetLocation(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Parab_SetPosition (gp_Parab *larg1, gp_Ax2 *larg2) {
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetPosition((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab_SetPosition\n  * wrapname: _wrap_gp_Parab_SetPosition\n  * fulldecl: void gp_Parab::SetPosition(gp_Ax2 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax1 *_wrap_gp_Parab_Axis (gp_Parab *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  gp_Ax1 *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax1 *) &((gp_Parab const *)arg1)->Axis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab_Axis\n  * wrapname: _wrap_gp_Parab_Axis\n  * fulldecl: gp_Ax1 const & gp_Parab::Axis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Parab_Directrix (gp_Parab *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Parab const *)arg1)->Directrix();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab_Directrix\n  * wrapname: _wrap_gp_Parab_Directrix\n  * fulldecl: gp_Ax1 gp_Parab::Directrix() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Parab_Focal (gp_Parab *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Parab const *)arg1)->Focal();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab_Focal\n  * wrapname: _wrap_gp_Parab_Focal\n  * fulldecl: Standard_Real gp_Parab::Focal() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Pnt *_wrap_gp_Parab_Focus (gp_Parab *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Parab const *)arg1)->Focus();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab_Focus\n  * wrapname: _wrap_gp_Parab_Focus\n  * fulldecl: gp_Pnt gp_Parab::Focus() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT gp_Pnt *_wrap_gp_Parab_Location (gp_Parab *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  gp_Pnt *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt *) &((gp_Parab const *)arg1)->Location();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab_Location\n  * wrapname: _wrap_gp_Parab_Location\n  * fulldecl: gp_Pnt const & gp_Parab::Location() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Parab_Parameter (gp_Parab *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Parab const *)arg1)->Parameter();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab_Parameter\n  * wrapname: _wrap_gp_Parab_Parameter\n  * fulldecl: Standard_Real gp_Parab::Parameter() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Ax2 *_wrap_gp_Parab_Position (gp_Parab *larg1) {
  gp_Ax2 * lresult = (gp_Ax2 *)0 ;
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  gp_Ax2 *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax2 *) &((gp_Parab const *)arg1)->Position();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab_Position\n  * wrapname: _wrap_gp_Parab_Position\n  * fulldecl: gp_Ax2 const & gp_Parab::Position() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax2 *)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Parab_XAxis (gp_Parab *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Parab const *)arg1)->XAxis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab_XAxis\n  * wrapname: _wrap_gp_Parab_XAxis\n  * fulldecl: gp_Ax1 gp_Parab::XAxis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Parab_YAxis (gp_Parab *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Parab const *)arg1)->YAxis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab_YAxis\n  * wrapname: _wrap_gp_Parab_YAxis\n  * fulldecl: gp_Ax1 gp_Parab::YAxis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT void _wrap_gp_Parab_Mirror__SWIG_0 (gp_Parab *larg1, gp_Pnt *larg2) {
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab_Mirror\n  * wrapname: _wrap_gp_Parab_Mirror__SWIG_0\n  * fulldecl: void gp_Parab::Mirror(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Parab *_wrap_gp_Parab_Mirrored__SWIG_0 (gp_Parab *larg1, gp_Pnt *larg2) {
  gp_Parab * lresult = (gp_Parab *)0 ;
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Parab result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Parab const *)arg1)->Mirrored((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab_Mirrored\n  * wrapname: _wrap_gp_Parab_Mirrored__SWIG_0\n  * fulldecl: gp_Parab gp_Parab::Mirrored(gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Parab(result);
    return lresult;
  } catch (...) {
    return (gp_Parab *)0;
  }
}


EXPORT void _wrap_gp_Parab_Mirror__SWIG_1 (gp_Parab *larg1, gp_Ax1 *larg2) {
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab_Mirror\n  * wrapname: _wrap_gp_Parab_Mirror__SWIG_1\n  * fulldecl: void gp_Parab::Mirror(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Parab *_wrap_gp_Parab_Mirrored__SWIG_1 (gp_Parab *larg1, gp_Ax1 *larg2) {
  gp_Parab * lresult = (gp_Parab *)0 ;
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  gp_Parab result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Parab const *)arg1)->Mirrored((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab_Mirrored\n  * wrapname: _wrap_gp_Parab_Mirrored__SWIG_1\n  * fulldecl: gp_Parab gp_Parab::Mirrored(gp_Ax1 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Parab(result);
    return lresult;
  } catch (...) {
    return (gp_Parab *)0;
  }
}


EXPORT void _wrap_gp_Parab_Mirror__SWIG_2 (gp_Parab *larg1, gp_Ax2 *larg2) {
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab_Mirror\n  * wrapname: _wrap_gp_Parab_Mirror__SWIG_2\n  * fulldecl: void gp_Parab::Mirror(gp_Ax2 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Parab *_wrap_gp_Parab_Mirrored__SWIG_2 (gp_Parab *larg1, gp_Ax2 *larg2) {
  gp_Parab * lresult = (gp_Parab *)0 ;
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  gp_Parab result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Parab const *)arg1)->Mirrored((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab_Mirrored\n  * wrapname: _wrap_gp_Parab_Mirrored__SWIG_2\n  * fulldecl: gp_Parab gp_Parab::Mirrored(gp_Ax2 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Parab(result);
    return lresult;
  } catch (...) {
    return (gp_Parab *)0;
  }
}


EXPORT void _wrap_gp_Parab_Rotate (gp_Parab *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Rotate((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab_Rotate\n  * wrapname: _wrap_gp_Parab_Rotate\n  * fulldecl: void gp_Parab::Rotate(gp_Ax1 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Parab *_wrap_gp_Parab_Rotated (gp_Parab *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Parab * lresult = (gp_Parab *)0 ;
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Parab result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Parab const *)arg1)->Rotated((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab_Rotated\n  * wrapname: _wrap_gp_Parab_Rotated\n  * fulldecl: gp_Parab gp_Parab::Rotated(gp_Ax1 const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Parab(result);
    return lresult;
  } catch (...) {
    return (gp_Parab *)0;
  }
}


EXPORT void _wrap_gp_Parab_Scale (gp_Parab *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Scale((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab_Scale\n  * wrapname: _wrap_gp_Parab_Scale\n  * fulldecl: void gp_Parab::Scale(gp_Pnt const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Parab *_wrap_gp_Parab_Scaled (gp_Parab *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  gp_Parab * lresult = (gp_Parab *)0 ;
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Parab result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Parab const *)arg1)->Scaled((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab_Scaled\n  * wrapname: _wrap_gp_Parab_Scaled\n  * fulldecl: gp_Parab gp_Parab::Scaled(gp_Pnt const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Parab(result);
    return lresult;
  } catch (...) {
    return (gp_Parab *)0;
  }
}


EXPORT void _wrap_gp_Parab_Transform (gp_Parab *larg1, gp_Trsf *larg2) {
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  gp_Trsf *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Transform((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab_Transform\n  * wrapname: _wrap_gp_Parab_Transform\n  * fulldecl: void gp_Parab::Transform(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Parab *_wrap_gp_Parab_Transformed (gp_Parab *larg1, gp_Trsf *larg2) {
  gp_Parab * lresult = (gp_Parab *)0 ;
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  gp_Trsf *arg2 = 0 ;
  gp_Parab result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Parab const *)arg1)->Transformed((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab_Transformed\n  * wrapname: _wrap_gp_Parab_Transformed\n  * fulldecl: gp_Parab gp_Parab::Transformed(gp_Trsf const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Parab(result);
    return lresult;
  } catch (...) {
    return (gp_Parab *)0;
  }
}


EXPORT void _wrap_gp_Parab_Translate__SWIG_0 (gp_Parab *larg1, gp_Vec *larg2) {
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  gp_Vec *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab_Translate\n  * wrapname: _wrap_gp_Parab_Translate__SWIG_0\n  * fulldecl: void gp_Parab::Translate(gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Parab *_wrap_gp_Parab_Translated__SWIG_0 (gp_Parab *larg1, gp_Vec *larg2) {
  gp_Parab * lresult = (gp_Parab *)0 ;
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  gp_Vec *arg2 = 0 ;
  gp_Parab result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Parab const *)arg1)->Translated((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab_Translated\n  * wrapname: _wrap_gp_Parab_Translated__SWIG_0\n  * fulldecl: gp_Parab gp_Parab::Translated(gp_Vec const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Parab(result);
    return lresult;
  } catch (...) {
    return (gp_Parab *)0;
  }
}


EXPORT void _wrap_gp_Parab_Translate__SWIG_1 (gp_Parab *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab_Translate\n  * wrapname: _wrap_gp_Parab_Translate__SWIG_1\n  * fulldecl: void gp_Parab::Translate(gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Parab *_wrap_gp_Parab_Translated__SWIG_1 (gp_Parab *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  gp_Parab * lresult = (gp_Parab *)0 ;
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  gp_Parab result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Parab const *)arg1)->Translated((gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Parab_Translated\n  * wrapname: _wrap_gp_Parab_Translated__SWIG_1\n  * fulldecl: gp_Parab gp_Parab::Translated(gp_Pnt const &,gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Parab(result);
    return lresult;
  } catch (...) {
    return (gp_Parab *)0;
  }
}


EXPORT void _wrap_delete_gp_Parab (gp_Parab *larg1) {
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Parab\n  * wrapname: _wrap_delete_gp_Parab\n  * fulldecl: gp_Parab::~gp_Parab()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Hypr *_wrap_new_gp_Hypr__SWIG_0 () {
  gp_Hypr * lresult = (gp_Hypr *)0 ;
  gp_Hypr *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Hypr *)new gp_Hypr();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Hypr\n  * wrapname: _wrap_new_gp_Hypr__SWIG_0\n  * fulldecl: gp_Hypr::gp_Hypr()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Hypr *)0;
  }
}


EXPORT gp_Hypr *_wrap_new_gp_Hypr__SWIG_1 (gp_Ax2 *larg1, Standard_Real larg2, Standard_Real larg3) {
  gp_Hypr * lresult = (gp_Hypr *)0 ;
  gp_Ax2 *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  gp_Hypr *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Hypr *)new gp_Hypr((gp_Ax2 const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Hypr\n  * wrapname: _wrap_new_gp_Hypr__SWIG_1\n  * fulldecl: gp_Hypr::gp_Hypr(gp_Ax2 const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Hypr *)0;
  }
}


EXPORT void _wrap_gp_Hypr_SetAxis (gp_Hypr *larg1, gp_Ax1 *larg2) {
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetAxis((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_SetAxis\n  * wrapname: _wrap_gp_Hypr_SetAxis\n  * fulldecl: void gp_Hypr::SetAxis(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Hypr_SetLocation (gp_Hypr *larg1, gp_Pnt *larg2) {
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLocation((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_SetLocation\n  * wrapname: _wrap_gp_Hypr_SetLocation\n  * fulldecl: void gp_Hypr::SetLocation(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Hypr_SetMajorRadius (gp_Hypr *larg1, Standard_Real larg2) {
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetMajorRadius(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_SetMajorRadius\n  * wrapname: _wrap_gp_Hypr_SetMajorRadius\n  * fulldecl: void gp_Hypr::SetMajorRadius(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Hypr_SetMinorRadius (gp_Hypr *larg1, Standard_Real larg2) {
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetMinorRadius(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_SetMinorRadius\n  * wrapname: _wrap_gp_Hypr_SetMinorRadius\n  * fulldecl: void gp_Hypr::SetMinorRadius(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Hypr_SetPosition (gp_Hypr *larg1, gp_Ax2 *larg2) {
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetPosition((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_SetPosition\n  * wrapname: _wrap_gp_Hypr_SetPosition\n  * fulldecl: void gp_Hypr::SetPosition(gp_Ax2 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax1 *_wrap_gp_Hypr_Asymptote1 (gp_Hypr *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr const *)arg1)->Asymptote1();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_Asymptote1\n  * wrapname: _wrap_gp_Hypr_Asymptote1\n  * fulldecl: gp_Ax1 gp_Hypr::Asymptote1() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Hypr_Asymptote2 (gp_Hypr *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr const *)arg1)->Asymptote2();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_Asymptote2\n  * wrapname: _wrap_gp_Hypr_Asymptote2\n  * fulldecl: gp_Ax1 gp_Hypr::Asymptote2() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Hypr_Axis (gp_Hypr *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Ax1 *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax1 *) &((gp_Hypr const *)arg1)->Axis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_Axis\n  * wrapname: _wrap_gp_Hypr_Axis\n  * fulldecl: gp_Ax1 const & gp_Hypr::Axis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT gp_Hypr *_wrap_gp_Hypr_ConjugateBranch1 (gp_Hypr *larg1) {
  gp_Hypr * lresult = (gp_Hypr *)0 ;
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Hypr result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr const *)arg1)->ConjugateBranch1();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_ConjugateBranch1\n  * wrapname: _wrap_gp_Hypr_ConjugateBranch1\n  * fulldecl: gp_Hypr gp_Hypr::ConjugateBranch1() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr *)0;
  }
}


EXPORT gp_Hypr *_wrap_gp_Hypr_ConjugateBranch2 (gp_Hypr *larg1) {
  gp_Hypr * lresult = (gp_Hypr *)0 ;
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Hypr result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr const *)arg1)->ConjugateBranch2();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_ConjugateBranch2\n  * wrapname: _wrap_gp_Hypr_ConjugateBranch2\n  * fulldecl: gp_Hypr gp_Hypr::ConjugateBranch2() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr *)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Hypr_Directrix1 (gp_Hypr *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr const *)arg1)->Directrix1();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_Directrix1\n  * wrapname: _wrap_gp_Hypr_Directrix1\n  * fulldecl: gp_Ax1 gp_Hypr::Directrix1() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Hypr_Directrix2 (gp_Hypr *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr const *)arg1)->Directrix2();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_Directrix2\n  * wrapname: _wrap_gp_Hypr_Directrix2\n  * fulldecl: gp_Ax1 gp_Hypr::Directrix2() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Hypr_Eccentricity (gp_Hypr *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Hypr const *)arg1)->Eccentricity();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_Eccentricity\n  * wrapname: _wrap_gp_Hypr_Eccentricity\n  * fulldecl: Standard_Real gp_Hypr::Eccentricity() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Hypr_Focal (gp_Hypr *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Hypr const *)arg1)->Focal();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_Focal\n  * wrapname: _wrap_gp_Hypr_Focal\n  * fulldecl: Standard_Real gp_Hypr::Focal() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Pnt *_wrap_gp_Hypr_Focus1 (gp_Hypr *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr const *)arg1)->Focus1();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_Focus1\n  * wrapname: _wrap_gp_Hypr_Focus1\n  * fulldecl: gp_Pnt gp_Hypr::Focus1() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT gp_Pnt *_wrap_gp_Hypr_Focus2 (gp_Hypr *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr const *)arg1)->Focus2();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_Focus2\n  * wrapname: _wrap_gp_Hypr_Focus2\n  * fulldecl: gp_Pnt gp_Hypr::Focus2() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT gp_Pnt *_wrap_gp_Hypr_Location (gp_Hypr *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Pnt *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt *) &((gp_Hypr const *)arg1)->Location();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_Location\n  * wrapname: _wrap_gp_Hypr_Location\n  * fulldecl: gp_Pnt const & gp_Hypr::Location() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Hypr_MajorRadius (gp_Hypr *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Hypr const *)arg1)->MajorRadius();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_MajorRadius\n  * wrapname: _wrap_gp_Hypr_MajorRadius\n  * fulldecl: Standard_Real gp_Hypr::MajorRadius() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Hypr_MinorRadius (gp_Hypr *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Hypr const *)arg1)->MinorRadius();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_MinorRadius\n  * wrapname: _wrap_gp_Hypr_MinorRadius\n  * fulldecl: Standard_Real gp_Hypr::MinorRadius() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Hypr *_wrap_gp_Hypr_OtherBranch (gp_Hypr *larg1) {
  gp_Hypr * lresult = (gp_Hypr *)0 ;
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Hypr result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr const *)arg1)->OtherBranch();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_OtherBranch\n  * wrapname: _wrap_gp_Hypr_OtherBranch\n  * fulldecl: gp_Hypr gp_Hypr::OtherBranch() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Hypr_Parameter (gp_Hypr *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Hypr const *)arg1)->Parameter();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_Parameter\n  * wrapname: _wrap_gp_Hypr_Parameter\n  * fulldecl: Standard_Real gp_Hypr::Parameter() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Ax2 *_wrap_gp_Hypr_Position (gp_Hypr *larg1) {
  gp_Ax2 * lresult = (gp_Ax2 *)0 ;
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Ax2 *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax2 *) &((gp_Hypr const *)arg1)->Position();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_Position\n  * wrapname: _wrap_gp_Hypr_Position\n  * fulldecl: gp_Ax2 const & gp_Hypr::Position() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax2 *)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Hypr_XAxis (gp_Hypr *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr const *)arg1)->XAxis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_XAxis\n  * wrapname: _wrap_gp_Hypr_XAxis\n  * fulldecl: gp_Ax1 gp_Hypr::XAxis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Hypr_YAxis (gp_Hypr *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr const *)arg1)->YAxis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_YAxis\n  * wrapname: _wrap_gp_Hypr_YAxis\n  * fulldecl: gp_Ax1 gp_Hypr::YAxis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT void _wrap_gp_Hypr_Mirror__SWIG_0 (gp_Hypr *larg1, gp_Pnt *larg2) {
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_Mirror\n  * wrapname: _wrap_gp_Hypr_Mirror__SWIG_0\n  * fulldecl: void gp_Hypr::Mirror(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Hypr *_wrap_gp_Hypr_Mirrored__SWIG_0 (gp_Hypr *larg1, gp_Pnt *larg2) {
  gp_Hypr * lresult = (gp_Hypr *)0 ;
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Hypr result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr const *)arg1)->Mirrored((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_Mirrored\n  * wrapname: _wrap_gp_Hypr_Mirrored__SWIG_0\n  * fulldecl: gp_Hypr gp_Hypr::Mirrored(gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr *)0;
  }
}


EXPORT void _wrap_gp_Hypr_Mirror__SWIG_1 (gp_Hypr *larg1, gp_Ax1 *larg2) {
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_Mirror\n  * wrapname: _wrap_gp_Hypr_Mirror__SWIG_1\n  * fulldecl: void gp_Hypr::Mirror(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Hypr *_wrap_gp_Hypr_Mirrored__SWIG_1 (gp_Hypr *larg1, gp_Ax1 *larg2) {
  gp_Hypr * lresult = (gp_Hypr *)0 ;
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  gp_Hypr result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr const *)arg1)->Mirrored((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_Mirrored\n  * wrapname: _wrap_gp_Hypr_Mirrored__SWIG_1\n  * fulldecl: gp_Hypr gp_Hypr::Mirrored(gp_Ax1 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr *)0;
  }
}


EXPORT void _wrap_gp_Hypr_Mirror__SWIG_2 (gp_Hypr *larg1, gp_Ax2 *larg2) {
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_Mirror\n  * wrapname: _wrap_gp_Hypr_Mirror__SWIG_2\n  * fulldecl: void gp_Hypr::Mirror(gp_Ax2 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Hypr *_wrap_gp_Hypr_Mirrored__SWIG_2 (gp_Hypr *larg1, gp_Ax2 *larg2) {
  gp_Hypr * lresult = (gp_Hypr *)0 ;
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  gp_Hypr result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr const *)arg1)->Mirrored((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_Mirrored\n  * wrapname: _wrap_gp_Hypr_Mirrored__SWIG_2\n  * fulldecl: gp_Hypr gp_Hypr::Mirrored(gp_Ax2 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr *)0;
  }
}


EXPORT void _wrap_gp_Hypr_Rotate (gp_Hypr *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Rotate((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_Rotate\n  * wrapname: _wrap_gp_Hypr_Rotate\n  * fulldecl: void gp_Hypr::Rotate(gp_Ax1 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Hypr *_wrap_gp_Hypr_Rotated (gp_Hypr *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Hypr * lresult = (gp_Hypr *)0 ;
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Hypr result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr const *)arg1)->Rotated((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_Rotated\n  * wrapname: _wrap_gp_Hypr_Rotated\n  * fulldecl: gp_Hypr gp_Hypr::Rotated(gp_Ax1 const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr *)0;
  }
}


EXPORT void _wrap_gp_Hypr_Scale (gp_Hypr *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Scale((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_Scale\n  * wrapname: _wrap_gp_Hypr_Scale\n  * fulldecl: void gp_Hypr::Scale(gp_Pnt const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Hypr *_wrap_gp_Hypr_Scaled (gp_Hypr *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  gp_Hypr * lresult = (gp_Hypr *)0 ;
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Hypr result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr const *)arg1)->Scaled((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_Scaled\n  * wrapname: _wrap_gp_Hypr_Scaled\n  * fulldecl: gp_Hypr gp_Hypr::Scaled(gp_Pnt const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr *)0;
  }
}


EXPORT void _wrap_gp_Hypr_Transform (gp_Hypr *larg1, gp_Trsf *larg2) {
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Trsf *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Transform((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_Transform\n  * wrapname: _wrap_gp_Hypr_Transform\n  * fulldecl: void gp_Hypr::Transform(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Hypr *_wrap_gp_Hypr_Transformed (gp_Hypr *larg1, gp_Trsf *larg2) {
  gp_Hypr * lresult = (gp_Hypr *)0 ;
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Trsf *arg2 = 0 ;
  gp_Hypr result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr const *)arg1)->Transformed((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_Transformed\n  * wrapname: _wrap_gp_Hypr_Transformed\n  * fulldecl: gp_Hypr gp_Hypr::Transformed(gp_Trsf const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr *)0;
  }
}


EXPORT void _wrap_gp_Hypr_Translate__SWIG_0 (gp_Hypr *larg1, gp_Vec *larg2) {
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Vec *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_Translate\n  * wrapname: _wrap_gp_Hypr_Translate__SWIG_0\n  * fulldecl: void gp_Hypr::Translate(gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Hypr *_wrap_gp_Hypr_Translated__SWIG_0 (gp_Hypr *larg1, gp_Vec *larg2) {
  gp_Hypr * lresult = (gp_Hypr *)0 ;
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Vec *arg2 = 0 ;
  gp_Hypr result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr const *)arg1)->Translated((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_Translated\n  * wrapname: _wrap_gp_Hypr_Translated__SWIG_0\n  * fulldecl: gp_Hypr gp_Hypr::Translated(gp_Vec const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr *)0;
  }
}


EXPORT void _wrap_gp_Hypr_Translate__SWIG_1 (gp_Hypr *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_Translate\n  * wrapname: _wrap_gp_Hypr_Translate__SWIG_1\n  * fulldecl: void gp_Hypr::Translate(gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Hypr *_wrap_gp_Hypr_Translated__SWIG_1 (gp_Hypr *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  gp_Hypr * lresult = (gp_Hypr *)0 ;
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  gp_Hypr result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Hypr const *)arg1)->Translated((gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Hypr_Translated\n  * wrapname: _wrap_gp_Hypr_Translated__SWIG_1\n  * fulldecl: gp_Hypr gp_Hypr::Translated(gp_Pnt const &,gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr *)0;
  }
}


EXPORT void _wrap_delete_gp_Hypr (gp_Hypr *larg1) {
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Hypr\n  * wrapname: _wrap_delete_gp_Hypr\n  * fulldecl: gp_Hypr::~gp_Hypr()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Torus *_wrap_new_gp_Torus__SWIG_0 () {
  gp_Torus * lresult = (gp_Torus *)0 ;
  gp_Torus *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Torus *)new gp_Torus();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Torus\n  * wrapname: _wrap_new_gp_Torus__SWIG_0\n  * fulldecl: gp_Torus::gp_Torus()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Torus *)0;
  }
}


EXPORT gp_Torus *_wrap_new_gp_Torus__SWIG_1 (gp_Ax3 *larg1, Standard_Real *larg2, Standard_Real *larg3) {
  gp_Torus * lresult = (gp_Torus *)0 ;
  gp_Ax3 *arg1 = 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  gp_Torus *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Torus *)new gp_Torus((gp_Ax3 const &)*arg1,*arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Torus\n  * wrapname: _wrap_new_gp_Torus__SWIG_1\n  * fulldecl: gp_Torus::gp_Torus(gp_Ax3 const &,Standard_Real &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Torus *)0;
  }
}


EXPORT void _wrap_gp_Torus_SetAxis (gp_Torus *larg1, gp_Ax1 *larg2) {
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetAxis((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_SetAxis\n  * wrapname: _wrap_gp_Torus_SetAxis\n  * fulldecl: void gp_Torus::SetAxis(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Torus_SetLocation (gp_Torus *larg1, gp_Pnt *larg2) {
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLocation((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_SetLocation\n  * wrapname: _wrap_gp_Torus_SetLocation\n  * fulldecl: void gp_Torus::SetLocation(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Torus_SetMajorRadius (gp_Torus *larg1, Standard_Real larg2) {
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetMajorRadius(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_SetMajorRadius\n  * wrapname: _wrap_gp_Torus_SetMajorRadius\n  * fulldecl: void gp_Torus::SetMajorRadius(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Torus_SetMinorRadius (gp_Torus *larg1, Standard_Real larg2) {
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetMinorRadius(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_SetMinorRadius\n  * wrapname: _wrap_gp_Torus_SetMinorRadius\n  * fulldecl: void gp_Torus::SetMinorRadius(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Torus_SetPosition (gp_Torus *larg1, gp_Ax3 *larg2) {
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  gp_Ax3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetPosition((gp_Ax3 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_SetPosition\n  * wrapname: _wrap_gp_Torus_SetPosition\n  * fulldecl: void gp_Torus::SetPosition(gp_Ax3 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Real _wrap_gp_Torus_Area (gp_Torus *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Torus const *)arg1)->Area();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_Area\n  * wrapname: _wrap_gp_Torus_Area\n  * fulldecl: Standard_Real gp_Torus::Area() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_gp_Torus_UReverse (gp_Torus *larg1) {
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->UReverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_UReverse\n  * wrapname: _wrap_gp_Torus_UReverse\n  * fulldecl: void gp_Torus::UReverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Torus_VReverse (gp_Torus *larg1) {
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->VReverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_VReverse\n  * wrapname: _wrap_gp_Torus_VReverse\n  * fulldecl: void gp_Torus::VReverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_gp_Torus_Direct (gp_Torus *larg1) {
  bool lresult = (bool)0 ;
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Torus const *)arg1)->Direct();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_Direct\n  * wrapname: _wrap_gp_Torus_Direct\n  * fulldecl: Standard_Boolean gp_Torus::Direct() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Torus_Axis (gp_Torus *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  gp_Ax1 *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax1 *) &((gp_Torus const *)arg1)->Axis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_Axis\n  * wrapname: _wrap_gp_Torus_Axis\n  * fulldecl: gp_Ax1 const & gp_Torus::Axis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT void _wrap_gp_Torus_Coefficients (gp_Torus *larg1, TColStd_Array1OfReal *larg2) {
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((gp_Torus const *)arg1)->Coefficients(*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_Coefficients\n  * wrapname: _wrap_gp_Torus_Coefficients\n  * fulldecl: void gp_Torus::Coefficients(TColStd_Array1OfReal &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pnt *_wrap_gp_Torus_Location (gp_Torus *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  gp_Pnt *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt *) &((gp_Torus const *)arg1)->Location();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_Location\n  * wrapname: _wrap_gp_Torus_Location\n  * fulldecl: gp_Pnt const & gp_Torus::Location() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT gp_Ax3 *_wrap_gp_Torus_Position (gp_Torus *larg1) {
  gp_Ax3 * lresult = (gp_Ax3 *)0 ;
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  gp_Ax3 *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax3 *) &((gp_Torus const *)arg1)->Position();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_Position\n  * wrapname: _wrap_gp_Torus_Position\n  * fulldecl: gp_Ax3 const & gp_Torus::Position() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax3 *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Torus_MajorRadius (gp_Torus *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Torus const *)arg1)->MajorRadius();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_MajorRadius\n  * wrapname: _wrap_gp_Torus_MajorRadius\n  * fulldecl: Standard_Real gp_Torus::MajorRadius() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Torus_MinorRadius (gp_Torus *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Torus const *)arg1)->MinorRadius();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_MinorRadius\n  * wrapname: _wrap_gp_Torus_MinorRadius\n  * fulldecl: Standard_Real gp_Torus::MinorRadius() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Torus_Volume (gp_Torus *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Torus const *)arg1)->Volume();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_Volume\n  * wrapname: _wrap_gp_Torus_Volume\n  * fulldecl: Standard_Real gp_Torus::Volume() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Torus_XAxis (gp_Torus *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Torus const *)arg1)->XAxis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_XAxis\n  * wrapname: _wrap_gp_Torus_XAxis\n  * fulldecl: gp_Ax1 gp_Torus::XAxis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Torus_YAxis (gp_Torus *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Torus const *)arg1)->YAxis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_YAxis\n  * wrapname: _wrap_gp_Torus_YAxis\n  * fulldecl: gp_Ax1 gp_Torus::YAxis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT void _wrap_gp_Torus_Mirror__SWIG_0 (gp_Torus *larg1, gp_Pnt *larg2) {
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_Mirror\n  * wrapname: _wrap_gp_Torus_Mirror__SWIG_0\n  * fulldecl: void gp_Torus::Mirror(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Torus *_wrap_gp_Torus_Mirrored__SWIG_0 (gp_Torus *larg1, gp_Pnt *larg2) {
  gp_Torus * lresult = (gp_Torus *)0 ;
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Torus result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Torus const *)arg1)->Mirrored((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_Mirrored\n  * wrapname: _wrap_gp_Torus_Mirrored__SWIG_0\n  * fulldecl: gp_Torus gp_Torus::Mirrored(gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Torus(result);
    return lresult;
  } catch (...) {
    return (gp_Torus *)0;
  }
}


EXPORT void _wrap_gp_Torus_Mirror__SWIG_1 (gp_Torus *larg1, gp_Ax1 *larg2) {
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_Mirror\n  * wrapname: _wrap_gp_Torus_Mirror__SWIG_1\n  * fulldecl: void gp_Torus::Mirror(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Torus *_wrap_gp_Torus_Mirrored__SWIG_1 (gp_Torus *larg1, gp_Ax1 *larg2) {
  gp_Torus * lresult = (gp_Torus *)0 ;
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  gp_Torus result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Torus const *)arg1)->Mirrored((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_Mirrored\n  * wrapname: _wrap_gp_Torus_Mirrored__SWIG_1\n  * fulldecl: gp_Torus gp_Torus::Mirrored(gp_Ax1 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Torus(result);
    return lresult;
  } catch (...) {
    return (gp_Torus *)0;
  }
}


EXPORT void _wrap_gp_Torus_Mirror__SWIG_2 (gp_Torus *larg1, gp_Ax2 *larg2) {
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_Mirror\n  * wrapname: _wrap_gp_Torus_Mirror__SWIG_2\n  * fulldecl: void gp_Torus::Mirror(gp_Ax2 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Torus *_wrap_gp_Torus_Mirrored__SWIG_2 (gp_Torus *larg1, gp_Ax2 *larg2) {
  gp_Torus * lresult = (gp_Torus *)0 ;
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  gp_Torus result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Torus const *)arg1)->Mirrored((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_Mirrored\n  * wrapname: _wrap_gp_Torus_Mirrored__SWIG_2\n  * fulldecl: gp_Torus gp_Torus::Mirrored(gp_Ax2 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Torus(result);
    return lresult;
  } catch (...) {
    return (gp_Torus *)0;
  }
}


EXPORT void _wrap_gp_Torus_Rotate (gp_Torus *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Rotate((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_Rotate\n  * wrapname: _wrap_gp_Torus_Rotate\n  * fulldecl: void gp_Torus::Rotate(gp_Ax1 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Torus *_wrap_gp_Torus_Rotated (gp_Torus *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Torus * lresult = (gp_Torus *)0 ;
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Torus result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Torus const *)arg1)->Rotated((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_Rotated\n  * wrapname: _wrap_gp_Torus_Rotated\n  * fulldecl: gp_Torus gp_Torus::Rotated(gp_Ax1 const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Torus(result);
    return lresult;
  } catch (...) {
    return (gp_Torus *)0;
  }
}


EXPORT void _wrap_gp_Torus_Scale (gp_Torus *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Scale((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_Scale\n  * wrapname: _wrap_gp_Torus_Scale\n  * fulldecl: void gp_Torus::Scale(gp_Pnt const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Torus *_wrap_gp_Torus_Scaled (gp_Torus *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  gp_Torus * lresult = (gp_Torus *)0 ;
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Torus result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Torus const *)arg1)->Scaled((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_Scaled\n  * wrapname: _wrap_gp_Torus_Scaled\n  * fulldecl: gp_Torus gp_Torus::Scaled(gp_Pnt const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Torus(result);
    return lresult;
  } catch (...) {
    return (gp_Torus *)0;
  }
}


EXPORT void _wrap_gp_Torus_Transform (gp_Torus *larg1, gp_Trsf *larg2) {
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  gp_Trsf *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Transform((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_Transform\n  * wrapname: _wrap_gp_Torus_Transform\n  * fulldecl: void gp_Torus::Transform(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Torus *_wrap_gp_Torus_Transformed (gp_Torus *larg1, gp_Trsf *larg2) {
  gp_Torus * lresult = (gp_Torus *)0 ;
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  gp_Trsf *arg2 = 0 ;
  gp_Torus result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Torus const *)arg1)->Transformed((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_Transformed\n  * wrapname: _wrap_gp_Torus_Transformed\n  * fulldecl: gp_Torus gp_Torus::Transformed(gp_Trsf const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Torus(result);
    return lresult;
  } catch (...) {
    return (gp_Torus *)0;
  }
}


EXPORT void _wrap_gp_Torus_Translate__SWIG_0 (gp_Torus *larg1, gp_Vec *larg2) {
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  gp_Vec *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_Translate\n  * wrapname: _wrap_gp_Torus_Translate__SWIG_0\n  * fulldecl: void gp_Torus::Translate(gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Torus *_wrap_gp_Torus_Translated__SWIG_0 (gp_Torus *larg1, gp_Vec *larg2) {
  gp_Torus * lresult = (gp_Torus *)0 ;
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  gp_Vec *arg2 = 0 ;
  gp_Torus result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Torus const *)arg1)->Translated((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_Translated\n  * wrapname: _wrap_gp_Torus_Translated__SWIG_0\n  * fulldecl: gp_Torus gp_Torus::Translated(gp_Vec const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Torus(result);
    return lresult;
  } catch (...) {
    return (gp_Torus *)0;
  }
}


EXPORT void _wrap_gp_Torus_Translate__SWIG_1 (gp_Torus *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_Translate\n  * wrapname: _wrap_gp_Torus_Translate__SWIG_1\n  * fulldecl: void gp_Torus::Translate(gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Torus *_wrap_gp_Torus_Translated__SWIG_1 (gp_Torus *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  gp_Torus * lresult = (gp_Torus *)0 ;
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  gp_Torus result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Torus const *)arg1)->Translated((gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Torus_Translated\n  * wrapname: _wrap_gp_Torus_Translated__SWIG_1\n  * fulldecl: gp_Torus gp_Torus::Translated(gp_Pnt const &,gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Torus(result);
    return lresult;
  } catch (...) {
    return (gp_Torus *)0;
  }
}


EXPORT void _wrap_delete_gp_Torus (gp_Torus *larg1) {
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Torus\n  * wrapname: _wrap_delete_gp_Torus\n  * fulldecl: gp_Torus::~gp_Torus()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Sphere *_wrap_new_gp_Sphere__SWIG_0 () {
  gp_Sphere * lresult = (gp_Sphere *)0 ;
  gp_Sphere *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Sphere *)new gp_Sphere();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Sphere\n  * wrapname: _wrap_new_gp_Sphere__SWIG_0\n  * fulldecl: gp_Sphere::gp_Sphere()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Sphere *)0;
  }
}


EXPORT gp_Sphere *_wrap_new_gp_Sphere__SWIG_1 (gp_Ax3 *larg1, Standard_Real *larg2) {
  gp_Sphere * lresult = (gp_Sphere *)0 ;
  gp_Ax3 *arg1 = 0 ;
  Standard_Real *arg2 = 0 ;
  gp_Sphere *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Sphere *)new gp_Sphere((gp_Ax3 const &)*arg1,*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Sphere\n  * wrapname: _wrap_new_gp_Sphere__SWIG_1\n  * fulldecl: gp_Sphere::gp_Sphere(gp_Ax3 const &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Sphere *)0;
  }
}


EXPORT void _wrap_gp_Sphere_SetLocation (gp_Sphere *larg1, gp_Pnt *larg2) {
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLocation((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Sphere_SetLocation\n  * wrapname: _wrap_gp_Sphere_SetLocation\n  * fulldecl: void gp_Sphere::SetLocation(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Sphere_SetPosition (gp_Sphere *larg1, gp_Ax3 *larg2) {
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  gp_Ax3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetPosition((gp_Ax3 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Sphere_SetPosition\n  * wrapname: _wrap_gp_Sphere_SetPosition\n  * fulldecl: void gp_Sphere::SetPosition(gp_Ax3 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Sphere_SetRadius (gp_Sphere *larg1, Standard_Real larg2) {
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetRadius(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Sphere_SetRadius\n  * wrapname: _wrap_gp_Sphere_SetRadius\n  * fulldecl: void gp_Sphere::SetRadius(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Real _wrap_gp_Sphere_Area (gp_Sphere *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Sphere const *)arg1)->Area();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Sphere_Area\n  * wrapname: _wrap_gp_Sphere_Area\n  * fulldecl: Standard_Real gp_Sphere::Area() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_gp_Sphere_Coefficients (gp_Sphere *larg1, Standard_Real *larg2, Standard_Real *larg3, Standard_Real *larg4, Standard_Real *larg5, Standard_Real *larg6, Standard_Real *larg7, Standard_Real *larg8, Standard_Real *larg9, Standard_Real *larg10, Standard_Real *larg11) {
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  Standard_Real *arg5 = 0 ;
  Standard_Real *arg6 = 0 ;
  Standard_Real *arg7 = 0 ;
  Standard_Real *arg8 = 0 ;
  Standard_Real *arg9 = 0 ;
  Standard_Real *arg10 = 0 ;
  Standard_Real *arg11 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  arg11 = larg11;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((gp_Sphere const *)arg1)->Coefficients(*arg2,*arg3,*arg4,*arg5,*arg6,*arg7,*arg8,*arg9,*arg10,*arg11);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Sphere_Coefficients\n  * wrapname: _wrap_gp_Sphere_Coefficients\n  * fulldecl: void gp_Sphere::Coefficients(Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Sphere_UReverse (gp_Sphere *larg1) {
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->UReverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Sphere_UReverse\n  * wrapname: _wrap_gp_Sphere_UReverse\n  * fulldecl: void gp_Sphere::UReverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Sphere_VReverse (gp_Sphere *larg1) {
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->VReverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Sphere_VReverse\n  * wrapname: _wrap_gp_Sphere_VReverse\n  * fulldecl: void gp_Sphere::VReverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_gp_Sphere_Direct (gp_Sphere *larg1) {
  bool lresult = (bool)0 ;
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Sphere const *)arg1)->Direct();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Sphere_Direct\n  * wrapname: _wrap_gp_Sphere_Direct\n  * fulldecl: Standard_Boolean gp_Sphere::Direct() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT gp_Pnt *_wrap_gp_Sphere_Location (gp_Sphere *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  gp_Pnt *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt *) &((gp_Sphere const *)arg1)->Location();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Sphere_Location\n  * wrapname: _wrap_gp_Sphere_Location\n  * fulldecl: gp_Pnt const & gp_Sphere::Location() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT gp_Ax3 *_wrap_gp_Sphere_Position (gp_Sphere *larg1) {
  gp_Ax3 * lresult = (gp_Ax3 *)0 ;
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  gp_Ax3 *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax3 *) &((gp_Sphere const *)arg1)->Position();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Sphere_Position\n  * wrapname: _wrap_gp_Sphere_Position\n  * fulldecl: gp_Ax3 const & gp_Sphere::Position() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax3 *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Sphere_Radius (gp_Sphere *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Sphere const *)arg1)->Radius();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Sphere_Radius\n  * wrapname: _wrap_gp_Sphere_Radius\n  * fulldecl: Standard_Real gp_Sphere::Radius() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Sphere_Volume (gp_Sphere *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Sphere const *)arg1)->Volume();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Sphere_Volume\n  * wrapname: _wrap_gp_Sphere_Volume\n  * fulldecl: Standard_Real gp_Sphere::Volume() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Sphere_XAxis (gp_Sphere *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Sphere const *)arg1)->XAxis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Sphere_XAxis\n  * wrapname: _wrap_gp_Sphere_XAxis\n  * fulldecl: gp_Ax1 gp_Sphere::XAxis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Sphere_YAxis (gp_Sphere *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Sphere const *)arg1)->YAxis();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Sphere_YAxis\n  * wrapname: _wrap_gp_Sphere_YAxis\n  * fulldecl: gp_Ax1 gp_Sphere::YAxis() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT void _wrap_gp_Sphere_Mirror__SWIG_0 (gp_Sphere *larg1, gp_Pnt *larg2) {
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Sphere_Mirror\n  * wrapname: _wrap_gp_Sphere_Mirror__SWIG_0\n  * fulldecl: void gp_Sphere::Mirror(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Sphere *_wrap_gp_Sphere_Mirrored__SWIG_0 (gp_Sphere *larg1, gp_Pnt *larg2) {
  gp_Sphere * lresult = (gp_Sphere *)0 ;
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Sphere result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Sphere const *)arg1)->Mirrored((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Sphere_Mirrored\n  * wrapname: _wrap_gp_Sphere_Mirrored__SWIG_0\n  * fulldecl: gp_Sphere gp_Sphere::Mirrored(gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Sphere(result);
    return lresult;
  } catch (...) {
    return (gp_Sphere *)0;
  }
}


EXPORT void _wrap_gp_Sphere_Mirror__SWIG_1 (gp_Sphere *larg1, gp_Ax1 *larg2) {
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Sphere_Mirror\n  * wrapname: _wrap_gp_Sphere_Mirror__SWIG_1\n  * fulldecl: void gp_Sphere::Mirror(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Sphere *_wrap_gp_Sphere_Mirrored__SWIG_1 (gp_Sphere *larg1, gp_Ax1 *larg2) {
  gp_Sphere * lresult = (gp_Sphere *)0 ;
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  gp_Sphere result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Sphere const *)arg1)->Mirrored((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Sphere_Mirrored\n  * wrapname: _wrap_gp_Sphere_Mirrored__SWIG_1\n  * fulldecl: gp_Sphere gp_Sphere::Mirrored(gp_Ax1 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Sphere(result);
    return lresult;
  } catch (...) {
    return (gp_Sphere *)0;
  }
}


EXPORT void _wrap_gp_Sphere_Mirror__SWIG_2 (gp_Sphere *larg1, gp_Ax2 *larg2) {
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Sphere_Mirror\n  * wrapname: _wrap_gp_Sphere_Mirror__SWIG_2\n  * fulldecl: void gp_Sphere::Mirror(gp_Ax2 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Sphere *_wrap_gp_Sphere_Mirrored__SWIG_2 (gp_Sphere *larg1, gp_Ax2 *larg2) {
  gp_Sphere * lresult = (gp_Sphere *)0 ;
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  gp_Sphere result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Sphere const *)arg1)->Mirrored((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Sphere_Mirrored\n  * wrapname: _wrap_gp_Sphere_Mirrored__SWIG_2\n  * fulldecl: gp_Sphere gp_Sphere::Mirrored(gp_Ax2 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Sphere(result);
    return lresult;
  } catch (...) {
    return (gp_Sphere *)0;
  }
}


EXPORT void _wrap_gp_Sphere_Rotate (gp_Sphere *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Rotate((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Sphere_Rotate\n  * wrapname: _wrap_gp_Sphere_Rotate\n  * fulldecl: void gp_Sphere::Rotate(gp_Ax1 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Sphere *_wrap_gp_Sphere_Rotated (gp_Sphere *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Sphere * lresult = (gp_Sphere *)0 ;
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Sphere result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Sphere const *)arg1)->Rotated((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Sphere_Rotated\n  * wrapname: _wrap_gp_Sphere_Rotated\n  * fulldecl: gp_Sphere gp_Sphere::Rotated(gp_Ax1 const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Sphere(result);
    return lresult;
  } catch (...) {
    return (gp_Sphere *)0;
  }
}


EXPORT void _wrap_gp_Sphere_Scale (gp_Sphere *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Scale((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Sphere_Scale\n  * wrapname: _wrap_gp_Sphere_Scale\n  * fulldecl: void gp_Sphere::Scale(gp_Pnt const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Sphere *_wrap_gp_Sphere_Scaled (gp_Sphere *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  gp_Sphere * lresult = (gp_Sphere *)0 ;
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Sphere result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Sphere const *)arg1)->Scaled((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Sphere_Scaled\n  * wrapname: _wrap_gp_Sphere_Scaled\n  * fulldecl: gp_Sphere gp_Sphere::Scaled(gp_Pnt const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Sphere(result);
    return lresult;
  } catch (...) {
    return (gp_Sphere *)0;
  }
}


EXPORT void _wrap_gp_Sphere_Transform (gp_Sphere *larg1, gp_Trsf *larg2) {
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  gp_Trsf *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Transform((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Sphere_Transform\n  * wrapname: _wrap_gp_Sphere_Transform\n  * fulldecl: void gp_Sphere::Transform(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Sphere *_wrap_gp_Sphere_Transformed (gp_Sphere *larg1, gp_Trsf *larg2) {
  gp_Sphere * lresult = (gp_Sphere *)0 ;
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  gp_Trsf *arg2 = 0 ;
  gp_Sphere result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Sphere const *)arg1)->Transformed((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Sphere_Transformed\n  * wrapname: _wrap_gp_Sphere_Transformed\n  * fulldecl: gp_Sphere gp_Sphere::Transformed(gp_Trsf const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Sphere(result);
    return lresult;
  } catch (...) {
    return (gp_Sphere *)0;
  }
}


EXPORT void _wrap_gp_Sphere_Translate__SWIG_0 (gp_Sphere *larg1, gp_Vec *larg2) {
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  gp_Vec *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Sphere_Translate\n  * wrapname: _wrap_gp_Sphere_Translate__SWIG_0\n  * fulldecl: void gp_Sphere::Translate(gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Sphere *_wrap_gp_Sphere_Translated__SWIG_0 (gp_Sphere *larg1, gp_Vec *larg2) {
  gp_Sphere * lresult = (gp_Sphere *)0 ;
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  gp_Vec *arg2 = 0 ;
  gp_Sphere result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Sphere const *)arg1)->Translated((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Sphere_Translated\n  * wrapname: _wrap_gp_Sphere_Translated__SWIG_0\n  * fulldecl: gp_Sphere gp_Sphere::Translated(gp_Vec const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Sphere(result);
    return lresult;
  } catch (...) {
    return (gp_Sphere *)0;
  }
}


EXPORT void _wrap_gp_Sphere_Translate__SWIG_1 (gp_Sphere *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Sphere_Translate\n  * wrapname: _wrap_gp_Sphere_Translate__SWIG_1\n  * fulldecl: void gp_Sphere::Translate(gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Sphere *_wrap_gp_Sphere_Translated__SWIG_1 (gp_Sphere *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  gp_Sphere * lresult = (gp_Sphere *)0 ;
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  gp_Sphere result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Sphere const *)arg1)->Translated((gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Sphere_Translated\n  * wrapname: _wrap_gp_Sphere_Translated__SWIG_1\n  * fulldecl: gp_Sphere gp_Sphere::Translated(gp_Pnt const &,gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Sphere(result);
    return lresult;
  } catch (...) {
    return (gp_Sphere *)0;
  }
}


EXPORT void _wrap_delete_gp_Sphere (gp_Sphere *larg1) {
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Sphere\n  * wrapname: _wrap_delete_gp_Sphere\n  * fulldecl: gp_Sphere::~gp_Sphere()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_XY *_wrap_new_gp_XY__SWIG_0 () {
  gp_XY * lresult = (gp_XY *)0 ;
  gp_XY *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_XY *)new gp_XY();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_XY\n  * wrapname: _wrap_new_gp_XY__SWIG_0\n  * fulldecl: gp_XY::gp_XY()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_XY *)0;
  }
}


EXPORT gp_XY *_wrap_new_gp_XY__SWIG_1 (Standard_Real larg1, Standard_Real larg2) {
  gp_XY * lresult = (gp_XY *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  gp_XY *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_XY *)new gp_XY(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_XY\n  * wrapname: _wrap_new_gp_XY__SWIG_1\n  * fulldecl: gp_XY::gp_XY(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_XY *)0;
  }
}


EXPORT void _wrap_gp_XY_SetCoord (gp_XY *larg1, Standard_Real larg2, Standard_Real larg3) {
  gp_XY *arg1 = (gp_XY *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetCoord(arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_SetCoord\n  * wrapname: _wrap_gp_XY_SetCoord\n  * fulldecl: void gp_XY::SetCoord(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_XY_SetX (gp_XY *larg1, Standard_Real larg2) {
  gp_XY *arg1 = (gp_XY *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetX(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_SetX\n  * wrapname: _wrap_gp_XY_SetX\n  * fulldecl: void gp_XY::SetX(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_XY_SetY (gp_XY *larg1, Standard_Real larg2) {
  gp_XY *arg1 = (gp_XY *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetY(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_SetY\n  * wrapname: _wrap_gp_XY_SetY\n  * fulldecl: void gp_XY::SetY(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Real _wrap_gp_XY_X (gp_XY *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_XY *arg1 = (gp_XY *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_XY const *)arg1)->X();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_X\n  * wrapname: _wrap_gp_XY_X\n  * fulldecl: Standard_Real gp_XY::X() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_XY_Y (gp_XY *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_XY *arg1 = (gp_XY *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_XY const *)arg1)->Y();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_Y\n  * wrapname: _wrap_gp_XY_Y\n  * fulldecl: Standard_Real gp_XY::Y() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_XY_Modulus (gp_XY *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_XY *arg1 = (gp_XY *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_XY const *)arg1)->Modulus();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_Modulus\n  * wrapname: _wrap_gp_XY_Modulus\n  * fulldecl: Standard_Real gp_XY::Modulus() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_XY_SquareModulus (gp_XY *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_XY *arg1 = (gp_XY *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_XY const *)arg1)->SquareModulus();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_SquareModulus\n  * wrapname: _wrap_gp_XY_SquareModulus\n  * fulldecl: Standard_Real gp_XY::SquareModulus() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT bool _wrap_gp_XY_IsEqual (gp_XY *larg1, gp_XY *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  gp_XY *arg1 = (gp_XY *) 0 ;
  gp_XY *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_XY const *)arg1)->IsEqual((gp_XY const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_IsEqual\n  * wrapname: _wrap_gp_XY_IsEqual\n  * fulldecl: Standard_Boolean gp_XY::IsEqual(gp_XY const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_gp_XY_Add (gp_XY *larg1, gp_XY *larg2) {
  gp_XY *arg1 = (gp_XY *) 0 ;
  gp_XY *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Add((gp_XY const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_Add\n  * wrapname: _wrap_gp_XY_Add\n  * fulldecl: void gp_XY::Add(gp_XY const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_XY *_wrap_gp_XY_Added (gp_XY *larg1, gp_XY *larg2) {
  gp_XY * lresult = (gp_XY *)0 ;
  gp_XY *arg1 = (gp_XY *) 0 ;
  gp_XY *arg2 = 0 ;
  gp_XY result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_XY const *)arg1)->Added((gp_XY const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_Added\n  * wrapname: _wrap_gp_XY_Added\n  * fulldecl: gp_XY gp_XY::Added(gp_XY const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_XY(result);
    return lresult;
  } catch (...) {
    return (gp_XY *)0;
  }
}


EXPORT Standard_Real _wrap_gp_XY_Crossed (gp_XY *larg1, gp_XY *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_XY *arg1 = (gp_XY *) 0 ;
  gp_XY *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_XY const *)arg1)->Crossed((gp_XY const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_Crossed\n  * wrapname: _wrap_gp_XY_Crossed\n  * fulldecl: Standard_Real gp_XY::Crossed(gp_XY const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_XY_CrossMagnitude (gp_XY *larg1, gp_XY *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_XY *arg1 = (gp_XY *) 0 ;
  gp_XY *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_XY const *)arg1)->CrossMagnitude((gp_XY const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_CrossMagnitude\n  * wrapname: _wrap_gp_XY_CrossMagnitude\n  * fulldecl: Standard_Real gp_XY::CrossMagnitude(gp_XY const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_XY_CrossSquareMagnitude (gp_XY *larg1, gp_XY *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_XY *arg1 = (gp_XY *) 0 ;
  gp_XY *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_XY const *)arg1)->CrossSquareMagnitude((gp_XY const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_CrossSquareMagnitude\n  * wrapname: _wrap_gp_XY_CrossSquareMagnitude\n  * fulldecl: Standard_Real gp_XY::CrossSquareMagnitude(gp_XY const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_gp_XY_Divide (gp_XY *larg1, Standard_Real larg2) {
  gp_XY *arg1 = (gp_XY *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Divide(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_Divide\n  * wrapname: _wrap_gp_XY_Divide\n  * fulldecl: void gp_XY::Divide(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_XY *_wrap_gp_XY_Divided (gp_XY *larg1, Standard_Real larg2) {
  gp_XY * lresult = (gp_XY *)0 ;
  gp_XY *arg1 = (gp_XY *) 0 ;
  Standard_Real arg2 ;
  gp_XY result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_XY const *)arg1)->Divided(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_Divided\n  * wrapname: _wrap_gp_XY_Divided\n  * fulldecl: gp_XY gp_XY::Divided(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_XY(result);
    return lresult;
  } catch (...) {
    return (gp_XY *)0;
  }
}


EXPORT Standard_Real _wrap_gp_XY_Dot (gp_XY *larg1, gp_XY *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_XY *arg1 = (gp_XY *) 0 ;
  gp_XY *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_XY const *)arg1)->Dot((gp_XY const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_Dot\n  * wrapname: _wrap_gp_XY_Dot\n  * fulldecl: Standard_Real gp_XY::Dot(gp_XY const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_gp_XY_Multiply__SWIG_0 (gp_XY *larg1, Standard_Real larg2) {
  gp_XY *arg1 = (gp_XY *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Multiply(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_Multiply\n  * wrapname: _wrap_gp_XY_Multiply__SWIG_0\n  * fulldecl: void gp_XY::Multiply(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_XY_Multiply__SWIG_1 (gp_XY *larg1, gp_XY *larg2) {
  gp_XY *arg1 = (gp_XY *) 0 ;
  gp_XY *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Multiply((gp_XY const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_Multiply\n  * wrapname: _wrap_gp_XY_Multiply__SWIG_1\n  * fulldecl: void gp_XY::Multiply(gp_XY const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_XY_Multiply__SWIG_2 (gp_XY *larg1, gp_Mat2d *larg2) {
  gp_XY *arg1 = (gp_XY *) 0 ;
  gp_Mat2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Multiply((gp_Mat2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_Multiply\n  * wrapname: _wrap_gp_XY_Multiply__SWIG_2\n  * fulldecl: void gp_XY::Multiply(gp_Mat2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_XY *_wrap_gp_XY_Multiplied__SWIG_0 (gp_XY *larg1, Standard_Real larg2) {
  gp_XY * lresult = (gp_XY *)0 ;
  gp_XY *arg1 = (gp_XY *) 0 ;
  Standard_Real arg2 ;
  gp_XY result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_XY const *)arg1)->Multiplied(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_Multiplied\n  * wrapname: _wrap_gp_XY_Multiplied__SWIG_0\n  * fulldecl: gp_XY gp_XY::Multiplied(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_XY(result);
    return lresult;
  } catch (...) {
    return (gp_XY *)0;
  }
}


EXPORT gp_XY *_wrap_gp_XY_Multiplied__SWIG_1 (gp_XY *larg1, gp_XY *larg2) {
  gp_XY * lresult = (gp_XY *)0 ;
  gp_XY *arg1 = (gp_XY *) 0 ;
  gp_XY *arg2 = 0 ;
  gp_XY result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_XY const *)arg1)->Multiplied((gp_XY const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_Multiplied\n  * wrapname: _wrap_gp_XY_Multiplied__SWIG_1\n  * fulldecl: gp_XY gp_XY::Multiplied(gp_XY const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_XY(result);
    return lresult;
  } catch (...) {
    return (gp_XY *)0;
  }
}


EXPORT gp_XY *_wrap_gp_XY_Multiplied__SWIG_2 (gp_XY *larg1, gp_Mat2d *larg2) {
  gp_XY * lresult = (gp_XY *)0 ;
  gp_XY *arg1 = (gp_XY *) 0 ;
  gp_Mat2d *arg2 = 0 ;
  gp_XY result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_XY const *)arg1)->Multiplied((gp_Mat2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_Multiplied\n  * wrapname: _wrap_gp_XY_Multiplied__SWIG_2\n  * fulldecl: gp_XY gp_XY::Multiplied(gp_Mat2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_XY(result);
    return lresult;
  } catch (...) {
    return (gp_XY *)0;
  }
}


EXPORT void _wrap_gp_XY_Normalize (gp_XY *larg1) {
  gp_XY *arg1 = (gp_XY *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Normalize();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_Normalize\n  * wrapname: _wrap_gp_XY_Normalize\n  * fulldecl: void gp_XY::Normalize()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_XY *_wrap_gp_XY_Normalized (gp_XY *larg1) {
  gp_XY * lresult = (gp_XY *)0 ;
  gp_XY *arg1 = (gp_XY *) 0 ;
  gp_XY result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_XY const *)arg1)->Normalized();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_Normalized\n  * wrapname: _wrap_gp_XY_Normalized\n  * fulldecl: gp_XY gp_XY::Normalized() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_XY(result);
    return lresult;
  } catch (...) {
    return (gp_XY *)0;
  }
}


EXPORT void _wrap_gp_XY_Reverse (gp_XY *larg1) {
  gp_XY *arg1 = (gp_XY *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Reverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_Reverse\n  * wrapname: _wrap_gp_XY_Reverse\n  * fulldecl: void gp_XY::Reverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_XY *_wrap_gp_XY_Reversed (gp_XY *larg1) {
  gp_XY * lresult = (gp_XY *)0 ;
  gp_XY *arg1 = (gp_XY *) 0 ;
  gp_XY result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_XY const *)arg1)->Reversed();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_Reversed\n  * wrapname: _wrap_gp_XY_Reversed\n  * fulldecl: gp_XY gp_XY::Reversed() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_XY(result);
    return lresult;
  } catch (...) {
    return (gp_XY *)0;
  }
}


EXPORT void _wrap_gp_XY_SetLinearForm__SWIG_0 (gp_XY *larg1, Standard_Real larg2, gp_XY *larg3, Standard_Real larg4, gp_XY *larg5) {
  gp_XY *arg1 = (gp_XY *) 0 ;
  Standard_Real arg2 ;
  gp_XY *arg3 = 0 ;
  Standard_Real arg4 ;
  gp_XY *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLinearForm(arg2,(gp_XY const &)*arg3,arg4,(gp_XY const &)*arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_SetLinearForm\n  * wrapname: _wrap_gp_XY_SetLinearForm__SWIG_0\n  * fulldecl: void gp_XY::SetLinearForm(Standard_Real const,gp_XY const &,Standard_Real const,gp_XY const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_XY_SetLinearForm__SWIG_1 (gp_XY *larg1, Standard_Real larg2, gp_XY *larg3, Standard_Real larg4, gp_XY *larg5, gp_XY *larg6) {
  gp_XY *arg1 = (gp_XY *) 0 ;
  Standard_Real arg2 ;
  gp_XY *arg3 = 0 ;
  Standard_Real arg4 ;
  gp_XY *arg5 = 0 ;
  gp_XY *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLinearForm(arg2,(gp_XY const &)*arg3,arg4,(gp_XY const &)*arg5,(gp_XY const &)*arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_SetLinearForm\n  * wrapname: _wrap_gp_XY_SetLinearForm__SWIG_1\n  * fulldecl: void gp_XY::SetLinearForm(Standard_Real const,gp_XY const &,Standard_Real const,gp_XY const &,gp_XY const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_XY_SetLinearForm__SWIG_2 (gp_XY *larg1, Standard_Real larg2, gp_XY *larg3, gp_XY *larg4) {
  gp_XY *arg1 = (gp_XY *) 0 ;
  Standard_Real arg2 ;
  gp_XY *arg3 = 0 ;
  gp_XY *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLinearForm(arg2,(gp_XY const &)*arg3,(gp_XY const &)*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_SetLinearForm\n  * wrapname: _wrap_gp_XY_SetLinearForm__SWIG_2\n  * fulldecl: void gp_XY::SetLinearForm(Standard_Real const,gp_XY const &,gp_XY const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_XY_SetLinearForm__SWIG_3 (gp_XY *larg1, gp_XY *larg2, gp_XY *larg3) {
  gp_XY *arg1 = (gp_XY *) 0 ;
  gp_XY *arg2 = 0 ;
  gp_XY *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLinearForm((gp_XY const &)*arg2,(gp_XY const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_SetLinearForm\n  * wrapname: _wrap_gp_XY_SetLinearForm__SWIG_3\n  * fulldecl: void gp_XY::SetLinearForm(gp_XY const &,gp_XY const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_XY_Subtract (gp_XY *larg1, gp_XY *larg2) {
  gp_XY *arg1 = (gp_XY *) 0 ;
  gp_XY *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Subtract((gp_XY const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_Subtract\n  * wrapname: _wrap_gp_XY_Subtract\n  * fulldecl: void gp_XY::Subtract(gp_XY const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_XY *_wrap_gp_XY_Subtracted (gp_XY *larg1, gp_XY *larg2) {
  gp_XY * lresult = (gp_XY *)0 ;
  gp_XY *arg1 = (gp_XY *) 0 ;
  gp_XY *arg2 = 0 ;
  gp_XY result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_XY const *)arg1)->Subtracted((gp_XY const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_XY_Subtracted\n  * wrapname: _wrap_gp_XY_Subtracted\n  * fulldecl: gp_XY gp_XY::Subtracted(gp_XY const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_XY(result);
    return lresult;
  } catch (...) {
    return (gp_XY *)0;
  }
}


EXPORT void _wrap_delete_gp_XY (gp_XY *larg1) {
  gp_XY *arg1 = (gp_XY *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_XY\n  * wrapname: _wrap_delete_gp_XY\n  * fulldecl: gp_XY::~gp_XY()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Lin *_wrap_new_gp_Lin__SWIG_0 () {
  gp_Lin * lresult = (gp_Lin *)0 ;
  gp_Lin *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Lin *)new gp_Lin();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Lin\n  * wrapname: _wrap_new_gp_Lin__SWIG_0\n  * fulldecl: gp_Lin::gp_Lin()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Lin *)0;
  }
}


EXPORT gp_Lin *_wrap_new_gp_Lin__SWIG_1 (gp_Ax1 *larg1) {
  gp_Lin * lresult = (gp_Lin *)0 ;
  gp_Ax1 *arg1 = 0 ;
  gp_Lin *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Lin *)new gp_Lin((gp_Ax1 const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Lin\n  * wrapname: _wrap_new_gp_Lin__SWIG_1\n  * fulldecl: gp_Lin::gp_Lin(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Lin *)0;
  }
}


EXPORT gp_Lin *_wrap_new_gp_Lin__SWIG_2 (gp_Pnt *larg1, gp_Dir *larg2) {
  gp_Lin * lresult = (gp_Lin *)0 ;
  gp_Pnt *arg1 = 0 ;
  gp_Dir *arg2 = 0 ;
  gp_Lin *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Lin *)new gp_Lin((gp_Pnt const &)*arg1,(gp_Dir const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Lin\n  * wrapname: _wrap_new_gp_Lin__SWIG_2\n  * fulldecl: gp_Lin::gp_Lin(gp_Pnt const &,gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Lin *)0;
  }
}


EXPORT void _wrap_gp_Lin_Reverse (gp_Lin *larg1) {
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Reverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_Reverse\n  * wrapname: _wrap_gp_Lin_Reverse\n  * fulldecl: void gp_Lin::Reverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Lin *_wrap_gp_Lin_Reversed (gp_Lin *larg1) {
  gp_Lin * lresult = (gp_Lin *)0 ;
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  gp_Lin result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Lin const *)arg1)->Reversed();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_Reversed\n  * wrapname: _wrap_gp_Lin_Reversed\n  * fulldecl: gp_Lin gp_Lin::Reversed() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Lin(result);
    return lresult;
  } catch (...) {
    return (gp_Lin *)0;
  }
}


EXPORT void _wrap_gp_Lin_SetDirection (gp_Lin *larg1, gp_Dir *larg2) {
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  gp_Dir *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetDirection((gp_Dir const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_SetDirection\n  * wrapname: _wrap_gp_Lin_SetDirection\n  * fulldecl: void gp_Lin::SetDirection(gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Lin_SetLocation (gp_Lin *larg1, gp_Pnt *larg2) {
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLocation((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_SetLocation\n  * wrapname: _wrap_gp_Lin_SetLocation\n  * fulldecl: void gp_Lin::SetLocation(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Lin_SetPosition (gp_Lin *larg1, gp_Ax1 *larg2) {
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetPosition((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_SetPosition\n  * wrapname: _wrap_gp_Lin_SetPosition\n  * fulldecl: void gp_Lin::SetPosition(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Dir *_wrap_gp_Lin_Direction (gp_Lin *larg1) {
  gp_Dir * lresult = (gp_Dir *)0 ;
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  gp_Dir *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Dir *) &((gp_Lin const *)arg1)->Direction();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_Direction\n  * wrapname: _wrap_gp_Lin_Direction\n  * fulldecl: gp_Dir const & gp_Lin::Direction() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Dir *)0;
  }
}


EXPORT gp_Pnt *_wrap_gp_Lin_Location (gp_Lin *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  gp_Pnt *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt *) &((gp_Lin const *)arg1)->Location();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_Location\n  * wrapname: _wrap_gp_Lin_Location\n  * fulldecl: gp_Pnt const & gp_Lin::Location() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT gp_Ax1 *_wrap_gp_Lin_Position (gp_Lin *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  gp_Ax1 *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax1 *) &((gp_Lin const *)arg1)->Position();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_Position\n  * wrapname: _wrap_gp_Lin_Position\n  * fulldecl: gp_Ax1 const & gp_Lin::Position() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Lin_Angle (gp_Lin *larg1, gp_Lin *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  gp_Lin *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Lin const *)arg1)->Angle((gp_Lin const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_Angle\n  * wrapname: _wrap_gp_Lin_Angle\n  * fulldecl: Standard_Real gp_Lin::Angle(gp_Lin const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT bool _wrap_gp_Lin_Contains (gp_Lin *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Lin const *)arg1)->Contains((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_Contains\n  * wrapname: _wrap_gp_Lin_Contains\n  * fulldecl: Standard_Boolean gp_Lin::Contains(gp_Pnt const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Standard_Real _wrap_gp_Lin_Distance__SWIG_0 (gp_Lin *larg1, gp_Pnt *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Lin const *)arg1)->Distance((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_Distance\n  * wrapname: _wrap_gp_Lin_Distance__SWIG_0\n  * fulldecl: Standard_Real gp_Lin::Distance(gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Lin_Distance__SWIG_1 (gp_Lin *larg1, gp_Lin *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  gp_Lin *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Lin const *)arg1)->Distance((gp_Lin const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_Distance\n  * wrapname: _wrap_gp_Lin_Distance__SWIG_1\n  * fulldecl: Standard_Real gp_Lin::Distance(gp_Lin const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Lin_SquareDistance__SWIG_0 (gp_Lin *larg1, gp_Pnt *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Lin const *)arg1)->SquareDistance((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_SquareDistance\n  * wrapname: _wrap_gp_Lin_SquareDistance__SWIG_0\n  * fulldecl: Standard_Real gp_Lin::SquareDistance(gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Lin_SquareDistance__SWIG_1 (gp_Lin *larg1, gp_Lin *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  gp_Lin *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Lin const *)arg1)->SquareDistance((gp_Lin const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_SquareDistance\n  * wrapname: _wrap_gp_Lin_SquareDistance__SWIG_1\n  * fulldecl: Standard_Real gp_Lin::SquareDistance(gp_Lin const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Lin *_wrap_gp_Lin_Normal (gp_Lin *larg1, gp_Pnt *larg2) {
  gp_Lin * lresult = (gp_Lin *)0 ;
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Lin result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Lin const *)arg1)->Normal((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_Normal\n  * wrapname: _wrap_gp_Lin_Normal\n  * fulldecl: gp_Lin gp_Lin::Normal(gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Lin(result);
    return lresult;
  } catch (...) {
    return (gp_Lin *)0;
  }
}


EXPORT void _wrap_gp_Lin_Mirror__SWIG_0 (gp_Lin *larg1, gp_Pnt *larg2) {
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_Mirror\n  * wrapname: _wrap_gp_Lin_Mirror__SWIG_0\n  * fulldecl: void gp_Lin::Mirror(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Lin *_wrap_gp_Lin_Mirrored__SWIG_0 (gp_Lin *larg1, gp_Pnt *larg2) {
  gp_Lin * lresult = (gp_Lin *)0 ;
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Lin result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Lin const *)arg1)->Mirrored((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_Mirrored\n  * wrapname: _wrap_gp_Lin_Mirrored__SWIG_0\n  * fulldecl: gp_Lin gp_Lin::Mirrored(gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Lin(result);
    return lresult;
  } catch (...) {
    return (gp_Lin *)0;
  }
}


EXPORT void _wrap_gp_Lin_Mirror__SWIG_1 (gp_Lin *larg1, gp_Ax1 *larg2) {
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_Mirror\n  * wrapname: _wrap_gp_Lin_Mirror__SWIG_1\n  * fulldecl: void gp_Lin::Mirror(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Lin *_wrap_gp_Lin_Mirrored__SWIG_1 (gp_Lin *larg1, gp_Ax1 *larg2) {
  gp_Lin * lresult = (gp_Lin *)0 ;
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  gp_Lin result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Lin const *)arg1)->Mirrored((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_Mirrored\n  * wrapname: _wrap_gp_Lin_Mirrored__SWIG_1\n  * fulldecl: gp_Lin gp_Lin::Mirrored(gp_Ax1 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Lin(result);
    return lresult;
  } catch (...) {
    return (gp_Lin *)0;
  }
}


EXPORT void _wrap_gp_Lin_Mirror__SWIG_2 (gp_Lin *larg1, gp_Ax2 *larg2) {
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_Mirror\n  * wrapname: _wrap_gp_Lin_Mirror__SWIG_2\n  * fulldecl: void gp_Lin::Mirror(gp_Ax2 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Lin *_wrap_gp_Lin_Mirrored__SWIG_2 (gp_Lin *larg1, gp_Ax2 *larg2) {
  gp_Lin * lresult = (gp_Lin *)0 ;
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  gp_Lin result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Lin const *)arg1)->Mirrored((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_Mirrored\n  * wrapname: _wrap_gp_Lin_Mirrored__SWIG_2\n  * fulldecl: gp_Lin gp_Lin::Mirrored(gp_Ax2 const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Lin(result);
    return lresult;
  } catch (...) {
    return (gp_Lin *)0;
  }
}


EXPORT void _wrap_gp_Lin_Rotate (gp_Lin *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Rotate((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_Rotate\n  * wrapname: _wrap_gp_Lin_Rotate\n  * fulldecl: void gp_Lin::Rotate(gp_Ax1 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Lin *_wrap_gp_Lin_Rotated (gp_Lin *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Lin * lresult = (gp_Lin *)0 ;
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Lin result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Lin const *)arg1)->Rotated((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_Rotated\n  * wrapname: _wrap_gp_Lin_Rotated\n  * fulldecl: gp_Lin gp_Lin::Rotated(gp_Ax1 const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Lin(result);
    return lresult;
  } catch (...) {
    return (gp_Lin *)0;
  }
}


EXPORT void _wrap_gp_Lin_Scale (gp_Lin *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Scale((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_Scale\n  * wrapname: _wrap_gp_Lin_Scale\n  * fulldecl: void gp_Lin::Scale(gp_Pnt const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Lin *_wrap_gp_Lin_Scaled (gp_Lin *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  gp_Lin * lresult = (gp_Lin *)0 ;
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Lin result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Lin const *)arg1)->Scaled((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_Scaled\n  * wrapname: _wrap_gp_Lin_Scaled\n  * fulldecl: gp_Lin gp_Lin::Scaled(gp_Pnt const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Lin(result);
    return lresult;
  } catch (...) {
    return (gp_Lin *)0;
  }
}


EXPORT void _wrap_gp_Lin_Transform (gp_Lin *larg1, gp_Trsf *larg2) {
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  gp_Trsf *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Transform((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_Transform\n  * wrapname: _wrap_gp_Lin_Transform\n  * fulldecl: void gp_Lin::Transform(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Lin *_wrap_gp_Lin_Transformed (gp_Lin *larg1, gp_Trsf *larg2) {
  gp_Lin * lresult = (gp_Lin *)0 ;
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  gp_Trsf *arg2 = 0 ;
  gp_Lin result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Lin const *)arg1)->Transformed((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_Transformed\n  * wrapname: _wrap_gp_Lin_Transformed\n  * fulldecl: gp_Lin gp_Lin::Transformed(gp_Trsf const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Lin(result);
    return lresult;
  } catch (...) {
    return (gp_Lin *)0;
  }
}


EXPORT void _wrap_gp_Lin_Translate__SWIG_0 (gp_Lin *larg1, gp_Vec *larg2) {
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  gp_Vec *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_Translate\n  * wrapname: _wrap_gp_Lin_Translate__SWIG_0\n  * fulldecl: void gp_Lin::Translate(gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Lin *_wrap_gp_Lin_Translated__SWIG_0 (gp_Lin *larg1, gp_Vec *larg2) {
  gp_Lin * lresult = (gp_Lin *)0 ;
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  gp_Vec *arg2 = 0 ;
  gp_Lin result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Lin const *)arg1)->Translated((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_Translated\n  * wrapname: _wrap_gp_Lin_Translated__SWIG_0\n  * fulldecl: gp_Lin gp_Lin::Translated(gp_Vec const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Lin(result);
    return lresult;
  } catch (...) {
    return (gp_Lin *)0;
  }
}


EXPORT void _wrap_gp_Lin_Translate__SWIG_1 (gp_Lin *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_Translate\n  * wrapname: _wrap_gp_Lin_Translate__SWIG_1\n  * fulldecl: void gp_Lin::Translate(gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Lin *_wrap_gp_Lin_Translated__SWIG_1 (gp_Lin *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  gp_Lin * lresult = (gp_Lin *)0 ;
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  gp_Lin result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Lin const *)arg1)->Translated((gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin_Translated\n  * wrapname: _wrap_gp_Lin_Translated__SWIG_1\n  * fulldecl: gp_Lin gp_Lin::Translated(gp_Pnt const &,gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Lin(result);
    return lresult;
  } catch (...) {
    return (gp_Lin *)0;
  }
}


EXPORT void _wrap_delete_gp_Lin (gp_Lin *larg1) {
  gp_Lin *arg1 = (gp_Lin *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Lin\n  * wrapname: _wrap_delete_gp_Lin\n  * fulldecl: gp_Lin::~gp_Lin()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Lin2d *_wrap_new_gp_Lin2d__SWIG_0 () {
  gp_Lin2d * lresult = (gp_Lin2d *)0 ;
  gp_Lin2d *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Lin2d *)new gp_Lin2d();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Lin2d\n  * wrapname: _wrap_new_gp_Lin2d__SWIG_0\n  * fulldecl: gp_Lin2d::gp_Lin2d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Lin2d *)0;
  }
}


EXPORT gp_Lin2d *_wrap_new_gp_Lin2d__SWIG_1 (gp_Ax2d *larg1) {
  gp_Lin2d * lresult = (gp_Lin2d *)0 ;
  gp_Ax2d *arg1 = 0 ;
  gp_Lin2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Lin2d *)new gp_Lin2d((gp_Ax2d const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Lin2d\n  * wrapname: _wrap_new_gp_Lin2d__SWIG_1\n  * fulldecl: gp_Lin2d::gp_Lin2d(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Lin2d *)0;
  }
}


EXPORT gp_Lin2d *_wrap_new_gp_Lin2d__SWIG_2 (gp_Pnt2d *larg1, gp_Dir2d *larg2) {
  gp_Lin2d * lresult = (gp_Lin2d *)0 ;
  gp_Pnt2d *arg1 = 0 ;
  gp_Dir2d *arg2 = 0 ;
  gp_Lin2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Lin2d *)new gp_Lin2d((gp_Pnt2d const &)*arg1,(gp_Dir2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Lin2d\n  * wrapname: _wrap_new_gp_Lin2d__SWIG_2\n  * fulldecl: gp_Lin2d::gp_Lin2d(gp_Pnt2d const &,gp_Dir2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Lin2d *)0;
  }
}


EXPORT gp_Lin2d *_wrap_new_gp_Lin2d__SWIG_3 (Standard_Real larg1, Standard_Real larg2, Standard_Real larg3) {
  gp_Lin2d * lresult = (gp_Lin2d *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  gp_Lin2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Lin2d *)new gp_Lin2d(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Lin2d\n  * wrapname: _wrap_new_gp_Lin2d__SWIG_3\n  * fulldecl: gp_Lin2d::gp_Lin2d(Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Lin2d *)0;
  }
}


EXPORT void _wrap_gp_Lin2d_Reverse (gp_Lin2d *larg1) {
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Reverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin2d_Reverse\n  * wrapname: _wrap_gp_Lin2d_Reverse\n  * fulldecl: void gp_Lin2d::Reverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Lin2d *_wrap_gp_Lin2d_Reversed (gp_Lin2d *larg1) {
  gp_Lin2d * lresult = (gp_Lin2d *)0 ;
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  gp_Lin2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Lin2d const *)arg1)->Reversed();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin2d_Reversed\n  * wrapname: _wrap_gp_Lin2d_Reversed\n  * fulldecl: gp_Lin2d gp_Lin2d::Reversed() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Lin2d(result);
    return lresult;
  } catch (...) {
    return (gp_Lin2d *)0;
  }
}


EXPORT void _wrap_gp_Lin2d_SetDirection (gp_Lin2d *larg1, gp_Dir2d *larg2) {
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  gp_Dir2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetDirection((gp_Dir2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin2d_SetDirection\n  * wrapname: _wrap_gp_Lin2d_SetDirection\n  * fulldecl: void gp_Lin2d::SetDirection(gp_Dir2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Lin2d_SetLocation (gp_Lin2d *larg1, gp_Pnt2d *larg2) {
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLocation((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin2d_SetLocation\n  * wrapname: _wrap_gp_Lin2d_SetLocation\n  * fulldecl: void gp_Lin2d::SetLocation(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Lin2d_SetPosition (gp_Lin2d *larg1, gp_Ax2d *larg2) {
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetPosition((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin2d_SetPosition\n  * wrapname: _wrap_gp_Lin2d_SetPosition\n  * fulldecl: void gp_Lin2d::SetPosition(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Lin2d_Coefficients (gp_Lin2d *larg1, Standard_Real *larg2, Standard_Real *larg3, Standard_Real *larg4) {
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((gp_Lin2d const *)arg1)->Coefficients(*arg2,*arg3,*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin2d_Coefficients\n  * wrapname: _wrap_gp_Lin2d_Coefficients\n  * fulldecl: void gp_Lin2d::Coefficients(Standard_Real &,Standard_Real &,Standard_Real &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Dir2d *_wrap_gp_Lin2d_Direction (gp_Lin2d *larg1) {
  gp_Dir2d * lresult = (gp_Dir2d *)0 ;
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  gp_Dir2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Dir2d *) &((gp_Lin2d const *)arg1)->Direction();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin2d_Direction\n  * wrapname: _wrap_gp_Lin2d_Direction\n  * fulldecl: gp_Dir2d const & gp_Lin2d::Direction() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Dir2d *)0;
  }
}


EXPORT gp_Pnt2d *_wrap_gp_Lin2d_Location (gp_Lin2d *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  gp_Pnt2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt2d *) &((gp_Lin2d const *)arg1)->Location();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin2d_Location\n  * wrapname: _wrap_gp_Lin2d_Location\n  * fulldecl: gp_Pnt2d const & gp_Lin2d::Location() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT gp_Ax2d *_wrap_gp_Lin2d_Position (gp_Lin2d *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  gp_Ax2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax2d *) &((gp_Lin2d const *)arg1)->Position();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin2d_Position\n  * wrapname: _wrap_gp_Lin2d_Position\n  * fulldecl: gp_Ax2d const & gp_Lin2d::Position() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Lin2d_Angle (gp_Lin2d *larg1, gp_Lin2d *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  gp_Lin2d *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Lin2d const *)arg1)->Angle((gp_Lin2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin2d_Angle\n  * wrapname: _wrap_gp_Lin2d_Angle\n  * fulldecl: Standard_Real gp_Lin2d::Angle(gp_Lin2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT bool _wrap_gp_Lin2d_Contains (gp_Lin2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Lin2d const *)arg1)->Contains((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin2d_Contains\n  * wrapname: _wrap_gp_Lin2d_Contains\n  * fulldecl: Standard_Boolean gp_Lin2d::Contains(gp_Pnt2d const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Standard_Real _wrap_gp_Lin2d_Distance__SWIG_0 (gp_Lin2d *larg1, gp_Pnt2d *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Lin2d const *)arg1)->Distance((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin2d_Distance\n  * wrapname: _wrap_gp_Lin2d_Distance__SWIG_0\n  * fulldecl: Standard_Real gp_Lin2d::Distance(gp_Pnt2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Lin2d_Distance__SWIG_1 (gp_Lin2d *larg1, gp_Lin2d *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  gp_Lin2d *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Lin2d const *)arg1)->Distance((gp_Lin2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin2d_Distance\n  * wrapname: _wrap_gp_Lin2d_Distance__SWIG_1\n  * fulldecl: Standard_Real gp_Lin2d::Distance(gp_Lin2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Lin2d_SquareDistance__SWIG_0 (gp_Lin2d *larg1, gp_Pnt2d *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Lin2d const *)arg1)->SquareDistance((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin2d_SquareDistance\n  * wrapname: _wrap_gp_Lin2d_SquareDistance__SWIG_0\n  * fulldecl: Standard_Real gp_Lin2d::SquareDistance(gp_Pnt2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Lin2d_SquareDistance__SWIG_1 (gp_Lin2d *larg1, gp_Lin2d *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  gp_Lin2d *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Lin2d const *)arg1)->SquareDistance((gp_Lin2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin2d_SquareDistance\n  * wrapname: _wrap_gp_Lin2d_SquareDistance__SWIG_1\n  * fulldecl: Standard_Real gp_Lin2d::SquareDistance(gp_Lin2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Lin2d *_wrap_gp_Lin2d_Normal (gp_Lin2d *larg1, gp_Pnt2d *larg2) {
  gp_Lin2d * lresult = (gp_Lin2d *)0 ;
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Lin2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Lin2d const *)arg1)->Normal((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin2d_Normal\n  * wrapname: _wrap_gp_Lin2d_Normal\n  * fulldecl: gp_Lin2d gp_Lin2d::Normal(gp_Pnt2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Lin2d(result);
    return lresult;
  } catch (...) {
    return (gp_Lin2d *)0;
  }
}


EXPORT void _wrap_gp_Lin2d_Mirror__SWIG_0 (gp_Lin2d *larg1, gp_Pnt2d *larg2) {
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin2d_Mirror\n  * wrapname: _wrap_gp_Lin2d_Mirror__SWIG_0\n  * fulldecl: void gp_Lin2d::Mirror(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Lin2d *_wrap_gp_Lin2d_Mirrored__SWIG_0 (gp_Lin2d *larg1, gp_Pnt2d *larg2) {
  gp_Lin2d * lresult = (gp_Lin2d *)0 ;
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Lin2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Lin2d const *)arg1)->Mirrored((gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin2d_Mirrored\n  * wrapname: _wrap_gp_Lin2d_Mirrored__SWIG_0\n  * fulldecl: gp_Lin2d gp_Lin2d::Mirrored(gp_Pnt2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Lin2d(result);
    return lresult;
  } catch (...) {
    return (gp_Lin2d *)0;
  }
}


EXPORT void _wrap_gp_Lin2d_Mirror__SWIG_1 (gp_Lin2d *larg1, gp_Ax2d *larg2) {
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Mirror((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin2d_Mirror\n  * wrapname: _wrap_gp_Lin2d_Mirror__SWIG_1\n  * fulldecl: void gp_Lin2d::Mirror(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Lin2d *_wrap_gp_Lin2d_Mirrored__SWIG_1 (gp_Lin2d *larg1, gp_Ax2d *larg2) {
  gp_Lin2d * lresult = (gp_Lin2d *)0 ;
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  gp_Lin2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Lin2d const *)arg1)->Mirrored((gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin2d_Mirrored\n  * wrapname: _wrap_gp_Lin2d_Mirrored__SWIG_1\n  * fulldecl: gp_Lin2d gp_Lin2d::Mirrored(gp_Ax2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Lin2d(result);
    return lresult;
  } catch (...) {
    return (gp_Lin2d *)0;
  }
}


EXPORT void _wrap_gp_Lin2d_Rotate (gp_Lin2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Rotate((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin2d_Rotate\n  * wrapname: _wrap_gp_Lin2d_Rotate\n  * fulldecl: void gp_Lin2d::Rotate(gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Lin2d *_wrap_gp_Lin2d_Rotated (gp_Lin2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Lin2d * lresult = (gp_Lin2d *)0 ;
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Lin2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Lin2d const *)arg1)->Rotated((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin2d_Rotated\n  * wrapname: _wrap_gp_Lin2d_Rotated\n  * fulldecl: gp_Lin2d gp_Lin2d::Rotated(gp_Pnt2d const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Lin2d(result);
    return lresult;
  } catch (...) {
    return (gp_Lin2d *)0;
  }
}


EXPORT void _wrap_gp_Lin2d_Scale (gp_Lin2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Scale((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin2d_Scale\n  * wrapname: _wrap_gp_Lin2d_Scale\n  * fulldecl: void gp_Lin2d::Scale(gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Lin2d *_wrap_gp_Lin2d_Scaled (gp_Lin2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  gp_Lin2d * lresult = (gp_Lin2d *)0 ;
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Lin2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Lin2d const *)arg1)->Scaled((gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin2d_Scaled\n  * wrapname: _wrap_gp_Lin2d_Scaled\n  * fulldecl: gp_Lin2d gp_Lin2d::Scaled(gp_Pnt2d const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Lin2d(result);
    return lresult;
  } catch (...) {
    return (gp_Lin2d *)0;
  }
}


EXPORT void _wrap_gp_Lin2d_Transform (gp_Lin2d *larg1, gp_Trsf2d *larg2) {
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Transform((gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin2d_Transform\n  * wrapname: _wrap_gp_Lin2d_Transform\n  * fulldecl: void gp_Lin2d::Transform(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Lin2d *_wrap_gp_Lin2d_Transformed (gp_Lin2d *larg1, gp_Trsf2d *larg2) {
  gp_Lin2d * lresult = (gp_Lin2d *)0 ;
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  gp_Lin2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Lin2d const *)arg1)->Transformed((gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin2d_Transformed\n  * wrapname: _wrap_gp_Lin2d_Transformed\n  * fulldecl: gp_Lin2d gp_Lin2d::Transformed(gp_Trsf2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Lin2d(result);
    return lresult;
  } catch (...) {
    return (gp_Lin2d *)0;
  }
}


EXPORT void _wrap_gp_Lin2d_Translate__SWIG_0 (gp_Lin2d *larg1, gp_Vec2d *larg2) {
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin2d_Translate\n  * wrapname: _wrap_gp_Lin2d_Translate__SWIG_0\n  * fulldecl: void gp_Lin2d::Translate(gp_Vec2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Lin2d *_wrap_gp_Lin2d_Translated__SWIG_0 (gp_Lin2d *larg1, gp_Vec2d *larg2) {
  gp_Lin2d * lresult = (gp_Lin2d *)0 ;
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  gp_Lin2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Lin2d const *)arg1)->Translated((gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin2d_Translated\n  * wrapname: _wrap_gp_Lin2d_Translated__SWIG_0\n  * fulldecl: gp_Lin2d gp_Lin2d::Translated(gp_Vec2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Lin2d(result);
    return lresult;
  } catch (...) {
    return (gp_Lin2d *)0;
  }
}


EXPORT void _wrap_gp_Lin2d_Translate__SWIG_1 (gp_Lin2d *larg1, gp_Pnt2d *larg2, gp_Pnt2d *larg3) {
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Pnt2d *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Translate((gp_Pnt2d const &)*arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin2d_Translate\n  * wrapname: _wrap_gp_Lin2d_Translate__SWIG_1\n  * fulldecl: void gp_Lin2d::Translate(gp_Pnt2d const &,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Lin2d *_wrap_gp_Lin2d_Translated__SWIG_1 (gp_Lin2d *larg1, gp_Pnt2d *larg2, gp_Pnt2d *larg3) {
  gp_Lin2d * lresult = (gp_Lin2d *)0 ;
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Pnt2d *arg3 = 0 ;
  gp_Lin2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Lin2d const *)arg1)->Translated((gp_Pnt2d const &)*arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Lin2d_Translated\n  * wrapname: _wrap_gp_Lin2d_Translated__SWIG_1\n  * fulldecl: gp_Lin2d gp_Lin2d::Translated(gp_Pnt2d const &,gp_Pnt2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Lin2d(result);
    return lresult;
  } catch (...) {
    return (gp_Lin2d *)0;
  }
}


EXPORT void _wrap_delete_gp_Lin2d (gp_Lin2d *larg1) {
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Lin2d\n  * wrapname: _wrap_delete_gp_Lin2d\n  * fulldecl: gp_Lin2d::~gp_Lin2d()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Mat *_wrap_new_gp_Mat__SWIG_0 () {
  gp_Mat * lresult = (gp_Mat *)0 ;
  gp_Mat *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Mat *)new gp_Mat();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Mat\n  * wrapname: _wrap_new_gp_Mat__SWIG_0\n  * fulldecl: gp_Mat::gp_Mat()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Mat *)0;
  }
}


EXPORT gp_Mat *_wrap_new_gp_Mat__SWIG_1 (Standard_Real larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5, Standard_Real larg6, Standard_Real larg7, Standard_Real larg8, Standard_Real larg9) {
  gp_Mat * lresult = (gp_Mat *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  Standard_Real arg6 ;
  Standard_Real arg7 ;
  Standard_Real arg8 ;
  Standard_Real arg9 ;
  gp_Mat *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Mat *)new gp_Mat(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Mat\n  * wrapname: _wrap_new_gp_Mat__SWIG_1\n  * fulldecl: gp_Mat::gp_Mat(Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Mat *)0;
  }
}


EXPORT gp_Mat *_wrap_new_gp_Mat__SWIG_2 (gp_XYZ *larg1, gp_XYZ *larg2, gp_XYZ *larg3) {
  gp_Mat * lresult = (gp_Mat *)0 ;
  gp_XYZ *arg1 = 0 ;
  gp_XYZ *arg2 = 0 ;
  gp_XYZ *arg3 = 0 ;
  gp_Mat *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Mat *)new gp_Mat((gp_XYZ const &)*arg1,(gp_XYZ const &)*arg2,(gp_XYZ const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Mat\n  * wrapname: _wrap_new_gp_Mat__SWIG_2\n  * fulldecl: gp_Mat::gp_Mat(gp_XYZ const &,gp_XYZ const &,gp_XYZ const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Mat *)0;
  }
}


EXPORT void _wrap_gp_Mat_SetCol (gp_Mat *larg1, Standard_Integer larg2, gp_XYZ *larg3) {
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  Standard_Integer arg2 ;
  gp_XYZ *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetCol(arg2,(gp_XYZ const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_SetCol\n  * wrapname: _wrap_gp_Mat_SetCol\n  * fulldecl: void gp_Mat::SetCol(Standard_Integer const,gp_XYZ const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Mat_SetCols (gp_Mat *larg1, gp_XYZ *larg2, gp_XYZ *larg3, gp_XYZ *larg4) {
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  gp_XYZ *arg2 = 0 ;
  gp_XYZ *arg3 = 0 ;
  gp_XYZ *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetCols((gp_XYZ const &)*arg2,(gp_XYZ const &)*arg3,(gp_XYZ const &)*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_SetCols\n  * wrapname: _wrap_gp_Mat_SetCols\n  * fulldecl: void gp_Mat::SetCols(gp_XYZ const &,gp_XYZ const &,gp_XYZ const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Mat_SetCross (gp_Mat *larg1, gp_XYZ *larg2) {
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  gp_XYZ *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetCross((gp_XYZ const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_SetCross\n  * wrapname: _wrap_gp_Mat_SetCross\n  * fulldecl: void gp_Mat::SetCross(gp_XYZ const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Mat_SetDiagonal (gp_Mat *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4) {
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetDiagonal(arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_SetDiagonal\n  * wrapname: _wrap_gp_Mat_SetDiagonal\n  * fulldecl: void gp_Mat::SetDiagonal(Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Mat_SetDot (gp_Mat *larg1, gp_XYZ *larg2) {
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  gp_XYZ *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetDot((gp_XYZ const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_SetDot\n  * wrapname: _wrap_gp_Mat_SetDot\n  * fulldecl: void gp_Mat::SetDot(gp_XYZ const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Mat_SetIdentity (gp_Mat *larg1) {
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetIdentity();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_SetIdentity\n  * wrapname: _wrap_gp_Mat_SetIdentity\n  * fulldecl: void gp_Mat::SetIdentity()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Mat_SetRotation (gp_Mat *larg1, gp_XYZ *larg2, Standard_Real larg3) {
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  gp_XYZ *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetRotation((gp_XYZ const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_SetRotation\n  * wrapname: _wrap_gp_Mat_SetRotation\n  * fulldecl: void gp_Mat::SetRotation(gp_XYZ const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Mat_SetRow (gp_Mat *larg1, Standard_Integer larg2, gp_XYZ *larg3) {
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  Standard_Integer arg2 ;
  gp_XYZ *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetRow(arg2,(gp_XYZ const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_SetRow\n  * wrapname: _wrap_gp_Mat_SetRow\n  * fulldecl: void gp_Mat::SetRow(Standard_Integer const,gp_XYZ const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Mat_SetRows (gp_Mat *larg1, gp_XYZ *larg2, gp_XYZ *larg3, gp_XYZ *larg4) {
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  gp_XYZ *arg2 = 0 ;
  gp_XYZ *arg3 = 0 ;
  gp_XYZ *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetRows((gp_XYZ const &)*arg2,(gp_XYZ const &)*arg3,(gp_XYZ const &)*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_SetRows\n  * wrapname: _wrap_gp_Mat_SetRows\n  * fulldecl: void gp_Mat::SetRows(gp_XYZ const &,gp_XYZ const &,gp_XYZ const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Mat_SetScale (gp_Mat *larg1, Standard_Real larg2) {
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetScale(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_SetScale\n  * wrapname: _wrap_gp_Mat_SetScale\n  * fulldecl: void gp_Mat::SetScale(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Mat_SetValue (gp_Mat *larg1, Standard_Integer larg2, Standard_Integer larg3, Standard_Real larg4) {
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetValue(arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_SetValue\n  * wrapname: _wrap_gp_Mat_SetValue\n  * fulldecl: void gp_Mat::SetValue(Standard_Integer const,Standard_Integer const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_XYZ *_wrap_gp_Mat_Column (gp_Mat *larg1, Standard_Integer larg2) {
  gp_XYZ * lresult = (gp_XYZ *)0 ;
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  Standard_Integer arg2 ;
  gp_XYZ result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Mat const *)arg1)->Column(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_Column\n  * wrapname: _wrap_gp_Mat_Column\n  * fulldecl: gp_XYZ gp_Mat::Column(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_XYZ(result);
    return lresult;
  } catch (...) {
    return (gp_XYZ *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Mat_Determinant (gp_Mat *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Mat const *)arg1)->Determinant();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_Determinant\n  * wrapname: _wrap_gp_Mat_Determinant\n  * fulldecl: Standard_Real gp_Mat::Determinant() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_XYZ *_wrap_gp_Mat_Diagonal (gp_Mat *larg1) {
  gp_XYZ * lresult = (gp_XYZ *)0 ;
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  gp_XYZ result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Mat const *)arg1)->Diagonal();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_Diagonal\n  * wrapname: _wrap_gp_Mat_Diagonal\n  * fulldecl: gp_XYZ gp_Mat::Diagonal() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_XYZ(result);
    return lresult;
  } catch (...) {
    return (gp_XYZ *)0;
  }
}


EXPORT gp_XYZ *_wrap_gp_Mat_Row (gp_Mat *larg1, Standard_Integer larg2) {
  gp_XYZ * lresult = (gp_XYZ *)0 ;
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  Standard_Integer arg2 ;
  gp_XYZ result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Mat const *)arg1)->Row(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_Row\n  * wrapname: _wrap_gp_Mat_Row\n  * fulldecl: gp_XYZ gp_Mat::Row(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_XYZ(result);
    return lresult;
  } catch (...) {
    return (gp_XYZ *)0;
  }
}


EXPORT Standard_Real *_wrap_gp_Mat_Value (gp_Mat *larg1, Standard_Integer larg2, Standard_Integer larg3) {
  Standard_Real * lresult = (Standard_Real *)0 ;
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  Standard_Real *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real *) &((gp_Mat const *)arg1)->Value(arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_Value\n  * wrapname: _wrap_gp_Mat_Value\n  * fulldecl: Standard_Real const & gp_Mat::Value(Standard_Integer const,Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real *)0;
  }
}


EXPORT bool _wrap_gp_Mat_IsSingular (gp_Mat *larg1) {
  bool lresult = (bool)0 ;
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Mat const *)arg1)->IsSingular();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_IsSingular\n  * wrapname: _wrap_gp_Mat_IsSingular\n  * fulldecl: Standard_Boolean gp_Mat::IsSingular() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_gp_Mat_Add (gp_Mat *larg1, gp_Mat *larg2) {
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  gp_Mat *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Add((gp_Mat const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_Add\n  * wrapname: _wrap_gp_Mat_Add\n  * fulldecl: void gp_Mat::Add(gp_Mat const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Mat *_wrap_gp_Mat_Added (gp_Mat *larg1, gp_Mat *larg2) {
  gp_Mat * lresult = (gp_Mat *)0 ;
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  gp_Mat *arg2 = 0 ;
  gp_Mat result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Mat const *)arg1)->Added((gp_Mat const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_Added\n  * wrapname: _wrap_gp_Mat_Added\n  * fulldecl: gp_Mat gp_Mat::Added(gp_Mat const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Mat(result);
    return lresult;
  } catch (...) {
    return (gp_Mat *)0;
  }
}


EXPORT void _wrap_gp_Mat_Divide (gp_Mat *larg1, Standard_Real larg2) {
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Divide(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_Divide\n  * wrapname: _wrap_gp_Mat_Divide\n  * fulldecl: void gp_Mat::Divide(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Mat *_wrap_gp_Mat_Divided (gp_Mat *larg1, Standard_Real larg2) {
  gp_Mat * lresult = (gp_Mat *)0 ;
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  Standard_Real arg2 ;
  gp_Mat result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Mat const *)arg1)->Divided(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_Divided\n  * wrapname: _wrap_gp_Mat_Divided\n  * fulldecl: gp_Mat gp_Mat::Divided(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Mat(result);
    return lresult;
  } catch (...) {
    return (gp_Mat *)0;
  }
}


EXPORT void _wrap_gp_Mat_Invert (gp_Mat *larg1) {
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Invert();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_Invert\n  * wrapname: _wrap_gp_Mat_Invert\n  * fulldecl: void gp_Mat::Invert()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Mat *_wrap_gp_Mat_Inverted (gp_Mat *larg1) {
  gp_Mat * lresult = (gp_Mat *)0 ;
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  gp_Mat result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Mat const *)arg1)->Inverted();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_Inverted\n  * wrapname: _wrap_gp_Mat_Inverted\n  * fulldecl: gp_Mat gp_Mat::Inverted() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Mat(result);
    return lresult;
  } catch (...) {
    return (gp_Mat *)0;
  }
}


EXPORT gp_Mat *_wrap_gp_Mat_Multiplied__SWIG_0 (gp_Mat *larg1, gp_Mat *larg2) {
  gp_Mat * lresult = (gp_Mat *)0 ;
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  gp_Mat *arg2 = 0 ;
  gp_Mat result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Mat const *)arg1)->Multiplied((gp_Mat const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_Multiplied\n  * wrapname: _wrap_gp_Mat_Multiplied__SWIG_0\n  * fulldecl: gp_Mat gp_Mat::Multiplied(gp_Mat const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Mat(result);
    return lresult;
  } catch (...) {
    return (gp_Mat *)0;
  }
}


EXPORT void _wrap_gp_Mat_Multiply__SWIG_0 (gp_Mat *larg1, gp_Mat *larg2) {
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  gp_Mat *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Multiply((gp_Mat const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_Multiply\n  * wrapname: _wrap_gp_Mat_Multiply__SWIG_0\n  * fulldecl: void gp_Mat::Multiply(gp_Mat const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Mat_PreMultiply (gp_Mat *larg1, gp_Mat *larg2) {
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  gp_Mat *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->PreMultiply((gp_Mat const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_PreMultiply\n  * wrapname: _wrap_gp_Mat_PreMultiply\n  * fulldecl: void gp_Mat::PreMultiply(gp_Mat const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Mat *_wrap_gp_Mat_Multiplied__SWIG_1 (gp_Mat *larg1, Standard_Real larg2) {
  gp_Mat * lresult = (gp_Mat *)0 ;
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  Standard_Real arg2 ;
  gp_Mat result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Mat const *)arg1)->Multiplied(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_Multiplied\n  * wrapname: _wrap_gp_Mat_Multiplied__SWIG_1\n  * fulldecl: gp_Mat gp_Mat::Multiplied(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Mat(result);
    return lresult;
  } catch (...) {
    return (gp_Mat *)0;
  }
}


EXPORT void _wrap_gp_Mat_Multiply__SWIG_1 (gp_Mat *larg1, Standard_Real larg2) {
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Multiply(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_Multiply\n  * wrapname: _wrap_gp_Mat_Multiply__SWIG_1\n  * fulldecl: void gp_Mat::Multiply(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Mat_Power (gp_Mat *larg1, Standard_Integer larg2) {
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  Standard_Integer arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Power(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_Power\n  * wrapname: _wrap_gp_Mat_Power\n  * fulldecl: void gp_Mat::Power(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Mat *_wrap_gp_Mat_Powered (gp_Mat *larg1, Standard_Integer larg2) {
  gp_Mat * lresult = (gp_Mat *)0 ;
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  Standard_Integer arg2 ;
  gp_Mat result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Mat const *)arg1)->Powered(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_Powered\n  * wrapname: _wrap_gp_Mat_Powered\n  * fulldecl: gp_Mat gp_Mat::Powered(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Mat(result);
    return lresult;
  } catch (...) {
    return (gp_Mat *)0;
  }
}


EXPORT void _wrap_gp_Mat_Subtract (gp_Mat *larg1, gp_Mat *larg2) {
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  gp_Mat *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Subtract((gp_Mat const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_Subtract\n  * wrapname: _wrap_gp_Mat_Subtract\n  * fulldecl: void gp_Mat::Subtract(gp_Mat const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Mat *_wrap_gp_Mat_Subtracted (gp_Mat *larg1, gp_Mat *larg2) {
  gp_Mat * lresult = (gp_Mat *)0 ;
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  gp_Mat *arg2 = 0 ;
  gp_Mat result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Mat const *)arg1)->Subtracted((gp_Mat const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_Subtracted\n  * wrapname: _wrap_gp_Mat_Subtracted\n  * fulldecl: gp_Mat gp_Mat::Subtracted(gp_Mat const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Mat(result);
    return lresult;
  } catch (...) {
    return (gp_Mat *)0;
  }
}


EXPORT void _wrap_gp_Mat_Transpose (gp_Mat *larg1) {
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Transpose();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_Transpose\n  * wrapname: _wrap_gp_Mat_Transpose\n  * fulldecl: void gp_Mat::Transpose()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Mat *_wrap_gp_Mat_Transposed (gp_Mat *larg1) {
  gp_Mat * lresult = (gp_Mat *)0 ;
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  gp_Mat result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Mat const *)arg1)->Transposed();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat_Transposed\n  * wrapname: _wrap_gp_Mat_Transposed\n  * fulldecl: gp_Mat gp_Mat::Transposed() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Mat(result);
    return lresult;
  } catch (...) {
    return (gp_Mat *)0;
  }
}


EXPORT void _wrap_delete_gp_Mat (gp_Mat *larg1) {
  gp_Mat *arg1 = (gp_Mat *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Mat\n  * wrapname: _wrap_delete_gp_Mat\n  * fulldecl: gp_Mat::~gp_Mat()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Mat2d *_wrap_new_gp_Mat2d__SWIG_0 () {
  gp_Mat2d * lresult = (gp_Mat2d *)0 ;
  gp_Mat2d *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Mat2d *)new gp_Mat2d();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Mat2d\n  * wrapname: _wrap_new_gp_Mat2d__SWIG_0\n  * fulldecl: gp_Mat2d::gp_Mat2d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Mat2d *)0;
  }
}


EXPORT gp_Mat2d *_wrap_new_gp_Mat2d__SWIG_1 (gp_XY *larg1, gp_XY *larg2) {
  gp_Mat2d * lresult = (gp_Mat2d *)0 ;
  gp_XY *arg1 = 0 ;
  gp_XY *arg2 = 0 ;
  gp_Mat2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Mat2d *)new gp_Mat2d((gp_XY const &)*arg1,(gp_XY const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Mat2d\n  * wrapname: _wrap_new_gp_Mat2d__SWIG_1\n  * fulldecl: gp_Mat2d::gp_Mat2d(gp_XY const &,gp_XY const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Mat2d *)0;
  }
}


EXPORT void _wrap_gp_Mat2d_SetCol (gp_Mat2d *larg1, Standard_Integer larg2, gp_XY *larg3) {
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  Standard_Integer arg2 ;
  gp_XY *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetCol(arg2,(gp_XY const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_SetCol\n  * wrapname: _wrap_gp_Mat2d_SetCol\n  * fulldecl: void gp_Mat2d::SetCol(Standard_Integer const,gp_XY const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Mat2d_SetCols (gp_Mat2d *larg1, gp_XY *larg2, gp_XY *larg3) {
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  gp_XY *arg2 = 0 ;
  gp_XY *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetCols((gp_XY const &)*arg2,(gp_XY const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_SetCols\n  * wrapname: _wrap_gp_Mat2d_SetCols\n  * fulldecl: void gp_Mat2d::SetCols(gp_XY const &,gp_XY const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Mat2d_SetDiagonal (gp_Mat2d *larg1, Standard_Real larg2, Standard_Real larg3) {
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetDiagonal(arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_SetDiagonal\n  * wrapname: _wrap_gp_Mat2d_SetDiagonal\n  * fulldecl: void gp_Mat2d::SetDiagonal(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Mat2d_SetIdentity (gp_Mat2d *larg1) {
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetIdentity();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_SetIdentity\n  * wrapname: _wrap_gp_Mat2d_SetIdentity\n  * fulldecl: void gp_Mat2d::SetIdentity()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Mat2d_SetRotation (gp_Mat2d *larg1, Standard_Real larg2) {
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetRotation(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_SetRotation\n  * wrapname: _wrap_gp_Mat2d_SetRotation\n  * fulldecl: void gp_Mat2d::SetRotation(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Mat2d_SetRow (gp_Mat2d *larg1, Standard_Integer larg2, gp_XY *larg3) {
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  Standard_Integer arg2 ;
  gp_XY *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetRow(arg2,(gp_XY const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_SetRow\n  * wrapname: _wrap_gp_Mat2d_SetRow\n  * fulldecl: void gp_Mat2d::SetRow(Standard_Integer const,gp_XY const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Mat2d_SetRows (gp_Mat2d *larg1, gp_XY *larg2, gp_XY *larg3) {
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  gp_XY *arg2 = 0 ;
  gp_XY *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetRows((gp_XY const &)*arg2,(gp_XY const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_SetRows\n  * wrapname: _wrap_gp_Mat2d_SetRows\n  * fulldecl: void gp_Mat2d::SetRows(gp_XY const &,gp_XY const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Mat2d_SetScale (gp_Mat2d *larg1, Standard_Real larg2) {
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetScale(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_SetScale\n  * wrapname: _wrap_gp_Mat2d_SetScale\n  * fulldecl: void gp_Mat2d::SetScale(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Mat2d_SetValue (gp_Mat2d *larg1, Standard_Integer larg2, Standard_Integer larg3, Standard_Real larg4) {
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetValue(arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_SetValue\n  * wrapname: _wrap_gp_Mat2d_SetValue\n  * fulldecl: void gp_Mat2d::SetValue(Standard_Integer const,Standard_Integer const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_XY *_wrap_gp_Mat2d_Column (gp_Mat2d *larg1, Standard_Integer larg2) {
  gp_XY * lresult = (gp_XY *)0 ;
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  Standard_Integer arg2 ;
  gp_XY result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Mat2d const *)arg1)->Column(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_Column\n  * wrapname: _wrap_gp_Mat2d_Column\n  * fulldecl: gp_XY gp_Mat2d::Column(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_XY(result);
    return lresult;
  } catch (...) {
    return (gp_XY *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Mat2d_Determinant (gp_Mat2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Mat2d const *)arg1)->Determinant();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_Determinant\n  * wrapname: _wrap_gp_Mat2d_Determinant\n  * fulldecl: Standard_Real gp_Mat2d::Determinant() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_XY *_wrap_gp_Mat2d_Diagonal (gp_Mat2d *larg1) {
  gp_XY * lresult = (gp_XY *)0 ;
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  gp_XY result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Mat2d const *)arg1)->Diagonal();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_Diagonal\n  * wrapname: _wrap_gp_Mat2d_Diagonal\n  * fulldecl: gp_XY gp_Mat2d::Diagonal() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_XY(result);
    return lresult;
  } catch (...) {
    return (gp_XY *)0;
  }
}


EXPORT gp_XY *_wrap_gp_Mat2d_Row (gp_Mat2d *larg1, Standard_Integer larg2) {
  gp_XY * lresult = (gp_XY *)0 ;
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  Standard_Integer arg2 ;
  gp_XY result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Mat2d const *)arg1)->Row(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_Row\n  * wrapname: _wrap_gp_Mat2d_Row\n  * fulldecl: gp_XY gp_Mat2d::Row(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_XY(result);
    return lresult;
  } catch (...) {
    return (gp_XY *)0;
  }
}


EXPORT Standard_Real *_wrap_gp_Mat2d_Value (gp_Mat2d *larg1, Standard_Integer larg2, Standard_Integer larg3) {
  Standard_Real * lresult = (Standard_Real *)0 ;
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  Standard_Real *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real *) &((gp_Mat2d const *)arg1)->Value(arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_Value\n  * wrapname: _wrap_gp_Mat2d_Value\n  * fulldecl: Standard_Real const & gp_Mat2d::Value(Standard_Integer const,Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real *)0;
  }
}


EXPORT bool _wrap_gp_Mat2d_IsSingular (gp_Mat2d *larg1) {
  bool lresult = (bool)0 ;
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Mat2d const *)arg1)->IsSingular();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_IsSingular\n  * wrapname: _wrap_gp_Mat2d_IsSingular\n  * fulldecl: Standard_Boolean gp_Mat2d::IsSingular() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_gp_Mat2d_Add (gp_Mat2d *larg1, gp_Mat2d *larg2) {
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  gp_Mat2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Add((gp_Mat2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_Add\n  * wrapname: _wrap_gp_Mat2d_Add\n  * fulldecl: void gp_Mat2d::Add(gp_Mat2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Mat2d *_wrap_gp_Mat2d_Added (gp_Mat2d *larg1, gp_Mat2d *larg2) {
  gp_Mat2d * lresult = (gp_Mat2d *)0 ;
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  gp_Mat2d *arg2 = 0 ;
  gp_Mat2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Mat2d const *)arg1)->Added((gp_Mat2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_Added\n  * wrapname: _wrap_gp_Mat2d_Added\n  * fulldecl: gp_Mat2d gp_Mat2d::Added(gp_Mat2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Mat2d(result);
    return lresult;
  } catch (...) {
    return (gp_Mat2d *)0;
  }
}


EXPORT void _wrap_gp_Mat2d_Divide (gp_Mat2d *larg1, Standard_Real larg2) {
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Divide(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_Divide\n  * wrapname: _wrap_gp_Mat2d_Divide\n  * fulldecl: void gp_Mat2d::Divide(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Mat2d *_wrap_gp_Mat2d_Divided (gp_Mat2d *larg1, Standard_Real larg2) {
  gp_Mat2d * lresult = (gp_Mat2d *)0 ;
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  Standard_Real arg2 ;
  gp_Mat2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Mat2d const *)arg1)->Divided(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_Divided\n  * wrapname: _wrap_gp_Mat2d_Divided\n  * fulldecl: gp_Mat2d gp_Mat2d::Divided(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Mat2d(result);
    return lresult;
  } catch (...) {
    return (gp_Mat2d *)0;
  }
}


EXPORT void _wrap_gp_Mat2d_Invert (gp_Mat2d *larg1) {
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Invert();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_Invert\n  * wrapname: _wrap_gp_Mat2d_Invert\n  * fulldecl: void gp_Mat2d::Invert()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Mat2d *_wrap_gp_Mat2d_Inverted (gp_Mat2d *larg1) {
  gp_Mat2d * lresult = (gp_Mat2d *)0 ;
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  gp_Mat2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Mat2d const *)arg1)->Inverted();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_Inverted\n  * wrapname: _wrap_gp_Mat2d_Inverted\n  * fulldecl: gp_Mat2d gp_Mat2d::Inverted() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Mat2d(result);
    return lresult;
  } catch (...) {
    return (gp_Mat2d *)0;
  }
}


EXPORT gp_Mat2d *_wrap_gp_Mat2d_Multiplied__SWIG_0 (gp_Mat2d *larg1, gp_Mat2d *larg2) {
  gp_Mat2d * lresult = (gp_Mat2d *)0 ;
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  gp_Mat2d *arg2 = 0 ;
  gp_Mat2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Mat2d const *)arg1)->Multiplied((gp_Mat2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_Multiplied\n  * wrapname: _wrap_gp_Mat2d_Multiplied__SWIG_0\n  * fulldecl: gp_Mat2d gp_Mat2d::Multiplied(gp_Mat2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Mat2d(result);
    return lresult;
  } catch (...) {
    return (gp_Mat2d *)0;
  }
}


EXPORT void _wrap_gp_Mat2d_Multiply__SWIG_0 (gp_Mat2d *larg1, gp_Mat2d *larg2) {
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  gp_Mat2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Multiply((gp_Mat2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_Multiply\n  * wrapname: _wrap_gp_Mat2d_Multiply__SWIG_0\n  * fulldecl: void gp_Mat2d::Multiply(gp_Mat2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Mat2d_PreMultiply (gp_Mat2d *larg1, gp_Mat2d *larg2) {
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  gp_Mat2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->PreMultiply((gp_Mat2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_PreMultiply\n  * wrapname: _wrap_gp_Mat2d_PreMultiply\n  * fulldecl: void gp_Mat2d::PreMultiply(gp_Mat2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Mat2d *_wrap_gp_Mat2d_Multiplied__SWIG_1 (gp_Mat2d *larg1, Standard_Real larg2) {
  gp_Mat2d * lresult = (gp_Mat2d *)0 ;
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  Standard_Real arg2 ;
  gp_Mat2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Mat2d const *)arg1)->Multiplied(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_Multiplied\n  * wrapname: _wrap_gp_Mat2d_Multiplied__SWIG_1\n  * fulldecl: gp_Mat2d gp_Mat2d::Multiplied(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Mat2d(result);
    return lresult;
  } catch (...) {
    return (gp_Mat2d *)0;
  }
}


EXPORT void _wrap_gp_Mat2d_Multiply__SWIG_1 (gp_Mat2d *larg1, Standard_Real larg2) {
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Multiply(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_Multiply\n  * wrapname: _wrap_gp_Mat2d_Multiply__SWIG_1\n  * fulldecl: void gp_Mat2d::Multiply(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Mat2d_Power (gp_Mat2d *larg1, Standard_Integer larg2) {
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  Standard_Integer arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Power(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_Power\n  * wrapname: _wrap_gp_Mat2d_Power\n  * fulldecl: void gp_Mat2d::Power(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Mat2d *_wrap_gp_Mat2d_Powered (gp_Mat2d *larg1, Standard_Integer larg2) {
  gp_Mat2d * lresult = (gp_Mat2d *)0 ;
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  Standard_Integer arg2 ;
  gp_Mat2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Mat2d const *)arg1)->Powered(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_Powered\n  * wrapname: _wrap_gp_Mat2d_Powered\n  * fulldecl: gp_Mat2d gp_Mat2d::Powered(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Mat2d(result);
    return lresult;
  } catch (...) {
    return (gp_Mat2d *)0;
  }
}


EXPORT void _wrap_gp_Mat2d_Subtract (gp_Mat2d *larg1, gp_Mat2d *larg2) {
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  gp_Mat2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Subtract((gp_Mat2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_Subtract\n  * wrapname: _wrap_gp_Mat2d_Subtract\n  * fulldecl: void gp_Mat2d::Subtract(gp_Mat2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Mat2d *_wrap_gp_Mat2d_Subtracted (gp_Mat2d *larg1, gp_Mat2d *larg2) {
  gp_Mat2d * lresult = (gp_Mat2d *)0 ;
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  gp_Mat2d *arg2 = 0 ;
  gp_Mat2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Mat2d const *)arg1)->Subtracted((gp_Mat2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_Subtracted\n  * wrapname: _wrap_gp_Mat2d_Subtracted\n  * fulldecl: gp_Mat2d gp_Mat2d::Subtracted(gp_Mat2d const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Mat2d(result);
    return lresult;
  } catch (...) {
    return (gp_Mat2d *)0;
  }
}


EXPORT void _wrap_gp_Mat2d_Transpose (gp_Mat2d *larg1) {
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Transpose();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_Transpose\n  * wrapname: _wrap_gp_Mat2d_Transpose\n  * fulldecl: void gp_Mat2d::Transpose()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Mat2d *_wrap_gp_Mat2d_Transposed (gp_Mat2d *larg1) {
  gp_Mat2d * lresult = (gp_Mat2d *)0 ;
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  gp_Mat2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Mat2d const *)arg1)->Transposed();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Mat2d_Transposed\n  * wrapname: _wrap_gp_Mat2d_Transposed\n  * fulldecl: gp_Mat2d gp_Mat2d::Transposed() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Mat2d(result);
    return lresult;
  } catch (...) {
    return (gp_Mat2d *)0;
  }
}


EXPORT void _wrap_delete_gp_Mat2d (gp_Mat2d *larg1) {
  gp_Mat2d *arg1 = (gp_Mat2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Mat2d\n  * wrapname: _wrap_delete_gp_Mat2d\n  * fulldecl: gp_Mat2d::~gp_Mat2d()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Quaternion *_wrap_new_gp_Quaternion__SWIG_0 () {
  gp_Quaternion * lresult = (gp_Quaternion *)0 ;
  gp_Quaternion *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Quaternion *)new gp_Quaternion();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Quaternion\n  * wrapname: _wrap_new_gp_Quaternion__SWIG_0\n  * fulldecl: gp_Quaternion::gp_Quaternion()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Quaternion *)0;
  }
}


EXPORT gp_Quaternion *_wrap_new_gp_Quaternion__SWIG_1 (Standard_Real larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4) {
  gp_Quaternion * lresult = (gp_Quaternion *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  gp_Quaternion *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Quaternion *)new gp_Quaternion(arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Quaternion\n  * wrapname: _wrap_new_gp_Quaternion__SWIG_1\n  * fulldecl: gp_Quaternion::gp_Quaternion(Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Quaternion *)0;
  }
}


EXPORT gp_Quaternion *_wrap_new_gp_Quaternion__SWIG_2 (gp_Quaternion *larg1) {
  gp_Quaternion * lresult = (gp_Quaternion *)0 ;
  gp_Quaternion *arg1 = 0 ;
  gp_Quaternion *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Quaternion *)new gp_Quaternion((gp_Quaternion const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Quaternion\n  * wrapname: _wrap_new_gp_Quaternion__SWIG_2\n  * fulldecl: gp_Quaternion::gp_Quaternion(gp_Quaternion const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Quaternion *)0;
  }
}


EXPORT gp_Quaternion *_wrap_new_gp_Quaternion__SWIG_3 (gp_Vec *larg1, gp_Vec *larg2) {
  gp_Quaternion * lresult = (gp_Quaternion *)0 ;
  gp_Vec *arg1 = 0 ;
  gp_Vec *arg2 = 0 ;
  gp_Quaternion *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Quaternion *)new gp_Quaternion((gp_Vec const &)*arg1,(gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Quaternion\n  * wrapname: _wrap_new_gp_Quaternion__SWIG_3\n  * fulldecl: gp_Quaternion::gp_Quaternion(gp_Vec const &,gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Quaternion *)0;
  }
}


EXPORT gp_Quaternion *_wrap_new_gp_Quaternion__SWIG_4 (gp_Vec *larg1, gp_Vec *larg2, gp_Vec *larg3) {
  gp_Quaternion * lresult = (gp_Quaternion *)0 ;
  gp_Vec *arg1 = 0 ;
  gp_Vec *arg2 = 0 ;
  gp_Vec *arg3 = 0 ;
  gp_Quaternion *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Quaternion *)new gp_Quaternion((gp_Vec const &)*arg1,(gp_Vec const &)*arg2,(gp_Vec const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Quaternion\n  * wrapname: _wrap_new_gp_Quaternion__SWIG_4\n  * fulldecl: gp_Quaternion::gp_Quaternion(gp_Vec const &,gp_Vec const &,gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Quaternion *)0;
  }
}


EXPORT gp_Quaternion *_wrap_new_gp_Quaternion__SWIG_5 (gp_Vec *larg1, Standard_Real larg2) {
  gp_Quaternion * lresult = (gp_Quaternion *)0 ;
  gp_Vec *arg1 = 0 ;
  Standard_Real arg2 ;
  gp_Quaternion *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Quaternion *)new gp_Quaternion((gp_Vec const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Quaternion\n  * wrapname: _wrap_new_gp_Quaternion__SWIG_5\n  * fulldecl: gp_Quaternion::gp_Quaternion(gp_Vec const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Quaternion *)0;
  }
}


EXPORT gp_Quaternion *_wrap_new_gp_Quaternion__SWIG_6 (gp_Mat *larg1) {
  gp_Quaternion * lresult = (gp_Quaternion *)0 ;
  gp_Mat *arg1 = 0 ;
  gp_Quaternion *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Quaternion *)new gp_Quaternion((gp_Mat const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Quaternion\n  * wrapname: _wrap_new_gp_Quaternion__SWIG_6\n  * fulldecl: gp_Quaternion::gp_Quaternion(gp_Mat const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Quaternion *)0;
  }
}


EXPORT bool _wrap_gp_Quaternion_IsEqual (gp_Quaternion *larg1, gp_Quaternion *larg2) {
  bool lresult = (bool)0 ;
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  gp_Quaternion *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((gp_Quaternion const *)arg1)->IsEqual((gp_Quaternion const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_IsEqual\n  * wrapname: _wrap_gp_Quaternion_IsEqual\n  * fulldecl: Standard_Boolean gp_Quaternion::IsEqual(gp_Quaternion const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_gp_Quaternion_SetRotation__SWIG_0 (gp_Quaternion *larg1, gp_Vec *larg2, gp_Vec *larg3) {
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  gp_Vec *arg2 = 0 ;
  gp_Vec *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetRotation((gp_Vec const &)*arg2,(gp_Vec const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_SetRotation\n  * wrapname: _wrap_gp_Quaternion_SetRotation__SWIG_0\n  * fulldecl: void gp_Quaternion::SetRotation(gp_Vec const &,gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Quaternion_SetRotation__SWIG_1 (gp_Quaternion *larg1, gp_Vec *larg2, gp_Vec *larg3, gp_Vec *larg4) {
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  gp_Vec *arg2 = 0 ;
  gp_Vec *arg3 = 0 ;
  gp_Vec *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetRotation((gp_Vec const &)*arg2,(gp_Vec const &)*arg3,(gp_Vec const &)*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_SetRotation\n  * wrapname: _wrap_gp_Quaternion_SetRotation__SWIG_1\n  * fulldecl: void gp_Quaternion::SetRotation(gp_Vec const &,gp_Vec const &,gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Quaternion_SetVectorAndAngle (gp_Quaternion *larg1, gp_Vec *larg2, Standard_Real larg3) {
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  gp_Vec *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetVectorAndAngle((gp_Vec const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_SetVectorAndAngle\n  * wrapname: _wrap_gp_Quaternion_SetVectorAndAngle\n  * fulldecl: void gp_Quaternion::SetVectorAndAngle(gp_Vec const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Quaternion_GetVectorAndAngle (gp_Quaternion *larg1, gp_Vec *larg2, Standard_Real *larg3) {
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  gp_Vec *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((gp_Quaternion const *)arg1)->GetVectorAndAngle(*arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_GetVectorAndAngle\n  * wrapname: _wrap_gp_Quaternion_GetVectorAndAngle\n  * fulldecl: void gp_Quaternion::GetVectorAndAngle(gp_Vec &,Standard_Real &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Quaternion_SetMatrix (gp_Quaternion *larg1, gp_Mat *larg2) {
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  gp_Mat *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetMatrix((gp_Mat const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_SetMatrix\n  * wrapname: _wrap_gp_Quaternion_SetMatrix\n  * fulldecl: void gp_Quaternion::SetMatrix(gp_Mat const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Mat *_wrap_gp_Quaternion_GetMatrix (gp_Quaternion *larg1) {
  gp_Mat * lresult = (gp_Mat *)0 ;
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  gp_Mat result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Quaternion const *)arg1)->GetMatrix();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_GetMatrix\n  * wrapname: _wrap_gp_Quaternion_GetMatrix\n  * fulldecl: gp_Mat gp_Quaternion::GetMatrix() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Mat(result);
    return lresult;
  } catch (...) {
    return (gp_Mat *)0;
  }
}


EXPORT void _wrap_gp_Quaternion_SetEulerAngles (gp_Quaternion *larg1, gp_EulerSequence larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5) {
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  gp_EulerSequence arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetEulerAngles(arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_SetEulerAngles\n  * wrapname: _wrap_gp_Quaternion_SetEulerAngles\n  * fulldecl: void gp_Quaternion::SetEulerAngles(gp_EulerSequence const,Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Quaternion_GetEulerAngles (gp_Quaternion *larg1, gp_EulerSequence larg2, Standard_Real *larg3, Standard_Real *larg4, Standard_Real *larg5) {
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  gp_EulerSequence arg2 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  Standard_Real *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((gp_Quaternion const *)arg1)->GetEulerAngles(arg2,*arg3,*arg4,*arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_GetEulerAngles\n  * wrapname: _wrap_gp_Quaternion_GetEulerAngles\n  * fulldecl: void gp_Quaternion::GetEulerAngles(gp_EulerSequence const,Standard_Real &,Standard_Real &,Standard_Real &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Quaternion_Set__SWIG_0 (gp_Quaternion *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5) {
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Set(arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_Set\n  * wrapname: _wrap_gp_Quaternion_Set__SWIG_0\n  * fulldecl: void gp_Quaternion::Set(Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Quaternion_Set__SWIG_1 (gp_Quaternion *larg1, gp_Quaternion *larg2) {
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  gp_Quaternion *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Set((gp_Quaternion const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_Set\n  * wrapname: _wrap_gp_Quaternion_Set__SWIG_1\n  * fulldecl: void gp_Quaternion::Set(gp_Quaternion const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Real _wrap_gp_Quaternion_X (gp_Quaternion *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Quaternion const *)arg1)->X();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_X\n  * wrapname: _wrap_gp_Quaternion_X\n  * fulldecl: Standard_Real gp_Quaternion::X() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Quaternion_Y (gp_Quaternion *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Quaternion const *)arg1)->Y();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_Y\n  * wrapname: _wrap_gp_Quaternion_Y\n  * fulldecl: Standard_Real gp_Quaternion::Y() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Quaternion_Z (gp_Quaternion *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Quaternion const *)arg1)->Z();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_Z\n  * wrapname: _wrap_gp_Quaternion_Z\n  * fulldecl: Standard_Real gp_Quaternion::Z() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Quaternion_W (gp_Quaternion *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Quaternion const *)arg1)->W();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_W\n  * wrapname: _wrap_gp_Quaternion_W\n  * fulldecl: Standard_Real gp_Quaternion::W() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_gp_Quaternion_SetIdent (gp_Quaternion *larg1) {
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetIdent();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_SetIdent\n  * wrapname: _wrap_gp_Quaternion_SetIdent\n  * fulldecl: void gp_Quaternion::SetIdent()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Quaternion_Reverse (gp_Quaternion *larg1) {
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Reverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_Reverse\n  * wrapname: _wrap_gp_Quaternion_Reverse\n  * fulldecl: void gp_Quaternion::Reverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Quaternion *_wrap_gp_Quaternion_Reversed (gp_Quaternion *larg1) {
  gp_Quaternion * lresult = (gp_Quaternion *)0 ;
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  gp_Quaternion result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Quaternion const *)arg1)->Reversed();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_Reversed\n  * wrapname: _wrap_gp_Quaternion_Reversed\n  * fulldecl: gp_Quaternion gp_Quaternion::Reversed() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Quaternion(result);
    return lresult;
  } catch (...) {
    return (gp_Quaternion *)0;
  }
}


EXPORT void _wrap_gp_Quaternion_Invert (gp_Quaternion *larg1) {
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Invert();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_Invert\n  * wrapname: _wrap_gp_Quaternion_Invert\n  * fulldecl: void gp_Quaternion::Invert()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Quaternion *_wrap_gp_Quaternion_Inverted (gp_Quaternion *larg1) {
  gp_Quaternion * lresult = (gp_Quaternion *)0 ;
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  gp_Quaternion result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Quaternion const *)arg1)->Inverted();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_Inverted\n  * wrapname: _wrap_gp_Quaternion_Inverted\n  * fulldecl: gp_Quaternion gp_Quaternion::Inverted() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Quaternion(result);
    return lresult;
  } catch (...) {
    return (gp_Quaternion *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Quaternion_SquareNorm (gp_Quaternion *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Quaternion const *)arg1)->SquareNorm();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_SquareNorm\n  * wrapname: _wrap_gp_Quaternion_SquareNorm\n  * fulldecl: Standard_Real gp_Quaternion::SquareNorm() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Quaternion_Norm (gp_Quaternion *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Quaternion const *)arg1)->Norm();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_Norm\n  * wrapname: _wrap_gp_Quaternion_Norm\n  * fulldecl: Standard_Real gp_Quaternion::Norm() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_gp_Quaternion_Scale (gp_Quaternion *larg1, Standard_Real larg2) {
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Scale(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_Scale\n  * wrapname: _wrap_gp_Quaternion_Scale\n  * fulldecl: void gp_Quaternion::Scale(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Quaternion *_wrap_gp_Quaternion_Scaled (gp_Quaternion *larg1, Standard_Real larg2) {
  gp_Quaternion * lresult = (gp_Quaternion *)0 ;
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  Standard_Real arg2 ;
  gp_Quaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Quaternion const *)arg1)->Scaled(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_Scaled\n  * wrapname: _wrap_gp_Quaternion_Scaled\n  * fulldecl: gp_Quaternion gp_Quaternion::Scaled(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Quaternion(result);
    return lresult;
  } catch (...) {
    return (gp_Quaternion *)0;
  }
}


EXPORT void _wrap_gp_Quaternion_StabilizeLength (gp_Quaternion *larg1) {
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->StabilizeLength();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_StabilizeLength\n  * wrapname: _wrap_gp_Quaternion_StabilizeLength\n  * fulldecl: void gp_Quaternion::StabilizeLength()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Quaternion_Normalize (gp_Quaternion *larg1) {
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Normalize();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_Normalize\n  * wrapname: _wrap_gp_Quaternion_Normalize\n  * fulldecl: void gp_Quaternion::Normalize()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Quaternion *_wrap_gp_Quaternion_Normalized (gp_Quaternion *larg1) {
  gp_Quaternion * lresult = (gp_Quaternion *)0 ;
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  gp_Quaternion result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Quaternion const *)arg1)->Normalized();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_Normalized\n  * wrapname: _wrap_gp_Quaternion_Normalized\n  * fulldecl: gp_Quaternion gp_Quaternion::Normalized() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Quaternion(result);
    return lresult;
  } catch (...) {
    return (gp_Quaternion *)0;
  }
}


EXPORT gp_Quaternion *_wrap_gp_Quaternion_Negated (gp_Quaternion *larg1) {
  gp_Quaternion * lresult = (gp_Quaternion *)0 ;
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  gp_Quaternion result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Quaternion const *)arg1)->Negated();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_Negated\n  * wrapname: _wrap_gp_Quaternion_Negated\n  * fulldecl: gp_Quaternion gp_Quaternion::Negated() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Quaternion(result);
    return lresult;
  } catch (...) {
    return (gp_Quaternion *)0;
  }
}


EXPORT gp_Quaternion *_wrap_gp_Quaternion_Added (gp_Quaternion *larg1, gp_Quaternion *larg2) {
  gp_Quaternion * lresult = (gp_Quaternion *)0 ;
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  gp_Quaternion *arg2 = 0 ;
  gp_Quaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Quaternion const *)arg1)->Added((gp_Quaternion const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_Added\n  * wrapname: _wrap_gp_Quaternion_Added\n  * fulldecl: gp_Quaternion gp_Quaternion::Added(gp_Quaternion const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Quaternion(result);
    return lresult;
  } catch (...) {
    return (gp_Quaternion *)0;
  }
}


EXPORT gp_Quaternion *_wrap_gp_Quaternion_Subtracted (gp_Quaternion *larg1, gp_Quaternion *larg2) {
  gp_Quaternion * lresult = (gp_Quaternion *)0 ;
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  gp_Quaternion *arg2 = 0 ;
  gp_Quaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Quaternion const *)arg1)->Subtracted((gp_Quaternion const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_Subtracted\n  * wrapname: _wrap_gp_Quaternion_Subtracted\n  * fulldecl: gp_Quaternion gp_Quaternion::Subtracted(gp_Quaternion const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Quaternion(result);
    return lresult;
  } catch (...) {
    return (gp_Quaternion *)0;
  }
}


EXPORT gp_Quaternion *_wrap_gp_Quaternion_Multiplied (gp_Quaternion *larg1, gp_Quaternion *larg2) {
  gp_Quaternion * lresult = (gp_Quaternion *)0 ;
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  gp_Quaternion *arg2 = 0 ;
  gp_Quaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Quaternion const *)arg1)->Multiplied((gp_Quaternion const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_Multiplied\n  * wrapname: _wrap_gp_Quaternion_Multiplied\n  * fulldecl: gp_Quaternion gp_Quaternion::Multiplied(gp_Quaternion const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Quaternion(result);
    return lresult;
  } catch (...) {
    return (gp_Quaternion *)0;
  }
}


EXPORT void _wrap_gp_Quaternion_Add (gp_Quaternion *larg1, gp_Quaternion *larg2) {
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  gp_Quaternion *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Add((gp_Quaternion const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_Add\n  * wrapname: _wrap_gp_Quaternion_Add\n  * fulldecl: void gp_Quaternion::Add(gp_Quaternion const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Quaternion_Subtract (gp_Quaternion *larg1, gp_Quaternion *larg2) {
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  gp_Quaternion *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Subtract((gp_Quaternion const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_Subtract\n  * wrapname: _wrap_gp_Quaternion_Subtract\n  * fulldecl: void gp_Quaternion::Subtract(gp_Quaternion const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Quaternion_Multiply__SWIG_0 (gp_Quaternion *larg1, gp_Quaternion *larg2) {
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  gp_Quaternion *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Multiply((gp_Quaternion const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_Multiply\n  * wrapname: _wrap_gp_Quaternion_Multiply__SWIG_0\n  * fulldecl: void gp_Quaternion::Multiply(gp_Quaternion const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Real _wrap_gp_Quaternion_Dot (gp_Quaternion *larg1, gp_Quaternion *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  gp_Quaternion *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Quaternion const *)arg1)->Dot((gp_Quaternion const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_Dot\n  * wrapname: _wrap_gp_Quaternion_Dot\n  * fulldecl: Standard_Real gp_Quaternion::Dot(gp_Quaternion const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Quaternion_GetRotationAngle (gp_Quaternion *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Quaternion const *)arg1)->GetRotationAngle();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_GetRotationAngle\n  * wrapname: _wrap_gp_Quaternion_GetRotationAngle\n  * fulldecl: Standard_Real gp_Quaternion::GetRotationAngle() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Vec *_wrap_gp_Quaternion_Multiply__SWIG_1 (gp_Quaternion *larg1, gp_Vec *larg2) {
  gp_Vec * lresult = (gp_Vec *)0 ;
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  gp_Vec *arg2 = 0 ;
  gp_Vec result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((gp_Quaternion const *)arg1)->Multiply((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Quaternion_Multiply\n  * wrapname: _wrap_gp_Quaternion_Multiply__SWIG_1\n  * fulldecl: gp_Vec gp_Quaternion::Multiply(gp_Vec const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec(result);
    return lresult;
  } catch (...) {
    return (gp_Vec *)0;
  }
}


EXPORT void _wrap_delete_gp_Quaternion (gp_Quaternion *larg1) {
  gp_Quaternion *arg1 = (gp_Quaternion *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Quaternion\n  * wrapname: _wrap_delete_gp_Quaternion\n  * fulldecl: gp_Quaternion::~gp_Quaternion()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Quaternion *_wrap_gp_QuaternionNLerp_Interpolate__SWIG_0 (gp_Quaternion *larg1, gp_Quaternion *larg2, Standard_Real larg3) {
  gp_Quaternion * lresult = (gp_Quaternion *)0 ;
  gp_Quaternion *arg1 = 0 ;
  gp_Quaternion *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Quaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = gp_QuaternionNLerp::Interpolate((gp_Quaternion const &)*arg1,(gp_Quaternion const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_QuaternionNLerp_Interpolate\n  * wrapname: _wrap_gp_QuaternionNLerp_Interpolate__SWIG_0\n  * fulldecl: gp_Quaternion gp_QuaternionNLerp::Interpolate(gp_Quaternion const &,gp_Quaternion const &,Standard_Real)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Quaternion(result);
    return lresult;
  } catch (...) {
    return (gp_Quaternion *)0;
  }
}


EXPORT gp_QuaternionNLerp *_wrap_new_gp_QuaternionNLerp__SWIG_0 () {
  gp_QuaternionNLerp * lresult = (gp_QuaternionNLerp *)0 ;
  gp_QuaternionNLerp *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_QuaternionNLerp *)new gp_QuaternionNLerp();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_QuaternionNLerp\n  * wrapname: _wrap_new_gp_QuaternionNLerp__SWIG_0\n  * fulldecl: gp_QuaternionNLerp::gp_QuaternionNLerp()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_QuaternionNLerp *)0;
  }
}


EXPORT gp_QuaternionNLerp *_wrap_new_gp_QuaternionNLerp__SWIG_1 (gp_Quaternion *larg1, gp_Quaternion *larg2) {
  gp_QuaternionNLerp * lresult = (gp_QuaternionNLerp *)0 ;
  gp_Quaternion *arg1 = 0 ;
  gp_Quaternion *arg2 = 0 ;
  gp_QuaternionNLerp *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_QuaternionNLerp *)new gp_QuaternionNLerp((gp_Quaternion const &)*arg1,(gp_Quaternion const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_QuaternionNLerp\n  * wrapname: _wrap_new_gp_QuaternionNLerp__SWIG_1\n  * fulldecl: gp_QuaternionNLerp::gp_QuaternionNLerp(gp_Quaternion const &,gp_Quaternion const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_QuaternionNLerp *)0;
  }
}


EXPORT void _wrap_gp_QuaternionNLerp_Init (gp_QuaternionNLerp *larg1, gp_Quaternion *larg2, gp_Quaternion *larg3) {
  gp_QuaternionNLerp *arg1 = (gp_QuaternionNLerp *) 0 ;
  gp_Quaternion *arg2 = 0 ;
  gp_Quaternion *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init((gp_Quaternion const &)*arg2,(gp_Quaternion const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_QuaternionNLerp_Init\n  * wrapname: _wrap_gp_QuaternionNLerp_Init\n  * fulldecl: void gp_QuaternionNLerp::Init(gp_Quaternion const &,gp_Quaternion const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_QuaternionNLerp_InitFromUnit (gp_QuaternionNLerp *larg1, gp_Quaternion *larg2, gp_Quaternion *larg3) {
  gp_QuaternionNLerp *arg1 = (gp_QuaternionNLerp *) 0 ;
  gp_Quaternion *arg2 = 0 ;
  gp_Quaternion *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->InitFromUnit((gp_Quaternion const &)*arg2,(gp_Quaternion const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_QuaternionNLerp_InitFromUnit\n  * wrapname: _wrap_gp_QuaternionNLerp_InitFromUnit\n  * fulldecl: void gp_QuaternionNLerp::InitFromUnit(gp_Quaternion const &,gp_Quaternion const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_QuaternionNLerp_Interpolate__SWIG_1 (gp_QuaternionNLerp *larg1, Standard_Real larg2, gp_Quaternion *larg3) {
  gp_QuaternionNLerp *arg1 = (gp_QuaternionNLerp *) 0 ;
  Standard_Real arg2 ;
  gp_Quaternion *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Interpolate(arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_QuaternionNLerp_Interpolate\n  * wrapname: _wrap_gp_QuaternionNLerp_Interpolate__SWIG_1\n  * fulldecl: void gp_QuaternionNLerp::Interpolate(Standard_Real,gp_Quaternion &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_gp_QuaternionNLerp (gp_QuaternionNLerp *larg1) {
  gp_QuaternionNLerp *arg1 = (gp_QuaternionNLerp *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_QuaternionNLerp\n  * wrapname: _wrap_delete_gp_QuaternionNLerp\n  * fulldecl: gp_QuaternionNLerp::~gp_QuaternionNLerp()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Quaternion *_wrap_gp_QuaternionSLerp_Interpolate__SWIG_0 (gp_Quaternion *larg1, gp_Quaternion *larg2, Standard_Real larg3) {
  gp_Quaternion * lresult = (gp_Quaternion *)0 ;
  gp_Quaternion *arg1 = 0 ;
  gp_Quaternion *arg2 = 0 ;
  Standard_Real arg3 ;
  gp_Quaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = gp_QuaternionSLerp::Interpolate((gp_Quaternion const &)*arg1,(gp_Quaternion const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_QuaternionSLerp_Interpolate\n  * wrapname: _wrap_gp_QuaternionSLerp_Interpolate__SWIG_0\n  * fulldecl: gp_Quaternion gp_QuaternionSLerp::Interpolate(gp_Quaternion const &,gp_Quaternion const &,Standard_Real)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Quaternion(result);
    return lresult;
  } catch (...) {
    return (gp_Quaternion *)0;
  }
}


EXPORT gp_QuaternionSLerp *_wrap_new_gp_QuaternionSLerp__SWIG_0 () {
  gp_QuaternionSLerp * lresult = (gp_QuaternionSLerp *)0 ;
  gp_QuaternionSLerp *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_QuaternionSLerp *)new gp_QuaternionSLerp();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_QuaternionSLerp\n  * wrapname: _wrap_new_gp_QuaternionSLerp__SWIG_0\n  * fulldecl: gp_QuaternionSLerp::gp_QuaternionSLerp()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_QuaternionSLerp *)0;
  }
}


EXPORT gp_QuaternionSLerp *_wrap_new_gp_QuaternionSLerp__SWIG_1 (gp_Quaternion *larg1, gp_Quaternion *larg2) {
  gp_QuaternionSLerp * lresult = (gp_QuaternionSLerp *)0 ;
  gp_Quaternion *arg1 = 0 ;
  gp_Quaternion *arg2 = 0 ;
  gp_QuaternionSLerp *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_QuaternionSLerp *)new gp_QuaternionSLerp((gp_Quaternion const &)*arg1,(gp_Quaternion const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_QuaternionSLerp\n  * wrapname: _wrap_new_gp_QuaternionSLerp__SWIG_1\n  * fulldecl: gp_QuaternionSLerp::gp_QuaternionSLerp(gp_Quaternion const &,gp_Quaternion const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_QuaternionSLerp *)0;
  }
}


EXPORT void _wrap_gp_QuaternionSLerp_Init (gp_QuaternionSLerp *larg1, gp_Quaternion *larg2, gp_Quaternion *larg3) {
  gp_QuaternionSLerp *arg1 = (gp_QuaternionSLerp *) 0 ;
  gp_Quaternion *arg2 = 0 ;
  gp_Quaternion *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init((gp_Quaternion const &)*arg2,(gp_Quaternion const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_QuaternionSLerp_Init\n  * wrapname: _wrap_gp_QuaternionSLerp_Init\n  * fulldecl: void gp_QuaternionSLerp::Init(gp_Quaternion const &,gp_Quaternion const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_QuaternionSLerp_InitFromUnit (gp_QuaternionSLerp *larg1, gp_Quaternion *larg2, gp_Quaternion *larg3) {
  gp_QuaternionSLerp *arg1 = (gp_QuaternionSLerp *) 0 ;
  gp_Quaternion *arg2 = 0 ;
  gp_Quaternion *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->InitFromUnit((gp_Quaternion const &)*arg2,(gp_Quaternion const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_QuaternionSLerp_InitFromUnit\n  * wrapname: _wrap_gp_QuaternionSLerp_InitFromUnit\n  * fulldecl: void gp_QuaternionSLerp::InitFromUnit(gp_Quaternion const &,gp_Quaternion const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_QuaternionSLerp_Interpolate__SWIG_1 (gp_QuaternionSLerp *larg1, Standard_Real larg2, gp_Quaternion *larg3) {
  gp_QuaternionSLerp *arg1 = (gp_QuaternionSLerp *) 0 ;
  Standard_Real arg2 ;
  gp_Quaternion *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Interpolate(arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_QuaternionSLerp_Interpolate\n  * wrapname: _wrap_gp_QuaternionSLerp_Interpolate__SWIG_1\n  * fulldecl: void gp_QuaternionSLerp::Interpolate(Standard_Real,gp_Quaternion &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_gp_QuaternionSLerp (gp_QuaternionSLerp *larg1) {
  gp_QuaternionSLerp *arg1 = (gp_QuaternionSLerp *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_QuaternionSLerp\n  * wrapname: _wrap_delete_gp_QuaternionSLerp\n  * fulldecl: gp_QuaternionSLerp::~gp_QuaternionSLerp()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <TColStd_HArray1OfBoolean.hxx>


#include <TColgp_HArray1OfPnt.hxx>

EXPORT TColgp_HArray1OfPnt *_wrap_new_TColgp_HArray1OfPnt (Standard_Integer larg1, Standard_Integer larg2) {
  TColgp_HArray1OfPnt * lresult = (TColgp_HArray1OfPnt *)0 ;
  Standard_Integer arg1 ;
  Standard_Integer arg2 ;
  TColgp_HArray1OfPnt *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColgp_HArray1OfPnt *)new TColgp_HArray1OfPnt(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TColgp_HArray1OfPnt\n  * wrapname: _wrap_new_TColgp_HArray1OfPnt\n  * fulldecl: TColgp_HArray1OfPnt::TColgp_HArray1OfPnt(Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColgp_HArray1OfPnt *)0;
  }
}


EXPORT void _wrap_TColgp_HArray1OfPnt_SetValue (TColgp_HArray1OfPnt *larg1, Standard_Integer larg2, gp_Pnt *larg3) {
  TColgp_HArray1OfPnt *arg1 = (TColgp_HArray1OfPnt *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetValue(arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColgp_HArray1OfPnt_SetValue\n  * wrapname: _wrap_TColgp_HArray1OfPnt_SetValue\n  * fulldecl: void TColgp_HArray1OfPnt::SetValue(Standard_Integer const,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_TColgp_HArray1OfPnt (TColgp_HArray1OfPnt *larg1) {
  TColgp_HArray1OfPnt *arg1 = (TColgp_HArray1OfPnt *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TColgp_HArray1OfPnt\n  * wrapname: _wrap_delete_TColgp_HArray1OfPnt\n  * fulldecl: TColgp_HArray1OfPnt::~TColgp_HArray1OfPnt()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_Handle_TColgp_HArray1OfPnt (Handle_TColgp_HArray1OfPnt *larg1) {
  Handle_TColgp_HArray1OfPnt *arg1 = (Handle_TColgp_HArray1OfPnt *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Handle_TColgp_HArray1OfPnt\n  * wrapname: _wrap_delete_Handle_TColgp_HArray1OfPnt\n  * fulldecl: Handle_TColgp_HArray1OfPnt::~Handle_TColgp_HArray1OfPnt()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_Handle_TColStd_HArray1OfBoolean (Handle_TColStd_HArray1OfBoolean *larg1) {
  Handle_TColStd_HArray1OfBoolean *arg1 = (Handle_TColStd_HArray1OfBoolean *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Handle_TColStd_HArray1OfBoolean\n  * wrapname: _wrap_delete_Handle_TColStd_HArray1OfBoolean\n  * fulldecl: Handle_TColStd_HArray1OfBoolean::~Handle_TColStd_HArray1OfBoolean()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <NCollection_Array1.hxx>
#include <TColgp_Array1OfVec.hxx>
  
EXPORT TColgp_Array1OfVec *_wrap_new_TColgp_Array1OfVec (Standard_Integer larg1, Standard_Integer larg2) {
  TColgp_Array1OfVec * lresult = (TColgp_Array1OfVec *)0 ;
  Standard_Integer arg1 ;
  Standard_Integer arg2 ;
  TColgp_Array1OfVec *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColgp_Array1OfVec *)new TColgp_Array1OfVec(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TColgp_Array1OfVec\n  * wrapname: _wrap_new_TColgp_Array1OfVec\n  * fulldecl: TColgp_Array1OfVec::TColgp_Array1OfVec(Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColgp_Array1OfVec *)0;
  }
}


EXPORT void _wrap_TColgp_Array1OfVec_SetValue (TColgp_Array1OfVec *larg1, Standard_Integer larg2, gp_Vec *larg3) {
  TColgp_Array1OfVec *arg1 = (TColgp_Array1OfVec *) 0 ;
  Standard_Integer arg2 ;
  gp_Vec *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetValue(arg2,(gp_Vec const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColgp_Array1OfVec_SetValue\n  * wrapname: _wrap_TColgp_Array1OfVec_SetValue\n  * fulldecl: void TColgp_Array1OfVec::SetValue(Standard_Integer const,gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void TColgp_Array1OfVec_Delete(TColgp_Array1OfVec *self){
    self->~TColgp_Array1OfVec();
  }
EXPORT void _wrap_TColgp_Array1OfVec_Delete (TColgp_Array1OfVec *larg1) {
  TColgp_Array1OfVec *arg1 = (TColgp_Array1OfVec *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        TColgp_Array1OfVec_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColgp_Array1OfVec_Delete\n  * wrapname: _wrap_TColgp_Array1OfVec_Delete\n  * fulldecl: void TColgp_Array1OfVec::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <TColgp_Array1OfPnt2d.hxx>
  
EXPORT TColgp_Array1OfPnt2d *_wrap_new_TColgp_Array1OfPnt2d (Standard_Integer larg1, Standard_Integer larg2) {
  TColgp_Array1OfPnt2d * lresult = (TColgp_Array1OfPnt2d *)0 ;
  Standard_Integer arg1 ;
  Standard_Integer arg2 ;
  TColgp_Array1OfPnt2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColgp_Array1OfPnt2d *)new TColgp_Array1OfPnt2d(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TColgp_Array1OfPnt2d\n  * wrapname: _wrap_new_TColgp_Array1OfPnt2d\n  * fulldecl: TColgp_Array1OfPnt2d::TColgp_Array1OfPnt2d(Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColgp_Array1OfPnt2d *)0;
  }
}


EXPORT void _wrap_TColgp_Array1OfPnt2d_SetValue (TColgp_Array1OfPnt2d *larg1, Standard_Integer larg2, gp_Pnt2d *larg3) {
  TColgp_Array1OfPnt2d *arg1 = (TColgp_Array1OfPnt2d *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetValue(arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColgp_Array1OfPnt2d_SetValue\n  * wrapname: _wrap_TColgp_Array1OfPnt2d_SetValue\n  * fulldecl: void TColgp_Array1OfPnt2d::SetValue(Standard_Integer const,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void TColgp_Array1OfPnt2d_Delete(TColgp_Array1OfPnt2d *self){
    self->~TColgp_Array1OfPnt2d();
  }
EXPORT void _wrap_TColgp_Array1OfPnt2d_Delete (TColgp_Array1OfPnt2d *larg1) {
  TColgp_Array1OfPnt2d *arg1 = (TColgp_Array1OfPnt2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        TColgp_Array1OfPnt2d_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColgp_Array1OfPnt2d_Delete\n  * wrapname: _wrap_TColgp_Array1OfPnt2d_Delete\n  * fulldecl: void TColgp_Array1OfPnt2d::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <TColStd_Array1OfReal.hxx>
  
EXPORT TColStd_Array1OfReal *_wrap_new_TColStd_Array1OfReal (Standard_Integer larg1, Standard_Integer larg2) {
  TColStd_Array1OfReal * lresult = (TColStd_Array1OfReal *)0 ;
  Standard_Integer arg1 ;
  Standard_Integer arg2 ;
  TColStd_Array1OfReal *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColStd_Array1OfReal *)new TColStd_Array1OfReal(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TColStd_Array1OfReal\n  * wrapname: _wrap_new_TColStd_Array1OfReal\n  * fulldecl: TColStd_Array1OfReal::TColStd_Array1OfReal(Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColStd_Array1OfReal *)0;
  }
}


EXPORT void _wrap_TColStd_Array1OfReal_SetValue (TColStd_Array1OfReal *larg1, Standard_Integer larg2, Standard_Real *larg3) {
  TColStd_Array1OfReal *arg1 = (TColStd_Array1OfReal *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetValue(arg2,(Standard_Real const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColStd_Array1OfReal_SetValue\n  * wrapname: _wrap_TColStd_Array1OfReal_SetValue\n  * fulldecl: void TColStd_Array1OfReal::SetValue(Standard_Integer const,Standard_Real const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void TColStd_Array1OfReal_Delete(TColStd_Array1OfReal *self){
    self->~TColStd_Array1OfReal();
  }
EXPORT void _wrap_TColStd_Array1OfReal_Delete (TColStd_Array1OfReal *larg1) {
  TColStd_Array1OfReal *arg1 = (TColStd_Array1OfReal *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        TColStd_Array1OfReal_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColStd_Array1OfReal_Delete\n  * wrapname: _wrap_TColStd_Array1OfReal_Delete\n  * fulldecl: void TColStd_Array1OfReal::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <TColStd_Array1OfInteger.hxx>
  
EXPORT TColStd_Array1OfInteger *_wrap_new_TColStd_Array1OfInteger (Standard_Integer larg1, Standard_Integer larg2) {
  TColStd_Array1OfInteger * lresult = (TColStd_Array1OfInteger *)0 ;
  Standard_Integer arg1 ;
  Standard_Integer arg2 ;
  TColStd_Array1OfInteger *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColStd_Array1OfInteger *)new TColStd_Array1OfInteger(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TColStd_Array1OfInteger\n  * wrapname: _wrap_new_TColStd_Array1OfInteger\n  * fulldecl: TColStd_Array1OfInteger::TColStd_Array1OfInteger(Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColStd_Array1OfInteger *)0;
  }
}


EXPORT void _wrap_TColStd_Array1OfInteger_SetValue (TColStd_Array1OfInteger *larg1, Standard_Integer larg2, Standard_Integer *larg3) {
  TColStd_Array1OfInteger *arg1 = (TColStd_Array1OfInteger *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetValue(arg2,(Standard_Integer const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColStd_Array1OfInteger_SetValue\n  * wrapname: _wrap_TColStd_Array1OfInteger_SetValue\n  * fulldecl: void TColStd_Array1OfInteger::SetValue(Standard_Integer const,Standard_Integer const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Integer _wrap_TColStd_Array1OfInteger_Value (TColStd_Array1OfInteger *larg1, Standard_Integer larg2) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  TColStd_Array1OfInteger *arg1 = (TColStd_Array1OfInteger *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)(arg1)->Value(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColStd_Array1OfInteger_Value\n  * wrapname: _wrap_TColStd_Array1OfInteger_Value\n  * fulldecl: Standard_Integer const TColStd_Array1OfInteger::Value(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT Standard_Integer _wrap_TColStd_Array1OfInteger_Lower (TColStd_Array1OfInteger *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  TColStd_Array1OfInteger *arg1 = (TColStd_Array1OfInteger *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((TColStd_Array1OfInteger const *)arg1)->Lower();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColStd_Array1OfInteger_Lower\n  * wrapname: _wrap_TColStd_Array1OfInteger_Lower\n  * fulldecl: Standard_Integer TColStd_Array1OfInteger::Lower() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT Standard_Integer _wrap_TColStd_Array1OfInteger_Upper (TColStd_Array1OfInteger *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  TColStd_Array1OfInteger *arg1 = (TColStd_Array1OfInteger *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((TColStd_Array1OfInteger const *)arg1)->Upper();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColStd_Array1OfInteger_Upper\n  * wrapname: _wrap_TColStd_Array1OfInteger_Upper\n  * fulldecl: Standard_Integer TColStd_Array1OfInteger::Upper() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN void TColStd_Array1OfInteger_Delete(TColStd_Array1OfInteger *self){
    self->~TColStd_Array1OfInteger();
  }
EXPORT void _wrap_TColStd_Array1OfInteger_Delete (TColStd_Array1OfInteger *larg1) {
  TColStd_Array1OfInteger *arg1 = (TColStd_Array1OfInteger *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        TColStd_Array1OfInteger_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColStd_Array1OfInteger_Delete\n  * wrapname: _wrap_TColStd_Array1OfInteger_Delete\n  * fulldecl: void TColStd_Array1OfInteger::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <TColgp_Array1OfPnt.hxx>
  
EXPORT TColgp_Array1OfPnt *_wrap_new_TColgp_Array1OfPnt (Standard_Integer larg1, Standard_Integer larg2) {
  TColgp_Array1OfPnt * lresult = (TColgp_Array1OfPnt *)0 ;
  Standard_Integer arg1 ;
  Standard_Integer arg2 ;
  TColgp_Array1OfPnt *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColgp_Array1OfPnt *)new TColgp_Array1OfPnt(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TColgp_Array1OfPnt\n  * wrapname: _wrap_new_TColgp_Array1OfPnt\n  * fulldecl: TColgp_Array1OfPnt::TColgp_Array1OfPnt(Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColgp_Array1OfPnt *)0;
  }
}


EXPORT gp_Pnt const *_wrap_TColgp_Array1OfPnt_Value (TColgp_Array1OfPnt *larg1, Standard_Integer larg2) {
  gp_Pnt const * lresult = (gp_Pnt const *)0 ;
  TColgp_Array1OfPnt *arg1 = (TColgp_Array1OfPnt *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (arg1)->Value(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColgp_Array1OfPnt_Value\n  * wrapname: _wrap_TColgp_Array1OfPnt_Value\n  * fulldecl: gp_Pnt const TColgp_Array1OfPnt::Value(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt const(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt const *)0;
  }
}


EXPORT void _wrap_TColgp_Array1OfPnt_SetValue (TColgp_Array1OfPnt *larg1, Standard_Integer larg2, gp_Pnt *larg3) {
  TColgp_Array1OfPnt *arg1 = (TColgp_Array1OfPnt *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetValue(arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColgp_Array1OfPnt_SetValue\n  * wrapname: _wrap_TColgp_Array1OfPnt_SetValue\n  * fulldecl: void TColgp_Array1OfPnt::SetValue(Standard_Integer const,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Integer _wrap_TColgp_Array1OfPnt_Lower (TColgp_Array1OfPnt *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  TColgp_Array1OfPnt *arg1 = (TColgp_Array1OfPnt *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((TColgp_Array1OfPnt const *)arg1)->Lower();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColgp_Array1OfPnt_Lower\n  * wrapname: _wrap_TColgp_Array1OfPnt_Lower\n  * fulldecl: Standard_Integer TColgp_Array1OfPnt::Lower() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT Standard_Integer _wrap_TColgp_Array1OfPnt_Upper (TColgp_Array1OfPnt *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  TColgp_Array1OfPnt *arg1 = (TColgp_Array1OfPnt *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((TColgp_Array1OfPnt const *)arg1)->Upper();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColgp_Array1OfPnt_Upper\n  * wrapname: _wrap_TColgp_Array1OfPnt_Upper\n  * fulldecl: Standard_Integer TColgp_Array1OfPnt::Upper() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN void TColgp_Array1OfPnt_Delete(TColgp_Array1OfPnt *self){
    self->~TColgp_Array1OfPnt();
  }
EXPORT void _wrap_TColgp_Array1OfPnt_Delete (TColgp_Array1OfPnt *larg1) {
  TColgp_Array1OfPnt *arg1 = (TColgp_Array1OfPnt *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        TColgp_Array1OfPnt_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColgp_Array1OfPnt_Delete\n  * wrapname: _wrap_TColgp_Array1OfPnt_Delete\n  * fulldecl: void TColgp_Array1OfPnt::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <TColgp_Array2OfPnt.hxx>
  
EXPORT TColgp_Array2OfPnt *_wrap_new_TColgp_Array2OfPnt (Standard_Integer larg1, Standard_Integer larg2, Standard_Integer larg3, Standard_Integer larg4) {
  TColgp_Array2OfPnt * lresult = (TColgp_Array2OfPnt *)0 ;
  Standard_Integer arg1 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  Standard_Integer arg4 ;
  TColgp_Array2OfPnt *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColgp_Array2OfPnt *)new TColgp_Array2OfPnt(arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TColgp_Array2OfPnt\n  * wrapname: _wrap_new_TColgp_Array2OfPnt\n  * fulldecl: TColgp_Array2OfPnt::TColgp_Array2OfPnt(Standard_Integer const,Standard_Integer const,Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColgp_Array2OfPnt *)0;
  }
}


EXPORT void _wrap_TColgp_Array2OfPnt_SetValue (TColgp_Array2OfPnt *larg1, Standard_Integer larg2, Standard_Integer larg3, gp_Pnt *larg4) {
  TColgp_Array2OfPnt *arg1 = (TColgp_Array2OfPnt *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  gp_Pnt *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetValue(arg2,arg3,(gp_Pnt const &)*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColgp_Array2OfPnt_SetValue\n  * wrapname: _wrap_TColgp_Array2OfPnt_SetValue\n  * fulldecl: void TColgp_Array2OfPnt::SetValue(Standard_Integer const,Standard_Integer const,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void TColgp_Array2OfPnt_Delete(TColgp_Array2OfPnt *self){
    self->~TColgp_Array2OfPnt();
  }
EXPORT void _wrap_TColgp_Array2OfPnt_Delete (TColgp_Array2OfPnt *larg1) {
  TColgp_Array2OfPnt *arg1 = (TColgp_Array2OfPnt *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        TColgp_Array2OfPnt_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColgp_Array2OfPnt_Delete\n  * wrapname: _wrap_TColgp_Array2OfPnt_Delete\n  * fulldecl: void TColgp_Array2OfPnt::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <TColStd_Array2OfReal.hxx>
  
EXPORT TColStd_Array2OfReal *_wrap_new_TColStd_Array2OfReal (Standard_Integer larg1, Standard_Integer larg2, Standard_Integer larg3, Standard_Integer larg4) {
  TColStd_Array2OfReal * lresult = (TColStd_Array2OfReal *)0 ;
  Standard_Integer arg1 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  Standard_Integer arg4 ;
  TColStd_Array2OfReal *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColStd_Array2OfReal *)new TColStd_Array2OfReal(arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TColStd_Array2OfReal\n  * wrapname: _wrap_new_TColStd_Array2OfReal\n  * fulldecl: TColStd_Array2OfReal::TColStd_Array2OfReal(Standard_Integer const,Standard_Integer const,Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColStd_Array2OfReal *)0;
  }
}


EXPORT void _wrap_TColStd_Array2OfReal_SetValue (TColStd_Array2OfReal *larg1, Standard_Integer larg2, Standard_Integer larg3, Standard_Real *larg4) {
  TColStd_Array2OfReal *arg1 = (TColStd_Array2OfReal *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  Standard_Real *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetValue(arg2,arg3,(Standard_Real const &)*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColStd_Array2OfReal_SetValue\n  * wrapname: _wrap_TColStd_Array2OfReal_SetValue\n  * fulldecl: void TColStd_Array2OfReal::SetValue(Standard_Integer const,Standard_Integer const,Standard_Real const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void TColStd_Array2OfReal_Delete(TColStd_Array2OfReal *self){
    self->~TColStd_Array2OfReal();
  }
EXPORT void _wrap_TColStd_Array2OfReal_Delete (TColStd_Array2OfReal *larg1) {
  TColStd_Array2OfReal *arg1 = (TColStd_Array2OfReal *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        TColStd_Array2OfReal_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColStd_Array2OfReal_Delete\n  * wrapname: _wrap_TColStd_Array2OfReal_Delete\n  * fulldecl: void TColStd_Array2OfReal::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <TopAbs_ShapeEnum.hxx>
#include <TopAbs_Orientation.hxx>
  

#include <TopoDS_Shape.hxx>
#include <TopoDS_Compound.hxx>
#include <TopoDS_CompSolid.hxx>
#include <TopoDS_Solid.hxx>
#include <TopoDS_Shell.hxx>
#include <TopoDS_Face.hxx>
#include <TopoDS_Wire.hxx>
#include <TopoDS_Edge.hxx>
#include <TopoDS_Vertex.hxx>
#include <TopoDS_Iterator.hxx>
#include <TopoDS_Builder.hxx>
  
EXPORT TopAbs_ShapeEnum _wrap_TopoDS_Shape_ShapeType (TopoDS_Shape *larg1) {
  TopAbs_ShapeEnum lresult = (TopAbs_ShapeEnum)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  TopAbs_ShapeEnum result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopAbs_ShapeEnum)(arg1)->ShapeType();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_ShapeType\n  * wrapname: _wrap_TopoDS_Shape_ShapeType\n  * fulldecl: TopAbs_ShapeEnum TopoDS_Shape::ShapeType()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopAbs_ShapeEnum)0;
  }
}


EXPORT bool _wrap_TopoDS_Shape_IsSame (TopoDS_Shape *larg1, TopoDS_Shape *larg2) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TopoDS_Shape const *)arg1)->IsSame((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_IsSame\n  * wrapname: _wrap_TopoDS_Shape_IsSame\n  * fulldecl: Standard_Boolean TopoDS_Shape::IsSame(TopoDS_Shape const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_TopoDS_Shape_IsPartner (TopoDS_Shape *larg1, TopoDS_Shape *larg2) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TopoDS_Shape const *)arg1)->IsPartner((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_IsPartner\n  * wrapname: _wrap_TopoDS_Shape_IsPartner\n  * fulldecl: Standard_Boolean TopoDS_Shape::IsPartner(TopoDS_Shape const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_TopoDS_Shape_IsEqual (TopoDS_Shape *larg1, TopoDS_Shape *larg2) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TopoDS_Shape const *)arg1)->IsEqual((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_IsEqual\n  * wrapname: _wrap_TopoDS_Shape_IsEqual\n  * fulldecl: Standard_Boolean TopoDS_Shape::IsEqual(TopoDS_Shape const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Handle_TopoDS_TShape *_wrap_TopoDS_Shape_TShape (TopoDS_Shape *larg1) {
  Handle_TopoDS_TShape * lresult = (Handle_TopoDS_TShape *)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Handle_TopoDS_TShape *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_TopoDS_TShape *) &((TopoDS_Shape const *)arg1)->TShape();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_TShape\n  * wrapname: _wrap_TopoDS_Shape_TShape\n  * fulldecl: Handle_TopoDS_TShape const & TopoDS_Shape::TShape() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_TopoDS_TShape *)0;
  }
}


EXPORT TopLoc_Location *_wrap_TopoDS_Shape_Location__SWIG_0 (TopoDS_Shape *larg1) {
  TopLoc_Location * lresult = (TopLoc_Location *)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  TopLoc_Location *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopLoc_Location *) &((TopoDS_Shape const *)arg1)->Location();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Location\n  * wrapname: _wrap_TopoDS_Shape_Location__SWIG_0\n  * fulldecl: TopLoc_Location const & TopoDS_Shape::Location() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopLoc_Location *)0;
  }
}


EXPORT void _wrap_TopoDS_Shape_Location__SWIG_1 (TopoDS_Shape *larg1, TopLoc_Location *larg2) {
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  TopLoc_Location *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Location((TopLoc_Location const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Location\n  * wrapname: _wrap_TopoDS_Shape_Location__SWIG_1\n  * fulldecl: void TopoDS_Shape::Location(TopLoc_Location const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopAbs_Orientation _wrap_TopoDS_Shape_Orientation__SWIG_0 (TopoDS_Shape *larg1) {
  TopAbs_Orientation lresult = (TopAbs_Orientation)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  TopAbs_Orientation result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopAbs_Orientation)((TopoDS_Shape const *)arg1)->Orientation();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Orientation\n  * wrapname: _wrap_TopoDS_Shape_Orientation__SWIG_0\n  * fulldecl: TopAbs_Orientation TopoDS_Shape::Orientation() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopAbs_Orientation)0;
  }
}


EXPORT void _wrap_TopoDS_Shape_Orientation__SWIG_1 (TopoDS_Shape *larg1, TopAbs_Orientation larg2) {
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  TopAbs_Orientation arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Orientation(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Orientation\n  * wrapname: _wrap_TopoDS_Shape_Orientation__SWIG_1\n  * fulldecl: void TopoDS_Shape::Orientation(TopAbs_Orientation const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopoDS_Shape_Reverse (TopoDS_Shape *larg1) {
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Reverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Reverse\n  * wrapname: _wrap_TopoDS_Shape_Reverse\n  * fulldecl: void TopoDS_Shape::Reverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopoDS_Shape *_wrap_TopoDS_Shape_Reversed (TopoDS_Shape *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  TopoDS_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((TopoDS_Shape const *)arg1)->Reversed();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Reversed\n  * wrapname: _wrap_TopoDS_Shape_Reversed\n  * fulldecl: TopoDS_Shape TopoDS_Shape::Reversed() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new TopoDS_Shape(result);
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT Standard_Integer _wrap_TopoDS_Shape_HashCode (TopoDS_Shape *larg1, Standard_Integer larg2) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((TopoDS_Shape const *)arg1)->HashCode(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_HashCode\n  * wrapname: _wrap_TopoDS_Shape_HashCode\n  * fulldecl: Standard_Integer TopoDS_Shape::HashCode(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT bool _wrap_TopoDS_Shape_Free__SWIG_0 (TopoDS_Shape *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TopoDS_Shape const *)arg1)->Free();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Free\n  * wrapname: _wrap_TopoDS_Shape_Free__SWIG_0\n  * fulldecl: Standard_Boolean TopoDS_Shape::Free() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_TopoDS_Shape_Free__SWIG_1 (TopoDS_Shape *larg1, bool larg2) {
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Free(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Free\n  * wrapname: _wrap_TopoDS_Shape_Free__SWIG_1\n  * fulldecl: void TopoDS_Shape::Free(Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_TopoDS_Shape_Locked__SWIG_0 (TopoDS_Shape *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TopoDS_Shape const *)arg1)->Locked();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Locked\n  * wrapname: _wrap_TopoDS_Shape_Locked__SWIG_0\n  * fulldecl: Standard_Boolean TopoDS_Shape::Locked() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_TopoDS_Shape_Locked__SWIG_1 (TopoDS_Shape *larg1, bool larg2) {
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Locked(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Locked\n  * wrapname: _wrap_TopoDS_Shape_Locked__SWIG_1\n  * fulldecl: void TopoDS_Shape::Locked(Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_TopoDS_Shape_Modified__SWIG_0 (TopoDS_Shape *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TopoDS_Shape const *)arg1)->Modified();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Modified\n  * wrapname: _wrap_TopoDS_Shape_Modified__SWIG_0\n  * fulldecl: Standard_Boolean TopoDS_Shape::Modified() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_TopoDS_Shape_Modified__SWIG_1 (TopoDS_Shape *larg1, bool larg2) {
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Modified(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Modified\n  * wrapname: _wrap_TopoDS_Shape_Modified__SWIG_1\n  * fulldecl: void TopoDS_Shape::Modified(Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_TopoDS_Shape_Checked__SWIG_0 (TopoDS_Shape *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TopoDS_Shape const *)arg1)->Checked();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Checked\n  * wrapname: _wrap_TopoDS_Shape_Checked__SWIG_0\n  * fulldecl: Standard_Boolean TopoDS_Shape::Checked() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_TopoDS_Shape_Checked__SWIG_1 (TopoDS_Shape *larg1, bool larg2) {
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Checked(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Checked\n  * wrapname: _wrap_TopoDS_Shape_Checked__SWIG_1\n  * fulldecl: void TopoDS_Shape::Checked(Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_TopoDS_Shape_Orientable__SWIG_0 (TopoDS_Shape *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TopoDS_Shape const *)arg1)->Orientable();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Orientable\n  * wrapname: _wrap_TopoDS_Shape_Orientable__SWIG_0\n  * fulldecl: Standard_Boolean TopoDS_Shape::Orientable() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_TopoDS_Shape_Orientable__SWIG_1 (TopoDS_Shape *larg1, bool larg2) {
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Orientable(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Orientable\n  * wrapname: _wrap_TopoDS_Shape_Orientable__SWIG_1\n  * fulldecl: void TopoDS_Shape::Orientable(Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_TopoDS_Shape_Closed__SWIG_0 (TopoDS_Shape *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TopoDS_Shape const *)arg1)->Closed();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Closed\n  * wrapname: _wrap_TopoDS_Shape_Closed__SWIG_0\n  * fulldecl: Standard_Boolean TopoDS_Shape::Closed() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_TopoDS_Shape_Closed__SWIG_1 (TopoDS_Shape *larg1, bool larg2) {
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Closed(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Closed\n  * wrapname: _wrap_TopoDS_Shape_Closed__SWIG_1\n  * fulldecl: void TopoDS_Shape::Closed(Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_TopoDS_Shape_Infinite__SWIG_0 (TopoDS_Shape *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TopoDS_Shape const *)arg1)->Infinite();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Infinite\n  * wrapname: _wrap_TopoDS_Shape_Infinite__SWIG_0\n  * fulldecl: Standard_Boolean TopoDS_Shape::Infinite() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_TopoDS_Shape_Infinite__SWIG_1 (TopoDS_Shape *larg1, bool larg2) {
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Infinite(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Infinite\n  * wrapname: _wrap_TopoDS_Shape_Infinite__SWIG_1\n  * fulldecl: void TopoDS_Shape::Infinite(Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_TopoDS_Shape_Convex__SWIG_0 (TopoDS_Shape *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TopoDS_Shape const *)arg1)->Convex();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Convex\n  * wrapname: _wrap_TopoDS_Shape_Convex__SWIG_0\n  * fulldecl: Standard_Boolean TopoDS_Shape::Convex() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_TopoDS_Shape_Convex__SWIG_1 (TopoDS_Shape *larg1, bool larg2) {
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Convex(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Convex\n  * wrapname: _wrap_TopoDS_Shape_Convex__SWIG_1\n  * fulldecl: void TopoDS_Shape::Convex(Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN TopoDS_Shape *TopoDS_Shape_copy_reference(TopoDS_Shape *self){
    TopoDS_Shape *copy = new TopoDS_Shape();
    *copy=*self;
    return copy;
  }
EXPORT TopoDS_Shape *_wrap_TopoDS_Shape_copy_reference (TopoDS_Shape *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *)TopoDS_Shape_copy_reference(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_copy_reference\n  * wrapname: _wrap_TopoDS_Shape_copy_reference\n  * fulldecl: TopoDS_Shape * TopoDS_Shape::copy_reference()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


SWIGINTERN Handle_TopoDS_TShape TopoDS_Shape_getTShape(TopoDS_Shape *self){
    return (Handle_TopoDS_TShape)&*self->TShape();
  }
EXPORT Handle_TopoDS_TShape *_wrap_TopoDS_Shape_getTShape (TopoDS_Shape *larg1) {
  Handle_TopoDS_TShape * lresult = (Handle_TopoDS_TShape *)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Handle_TopoDS_TShape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = TopoDS_Shape_getTShape(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_getTShape\n  * wrapname: _wrap_TopoDS_Shape_getTShape\n  * fulldecl: Handle_TopoDS_TShape TopoDS_Shape::getTShape()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_TopoDS_TShape(result);
    return lresult;
  } catch (...) {
    return (Handle_TopoDS_TShape *)0;
  }
}


EXPORT void _wrap_delete_TopoDS_Shape (TopoDS_Shape *larg1) {
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopoDS_Shape\n  * wrapname: _wrap_delete_TopoDS_Shape\n  * fulldecl: TopoDS_Shape::~TopoDS_Shape()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopoDS_Compound *_wrap_new_TopoDS_Compound () {
  TopoDS_Compound * lresult = (TopoDS_Compound *)0 ;
  TopoDS_Compound *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Compound *)new TopoDS_Compound();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TopoDS_Compound\n  * wrapname: _wrap_new_TopoDS_Compound\n  * fulldecl: TopoDS_Compound::TopoDS_Compound()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Compound *)0;
  }
}


EXPORT void _wrap_delete_TopoDS_Compound (TopoDS_Compound *larg1) {
  TopoDS_Compound *arg1 = (TopoDS_Compound *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopoDS_Compound\n  * wrapname: _wrap_delete_TopoDS_Compound\n  * fulldecl: TopoDS_Compound::~TopoDS_Compound()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_TopoDS_CompSolid (TopoDS_CompSolid *larg1) {
  TopoDS_CompSolid *arg1 = (TopoDS_CompSolid *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopoDS_CompSolid\n  * wrapname: _wrap_delete_TopoDS_CompSolid\n  * fulldecl: TopoDS_CompSolid::~TopoDS_CompSolid()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_TopoDS_Solid (TopoDS_Solid *larg1) {
  TopoDS_Solid *arg1 = (TopoDS_Solid *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopoDS_Solid\n  * wrapname: _wrap_delete_TopoDS_Solid\n  * fulldecl: TopoDS_Solid::~TopoDS_Solid()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_TopoDS_Shell (TopoDS_Shell *larg1) {
  TopoDS_Shell *arg1 = (TopoDS_Shell *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopoDS_Shell\n  * wrapname: _wrap_delete_TopoDS_Shell\n  * fulldecl: TopoDS_Shell::~TopoDS_Shell()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_TopoDS_Face (TopoDS_Face *larg1) {
  TopoDS_Face *arg1 = (TopoDS_Face *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopoDS_Face\n  * wrapname: _wrap_delete_TopoDS_Face\n  * fulldecl: TopoDS_Face::~TopoDS_Face()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_TopoDS_Wire (TopoDS_Wire *larg1) {
  TopoDS_Wire *arg1 = (TopoDS_Wire *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopoDS_Wire\n  * wrapname: _wrap_delete_TopoDS_Wire\n  * fulldecl: TopoDS_Wire::~TopoDS_Wire()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_TopoDS_Edge (TopoDS_Edge *larg1) {
  TopoDS_Edge *arg1 = (TopoDS_Edge *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopoDS_Edge\n  * wrapname: _wrap_delete_TopoDS_Edge\n  * fulldecl: TopoDS_Edge::~TopoDS_Edge()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_TopoDS_Vertex (TopoDS_Vertex *larg1) {
  TopoDS_Vertex *arg1 = (TopoDS_Vertex *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopoDS_Vertex\n  * wrapname: _wrap_delete_TopoDS_Vertex\n  * fulldecl: TopoDS_Vertex::~TopoDS_Vertex()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopoDS_Iterator *_wrap_new_TopoDS_Iterator__SWIG_0 () {
  TopoDS_Iterator * lresult = (TopoDS_Iterator *)0 ;
  TopoDS_Iterator *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Iterator *)new TopoDS_Iterator();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TopoDS_Iterator\n  * wrapname: _wrap_new_TopoDS_Iterator__SWIG_0\n  * fulldecl: TopoDS_Iterator::TopoDS_Iterator()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Iterator *)0;
  }
}


EXPORT TopoDS_Iterator *_wrap_new_TopoDS_Iterator__SWIG_1 (TopoDS_Shape *larg1, bool larg2, bool larg3) {
  TopoDS_Iterator * lresult = (TopoDS_Iterator *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Boolean arg2 ;
  Standard_Boolean arg3 ;
  TopoDS_Iterator *result = 0 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Iterator *)new TopoDS_Iterator((TopoDS_Shape const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TopoDS_Iterator\n  * wrapname: _wrap_new_TopoDS_Iterator__SWIG_1\n  * fulldecl: TopoDS_Iterator::TopoDS_Iterator(TopoDS_Shape const &,Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Iterator *)0;
  }
}


EXPORT TopoDS_Iterator *_wrap_new_TopoDS_Iterator__SWIG_2 (TopoDS_Shape *larg1, bool larg2) {
  TopoDS_Iterator * lresult = (TopoDS_Iterator *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Boolean arg2 ;
  TopoDS_Iterator *result = 0 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Iterator *)new TopoDS_Iterator((TopoDS_Shape const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TopoDS_Iterator\n  * wrapname: _wrap_new_TopoDS_Iterator__SWIG_2\n  * fulldecl: TopoDS_Iterator::TopoDS_Iterator(TopoDS_Shape const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Iterator *)0;
  }
}


EXPORT TopoDS_Iterator *_wrap_new_TopoDS_Iterator__SWIG_3 (TopoDS_Shape *larg1) {
  TopoDS_Iterator * lresult = (TopoDS_Iterator *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  TopoDS_Iterator *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Iterator *)new TopoDS_Iterator((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TopoDS_Iterator\n  * wrapname: _wrap_new_TopoDS_Iterator__SWIG_3\n  * fulldecl: TopoDS_Iterator::TopoDS_Iterator(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Iterator *)0;
  }
}


EXPORT void _wrap_TopoDS_Iterator_Initialize__SWIG_0 (TopoDS_Iterator *larg1, TopoDS_Shape *larg2, bool larg3, bool larg4) {
  TopoDS_Iterator *arg1 = (TopoDS_Iterator *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean arg3 ;
  Standard_Boolean arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Initialize((TopoDS_Shape const &)*arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Iterator_Initialize\n  * wrapname: _wrap_TopoDS_Iterator_Initialize__SWIG_0\n  * fulldecl: void TopoDS_Iterator::Initialize(TopoDS_Shape const &,Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopoDS_Iterator_Initialize__SWIG_1 (TopoDS_Iterator *larg1, TopoDS_Shape *larg2, bool larg3) {
  TopoDS_Iterator *arg1 = (TopoDS_Iterator *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Initialize((TopoDS_Shape const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Iterator_Initialize\n  * wrapname: _wrap_TopoDS_Iterator_Initialize__SWIG_1\n  * fulldecl: void TopoDS_Iterator::Initialize(TopoDS_Shape const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopoDS_Iterator_Initialize__SWIG_2 (TopoDS_Iterator *larg1, TopoDS_Shape *larg2) {
  TopoDS_Iterator *arg1 = (TopoDS_Iterator *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Initialize((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Iterator_Initialize\n  * wrapname: _wrap_TopoDS_Iterator_Initialize__SWIG_2\n  * fulldecl: void TopoDS_Iterator::Initialize(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_TopoDS_Iterator_More (TopoDS_Iterator *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Iterator *arg1 = (TopoDS_Iterator *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TopoDS_Iterator const *)arg1)->More();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Iterator_More\n  * wrapname: _wrap_TopoDS_Iterator_More\n  * fulldecl: Standard_Boolean TopoDS_Iterator::More() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_TopoDS_Iterator_Next (TopoDS_Iterator *larg1) {
  TopoDS_Iterator *arg1 = (TopoDS_Iterator *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Next();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Iterator_Next\n  * wrapname: _wrap_TopoDS_Iterator_Next\n  * fulldecl: void TopoDS_Iterator::Next()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopoDS_Shape *_wrap_TopoDS_Iterator_Value (TopoDS_Iterator *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  TopoDS_Iterator *arg1 = (TopoDS_Iterator *) 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &((TopoDS_Iterator const *)arg1)->Value();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Iterator_Value\n  * wrapname: _wrap_TopoDS_Iterator_Value\n  * fulldecl: TopoDS_Shape const & TopoDS_Iterator::Value() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT void _wrap_delete_TopoDS_Iterator (TopoDS_Iterator *larg1) {
  TopoDS_Iterator *arg1 = (TopoDS_Iterator *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopoDS_Iterator\n  * wrapname: _wrap_delete_TopoDS_Iterator\n  * fulldecl: TopoDS_Iterator::~TopoDS_Iterator()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopoDS_Builder_MakeWire (TopoDS_Builder *larg1, TopoDS_Wire *larg2) {
  TopoDS_Builder *arg1 = (TopoDS_Builder *) 0 ;
  TopoDS_Wire *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((TopoDS_Builder const *)arg1)->MakeWire(*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Builder_MakeWire\n  * wrapname: _wrap_TopoDS_Builder_MakeWire\n  * fulldecl: void TopoDS_Builder::MakeWire(TopoDS_Wire &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopoDS_Builder_MakeShell (TopoDS_Builder *larg1, TopoDS_Shell *larg2) {
  TopoDS_Builder *arg1 = (TopoDS_Builder *) 0 ;
  TopoDS_Shell *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((TopoDS_Builder const *)arg1)->MakeShell(*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Builder_MakeShell\n  * wrapname: _wrap_TopoDS_Builder_MakeShell\n  * fulldecl: void TopoDS_Builder::MakeShell(TopoDS_Shell &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopoDS_Builder_MakeSolid (TopoDS_Builder *larg1, TopoDS_Solid *larg2) {
  TopoDS_Builder *arg1 = (TopoDS_Builder *) 0 ;
  TopoDS_Solid *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((TopoDS_Builder const *)arg1)->MakeSolid(*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Builder_MakeSolid\n  * wrapname: _wrap_TopoDS_Builder_MakeSolid\n  * fulldecl: void TopoDS_Builder::MakeSolid(TopoDS_Solid &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopoDS_Builder_MakeCompSolid (TopoDS_Builder *larg1, TopoDS_CompSolid *larg2) {
  TopoDS_Builder *arg1 = (TopoDS_Builder *) 0 ;
  TopoDS_CompSolid *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((TopoDS_Builder const *)arg1)->MakeCompSolid(*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Builder_MakeCompSolid\n  * wrapname: _wrap_TopoDS_Builder_MakeCompSolid\n  * fulldecl: void TopoDS_Builder::MakeCompSolid(TopoDS_CompSolid &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopoDS_Builder_MakeCompound (TopoDS_Builder *larg1, TopoDS_Compound *larg2) {
  TopoDS_Builder *arg1 = (TopoDS_Builder *) 0 ;
  TopoDS_Compound *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((TopoDS_Builder const *)arg1)->MakeCompound(*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Builder_MakeCompound\n  * wrapname: _wrap_TopoDS_Builder_MakeCompound\n  * fulldecl: void TopoDS_Builder::MakeCompound(TopoDS_Compound &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopoDS_Builder_Add (TopoDS_Builder *larg1, TopoDS_Shape *larg2, TopoDS_Shape *larg3) {
  TopoDS_Builder *arg1 = (TopoDS_Builder *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopoDS_Shape *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((TopoDS_Builder const *)arg1)->Add(*arg2,(TopoDS_Shape const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Builder_Add\n  * wrapname: _wrap_TopoDS_Builder_Add\n  * fulldecl: void TopoDS_Builder::Add(TopoDS_Shape &,TopoDS_Shape const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopoDS_Builder_Remove (TopoDS_Builder *larg1, TopoDS_Shape *larg2, TopoDS_Shape *larg3) {
  TopoDS_Builder *arg1 = (TopoDS_Builder *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopoDS_Shape *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((TopoDS_Builder const *)arg1)->Remove(*arg2,(TopoDS_Shape const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Builder_Remove\n  * wrapname: _wrap_TopoDS_Builder_Remove\n  * fulldecl: void TopoDS_Builder::Remove(TopoDS_Shape &,TopoDS_Shape const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_TopoDS_Builder (TopoDS_Builder *larg1) {
  TopoDS_Builder *arg1 = (TopoDS_Builder *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopoDS_Builder\n  * wrapname: _wrap_delete_TopoDS_Builder\n  * fulldecl: TopoDS_Builder::~TopoDS_Builder()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <TopTools_HSequenceOfShape.hxx>

EXPORT TopTools_HSequenceOfShape *_wrap_new_TopTools_HSequenceOfShape () {
  TopTools_HSequenceOfShape * lresult = (TopTools_HSequenceOfShape *)0 ;
  TopTools_HSequenceOfShape *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopTools_HSequenceOfShape *)new TopTools_HSequenceOfShape();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TopTools_HSequenceOfShape\n  * wrapname: _wrap_new_TopTools_HSequenceOfShape\n  * fulldecl: TopTools_HSequenceOfShape::TopTools_HSequenceOfShape()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopTools_HSequenceOfShape *)0;
  }
}


EXPORT bool _wrap_TopTools_HSequenceOfShape_IsEmpty (TopTools_HSequenceOfShape *larg1) {
  bool lresult = (bool)0 ;
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TopTools_HSequenceOfShape const *)arg1)->IsEmpty();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_HSequenceOfShape_IsEmpty\n  * wrapname: _wrap_TopTools_HSequenceOfShape_IsEmpty\n  * fulldecl: Standard_Boolean TopTools_HSequenceOfShape::IsEmpty() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Standard_Integer _wrap_TopTools_HSequenceOfShape_Length (TopTools_HSequenceOfShape *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((TopTools_HSequenceOfShape const *)arg1)->Length();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_HSequenceOfShape_Length\n  * wrapname: _wrap_TopTools_HSequenceOfShape_Length\n  * fulldecl: Standard_Integer TopTools_HSequenceOfShape::Length() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT void _wrap_TopTools_HSequenceOfShape_Clear (TopTools_HSequenceOfShape *larg1) {
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Clear();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_HSequenceOfShape_Clear\n  * wrapname: _wrap_TopTools_HSequenceOfShape_Clear\n  * fulldecl: void TopTools_HSequenceOfShape::Clear()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopTools_HSequenceOfShape_Append (TopTools_HSequenceOfShape *larg1, TopoDS_Shape *larg2) {
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Append((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_HSequenceOfShape_Append\n  * wrapname: _wrap_TopTools_HSequenceOfShape_Append\n  * fulldecl: void TopTools_HSequenceOfShape::Append(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopTools_HSequenceOfShape_Prepend (TopTools_HSequenceOfShape *larg1, TopoDS_Shape *larg2) {
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Prepend((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_HSequenceOfShape_Prepend\n  * wrapname: _wrap_TopTools_HSequenceOfShape_Prepend\n  * fulldecl: void TopTools_HSequenceOfShape::Prepend(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopTools_HSequenceOfShape_Reverse (TopTools_HSequenceOfShape *larg1) {
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Reverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_HSequenceOfShape_Reverse\n  * wrapname: _wrap_TopTools_HSequenceOfShape_Reverse\n  * fulldecl: void TopTools_HSequenceOfShape::Reverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopTools_HSequenceOfShape_InsertBefore (TopTools_HSequenceOfShape *larg1, Standard_Integer larg2, TopoDS_Shape *larg3) {
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  Standard_Integer arg2 ;
  TopoDS_Shape *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->InsertBefore(arg2,(TopoDS_Shape const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_HSequenceOfShape_InsertBefore\n  * wrapname: _wrap_TopTools_HSequenceOfShape_InsertBefore\n  * fulldecl: void TopTools_HSequenceOfShape::InsertBefore(Standard_Integer const,TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopTools_HSequenceOfShape_InsertAfter (TopTools_HSequenceOfShape *larg1, Standard_Integer larg2, TopoDS_Shape *larg3) {
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  Standard_Integer arg2 ;
  TopoDS_Shape *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->InsertAfter(arg2,(TopoDS_Shape const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_HSequenceOfShape_InsertAfter\n  * wrapname: _wrap_TopTools_HSequenceOfShape_InsertAfter\n  * fulldecl: void TopTools_HSequenceOfShape::InsertAfter(Standard_Integer const,TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopTools_HSequenceOfShape_Exchange (TopTools_HSequenceOfShape *larg1, Standard_Integer larg2, Standard_Integer larg3) {
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Exchange(arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_HSequenceOfShape_Exchange\n  * wrapname: _wrap_TopTools_HSequenceOfShape_Exchange\n  * fulldecl: void TopTools_HSequenceOfShape::Exchange(Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopTools_HSequenceOfShape_SetValue (TopTools_HSequenceOfShape *larg1, Standard_Integer larg2, TopoDS_Shape *larg3) {
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  Standard_Integer arg2 ;
  TopoDS_Shape *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetValue(arg2,(TopoDS_Shape const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_HSequenceOfShape_SetValue\n  * wrapname: _wrap_TopTools_HSequenceOfShape_SetValue\n  * fulldecl: void TopTools_HSequenceOfShape::SetValue(Standard_Integer const,TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopoDS_Shape *_wrap_TopTools_HSequenceOfShape_Value (TopTools_HSequenceOfShape *larg1, Standard_Integer larg2) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  Standard_Integer arg2 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &((TopTools_HSequenceOfShape const *)arg1)->Value(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_HSequenceOfShape_Value\n  * wrapname: _wrap_TopTools_HSequenceOfShape_Value\n  * fulldecl: TopoDS_Shape const & TopTools_HSequenceOfShape::Value(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT TopoDS_Shape *_wrap_TopTools_HSequenceOfShape_ChangeValue (TopTools_HSequenceOfShape *larg1, Standard_Integer larg2) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  Standard_Integer arg2 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &(arg1)->ChangeValue(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_HSequenceOfShape_ChangeValue\n  * wrapname: _wrap_TopTools_HSequenceOfShape_ChangeValue\n  * fulldecl: TopoDS_Shape & TopTools_HSequenceOfShape::ChangeValue(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT void _wrap_TopTools_HSequenceOfShape_Remove__SWIG_0 (TopTools_HSequenceOfShape *larg1, Standard_Integer larg2) {
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  Standard_Integer arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Remove(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_HSequenceOfShape_Remove\n  * wrapname: _wrap_TopTools_HSequenceOfShape_Remove__SWIG_0\n  * fulldecl: void TopTools_HSequenceOfShape::Remove(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopTools_HSequenceOfShape_Remove__SWIG_1 (TopTools_HSequenceOfShape *larg1, Standard_Integer larg2, Standard_Integer larg3) {
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Remove(arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_HSequenceOfShape_Remove\n  * wrapname: _wrap_TopTools_HSequenceOfShape_Remove__SWIG_1\n  * fulldecl: void TopTools_HSequenceOfShape::Remove(Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopTools_SequenceOfShape *_wrap_TopTools_HSequenceOfShape_Sequence (TopTools_HSequenceOfShape *larg1) {
  TopTools_SequenceOfShape * lresult = (TopTools_SequenceOfShape *)0 ;
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  TopTools_SequenceOfShape *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopTools_SequenceOfShape *) &((TopTools_HSequenceOfShape const *)arg1)->Sequence();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_HSequenceOfShape_Sequence\n  * wrapname: _wrap_TopTools_HSequenceOfShape_Sequence\n  * fulldecl: TopTools_SequenceOfShape const & TopTools_HSequenceOfShape::Sequence() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopTools_SequenceOfShape *)0;
  }
}


EXPORT void _wrap_delete_TopTools_HSequenceOfShape (TopTools_HSequenceOfShape *larg1) {
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopTools_HSequenceOfShape\n  * wrapname: _wrap_delete_TopTools_HSequenceOfShape\n  * fulldecl: TopTools_HSequenceOfShape::~TopTools_HSequenceOfShape()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <TopTools_ListOfShape.hxx>

EXPORT TopTools_ListOfShape *_wrap_new_TopTools_ListOfShape () {
  TopTools_ListOfShape * lresult = (TopTools_ListOfShape *)0 ;
  TopTools_ListOfShape *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopTools_ListOfShape *)new TopTools_ListOfShape();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TopTools_ListOfShape\n  * wrapname: _wrap_new_TopTools_ListOfShape\n  * fulldecl: TopTools_ListOfShape::TopTools_ListOfShape()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopTools_ListOfShape *)0;
  }
}


EXPORT TopoDS_Shape *_wrap_TopTools_ListOfShape_Append (TopTools_ListOfShape *larg1, TopoDS_Shape *larg2) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  TopTools_ListOfShape *arg1 = (TopTools_ListOfShape *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &(arg1)->Append((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_ListOfShape_Append\n  * wrapname: _wrap_TopTools_ListOfShape_Append\n  * fulldecl: TopoDS_Shape & TopTools_ListOfShape::Append(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT TopoDS_Shape *_wrap_TopTools_ListOfShape_Prepend (TopTools_ListOfShape *larg1, TopoDS_Shape *larg2) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  TopTools_ListOfShape *arg1 = (TopTools_ListOfShape *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &(arg1)->Prepend((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_ListOfShape_Prepend\n  * wrapname: _wrap_TopTools_ListOfShape_Prepend\n  * fulldecl: TopoDS_Shape & TopTools_ListOfShape::Prepend(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT void _wrap_delete_TopTools_ListOfShape (TopTools_ListOfShape *larg1) {
  TopTools_ListOfShape *arg1 = (TopTools_ListOfShape *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopTools_ListOfShape\n  * wrapname: _wrap_delete_TopTools_ListOfShape\n  * fulldecl: TopTools_ListOfShape::~TopTools_ListOfShape()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



  #include <TopTools_MapOfShape.hxx>
  
EXPORT TopTools_MapOfShape *_wrap_new_TopTools_MapOfShape () {
  TopTools_MapOfShape * lresult = (TopTools_MapOfShape *)0 ;
  TopTools_MapOfShape *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopTools_MapOfShape *)new TopTools_MapOfShape();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TopTools_MapOfShape\n  * wrapname: _wrap_new_TopTools_MapOfShape\n  * fulldecl: TopTools_MapOfShape::TopTools_MapOfShape()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopTools_MapOfShape *)0;
  }
}


EXPORT bool _wrap_TopTools_MapOfShape_Add (TopTools_MapOfShape *larg1, TopoDS_Shape *larg2) {
  bool lresult = (bool)0 ;
  TopTools_MapOfShape *arg1 = (TopTools_MapOfShape *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->Add((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_MapOfShape_Add\n  * wrapname: _wrap_TopTools_MapOfShape_Add\n  * fulldecl: Standard_Boolean TopTools_MapOfShape::Add(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_TopTools_MapOfShape_Contains (TopTools_MapOfShape *larg1, TopoDS_Shape *larg2) {
  bool lresult = (bool)0 ;
  TopTools_MapOfShape *arg1 = (TopTools_MapOfShape *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TopTools_MapOfShape const *)arg1)->Contains((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_MapOfShape_Contains\n  * wrapname: _wrap_TopTools_MapOfShape_Contains\n  * fulldecl: Standard_Boolean TopTools_MapOfShape::Contains(TopoDS_Shape const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_delete_TopTools_MapOfShape (TopTools_MapOfShape *larg1) {
  TopTools_MapOfShape *arg1 = (TopTools_MapOfShape *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopTools_MapOfShape\n  * wrapname: _wrap_delete_TopTools_MapOfShape\n  * fulldecl: TopTools_MapOfShape::~TopTools_MapOfShape()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <TCollection_BasicMapIterator.hxx>
#include <TopTools_MapIteratorOfMapOfShape.hxx>
  
EXPORT bool _wrap_TCollection_BasicMapIterator_More (TCollection_BasicMapIterator *larg1) {
  bool lresult = (bool)0 ;
  TCollection_BasicMapIterator *arg1 = (TCollection_BasicMapIterator *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TCollection_BasicMapIterator const *)arg1)->More();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TCollection_BasicMapIterator_More\n  * wrapname: _wrap_TCollection_BasicMapIterator_More\n  * fulldecl: Standard_Boolean TCollection_BasicMapIterator::More() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_TCollection_BasicMapIterator_Next (TCollection_BasicMapIterator *larg1) {
  TCollection_BasicMapIterator *arg1 = (TCollection_BasicMapIterator *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Next();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TCollection_BasicMapIterator_Next\n  * wrapname: _wrap_TCollection_BasicMapIterator_Next\n  * fulldecl: void TCollection_BasicMapIterator::Next()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_TCollection_BasicMapIterator (TCollection_BasicMapIterator *larg1) {
  TCollection_BasicMapIterator *arg1 = (TCollection_BasicMapIterator *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TCollection_BasicMapIterator\n  * wrapname: _wrap_delete_TCollection_BasicMapIterator\n  * fulldecl: TCollection_BasicMapIterator::~TCollection_BasicMapIterator()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopTools_MapIteratorOfMapOfShape *_wrap_new_TopTools_MapIteratorOfMapOfShape (TopTools_MapOfShape *larg1) {
  TopTools_MapIteratorOfMapOfShape * lresult = (TopTools_MapIteratorOfMapOfShape *)0 ;
  TopTools_MapOfShape *arg1 = 0 ;
  TopTools_MapIteratorOfMapOfShape *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopTools_MapIteratorOfMapOfShape *)new TopTools_MapIteratorOfMapOfShape((TopTools_MapOfShape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TopTools_MapIteratorOfMapOfShape\n  * wrapname: _wrap_new_TopTools_MapIteratorOfMapOfShape\n  * fulldecl: TopTools_MapIteratorOfMapOfShape::TopTools_MapIteratorOfMapOfShape(TopTools_MapOfShape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopTools_MapIteratorOfMapOfShape *)0;
  }
}


EXPORT TopoDS_Shape *_wrap_TopTools_MapIteratorOfMapOfShape_Key (TopTools_MapIteratorOfMapOfShape *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  TopTools_MapIteratorOfMapOfShape *arg1 = (TopTools_MapIteratorOfMapOfShape *) 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &((TopTools_MapIteratorOfMapOfShape const *)arg1)->Key();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_MapIteratorOfMapOfShape_Key\n  * wrapname: _wrap_TopTools_MapIteratorOfMapOfShape_Key\n  * fulldecl: TopoDS_Shape const & TopTools_MapIteratorOfMapOfShape::Key() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT void _wrap_delete_TopTools_MapIteratorOfMapOfShape (TopTools_MapIteratorOfMapOfShape *larg1) {
  TopTools_MapIteratorOfMapOfShape *arg1 = (TopTools_MapIteratorOfMapOfShape *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopTools_MapIteratorOfMapOfShape\n  * wrapname: _wrap_delete_TopTools_MapIteratorOfMapOfShape\n  * fulldecl: TopTools_MapIteratorOfMapOfShape::~TopTools_MapIteratorOfMapOfShape()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <BRep_Tool.hxx>
#include <Geom_Curve.hxx>
#include <BRep_Builder.hxx>
#include <TopoDS_Builder.hxx>
#include <TopLoc_Location.hxx>
#include <Poly_Triangulation.hxx>

EXPORT bool _wrap_BRep_Tool_IsClosed (TopoDS_Shape *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRep_Tool::IsClosed((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_IsClosed\n  * wrapname: _wrap_BRep_Tool_IsClosed\n  * fulldecl: Standard_Boolean BRep_Tool::IsClosed(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Handle_Geom_Surface *_wrap_BRep_Tool_Surface (TopoDS_Face *larg1) {
  Handle_Geom_Surface * lresult = (Handle_Geom_Surface *)0 ;
  TopoDS_Face *arg1 = 0 ;
  SwigValueWrapper< Handle_Geom_Surface > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = BRep_Tool::Surface((TopoDS_Face const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_Surface\n  * wrapname: _wrap_BRep_Tool_Surface\n  * fulldecl: Handle_Geom_Surface BRep_Tool::Surface(TopoDS_Face const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Surface(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Surface *)0;
  }
}


EXPORT gp_Pnt const *_wrap_BRep_Tool_Pnt (TopoDS_Vertex *larg1) {
  gp_Pnt const * lresult = (gp_Pnt const *)0 ;
  TopoDS_Vertex *arg1 = 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = BRep_Tool::Pnt((TopoDS_Vertex const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_Pnt\n  * wrapname: _wrap_BRep_Tool_Pnt\n  * fulldecl: gp_Pnt const BRep_Tool::Pnt(TopoDS_Vertex const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt const(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt const *)0;
  }
}


EXPORT gp_Pnt2d *_wrap_BRep_Tool_Parameters (TopoDS_Vertex *larg1, TopoDS_Face *larg2) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  TopoDS_Vertex *arg1 = 0 ;
  TopoDS_Face *arg2 = 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = BRep_Tool::Parameters((TopoDS_Vertex const &)*arg1,(TopoDS_Face const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_Parameters\n  * wrapname: _wrap_BRep_Tool_Parameters\n  * fulldecl: gp_Pnt2d BRep_Tool::Parameters(TopoDS_Vertex const &,TopoDS_Face const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT Standard_Real _wrap_BRep_Tool_Parameter (TopoDS_Vertex *larg1, TopoDS_Edge *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  TopoDS_Vertex *arg1 = 0 ;
  TopoDS_Edge *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)BRep_Tool::Parameter((TopoDS_Vertex const &)*arg1,(TopoDS_Edge const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_Parameter\n  * wrapname: _wrap_BRep_Tool_Parameter\n  * fulldecl: Standard_Real BRep_Tool::Parameter(TopoDS_Vertex const &,TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT bool _wrap_BRep_Tool_Degenerated (TopoDS_Edge *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Edge *arg1 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRep_Tool::Degenerated((TopoDS_Edge const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_Degenerated\n  * wrapname: _wrap_BRep_Tool_Degenerated\n  * fulldecl: Standard_Boolean BRep_Tool::Degenerated(TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRep_Tool_SameParameter (TopoDS_Edge *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Edge *arg1 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRep_Tool::SameParameter((TopoDS_Edge const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_SameParameter\n  * wrapname: _wrap_BRep_Tool_SameParameter\n  * fulldecl: Standard_Boolean BRep_Tool::SameParameter(TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRep_Tool_SameRange (TopoDS_Edge *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Edge *arg1 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRep_Tool::SameRange((TopoDS_Edge const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_SameRange\n  * wrapname: _wrap_BRep_Tool_SameRange\n  * fulldecl: Standard_Boolean BRep_Tool::SameRange(TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRep_Tool_HasContinuity (TopoDS_Edge *larg1, TopoDS_Face *larg2, TopoDS_Face *larg3) {
  bool lresult = (bool)0 ;
  TopoDS_Edge *arg1 = 0 ;
  TopoDS_Face *arg2 = 0 ;
  TopoDS_Face *arg3 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRep_Tool::HasContinuity((TopoDS_Edge const &)*arg1,(TopoDS_Face const &)*arg2,(TopoDS_Face const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_HasContinuity\n  * wrapname: _wrap_BRep_Tool_HasContinuity\n  * fulldecl: Standard_Boolean BRep_Tool::HasContinuity(TopoDS_Edge const &,TopoDS_Face const &,TopoDS_Face const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT GeomAbs_Shape _wrap_BRep_Tool_Continuity (TopoDS_Edge *larg1, TopoDS_Face *larg2, TopoDS_Face *larg3) {
  GeomAbs_Shape lresult = (GeomAbs_Shape)0 ;
  TopoDS_Edge *arg1 = 0 ;
  TopoDS_Face *arg2 = 0 ;
  TopoDS_Face *arg3 = 0 ;
  GeomAbs_Shape result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAbs_Shape)BRep_Tool::Continuity((TopoDS_Edge const &)*arg1,(TopoDS_Face const &)*arg2,(TopoDS_Face const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_Continuity\n  * wrapname: _wrap_BRep_Tool_Continuity\n  * fulldecl: GeomAbs_Shape BRep_Tool::Continuity(TopoDS_Edge const &,TopoDS_Face const &,TopoDS_Face const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAbs_Shape)0;
  }
}


EXPORT Standard_Real _wrap_BRep_Tool_Tolerance__SWIG_0 (TopoDS_Face *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  TopoDS_Face *arg1 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)BRep_Tool::Tolerance((TopoDS_Face const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_Tolerance\n  * wrapname: _wrap_BRep_Tool_Tolerance__SWIG_0\n  * fulldecl: Standard_Real BRep_Tool::Tolerance(TopoDS_Face const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_BRep_Tool_Tolerance__SWIG_1 (TopoDS_Edge *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  TopoDS_Edge *arg1 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)BRep_Tool::Tolerance((TopoDS_Edge const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_Tolerance\n  * wrapname: _wrap_BRep_Tool_Tolerance__SWIG_1\n  * fulldecl: Standard_Real BRep_Tool::Tolerance(TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_BRep_Tool_Tolerance__SWIG_2 (TopoDS_Vertex *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  TopoDS_Vertex *arg1 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)BRep_Tool::Tolerance((TopoDS_Vertex const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_Tolerance\n  * wrapname: _wrap_BRep_Tool_Tolerance__SWIG_2\n  * fulldecl: Standard_Real BRep_Tool::Tolerance(TopoDS_Vertex const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Handle_Poly_Triangulation *_wrap_BRep_Tool_Triangulation (TopoDS_Face *larg1, TopLoc_Location *larg2) {
  Handle_Poly_Triangulation * lresult = (Handle_Poly_Triangulation *)0 ;
  TopoDS_Face *arg1 = 0 ;
  TopLoc_Location *arg2 = 0 ;
  Handle_Poly_Triangulation *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Poly_Triangulation *) &BRep_Tool::Triangulation((TopoDS_Face const &)*arg1,*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_Triangulation\n  * wrapname: _wrap_BRep_Tool_Triangulation\n  * fulldecl: Handle_Poly_Triangulation const & BRep_Tool::Triangulation(TopoDS_Face const &,TopLoc_Location &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Poly_Triangulation *)0;
  }
}


EXPORT Handle_Geom_Curve *_wrap_BRep_Tool_Curve (TopoDS_Edge *larg1, Standard_Real *larg2, Standard_Real *larg3) {
  Handle_Geom_Curve * lresult = (Handle_Geom_Curve *)0 ;
  TopoDS_Edge *arg1 = 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  SwigValueWrapper< Handle_Geom_Curve > result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = BRep_Tool::Curve((TopoDS_Edge const &)*arg1,*arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_Curve\n  * wrapname: _wrap_BRep_Tool_Curve\n  * fulldecl: Handle_Geom_Curve BRep_Tool::Curve(TopoDS_Edge const &,Standard_Real &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Curve(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Curve *)0;
  }
}


EXPORT Handle_Geom2d_Curve *_wrap_BRep_Tool_CurveOnSurface (TopoDS_Edge *larg1, TopoDS_Face *larg2, Standard_Real *larg3, Standard_Real *larg4) {
  Handle_Geom2d_Curve * lresult = (Handle_Geom2d_Curve *)0 ;
  TopoDS_Edge *arg1 = 0 ;
  TopoDS_Face *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  SwigValueWrapper< Handle_Geom2d_Curve > result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = BRep_Tool::CurveOnSurface((TopoDS_Edge const &)*arg1,(TopoDS_Face const &)*arg2,*arg3,*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_CurveOnSurface\n  * wrapname: _wrap_BRep_Tool_CurveOnSurface\n  * fulldecl: Handle_Geom2d_Curve BRep_Tool::CurveOnSurface(TopoDS_Edge const &,TopoDS_Face const &,Standard_Real &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Curve(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Curve *)0;
  }
}


EXPORT void _wrap_BRep_Tool_Range (TopoDS_Edge *larg1, Standard_Real *larg2, Standard_Real *larg3) {
  TopoDS_Edge *arg1 = 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRep_Tool::Range((TopoDS_Edge const &)*arg1,*arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_Range\n  * wrapname: _wrap_BRep_Tool_Range\n  * fulldecl: void BRep_Tool::Range(TopoDS_Edge const &,Standard_Real &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Poly_Polygon3D *BRep_Tool_Polygon3D(TopoDS_Edge const &E,TopLoc_Location &L){
    Handle_Poly_Polygon3D h = BRep_Tool::Polygon3D(E, L);
    if (h.IsNull())
      return (Poly_Polygon3D *) NULL;
    else
      return (Poly_Polygon3D *)h.get();
  }
EXPORT Poly_Polygon3D *_wrap_BRep_Tool_Polygon3D (TopoDS_Edge *larg1, TopLoc_Location *larg2) {
  Poly_Polygon3D * lresult = (Poly_Polygon3D *)0 ;
  TopoDS_Edge *arg1 = 0 ;
  TopLoc_Location *arg2 = 0 ;
  Poly_Polygon3D *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Poly_Polygon3D *)BRep_Tool_Polygon3D((TopoDS_Edge const &)*arg1,*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_Polygon3D\n  * wrapname: _wrap_BRep_Tool_Polygon3D\n  * fulldecl: Poly_Polygon3D * BRep_Tool::BRep_Tool_Polygon3D(TopoDS_Edge const &,TopLoc_Location &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Poly_Polygon3D *)0;
  }
}


SWIGINTERN Poly_PolygonOnTriangulation *BRep_Tool_PolygonOnTriangulation(TopoDS_Edge const &E,Handle_Poly_Triangulation const &T,TopLoc_Location const &L){
    Handle_Poly_PolygonOnTriangulation h = BRep_Tool::PolygonOnTriangulation(E, T, L);
    if (h.IsNull())
      return (Poly_PolygonOnTriangulation *) NULL;
    else
      return (Poly_PolygonOnTriangulation *)h.get();
  }
EXPORT Poly_PolygonOnTriangulation *_wrap_BRep_Tool_PolygonOnTriangulation (TopoDS_Edge *larg1, Handle_Poly_Triangulation *larg2, TopLoc_Location *larg3) {
  Poly_PolygonOnTriangulation * lresult = (Poly_PolygonOnTriangulation *)0 ;
  TopoDS_Edge *arg1 = 0 ;
  Handle_Poly_Triangulation *arg2 = 0 ;
  TopLoc_Location *arg3 = 0 ;
  Poly_PolygonOnTriangulation *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Poly_PolygonOnTriangulation *)BRep_Tool_PolygonOnTriangulation((TopoDS_Edge const &)*arg1,(Handle_Poly_Triangulation const &)*arg2,(TopLoc_Location const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_PolygonOnTriangulation\n  * wrapname: _wrap_BRep_Tool_PolygonOnTriangulation\n  * fulldecl: Poly_PolygonOnTriangulation * BRep_Tool::BRep_Tool_PolygonOnTriangulation(TopoDS_Edge const &,Handle_Poly_Triangulation const &,TopLoc_Location const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Poly_PolygonOnTriangulation *)0;
  }
}


EXPORT BRep_Builder *_wrap_new_BRep_Builder () {
  BRep_Builder * lresult = (BRep_Builder *)0 ;
  BRep_Builder *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRep_Builder *)new BRep_Builder();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRep_Builder\n  * wrapname: _wrap_new_BRep_Builder\n  * fulldecl: BRep_Builder::BRep_Builder()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRep_Builder *)0;
  }
}


EXPORT void _wrap_BRep_Builder_MakeFace__SWIG_0 (BRep_Builder *larg1, TopoDS_Face *larg2) {
  BRep_Builder *arg1 = (BRep_Builder *) 0 ;
  TopoDS_Face *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRep_Builder const *)arg1)->MakeFace(*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Builder_MakeFace\n  * wrapname: _wrap_BRep_Builder_MakeFace__SWIG_0\n  * fulldecl: void BRep_Builder::MakeFace(TopoDS_Face &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRep_Builder_MakeFace__SWIG_1 (BRep_Builder *larg1, TopoDS_Face *larg2, Handle_Geom_Surface *larg3, Standard_Real larg4) {
  BRep_Builder *arg1 = (BRep_Builder *) 0 ;
  TopoDS_Face *arg2 = 0 ;
  Handle_Geom_Surface *arg3 = 0 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRep_Builder const *)arg1)->MakeFace(*arg2,(Handle_Geom_Surface const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Builder_MakeFace\n  * wrapname: _wrap_BRep_Builder_MakeFace__SWIG_1\n  * fulldecl: void BRep_Builder::MakeFace(TopoDS_Face &,Handle_Geom_Surface const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRep_Builder_MakeFace__SWIG_2 (BRep_Builder *larg1, TopoDS_Face *larg2, Handle_Geom_Surface *larg3, TopLoc_Location *larg4, Standard_Real larg5) {
  BRep_Builder *arg1 = (BRep_Builder *) 0 ;
  TopoDS_Face *arg2 = 0 ;
  Handle_Geom_Surface *arg3 = 0 ;
  TopLoc_Location *arg4 = 0 ;
  Standard_Real arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRep_Builder const *)arg1)->MakeFace(*arg2,(Handle_Geom_Surface const &)*arg3,(TopLoc_Location const &)*arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Builder_MakeFace\n  * wrapname: _wrap_BRep_Builder_MakeFace__SWIG_2\n  * fulldecl: void BRep_Builder::MakeFace(TopoDS_Face &,Handle_Geom_Surface const &,TopLoc_Location const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRep_Builder_MakeEdge__SWIG_0 (BRep_Builder *larg1, TopoDS_Edge *larg2) {
  BRep_Builder *arg1 = (BRep_Builder *) 0 ;
  TopoDS_Edge *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRep_Builder const *)arg1)->MakeEdge(*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Builder_MakeEdge\n  * wrapname: _wrap_BRep_Builder_MakeEdge__SWIG_0\n  * fulldecl: void BRep_Builder::MakeEdge(TopoDS_Edge &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRep_Builder_MakeEdge__SWIG_1 (BRep_Builder *larg1, TopoDS_Edge *larg2, Handle_Geom_Curve *larg3, Standard_Real larg4) {
  BRep_Builder *arg1 = (BRep_Builder *) 0 ;
  TopoDS_Edge *arg2 = 0 ;
  Handle_Geom_Curve *arg3 = 0 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRep_Builder const *)arg1)->MakeEdge(*arg2,(Handle_Geom_Curve const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Builder_MakeEdge\n  * wrapname: _wrap_BRep_Builder_MakeEdge__SWIG_1\n  * fulldecl: void BRep_Builder::MakeEdge(TopoDS_Edge &,Handle_Geom_Curve const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRep_Builder_MakeEdge__SWIG_2 (BRep_Builder *larg1, TopoDS_Edge *larg2, Handle_Geom_Curve *larg3, TopLoc_Location *larg4, Standard_Real larg5) {
  BRep_Builder *arg1 = (BRep_Builder *) 0 ;
  TopoDS_Edge *arg2 = 0 ;
  Handle_Geom_Curve *arg3 = 0 ;
  TopLoc_Location *arg4 = 0 ;
  Standard_Real arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRep_Builder const *)arg1)->MakeEdge(*arg2,(Handle_Geom_Curve const &)*arg3,(TopLoc_Location const &)*arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Builder_MakeEdge\n  * wrapname: _wrap_BRep_Builder_MakeEdge__SWIG_2\n  * fulldecl: void BRep_Builder::MakeEdge(TopoDS_Edge &,Handle_Geom_Curve const &,TopLoc_Location const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRep_Builder_UpdateEdge__SWIG_0 (BRep_Builder *larg1, TopoDS_Edge *larg2, Handle_Geom_Curve *larg3, Standard_Real larg4) {
  BRep_Builder *arg1 = (BRep_Builder *) 0 ;
  TopoDS_Edge *arg2 = 0 ;
  Handle_Geom_Curve *arg3 = 0 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRep_Builder const *)arg1)->UpdateEdge((TopoDS_Edge const &)*arg2,(Handle_Geom_Curve const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Builder_UpdateEdge\n  * wrapname: _wrap_BRep_Builder_UpdateEdge__SWIG_0\n  * fulldecl: void BRep_Builder::UpdateEdge(TopoDS_Edge const &,Handle_Geom_Curve const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRep_Builder_UpdateEdge__SWIG_1 (BRep_Builder *larg1, TopoDS_Edge *larg2, Handle_Geom2d_Curve *larg3, TopoDS_Face *larg4, Standard_Real larg5) {
  BRep_Builder *arg1 = (BRep_Builder *) 0 ;
  TopoDS_Edge *arg2 = 0 ;
  Handle_Geom2d_Curve *arg3 = 0 ;
  TopoDS_Face *arg4 = 0 ;
  Standard_Real arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRep_Builder const *)arg1)->UpdateEdge((TopoDS_Edge const &)*arg2,(Handle_Geom2d_Curve const &)*arg3,(TopoDS_Face const &)*arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Builder_UpdateEdge\n  * wrapname: _wrap_BRep_Builder_UpdateEdge__SWIG_1\n  * fulldecl: void BRep_Builder::UpdateEdge(TopoDS_Edge const &,Handle_Geom2d_Curve const &,TopoDS_Face const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRep_Builder_UpdateEdge__SWIG_2 (BRep_Builder *larg1, TopoDS_Edge *larg2, Handle_Geom2d_Curve *larg3, Handle_Geom2d_Curve *larg4, TopoDS_Face *larg5, Standard_Real larg6) {
  BRep_Builder *arg1 = (BRep_Builder *) 0 ;
  TopoDS_Edge *arg2 = 0 ;
  Handle_Geom2d_Curve *arg3 = 0 ;
  Handle_Geom2d_Curve *arg4 = 0 ;
  TopoDS_Face *arg5 = 0 ;
  Standard_Real arg6 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRep_Builder const *)arg1)->UpdateEdge((TopoDS_Edge const &)*arg2,(Handle_Geom2d_Curve const &)*arg3,(Handle_Geom2d_Curve const &)*arg4,(TopoDS_Face const &)*arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Builder_UpdateEdge\n  * wrapname: _wrap_BRep_Builder_UpdateEdge__SWIG_2\n  * fulldecl: void BRep_Builder::UpdateEdge(TopoDS_Edge const &,Handle_Geom2d_Curve const &,Handle_Geom2d_Curve const &,TopoDS_Face const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRep_Builder_MakeVertex__SWIG_0 (BRep_Builder *larg1, TopoDS_Vertex *larg2) {
  BRep_Builder *arg1 = (BRep_Builder *) 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRep_Builder const *)arg1)->MakeVertex(*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Builder_MakeVertex\n  * wrapname: _wrap_BRep_Builder_MakeVertex__SWIG_0\n  * fulldecl: void BRep_Builder::MakeVertex(TopoDS_Vertex &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRep_Builder_MakeVertex__SWIG_1 (BRep_Builder *larg1, TopoDS_Vertex *larg2, gp_Pnt *larg3, Standard_Real larg4) {
  BRep_Builder *arg1 = (BRep_Builder *) 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRep_Builder const *)arg1)->MakeVertex(*arg2,(gp_Pnt const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Builder_MakeVertex\n  * wrapname: _wrap_BRep_Builder_MakeVertex__SWIG_1\n  * fulldecl: void BRep_Builder::MakeVertex(TopoDS_Vertex &,gp_Pnt const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRep_Builder_UpdateVertex__SWIG_0 (BRep_Builder *larg1, TopoDS_Vertex *larg2, Standard_Real larg3, Standard_Real larg4, TopoDS_Face *larg5, Standard_Real larg6) {
  BRep_Builder *arg1 = (BRep_Builder *) 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  TopoDS_Face *arg5 = 0 ;
  Standard_Real arg6 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRep_Builder const *)arg1)->UpdateVertex((TopoDS_Vertex const &)*arg2,arg3,arg4,(TopoDS_Face const &)*arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Builder_UpdateVertex\n  * wrapname: _wrap_BRep_Builder_UpdateVertex__SWIG_0\n  * fulldecl: void BRep_Builder::UpdateVertex(TopoDS_Vertex const &,Standard_Real const,Standard_Real const,TopoDS_Face const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRep_Builder_UpdateVertex__SWIG_1 (BRep_Builder *larg1, TopoDS_Vertex *larg2, Standard_Real larg3) {
  BRep_Builder *arg1 = (BRep_Builder *) 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRep_Builder const *)arg1)->UpdateVertex((TopoDS_Vertex const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Builder_UpdateVertex\n  * wrapname: _wrap_BRep_Builder_UpdateVertex__SWIG_1\n  * fulldecl: void BRep_Builder::UpdateVertex(TopoDS_Vertex const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRep_Builder_Degenerated (BRep_Builder *larg1, TopoDS_Edge *larg2, bool larg3) {
  BRep_Builder *arg1 = (BRep_Builder *) 0 ;
  TopoDS_Edge *arg2 = 0 ;
  Standard_Boolean arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRep_Builder const *)arg1)->Degenerated((TopoDS_Edge const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Builder_Degenerated\n  * wrapname: _wrap_BRep_Builder_Degenerated\n  * fulldecl: void BRep_Builder::Degenerated(TopoDS_Edge const &,Standard_Boolean const) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_BRep_Builder (BRep_Builder *larg1) {
  BRep_Builder *arg1 = (BRep_Builder *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRep_Builder\n  * wrapname: _wrap_delete_BRep_Builder\n  * fulldecl: BRep_Builder::~BRep_Builder()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include "GeomLProp_SLProps.hxx"
SWIGINTERN void GeomLProp_SLProps_normal(GeomLProp_SLProps *self,double normal[3]){
		if(!self->IsNormalDefined())
		{
			normal[0]=0;
			normal[1]=0;
			normal[2]=0;
		}
		else
		{
			const gp_Dir & d=self->Normal();
			normal[0]=d.X();
			normal[1]=d.Y();
			normal[2]=d.Z();
		}
	}
EXPORT void _wrap_GeomLProp_SLProps_normal (GeomLProp_SLProps *larg1, double *larg2) {
  GeomLProp_SLProps *arg1 = (GeomLProp_SLProps *) 0 ;
  double *arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        GeomLProp_SLProps_normal(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomLProp_SLProps_normal\n  * wrapname: _wrap_GeomLProp_SLProps_normal\n  * fulldecl: void GeomLProp_SLProps::normal(double [3])";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void GeomLProp_SLProps_normalArray(GeomLProp_SLProps *self,double *uvNodes,double *normalArray,int numNodes){
		for(int i=0;i<numNodes;i++)
		{
			self->SetParameters(uvNodes[2*i],uvNodes[2*i+1]);
			
			if(!self->IsNormalDefined())
			{
				normalArray[3*i]=0;
				normalArray[3*i+1]=0;
				normalArray[3*i+2]=0;
			}
			else
			{
				const gp_Dir & d=self->Normal();
				
				normalArray[3*i]=d.X();
				normalArray[3*i+1]=d.Y();
				normalArray[3*i+2]=d.Z();
			}
		}
	}
EXPORT void _wrap_GeomLProp_SLProps_normalArray (GeomLProp_SLProps *larg1, double *larg2, double *larg3, int larg4) {
  GeomLProp_SLProps *arg1 = (GeomLProp_SLProps *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        GeomLProp_SLProps_normalArray(arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomLProp_SLProps_normalArray\n  * wrapname: _wrap_GeomLProp_SLProps_normalArray\n  * fulldecl: void GeomLProp_SLProps::normalArray(double *,double *,int)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real GeomLProp_SLProps_minCurvature(GeomLProp_SLProps *self){
		if (!self->IsCurvatureDefined())
			return sqrt(-1.0);
		else
			return self->MinCurvature ();
	}
EXPORT Standard_Real _wrap_GeomLProp_SLProps_minCurvature (GeomLProp_SLProps *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  GeomLProp_SLProps *arg1 = (GeomLProp_SLProps *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)GeomLProp_SLProps_minCurvature(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomLProp_SLProps_minCurvature\n  * wrapname: _wrap_GeomLProp_SLProps_minCurvature\n  * fulldecl: Standard_Real GeomLProp_SLProps::minCurvature()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real GeomLProp_SLProps_maxCurvature(GeomLProp_SLProps *self){
		if (!self->IsCurvatureDefined())
			return sqrt(-1.0);
		else
			return self->MaxCurvature ();
	}
EXPORT Standard_Real _wrap_GeomLProp_SLProps_maxCurvature (GeomLProp_SLProps *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  GeomLProp_SLProps *arg1 = (GeomLProp_SLProps *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)GeomLProp_SLProps_maxCurvature(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomLProp_SLProps_maxCurvature\n  * wrapname: _wrap_GeomLProp_SLProps_maxCurvature\n  * fulldecl: Standard_Real GeomLProp_SLProps::maxCurvature()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN void GeomLProp_SLProps_curvatureDirection(GeomLProp_SLProps *self,double jmax[3],double jmin[3]){
		gp_Dir max, min;
		self->CurvatureDirections(max, min);
		jmax[0]=max.X();
		jmax[1]=max.Y();
		jmax[2]=max.Z();
		jmin[0]=min.X();
		jmin[1]=min.Y();
		jmin[2]=min.Z();
	}
EXPORT void _wrap_GeomLProp_SLProps_curvatureDirection (GeomLProp_SLProps *larg1, double *larg2, double *larg3) {
  GeomLProp_SLProps *arg1 = (GeomLProp_SLProps *) 0 ;
  double *arg2 ;
  double *arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        GeomLProp_SLProps_curvatureDirection(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomLProp_SLProps_curvatureDirection\n  * wrapname: _wrap_GeomLProp_SLProps_curvatureDirection\n  * fulldecl: void GeomLProp_SLProps::curvatureDirection(double [3],double [3])";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_GeomLProp_SLProps (GeomLProp_SLProps *larg1) {
  GeomLProp_SLProps *arg1 = (GeomLProp_SLProps *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_GeomLProp_SLProps\n  * wrapname: _wrap_delete_GeomLProp_SLProps\n  * fulldecl: GeomLProp_SLProps::~GeomLProp_SLProps()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <BRepTools.hxx>
#include <BRepTools_ShapeSet.hxx>    

EXPORT bool _wrap_BRepTools_Read (TopoDS_Shape *larg1, Standard_CString larg2, BRep_Builder *larg3) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_CString arg2 = (Standard_CString) (Standard_CString)0 ;
  BRep_Builder *arg3 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepTools::Read(*arg1,(char const *)arg2,(BRep_Builder const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_Read\n  * wrapname: _wrap_BRepTools_Read\n  * fulldecl: Standard_Boolean BRepTools::Read(TopoDS_Shape &,Standard_CString const,BRep_Builder const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepTools_Write__SWIG_0 (TopoDS_Shape *larg1, Standard_CString larg2) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_CString arg2 = (Standard_CString) (Standard_CString)0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepTools::Write((TopoDS_Shape const &)*arg1,(char const *)arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_Write\n  * wrapname: _wrap_BRepTools_Write__SWIG_0\n  * fulldecl: Standard_Boolean BRepTools::Write(TopoDS_Shape const &,Standard_CString const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_BRepTools_Write__SWIG_1 (TopoDS_Shape *larg1, Standard_OStream *larg2) {
  TopoDS_Shape *arg1 = 0 ;
  Standard_OStream *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepTools::Write((TopoDS_Shape const &)*arg1,*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_Write\n  * wrapname: _wrap_BRepTools_Write__SWIG_1\n  * fulldecl: void BRepTools::Write(TopoDS_Shape const &,Standard_OStream &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepTools_Clean (TopoDS_Shape *larg1) {
  TopoDS_Shape *arg1 = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepTools::Clean((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_Clean\n  * wrapname: _wrap_BRepTools_Clean\n  * fulldecl: void BRepTools::Clean(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopoDS_Wire *_wrap_BRepTools_OuterWire (TopoDS_Face *larg1) {
  TopoDS_Wire * lresult = (TopoDS_Wire *)0 ;
  TopoDS_Face *arg1 = 0 ;
  TopoDS_Wire result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = BRepTools::OuterWire((TopoDS_Face const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_OuterWire\n  * wrapname: _wrap_BRepTools_OuterWire\n  * fulldecl: TopoDS_Wire BRepTools::OuterWire(TopoDS_Face const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new TopoDS_Wire(result);
    return lresult;
  } catch (...) {
    return (TopoDS_Wire *)0;
  }
}



#include <BRepTools_WireExplorer.hxx>
  
EXPORT BRepTools_WireExplorer *_wrap_new_BRepTools_WireExplorer__SWIG_0 () {
  BRepTools_WireExplorer * lresult = (BRepTools_WireExplorer *)0 ;
  BRepTools_WireExplorer *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepTools_WireExplorer *)new BRepTools_WireExplorer();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepTools_WireExplorer\n  * wrapname: _wrap_new_BRepTools_WireExplorer__SWIG_0\n  * fulldecl: BRepTools_WireExplorer::BRepTools_WireExplorer()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepTools_WireExplorer *)0;
  }
}


EXPORT BRepTools_WireExplorer *_wrap_new_BRepTools_WireExplorer__SWIG_1 (TopoDS_Wire *larg1) {
  BRepTools_WireExplorer * lresult = (BRepTools_WireExplorer *)0 ;
  TopoDS_Wire *arg1 = 0 ;
  BRepTools_WireExplorer *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepTools_WireExplorer *)new BRepTools_WireExplorer((TopoDS_Wire const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepTools_WireExplorer\n  * wrapname: _wrap_new_BRepTools_WireExplorer__SWIG_1\n  * fulldecl: BRepTools_WireExplorer::BRepTools_WireExplorer(TopoDS_Wire const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepTools_WireExplorer *)0;
  }
}


EXPORT BRepTools_WireExplorer *_wrap_new_BRepTools_WireExplorer__SWIG_2 (TopoDS_Wire *larg1, TopoDS_Face *larg2) {
  BRepTools_WireExplorer * lresult = (BRepTools_WireExplorer *)0 ;
  TopoDS_Wire *arg1 = 0 ;
  TopoDS_Face *arg2 = 0 ;
  BRepTools_WireExplorer *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepTools_WireExplorer *)new BRepTools_WireExplorer((TopoDS_Wire const &)*arg1,(TopoDS_Face const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepTools_WireExplorer\n  * wrapname: _wrap_new_BRepTools_WireExplorer__SWIG_2\n  * fulldecl: BRepTools_WireExplorer::BRepTools_WireExplorer(TopoDS_Wire const &,TopoDS_Face const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepTools_WireExplorer *)0;
  }
}


EXPORT void _wrap_BRepTools_WireExplorer_Init__SWIG_0 (BRepTools_WireExplorer *larg1, TopoDS_Wire *larg2) {
  BRepTools_WireExplorer *arg1 = (BRepTools_WireExplorer *) 0 ;
  TopoDS_Wire *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init((TopoDS_Wire const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_WireExplorer_Init\n  * wrapname: _wrap_BRepTools_WireExplorer_Init__SWIG_0\n  * fulldecl: void BRepTools_WireExplorer::Init(TopoDS_Wire const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepTools_WireExplorer_Init__SWIG_1 (BRepTools_WireExplorer *larg1, TopoDS_Wire *larg2, TopoDS_Face *larg3) {
  BRepTools_WireExplorer *arg1 = (BRepTools_WireExplorer *) 0 ;
  TopoDS_Wire *arg2 = 0 ;
  TopoDS_Face *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init((TopoDS_Wire const &)*arg2,(TopoDS_Face const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_WireExplorer_Init\n  * wrapname: _wrap_BRepTools_WireExplorer_Init__SWIG_1\n  * fulldecl: void BRepTools_WireExplorer::Init(TopoDS_Wire const &,TopoDS_Face const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_BRepTools_WireExplorer_More (BRepTools_WireExplorer *larg1) {
  bool lresult = (bool)0 ;
  BRepTools_WireExplorer *arg1 = (BRepTools_WireExplorer *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepTools_WireExplorer const *)arg1)->More();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_WireExplorer_More\n  * wrapname: _wrap_BRepTools_WireExplorer_More\n  * fulldecl: Standard_Boolean BRepTools_WireExplorer::More() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_BRepTools_WireExplorer_Next (BRepTools_WireExplorer *larg1) {
  BRepTools_WireExplorer *arg1 = (BRepTools_WireExplorer *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Next();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_WireExplorer_Next\n  * wrapname: _wrap_BRepTools_WireExplorer_Next\n  * fulldecl: void BRepTools_WireExplorer::Next()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopoDS_Edge *_wrap_BRepTools_WireExplorer_Current (BRepTools_WireExplorer *larg1) {
  TopoDS_Edge * lresult = (TopoDS_Edge *)0 ;
  BRepTools_WireExplorer *arg1 = (BRepTools_WireExplorer *) 0 ;
  TopoDS_Edge *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Edge *) &((BRepTools_WireExplorer const *)arg1)->Current();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_WireExplorer_Current\n  * wrapname: _wrap_BRepTools_WireExplorer_Current\n  * fulldecl: TopoDS_Edge const & BRepTools_WireExplorer::Current() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Edge *)0;
  }
}


EXPORT TopAbs_Orientation _wrap_BRepTools_WireExplorer_Orientation (BRepTools_WireExplorer *larg1) {
  TopAbs_Orientation lresult = (TopAbs_Orientation)0 ;
  BRepTools_WireExplorer *arg1 = (BRepTools_WireExplorer *) 0 ;
  TopAbs_Orientation result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopAbs_Orientation)((BRepTools_WireExplorer const *)arg1)->Orientation();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_WireExplorer_Orientation\n  * wrapname: _wrap_BRepTools_WireExplorer_Orientation\n  * fulldecl: TopAbs_Orientation BRepTools_WireExplorer::Orientation() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopAbs_Orientation)0;
  }
}


EXPORT TopoDS_Vertex *_wrap_BRepTools_WireExplorer_CurrentVertex (BRepTools_WireExplorer *larg1) {
  TopoDS_Vertex * lresult = (TopoDS_Vertex *)0 ;
  BRepTools_WireExplorer *arg1 = (BRepTools_WireExplorer *) 0 ;
  TopoDS_Vertex *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Vertex *) &((BRepTools_WireExplorer const *)arg1)->CurrentVertex();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_WireExplorer_CurrentVertex\n  * wrapname: _wrap_BRepTools_WireExplorer_CurrentVertex\n  * fulldecl: TopoDS_Vertex const & BRepTools_WireExplorer::CurrentVertex() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Vertex *)0;
  }
}


EXPORT void _wrap_BRepTools_WireExplorer_Clear (BRepTools_WireExplorer *larg1) {
  BRepTools_WireExplorer *arg1 = (BRepTools_WireExplorer *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Clear();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_WireExplorer_Clear\n  * wrapname: _wrap_BRepTools_WireExplorer_Clear\n  * fulldecl: void BRepTools_WireExplorer::Clear()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_BRepTools_WireExplorer (BRepTools_WireExplorer *larg1) {
  BRepTools_WireExplorer *arg1 = (BRepTools_WireExplorer *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepTools_WireExplorer\n  * wrapname: _wrap_delete_BRepTools_WireExplorer\n  * fulldecl: BRepTools_WireExplorer::~BRepTools_WireExplorer()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <BRepTools_Quilt.hxx>
  
EXPORT BRepTools_Quilt *_wrap_new_BRepTools_Quilt () {
  BRepTools_Quilt * lresult = (BRepTools_Quilt *)0 ;
  BRepTools_Quilt *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepTools_Quilt *)new BRepTools_Quilt();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepTools_Quilt\n  * wrapname: _wrap_new_BRepTools_Quilt\n  * fulldecl: BRepTools_Quilt::BRepTools_Quilt()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepTools_Quilt *)0;
  }
}


EXPORT void _wrap_BRepTools_Quilt_Bind__SWIG_0 (BRepTools_Quilt *larg1, TopoDS_Edge *larg2, TopoDS_Edge *larg3) {
  BRepTools_Quilt *arg1 = (BRepTools_Quilt *) 0 ;
  TopoDS_Edge *arg2 = 0 ;
  TopoDS_Edge *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Bind((TopoDS_Edge const &)*arg2,(TopoDS_Edge const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_Quilt_Bind\n  * wrapname: _wrap_BRepTools_Quilt_Bind__SWIG_0\n  * fulldecl: void BRepTools_Quilt::Bind(TopoDS_Edge const &,TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepTools_Quilt_Bind__SWIG_1 (BRepTools_Quilt *larg1, TopoDS_Vertex *larg2, TopoDS_Vertex *larg3) {
  BRepTools_Quilt *arg1 = (BRepTools_Quilt *) 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  TopoDS_Vertex *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Bind((TopoDS_Vertex const &)*arg2,(TopoDS_Vertex const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_Quilt_Bind\n  * wrapname: _wrap_BRepTools_Quilt_Bind__SWIG_1\n  * fulldecl: void BRepTools_Quilt::Bind(TopoDS_Vertex const &,TopoDS_Vertex const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepTools_Quilt_Add (BRepTools_Quilt *larg1, TopoDS_Shape *larg2) {
  BRepTools_Quilt *arg1 = (BRepTools_Quilt *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Add((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_Quilt_Add\n  * wrapname: _wrap_BRepTools_Quilt_Add\n  * fulldecl: void BRepTools_Quilt::Add(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_BRepTools_Quilt_IsCopied (BRepTools_Quilt *larg1, TopoDS_Shape *larg2) {
  bool lresult = (bool)0 ;
  BRepTools_Quilt *arg1 = (BRepTools_Quilt *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepTools_Quilt const *)arg1)->IsCopied((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_Quilt_IsCopied\n  * wrapname: _wrap_BRepTools_Quilt_IsCopied\n  * fulldecl: Standard_Boolean BRepTools_Quilt::IsCopied(TopoDS_Shape const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT TopoDS_Shape *_wrap_BRepTools_Quilt_Copy (BRepTools_Quilt *larg1, TopoDS_Shape *larg2) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  BRepTools_Quilt *arg1 = (BRepTools_Quilt *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &((BRepTools_Quilt const *)arg1)->Copy((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_Quilt_Copy\n  * wrapname: _wrap_BRepTools_Quilt_Copy\n  * fulldecl: TopoDS_Shape const & BRepTools_Quilt::Copy(TopoDS_Shape const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT TopoDS_Shape *_wrap_BRepTools_Quilt_Shells (BRepTools_Quilt *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  BRepTools_Quilt *arg1 = (BRepTools_Quilt *) 0 ;
  TopoDS_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((BRepTools_Quilt const *)arg1)->Shells();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_Quilt_Shells\n  * wrapname: _wrap_BRepTools_Quilt_Shells\n  * fulldecl: TopoDS_Shape BRepTools_Quilt::Shells() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new TopoDS_Shape(result);
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT void _wrap_delete_BRepTools_Quilt (BRepTools_Quilt *larg1) {
  BRepTools_Quilt *arg1 = (BRepTools_Quilt *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepTools_Quilt\n  * wrapname: _wrap_delete_BRepTools_Quilt\n  * fulldecl: BRepTools_Quilt::~BRepTools_Quilt()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <BRepBuilderAPI_Transform.hxx>
#include <BRepBuilderAPI_ModifyShape.hxx>
#include <BRepBuilderAPI_MakeShape.hxx>
#include <BRepBuilderAPI_MakeShell.hxx>
#include <BRepBuilderAPI_MakeWire.hxx>
#include <BRepBuilderAPI_MakeVertex.hxx>
#include <BRepBuilderAPI_MakeEdge.hxx>
#include <BRepBuilderAPI_MakeFace.hxx>
#include <BRepBuilderAPI_MakeSolid.hxx>
#include <BRepBuilderAPI_NurbsConvert.hxx>
#include <Standard_Version.hxx>
#if OCC_VERSION_MAJOR >= 6
#include <BRepBuilderAPI_Sewing.hxx>
#else
#include <BRepAlgo_Sewing.hxx>
#define BRepBuilderAPI_Sewing BRepAlgo_Sewing
#endif

EXPORT bool _wrap_BRepBuilderAPI_Command_IsDone (BRepBuilderAPI_Command *larg1) {
  bool lresult = (bool)0 ;
  BRepBuilderAPI_Command *arg1 = (BRepBuilderAPI_Command *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepBuilderAPI_Command const *)arg1)->IsDone();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Command_IsDone\n  * wrapname: _wrap_BRepBuilderAPI_Command_IsDone\n  * fulldecl: Standard_Boolean BRepBuilderAPI_Command::IsDone() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_delete_BRepBuilderAPI_Command (BRepBuilderAPI_Command *larg1) {
  BRepBuilderAPI_Command *arg1 = (BRepBuilderAPI_Command *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepBuilderAPI_Command\n  * wrapname: _wrap_delete_BRepBuilderAPI_Command\n  * fulldecl: BRepBuilderAPI_Command::~BRepBuilderAPI_Command()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepBuilderAPI_MakeShape_Build (BRepBuilderAPI_MakeShape *larg1) {
  BRepBuilderAPI_MakeShape *arg1 = (BRepBuilderAPI_MakeShape *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Build();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeShape_Build\n  * wrapname: _wrap_BRepBuilderAPI_MakeShape_Build\n  * fulldecl: void BRepBuilderAPI_MakeShape::Build()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopoDS_Shape *_wrap_BRepBuilderAPI_MakeShape_Shape (BRepBuilderAPI_MakeShape *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  BRepBuilderAPI_MakeShape *arg1 = (BRepBuilderAPI_MakeShape *) 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &(arg1)->Shape();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeShape_Shape\n  * wrapname: _wrap_BRepBuilderAPI_MakeShape_Shape\n  * fulldecl: TopoDS_Shape const & BRepBuilderAPI_MakeShape::Shape()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT void _wrap_delete_BRepBuilderAPI_MakeShape (BRepBuilderAPI_MakeShape *larg1) {
  BRepBuilderAPI_MakeShape *arg1 = (BRepBuilderAPI_MakeShape *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepBuilderAPI_MakeShape\n  * wrapname: _wrap_delete_BRepBuilderAPI_MakeShape\n  * fulldecl: BRepBuilderAPI_MakeShape::~BRepBuilderAPI_MakeShape()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopoDS_Shape *_wrap_BRepBuilderAPI_ModifyShape_ModifiedShape (BRepBuilderAPI_ModifyShape *larg1, TopoDS_Shape *larg2) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  BRepBuilderAPI_ModifyShape *arg1 = (BRepBuilderAPI_ModifyShape *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopoDS_Shape result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((BRepBuilderAPI_ModifyShape const *)arg1)->ModifiedShape((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_ModifyShape_ModifiedShape\n  * wrapname: _wrap_BRepBuilderAPI_ModifyShape_ModifiedShape\n  * fulldecl: TopoDS_Shape BRepBuilderAPI_ModifyShape::ModifiedShape(TopoDS_Shape const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new TopoDS_Shape(result);
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT void _wrap_delete_BRepBuilderAPI_ModifyShape (BRepBuilderAPI_ModifyShape *larg1) {
  BRepBuilderAPI_ModifyShape *arg1 = (BRepBuilderAPI_ModifyShape *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepBuilderAPI_ModifyShape\n  * wrapname: _wrap_delete_BRepBuilderAPI_ModifyShape\n  * fulldecl: BRepBuilderAPI_ModifyShape::~BRepBuilderAPI_ModifyShape()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepBuilderAPI_Transform *_wrap_new_BRepBuilderAPI_Transform__SWIG_0 (gp_Trsf *larg1) {
  BRepBuilderAPI_Transform * lresult = (BRepBuilderAPI_Transform *)0 ;
  gp_Trsf *arg1 = 0 ;
  BRepBuilderAPI_Transform *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_Transform *)new BRepBuilderAPI_Transform((gp_Trsf const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_Transform\n  * wrapname: _wrap_new_BRepBuilderAPI_Transform__SWIG_0\n  * fulldecl: BRepBuilderAPI_Transform::BRepBuilderAPI_Transform(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_Transform *)0;
  }
}


EXPORT BRepBuilderAPI_Transform *_wrap_new_BRepBuilderAPI_Transform__SWIG_1 (TopoDS_Shape *larg1, gp_Trsf *larg2, bool larg3) {
  BRepBuilderAPI_Transform * lresult = (BRepBuilderAPI_Transform *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  gp_Trsf *arg2 = 0 ;
  Standard_Boolean arg3 ;
  BRepBuilderAPI_Transform *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_Transform *)new BRepBuilderAPI_Transform((TopoDS_Shape const &)*arg1,(gp_Trsf const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_Transform\n  * wrapname: _wrap_new_BRepBuilderAPI_Transform__SWIG_1\n  * fulldecl: BRepBuilderAPI_Transform::BRepBuilderAPI_Transform(TopoDS_Shape const &,gp_Trsf const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_Transform *)0;
  }
}


EXPORT BRepBuilderAPI_Transform *_wrap_new_BRepBuilderAPI_Transform__SWIG_2 (TopoDS_Shape *larg1, gp_Trsf *larg2) {
  BRepBuilderAPI_Transform * lresult = (BRepBuilderAPI_Transform *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  gp_Trsf *arg2 = 0 ;
  BRepBuilderAPI_Transform *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_Transform *)new BRepBuilderAPI_Transform((TopoDS_Shape const &)*arg1,(gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_Transform\n  * wrapname: _wrap_new_BRepBuilderAPI_Transform__SWIG_2\n  * fulldecl: BRepBuilderAPI_Transform::BRepBuilderAPI_Transform(TopoDS_Shape const &,gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_Transform *)0;
  }
}


EXPORT void _wrap_BRepBuilderAPI_Transform_Perform__SWIG_0 (BRepBuilderAPI_Transform *larg1, TopoDS_Shape *larg2, bool larg3) {
  BRepBuilderAPI_Transform *arg1 = (BRepBuilderAPI_Transform *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Perform((TopoDS_Shape const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Transform_Perform\n  * wrapname: _wrap_BRepBuilderAPI_Transform_Perform__SWIG_0\n  * fulldecl: void BRepBuilderAPI_Transform::Perform(TopoDS_Shape const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepBuilderAPI_Transform_Perform__SWIG_1 (BRepBuilderAPI_Transform *larg1, TopoDS_Shape *larg2) {
  BRepBuilderAPI_Transform *arg1 = (BRepBuilderAPI_Transform *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Perform((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Transform_Perform\n  * wrapname: _wrap_BRepBuilderAPI_Transform_Perform__SWIG_1\n  * fulldecl: void BRepBuilderAPI_Transform::Perform(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_BRepBuilderAPI_Transform (BRepBuilderAPI_Transform *larg1) {
  BRepBuilderAPI_Transform *arg1 = (BRepBuilderAPI_Transform *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepBuilderAPI_Transform\n  * wrapname: _wrap_delete_BRepBuilderAPI_Transform\n  * fulldecl: BRepBuilderAPI_Transform::~BRepBuilderAPI_Transform()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepBuilderAPI_MakeVertex *_wrap_new_BRepBuilderAPI_MakeVertex (gp_Pnt *larg1) {
  BRepBuilderAPI_MakeVertex * lresult = (BRepBuilderAPI_MakeVertex *)0 ;
  gp_Pnt *arg1 = 0 ;
  BRepBuilderAPI_MakeVertex *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeVertex *)new BRepBuilderAPI_MakeVertex((gp_Pnt const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeVertex\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeVertex\n  * fulldecl: BRepBuilderAPI_MakeVertex::BRepBuilderAPI_MakeVertex(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeVertex *)0;
  }
}


EXPORT TopoDS_Vertex *_wrap_BRepBuilderAPI_MakeVertex_Vertex (BRepBuilderAPI_MakeVertex *larg1) {
  TopoDS_Vertex * lresult = (TopoDS_Vertex *)0 ;
  BRepBuilderAPI_MakeVertex *arg1 = (BRepBuilderAPI_MakeVertex *) 0 ;
  TopoDS_Vertex *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Vertex *) &((BRepBuilderAPI_MakeVertex *)arg1)->Vertex();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeVertex_Vertex\n  * wrapname: _wrap_BRepBuilderAPI_MakeVertex_Vertex\n  * fulldecl: TopoDS_Vertex const & BRepBuilderAPI_MakeVertex::Vertex() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Vertex *)0;
  }
}


EXPORT void _wrap_delete_BRepBuilderAPI_MakeVertex (BRepBuilderAPI_MakeVertex *larg1) {
  BRepBuilderAPI_MakeVertex *arg1 = (BRepBuilderAPI_MakeVertex *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepBuilderAPI_MakeVertex\n  * wrapname: _wrap_delete_BRepBuilderAPI_MakeVertex\n  * fulldecl: BRepBuilderAPI_MakeVertex::~BRepBuilderAPI_MakeVertex()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepBuilderAPI_MakeWire *_wrap_new_BRepBuilderAPI_MakeWire__SWIG_0 () {
  BRepBuilderAPI_MakeWire * lresult = (BRepBuilderAPI_MakeWire *)0 ;
  BRepBuilderAPI_MakeWire *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeWire *)new BRepBuilderAPI_MakeWire();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeWire\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeWire__SWIG_0\n  * fulldecl: BRepBuilderAPI_MakeWire::BRepBuilderAPI_MakeWire()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeWire *)0;
  }
}


EXPORT BRepBuilderAPI_MakeWire *_wrap_new_BRepBuilderAPI_MakeWire__SWIG_1 (TopoDS_Edge *larg1) {
  BRepBuilderAPI_MakeWire * lresult = (BRepBuilderAPI_MakeWire *)0 ;
  TopoDS_Edge *arg1 = 0 ;
  BRepBuilderAPI_MakeWire *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeWire *)new BRepBuilderAPI_MakeWire((TopoDS_Edge const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeWire\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeWire__SWIG_1\n  * fulldecl: BRepBuilderAPI_MakeWire::BRepBuilderAPI_MakeWire(TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeWire *)0;
  }
}


EXPORT BRepBuilderAPI_MakeWire *_wrap_new_BRepBuilderAPI_MakeWire__SWIG_2 (TopoDS_Edge *larg1, TopoDS_Edge *larg2) {
  BRepBuilderAPI_MakeWire * lresult = (BRepBuilderAPI_MakeWire *)0 ;
  TopoDS_Edge *arg1 = 0 ;
  TopoDS_Edge *arg2 = 0 ;
  BRepBuilderAPI_MakeWire *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeWire *)new BRepBuilderAPI_MakeWire((TopoDS_Edge const &)*arg1,(TopoDS_Edge const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeWire\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeWire__SWIG_2\n  * fulldecl: BRepBuilderAPI_MakeWire::BRepBuilderAPI_MakeWire(TopoDS_Edge const &,TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeWire *)0;
  }
}


EXPORT BRepBuilderAPI_MakeWire *_wrap_new_BRepBuilderAPI_MakeWire__SWIG_3 (TopoDS_Edge *larg1, TopoDS_Edge *larg2, TopoDS_Edge *larg3) {
  BRepBuilderAPI_MakeWire * lresult = (BRepBuilderAPI_MakeWire *)0 ;
  TopoDS_Edge *arg1 = 0 ;
  TopoDS_Edge *arg2 = 0 ;
  TopoDS_Edge *arg3 = 0 ;
  BRepBuilderAPI_MakeWire *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeWire *)new BRepBuilderAPI_MakeWire((TopoDS_Edge const &)*arg1,(TopoDS_Edge const &)*arg2,(TopoDS_Edge const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeWire\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeWire__SWIG_3\n  * fulldecl: BRepBuilderAPI_MakeWire::BRepBuilderAPI_MakeWire(TopoDS_Edge const &,TopoDS_Edge const &,TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeWire *)0;
  }
}


EXPORT BRepBuilderAPI_MakeWire *_wrap_new_BRepBuilderAPI_MakeWire__SWIG_4 (TopoDS_Edge *larg1, TopoDS_Edge *larg2, TopoDS_Edge *larg3, TopoDS_Edge *larg4) {
  BRepBuilderAPI_MakeWire * lresult = (BRepBuilderAPI_MakeWire *)0 ;
  TopoDS_Edge *arg1 = 0 ;
  TopoDS_Edge *arg2 = 0 ;
  TopoDS_Edge *arg3 = 0 ;
  TopoDS_Edge *arg4 = 0 ;
  BRepBuilderAPI_MakeWire *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeWire *)new BRepBuilderAPI_MakeWire((TopoDS_Edge const &)*arg1,(TopoDS_Edge const &)*arg2,(TopoDS_Edge const &)*arg3,(TopoDS_Edge const &)*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeWire\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeWire__SWIG_4\n  * fulldecl: BRepBuilderAPI_MakeWire::BRepBuilderAPI_MakeWire(TopoDS_Edge const &,TopoDS_Edge const &,TopoDS_Edge const &,TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeWire *)0;
  }
}


EXPORT BRepBuilderAPI_MakeWire *_wrap_new_BRepBuilderAPI_MakeWire__SWIG_5 (TopoDS_Wire *larg1) {
  BRepBuilderAPI_MakeWire * lresult = (BRepBuilderAPI_MakeWire *)0 ;
  TopoDS_Wire *arg1 = 0 ;
  BRepBuilderAPI_MakeWire *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeWire *)new BRepBuilderAPI_MakeWire((TopoDS_Wire const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeWire\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeWire__SWIG_5\n  * fulldecl: BRepBuilderAPI_MakeWire::BRepBuilderAPI_MakeWire(TopoDS_Wire const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeWire *)0;
  }
}


EXPORT BRepBuilderAPI_MakeWire *_wrap_new_BRepBuilderAPI_MakeWire__SWIG_6 (TopoDS_Wire *larg1, TopoDS_Edge *larg2) {
  BRepBuilderAPI_MakeWire * lresult = (BRepBuilderAPI_MakeWire *)0 ;
  TopoDS_Wire *arg1 = 0 ;
  TopoDS_Edge *arg2 = 0 ;
  BRepBuilderAPI_MakeWire *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeWire *)new BRepBuilderAPI_MakeWire((TopoDS_Wire const &)*arg1,(TopoDS_Edge const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeWire\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeWire__SWIG_6\n  * fulldecl: BRepBuilderAPI_MakeWire::BRepBuilderAPI_MakeWire(TopoDS_Wire const &,TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeWire *)0;
  }
}


EXPORT void _wrap_BRepBuilderAPI_MakeWire_Add__SWIG_0 (BRepBuilderAPI_MakeWire *larg1, TopoDS_Edge *larg2) {
  BRepBuilderAPI_MakeWire *arg1 = (BRepBuilderAPI_MakeWire *) 0 ;
  TopoDS_Edge *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Add((TopoDS_Edge const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeWire_Add\n  * wrapname: _wrap_BRepBuilderAPI_MakeWire_Add__SWIG_0\n  * fulldecl: void BRepBuilderAPI_MakeWire::Add(TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepBuilderAPI_MakeWire_Add__SWIG_1 (BRepBuilderAPI_MakeWire *larg1, TopoDS_Wire *larg2) {
  BRepBuilderAPI_MakeWire *arg1 = (BRepBuilderAPI_MakeWire *) 0 ;
  TopoDS_Wire *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Add((TopoDS_Wire const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeWire_Add\n  * wrapname: _wrap_BRepBuilderAPI_MakeWire_Add__SWIG_1\n  * fulldecl: void BRepBuilderAPI_MakeWire::Add(TopoDS_Wire const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepBuilderAPI_MakeWire_Add__SWIG_2 (BRepBuilderAPI_MakeWire *larg1, TopTools_ListOfShape *larg2) {
  BRepBuilderAPI_MakeWire *arg1 = (BRepBuilderAPI_MakeWire *) 0 ;
  TopTools_ListOfShape *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Add((TopTools_ListOfShape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeWire_Add\n  * wrapname: _wrap_BRepBuilderAPI_MakeWire_Add__SWIG_2\n  * fulldecl: void BRepBuilderAPI_MakeWire::Add(TopTools_ListOfShape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_BRepBuilderAPI_MakeWire_IsDone (BRepBuilderAPI_MakeWire *larg1) {
  bool lresult = (bool)0 ;
  BRepBuilderAPI_MakeWire *arg1 = (BRepBuilderAPI_MakeWire *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepBuilderAPI_MakeWire const *)arg1)->IsDone();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeWire_IsDone\n  * wrapname: _wrap_BRepBuilderAPI_MakeWire_IsDone\n  * fulldecl: Standard_Boolean BRepBuilderAPI_MakeWire::IsDone() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT BRepBuilderAPI_WireError _wrap_BRepBuilderAPI_MakeWire_Error (BRepBuilderAPI_MakeWire *larg1) {
  BRepBuilderAPI_WireError lresult = (BRepBuilderAPI_WireError)0 ;
  BRepBuilderAPI_MakeWire *arg1 = (BRepBuilderAPI_MakeWire *) 0 ;
  BRepBuilderAPI_WireError result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_WireError)((BRepBuilderAPI_MakeWire const *)arg1)->Error();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeWire_Error\n  * wrapname: _wrap_BRepBuilderAPI_MakeWire_Error\n  * fulldecl: BRepBuilderAPI_WireError BRepBuilderAPI_MakeWire::Error() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_WireError)0;
  }
}


EXPORT TopoDS_Wire *_wrap_BRepBuilderAPI_MakeWire_Wire (BRepBuilderAPI_MakeWire *larg1) {
  TopoDS_Wire * lresult = (TopoDS_Wire *)0 ;
  BRepBuilderAPI_MakeWire *arg1 = (BRepBuilderAPI_MakeWire *) 0 ;
  TopoDS_Wire *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Wire *) &((BRepBuilderAPI_MakeWire *)arg1)->Wire();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeWire_Wire\n  * wrapname: _wrap_BRepBuilderAPI_MakeWire_Wire\n  * fulldecl: TopoDS_Wire const & BRepBuilderAPI_MakeWire::Wire() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Wire *)0;
  }
}


EXPORT void _wrap_delete_BRepBuilderAPI_MakeWire (BRepBuilderAPI_MakeWire *larg1) {
  BRepBuilderAPI_MakeWire *arg1 = (BRepBuilderAPI_MakeWire *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepBuilderAPI_MakeWire\n  * wrapname: _wrap_delete_BRepBuilderAPI_MakeWire\n  * fulldecl: BRepBuilderAPI_MakeWire::~BRepBuilderAPI_MakeWire()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepBuilderAPI_MakeShell *_wrap_new_BRepBuilderAPI_MakeShell () {
  BRepBuilderAPI_MakeShell * lresult = (BRepBuilderAPI_MakeShell *)0 ;
  BRepBuilderAPI_MakeShell *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeShell *)new BRepBuilderAPI_MakeShell();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeShell\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeShell\n  * fulldecl: BRepBuilderAPI_MakeShell::BRepBuilderAPI_MakeShell()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeShell *)0;
  }
}


EXPORT bool _wrap_BRepBuilderAPI_MakeShell_IsDone (BRepBuilderAPI_MakeShell *larg1) {
  bool lresult = (bool)0 ;
  BRepBuilderAPI_MakeShell *arg1 = (BRepBuilderAPI_MakeShell *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepBuilderAPI_MakeShell const *)arg1)->IsDone();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeShell_IsDone\n  * wrapname: _wrap_BRepBuilderAPI_MakeShell_IsDone\n  * fulldecl: Standard_Boolean BRepBuilderAPI_MakeShell::IsDone() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT BRepBuilderAPI_ShellError _wrap_BRepBuilderAPI_MakeShell_Error (BRepBuilderAPI_MakeShell *larg1) {
  BRepBuilderAPI_ShellError lresult = (BRepBuilderAPI_ShellError)0 ;
  BRepBuilderAPI_MakeShell *arg1 = (BRepBuilderAPI_MakeShell *) 0 ;
  BRepBuilderAPI_ShellError result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_ShellError)((BRepBuilderAPI_MakeShell const *)arg1)->Error();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeShell_Error\n  * wrapname: _wrap_BRepBuilderAPI_MakeShell_Error\n  * fulldecl: BRepBuilderAPI_ShellError BRepBuilderAPI_MakeShell::Error() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_ShellError)0;
  }
}


EXPORT TopoDS_Shell *_wrap_BRepBuilderAPI_MakeShell_Shell (BRepBuilderAPI_MakeShell *larg1) {
  TopoDS_Shell * lresult = (TopoDS_Shell *)0 ;
  BRepBuilderAPI_MakeShell *arg1 = (BRepBuilderAPI_MakeShell *) 0 ;
  TopoDS_Shell *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shell *) &((BRepBuilderAPI_MakeShell const *)arg1)->Shell();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeShell_Shell\n  * wrapname: _wrap_BRepBuilderAPI_MakeShell_Shell\n  * fulldecl: TopoDS_Shell const & BRepBuilderAPI_MakeShell::Shell() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shell *)0;
  }
}


EXPORT void _wrap_delete_BRepBuilderAPI_MakeShell (BRepBuilderAPI_MakeShell *larg1) {
  BRepBuilderAPI_MakeShell *arg1 = (BRepBuilderAPI_MakeShell *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepBuilderAPI_MakeShell\n  * wrapname: _wrap_delete_BRepBuilderAPI_MakeShell\n  * fulldecl: BRepBuilderAPI_MakeShell::~BRepBuilderAPI_MakeShell()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_0 () {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_0\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_1 (TopoDS_Vertex *larg1, TopoDS_Vertex *larg2) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  TopoDS_Vertex *arg1 = 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((TopoDS_Vertex const &)*arg1,(TopoDS_Vertex const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_1\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(TopoDS_Vertex const &,TopoDS_Vertex const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_2 (gp_Pnt *larg1, gp_Pnt *larg2) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Pnt *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Pnt const &)*arg1,(gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_2\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_3 (gp_Lin *larg1) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Lin *arg1 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Lin const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_3\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Lin const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_4 (gp_Lin *larg1, Standard_Real larg2, Standard_Real larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Lin *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Lin const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_4\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Lin const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_5 (gp_Lin *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Lin *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Lin const &)*arg1,(gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_5\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Lin const &,gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_6 (gp_Lin *larg1, TopoDS_Vertex *larg2, TopoDS_Vertex *larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Lin *arg1 = 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  TopoDS_Vertex *arg3 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Lin const &)*arg1,(TopoDS_Vertex const &)*arg2,(TopoDS_Vertex const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_6\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Lin const &,TopoDS_Vertex const &,TopoDS_Vertex const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_7 (gp_Circ *larg1) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Circ *arg1 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Circ const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_7\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Circ const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_8 (gp_Circ *larg1, Standard_Real larg2, Standard_Real larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Circ *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Circ const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_8\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Circ const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_9 (gp_Circ *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Circ *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Circ const &)*arg1,(gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_9\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Circ const &,gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_10 (gp_Circ *larg1, TopoDS_Vertex *larg2, TopoDS_Vertex *larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Circ *arg1 = 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  TopoDS_Vertex *arg3 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Circ const &)*arg1,(TopoDS_Vertex const &)*arg2,(TopoDS_Vertex const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_10\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Circ const &,TopoDS_Vertex const &,TopoDS_Vertex const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_11 (gp_Elips *larg1) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Elips *arg1 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Elips const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_11\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Elips const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_12 (gp_Elips *larg1, Standard_Real larg2, Standard_Real larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Elips *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Elips const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_12\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Elips const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_13 (gp_Elips *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Elips *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Elips const &)*arg1,(gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_13\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Elips const &,gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_14 (gp_Elips *larg1, TopoDS_Vertex *larg2, TopoDS_Vertex *larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Elips *arg1 = 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  TopoDS_Vertex *arg3 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Elips const &)*arg1,(TopoDS_Vertex const &)*arg2,(TopoDS_Vertex const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_14\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Elips const &,TopoDS_Vertex const &,TopoDS_Vertex const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_15 (gp_Hypr *larg1) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Hypr *arg1 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Hypr const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_15\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Hypr const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_16 (gp_Hypr *larg1, Standard_Real larg2, Standard_Real larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Hypr *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Hypr const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_16\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Hypr const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_17 (gp_Hypr *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Hypr *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Hypr const &)*arg1,(gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_17\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Hypr const &,gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_18 (gp_Hypr *larg1, TopoDS_Vertex *larg2, TopoDS_Vertex *larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Hypr *arg1 = 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  TopoDS_Vertex *arg3 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Hypr const &)*arg1,(TopoDS_Vertex const &)*arg2,(TopoDS_Vertex const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_18\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Hypr const &,TopoDS_Vertex const &,TopoDS_Vertex const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_19 (gp_Parab *larg1) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Parab *arg1 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Parab const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_19\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Parab const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_20 (gp_Parab *larg1, Standard_Real larg2, Standard_Real larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Parab *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Parab const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_20\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Parab const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_21 (gp_Parab *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Parab *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Parab const &)*arg1,(gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_21\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Parab const &,gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_22 (gp_Parab *larg1, TopoDS_Vertex *larg2, TopoDS_Vertex *larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Parab *arg1 = 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  TopoDS_Vertex *arg3 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Parab const &)*arg1,(TopoDS_Vertex const &)*arg2,(TopoDS_Vertex const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_22\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Parab const &,TopoDS_Vertex const &,TopoDS_Vertex const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_23 (Handle_Geom_Curve *larg1) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  Handle_Geom_Curve *arg1 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((Handle_Geom_Curve const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_23\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(Handle_Geom_Curve const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_24 (Handle_Geom_Curve *larg1, Standard_Real larg2, Standard_Real larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  Handle_Geom_Curve *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((Handle_Geom_Curve const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_24\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(Handle_Geom_Curve const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_25 (Handle_Geom_Curve *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  Handle_Geom_Curve *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((Handle_Geom_Curve const &)*arg1,(gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_25\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(Handle_Geom_Curve const &,gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_26 (Handle_Geom_Curve *larg1, TopoDS_Vertex *larg2, TopoDS_Vertex *larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  Handle_Geom_Curve *arg1 = 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  TopoDS_Vertex *arg3 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((Handle_Geom_Curve const &)*arg1,(TopoDS_Vertex const &)*arg2,(TopoDS_Vertex const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_26\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(Handle_Geom_Curve const &,TopoDS_Vertex const &,TopoDS_Vertex const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_27 (Handle_Geom_Curve *larg1, gp_Pnt *larg2, gp_Pnt *larg3, Standard_Real larg4, Standard_Real larg5) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  Handle_Geom_Curve *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((Handle_Geom_Curve const &)*arg1,(gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_27\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(Handle_Geom_Curve const &,gp_Pnt const &,gp_Pnt const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_28 (Handle_Geom_Curve *larg1, TopoDS_Vertex *larg2, TopoDS_Vertex *larg3, Standard_Real larg4, Standard_Real larg5) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  Handle_Geom_Curve *arg1 = 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  TopoDS_Vertex *arg3 = 0 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((Handle_Geom_Curve const &)*arg1,(TopoDS_Vertex const &)*arg2,(TopoDS_Vertex const &)*arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_28\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(Handle_Geom_Curve const &,TopoDS_Vertex const &,TopoDS_Vertex const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_29 (Handle_Geom2d_Curve *larg1, Handle_Geom_Surface *larg2) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  Handle_Geom2d_Curve *arg1 = 0 ;
  Handle_Geom_Surface *arg2 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((Handle_Geom2d_Curve const &)*arg1,(Handle_Geom_Surface const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_29\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(Handle_Geom2d_Curve const &,Handle_Geom_Surface const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_30 (Handle_Geom2d_Curve *larg1, Handle_Geom_Surface *larg2, Standard_Real larg3, Standard_Real larg4) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  Handle_Geom2d_Curve *arg1 = 0 ;
  Handle_Geom_Surface *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((Handle_Geom2d_Curve const &)*arg1,(Handle_Geom_Surface const &)*arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_30\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(Handle_Geom2d_Curve const &,Handle_Geom_Surface const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_31 (Handle_Geom2d_Curve *larg1, Handle_Geom_Surface *larg2, TopoDS_Vertex *larg3, TopoDS_Vertex *larg4) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  Handle_Geom2d_Curve *arg1 = 0 ;
  Handle_Geom_Surface *arg2 = 0 ;
  TopoDS_Vertex *arg3 = 0 ;
  TopoDS_Vertex *arg4 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((Handle_Geom2d_Curve const &)*arg1,(Handle_Geom_Surface const &)*arg2,(TopoDS_Vertex const &)*arg3,(TopoDS_Vertex const &)*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_31\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(Handle_Geom2d_Curve const &,Handle_Geom_Surface const &,TopoDS_Vertex const &,TopoDS_Vertex const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_32 (Handle_Geom2d_Curve *larg1, Handle_Geom_Surface *larg2, gp_Pnt *larg3, gp_Pnt *larg4, Standard_Real larg5, Standard_Real larg6) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  Handle_Geom2d_Curve *arg1 = 0 ;
  Handle_Geom_Surface *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  gp_Pnt *arg4 = 0 ;
  Standard_Real arg5 ;
  Standard_Real arg6 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((Handle_Geom2d_Curve const &)*arg1,(Handle_Geom_Surface const &)*arg2,(gp_Pnt const &)*arg3,(gp_Pnt const &)*arg4,arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_32\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(Handle_Geom2d_Curve const &,Handle_Geom_Surface const &,gp_Pnt const &,gp_Pnt const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_33 (Handle_Geom2d_Curve *larg1, Handle_Geom_Surface *larg2, TopoDS_Vertex *larg3, TopoDS_Vertex *larg4, Standard_Real larg5, Standard_Real larg6) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  Handle_Geom2d_Curve *arg1 = 0 ;
  Handle_Geom_Surface *arg2 = 0 ;
  TopoDS_Vertex *arg3 = 0 ;
  TopoDS_Vertex *arg4 = 0 ;
  Standard_Real arg5 ;
  Standard_Real arg6 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((Handle_Geom2d_Curve const &)*arg1,(Handle_Geom_Surface const &)*arg2,(TopoDS_Vertex const &)*arg3,(TopoDS_Vertex const &)*arg4,arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_33\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(Handle_Geom2d_Curve const &,Handle_Geom_Surface const &,TopoDS_Vertex const &,TopoDS_Vertex const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT bool _wrap_BRepBuilderAPI_MakeEdge_IsDone (BRepBuilderAPI_MakeEdge *larg1) {
  bool lresult = (bool)0 ;
  BRepBuilderAPI_MakeEdge *arg1 = (BRepBuilderAPI_MakeEdge *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepBuilderAPI_MakeEdge const *)arg1)->IsDone();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeEdge_IsDone\n  * wrapname: _wrap_BRepBuilderAPI_MakeEdge_IsDone\n  * fulldecl: Standard_Boolean BRepBuilderAPI_MakeEdge::IsDone() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT BRepBuilderAPI_EdgeError _wrap_BRepBuilderAPI_MakeEdge_Error (BRepBuilderAPI_MakeEdge *larg1) {
  BRepBuilderAPI_EdgeError lresult = (BRepBuilderAPI_EdgeError)0 ;
  BRepBuilderAPI_MakeEdge *arg1 = (BRepBuilderAPI_MakeEdge *) 0 ;
  BRepBuilderAPI_EdgeError result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_EdgeError)((BRepBuilderAPI_MakeEdge const *)arg1)->Error();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeEdge_Error\n  * wrapname: _wrap_BRepBuilderAPI_MakeEdge_Error\n  * fulldecl: BRepBuilderAPI_EdgeError BRepBuilderAPI_MakeEdge::Error() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_EdgeError)0;
  }
}


EXPORT TopoDS_Edge *_wrap_BRepBuilderAPI_MakeEdge_Edge (BRepBuilderAPI_MakeEdge *larg1) {
  TopoDS_Edge * lresult = (TopoDS_Edge *)0 ;
  BRepBuilderAPI_MakeEdge *arg1 = (BRepBuilderAPI_MakeEdge *) 0 ;
  TopoDS_Edge *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Edge *) &((BRepBuilderAPI_MakeEdge *)arg1)->Edge();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeEdge_Edge\n  * wrapname: _wrap_BRepBuilderAPI_MakeEdge_Edge\n  * fulldecl: TopoDS_Edge const & BRepBuilderAPI_MakeEdge::Edge() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Edge *)0;
  }
}


EXPORT void _wrap_delete_BRepBuilderAPI_MakeEdge (BRepBuilderAPI_MakeEdge *larg1) {
  BRepBuilderAPI_MakeEdge *arg1 = (BRepBuilderAPI_MakeEdge *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_delete_BRepBuilderAPI_MakeEdge\n  * fulldecl: BRepBuilderAPI_MakeEdge::~BRepBuilderAPI_MakeEdge()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepBuilderAPI_MakeFace *_wrap_new_BRepBuilderAPI_MakeFace__SWIG_0 (TopoDS_Wire *larg1, bool larg2) {
  BRepBuilderAPI_MakeFace * lresult = (BRepBuilderAPI_MakeFace *)0 ;
  TopoDS_Wire *arg1 = 0 ;
  Standard_Boolean arg2 ;
  BRepBuilderAPI_MakeFace *result = 0 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeFace *)new BRepBuilderAPI_MakeFace((TopoDS_Wire const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeFace\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeFace__SWIG_0\n  * fulldecl: BRepBuilderAPI_MakeFace::BRepBuilderAPI_MakeFace(TopoDS_Wire const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeFace *)0;
  }
}


EXPORT BRepBuilderAPI_MakeFace *_wrap_new_BRepBuilderAPI_MakeFace__SWIG_1 (TopoDS_Wire *larg1) {
  BRepBuilderAPI_MakeFace * lresult = (BRepBuilderAPI_MakeFace *)0 ;
  TopoDS_Wire *arg1 = 0 ;
  BRepBuilderAPI_MakeFace *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeFace *)new BRepBuilderAPI_MakeFace((TopoDS_Wire const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeFace\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeFace__SWIG_1\n  * fulldecl: BRepBuilderAPI_MakeFace::BRepBuilderAPI_MakeFace(TopoDS_Wire const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeFace *)0;
  }
}


EXPORT BRepBuilderAPI_MakeFace *_wrap_new_BRepBuilderAPI_MakeFace__SWIG_2 (TopoDS_Face *larg1, TopoDS_Wire *larg2) {
  BRepBuilderAPI_MakeFace * lresult = (BRepBuilderAPI_MakeFace *)0 ;
  TopoDS_Face *arg1 = 0 ;
  TopoDS_Wire *arg2 = 0 ;
  BRepBuilderAPI_MakeFace *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeFace *)new BRepBuilderAPI_MakeFace((TopoDS_Face const &)*arg1,(TopoDS_Wire const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeFace\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeFace__SWIG_2\n  * fulldecl: BRepBuilderAPI_MakeFace::BRepBuilderAPI_MakeFace(TopoDS_Face const &,TopoDS_Wire const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeFace *)0;
  }
}


EXPORT BRepBuilderAPI_MakeFace *_wrap_new_BRepBuilderAPI_MakeFace__SWIG_3 (Handle_Geom_Surface *larg1, TopoDS_Wire *larg2, bool larg3) {
  BRepBuilderAPI_MakeFace * lresult = (BRepBuilderAPI_MakeFace *)0 ;
  Handle_Geom_Surface *arg1 = 0 ;
  TopoDS_Wire *arg2 = 0 ;
  Standard_Boolean arg3 ;
  BRepBuilderAPI_MakeFace *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeFace *)new BRepBuilderAPI_MakeFace((Handle_Geom_Surface const &)*arg1,(TopoDS_Wire const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeFace\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeFace__SWIG_3\n  * fulldecl: BRepBuilderAPI_MakeFace::BRepBuilderAPI_MakeFace(Handle_Geom_Surface const &,TopoDS_Wire const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeFace *)0;
  }
}


EXPORT BRepBuilderAPI_MakeFace *_wrap_new_BRepBuilderAPI_MakeFace__SWIG_4 (Handle_Geom_Surface *larg1, TopoDS_Wire *larg2) {
  BRepBuilderAPI_MakeFace * lresult = (BRepBuilderAPI_MakeFace *)0 ;
  Handle_Geom_Surface *arg1 = 0 ;
  TopoDS_Wire *arg2 = 0 ;
  BRepBuilderAPI_MakeFace *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeFace *)new BRepBuilderAPI_MakeFace((Handle_Geom_Surface const &)*arg1,(TopoDS_Wire const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeFace\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeFace__SWIG_4\n  * fulldecl: BRepBuilderAPI_MakeFace::BRepBuilderAPI_MakeFace(Handle_Geom_Surface const &,TopoDS_Wire const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeFace *)0;
  }
}


EXPORT BRepBuilderAPI_MakeFace *_wrap_new_BRepBuilderAPI_MakeFace__SWIG_5 (Handle_Geom_Surface *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5, Standard_Real larg6) {
  BRepBuilderAPI_MakeFace * lresult = (BRepBuilderAPI_MakeFace *)0 ;
  Handle_Geom_Surface *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  Standard_Real arg6 ;
  BRepBuilderAPI_MakeFace *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeFace *)new BRepBuilderAPI_MakeFace((Handle_Geom_Surface const &)*arg1,arg2,arg3,arg4,arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeFace\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeFace__SWIG_5\n  * fulldecl: BRepBuilderAPI_MakeFace::BRepBuilderAPI_MakeFace(Handle_Geom_Surface const &,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeFace *)0;
  }
}


EXPORT bool _wrap_BRepBuilderAPI_MakeFace_IsDone (BRepBuilderAPI_MakeFace *larg1) {
  bool lresult = (bool)0 ;
  BRepBuilderAPI_MakeFace *arg1 = (BRepBuilderAPI_MakeFace *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepBuilderAPI_MakeFace const *)arg1)->IsDone();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeFace_IsDone\n  * wrapname: _wrap_BRepBuilderAPI_MakeFace_IsDone\n  * fulldecl: Standard_Boolean BRepBuilderAPI_MakeFace::IsDone() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT BRepBuilderAPI_FaceError _wrap_BRepBuilderAPI_MakeFace_Error (BRepBuilderAPI_MakeFace *larg1) {
  BRepBuilderAPI_FaceError lresult = (BRepBuilderAPI_FaceError)0 ;
  BRepBuilderAPI_MakeFace *arg1 = (BRepBuilderAPI_MakeFace *) 0 ;
  BRepBuilderAPI_FaceError result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_FaceError)((BRepBuilderAPI_MakeFace const *)arg1)->Error();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeFace_Error\n  * wrapname: _wrap_BRepBuilderAPI_MakeFace_Error\n  * fulldecl: BRepBuilderAPI_FaceError BRepBuilderAPI_MakeFace::Error() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_FaceError)0;
  }
}


EXPORT TopoDS_Face *_wrap_BRepBuilderAPI_MakeFace_Face (BRepBuilderAPI_MakeFace *larg1) {
  TopoDS_Face * lresult = (TopoDS_Face *)0 ;
  BRepBuilderAPI_MakeFace *arg1 = (BRepBuilderAPI_MakeFace *) 0 ;
  TopoDS_Face *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Face *) &((BRepBuilderAPI_MakeFace const *)arg1)->Face();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeFace_Face\n  * wrapname: _wrap_BRepBuilderAPI_MakeFace_Face\n  * fulldecl: TopoDS_Face const & BRepBuilderAPI_MakeFace::Face() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Face *)0;
  }
}


EXPORT void _wrap_delete_BRepBuilderAPI_MakeFace (BRepBuilderAPI_MakeFace *larg1) {
  BRepBuilderAPI_MakeFace *arg1 = (BRepBuilderAPI_MakeFace *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepBuilderAPI_MakeFace\n  * wrapname: _wrap_delete_BRepBuilderAPI_MakeFace\n  * fulldecl: BRepBuilderAPI_MakeFace::~BRepBuilderAPI_MakeFace()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepBuilderAPI_MakeSolid *_wrap_new_BRepBuilderAPI_MakeSolid__SWIG_0 () {
  BRepBuilderAPI_MakeSolid * lresult = (BRepBuilderAPI_MakeSolid *)0 ;
  BRepBuilderAPI_MakeSolid *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeSolid *)new BRepBuilderAPI_MakeSolid();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeSolid\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeSolid__SWIG_0\n  * fulldecl: BRepBuilderAPI_MakeSolid::BRepBuilderAPI_MakeSolid()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeSolid *)0;
  }
}


EXPORT BRepBuilderAPI_MakeSolid *_wrap_new_BRepBuilderAPI_MakeSolid__SWIG_1 (TopoDS_CompSolid *larg1) {
  BRepBuilderAPI_MakeSolid * lresult = (BRepBuilderAPI_MakeSolid *)0 ;
  TopoDS_CompSolid *arg1 = 0 ;
  BRepBuilderAPI_MakeSolid *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeSolid *)new BRepBuilderAPI_MakeSolid((TopoDS_CompSolid const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeSolid\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeSolid__SWIG_1\n  * fulldecl: BRepBuilderAPI_MakeSolid::BRepBuilderAPI_MakeSolid(TopoDS_CompSolid const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeSolid *)0;
  }
}


EXPORT BRepBuilderAPI_MakeSolid *_wrap_new_BRepBuilderAPI_MakeSolid__SWIG_2 (TopoDS_Shell *larg1) {
  BRepBuilderAPI_MakeSolid * lresult = (BRepBuilderAPI_MakeSolid *)0 ;
  TopoDS_Shell *arg1 = 0 ;
  BRepBuilderAPI_MakeSolid *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeSolid *)new BRepBuilderAPI_MakeSolid((TopoDS_Shell const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeSolid\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeSolid__SWIG_2\n  * fulldecl: BRepBuilderAPI_MakeSolid::BRepBuilderAPI_MakeSolid(TopoDS_Shell const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeSolid *)0;
  }
}


EXPORT BRepBuilderAPI_MakeSolid *_wrap_new_BRepBuilderAPI_MakeSolid__SWIG_3 (TopoDS_Shell *larg1, TopoDS_Shell *larg2) {
  BRepBuilderAPI_MakeSolid * lresult = (BRepBuilderAPI_MakeSolid *)0 ;
  TopoDS_Shell *arg1 = 0 ;
  TopoDS_Shell *arg2 = 0 ;
  BRepBuilderAPI_MakeSolid *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeSolid *)new BRepBuilderAPI_MakeSolid((TopoDS_Shell const &)*arg1,(TopoDS_Shell const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeSolid\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeSolid__SWIG_3\n  * fulldecl: BRepBuilderAPI_MakeSolid::BRepBuilderAPI_MakeSolid(TopoDS_Shell const &,TopoDS_Shell const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeSolid *)0;
  }
}


EXPORT BRepBuilderAPI_MakeSolid *_wrap_new_BRepBuilderAPI_MakeSolid__SWIG_4 (TopoDS_Shell *larg1, TopoDS_Shell *larg2, TopoDS_Shell *larg3) {
  BRepBuilderAPI_MakeSolid * lresult = (BRepBuilderAPI_MakeSolid *)0 ;
  TopoDS_Shell *arg1 = 0 ;
  TopoDS_Shell *arg2 = 0 ;
  TopoDS_Shell *arg3 = 0 ;
  BRepBuilderAPI_MakeSolid *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeSolid *)new BRepBuilderAPI_MakeSolid((TopoDS_Shell const &)*arg1,(TopoDS_Shell const &)*arg2,(TopoDS_Shell const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeSolid\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeSolid__SWIG_4\n  * fulldecl: BRepBuilderAPI_MakeSolid::BRepBuilderAPI_MakeSolid(TopoDS_Shell const &,TopoDS_Shell const &,TopoDS_Shell const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeSolid *)0;
  }
}


EXPORT BRepBuilderAPI_MakeSolid *_wrap_new_BRepBuilderAPI_MakeSolid__SWIG_5 (TopoDS_Solid *larg1) {
  BRepBuilderAPI_MakeSolid * lresult = (BRepBuilderAPI_MakeSolid *)0 ;
  TopoDS_Solid *arg1 = 0 ;
  BRepBuilderAPI_MakeSolid *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeSolid *)new BRepBuilderAPI_MakeSolid((TopoDS_Solid const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeSolid\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeSolid__SWIG_5\n  * fulldecl: BRepBuilderAPI_MakeSolid::BRepBuilderAPI_MakeSolid(TopoDS_Solid const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeSolid *)0;
  }
}


EXPORT BRepBuilderAPI_MakeSolid *_wrap_new_BRepBuilderAPI_MakeSolid__SWIG_6 (TopoDS_Solid *larg1, TopoDS_Shell *larg2) {
  BRepBuilderAPI_MakeSolid * lresult = (BRepBuilderAPI_MakeSolid *)0 ;
  TopoDS_Solid *arg1 = 0 ;
  TopoDS_Shell *arg2 = 0 ;
  BRepBuilderAPI_MakeSolid *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeSolid *)new BRepBuilderAPI_MakeSolid((TopoDS_Solid const &)*arg1,(TopoDS_Shell const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeSolid\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeSolid__SWIG_6\n  * fulldecl: BRepBuilderAPI_MakeSolid::BRepBuilderAPI_MakeSolid(TopoDS_Solid const &,TopoDS_Shell const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeSolid *)0;
  }
}


EXPORT void _wrap_BRepBuilderAPI_MakeSolid_Add (BRepBuilderAPI_MakeSolid *larg1, TopoDS_Shell *larg2) {
  BRepBuilderAPI_MakeSolid *arg1 = (BRepBuilderAPI_MakeSolid *) 0 ;
  TopoDS_Shell *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Add((TopoDS_Shell const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeSolid_Add\n  * wrapname: _wrap_BRepBuilderAPI_MakeSolid_Add\n  * fulldecl: void BRepBuilderAPI_MakeSolid::Add(TopoDS_Shell const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_BRepBuilderAPI_MakeSolid_IsDone (BRepBuilderAPI_MakeSolid *larg1) {
  bool lresult = (bool)0 ;
  BRepBuilderAPI_MakeSolid *arg1 = (BRepBuilderAPI_MakeSolid *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepBuilderAPI_MakeSolid const *)arg1)->IsDone();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeSolid_IsDone\n  * wrapname: _wrap_BRepBuilderAPI_MakeSolid_IsDone\n  * fulldecl: Standard_Boolean BRepBuilderAPI_MakeSolid::IsDone() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT TopoDS_Solid *_wrap_BRepBuilderAPI_MakeSolid_Solid (BRepBuilderAPI_MakeSolid *larg1) {
  TopoDS_Solid * lresult = (TopoDS_Solid *)0 ;
  BRepBuilderAPI_MakeSolid *arg1 = (BRepBuilderAPI_MakeSolid *) 0 ;
  TopoDS_Solid *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Solid *) &(arg1)->Solid();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeSolid_Solid\n  * wrapname: _wrap_BRepBuilderAPI_MakeSolid_Solid\n  * fulldecl: TopoDS_Solid const & BRepBuilderAPI_MakeSolid::Solid()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Solid *)0;
  }
}


EXPORT bool _wrap_BRepBuilderAPI_MakeSolid_IsDeleted (BRepBuilderAPI_MakeSolid *larg1, TopoDS_Shape *larg2) {
  bool lresult = (bool)0 ;
  BRepBuilderAPI_MakeSolid *arg1 = (BRepBuilderAPI_MakeSolid *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->IsDeleted((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeSolid_IsDeleted\n  * wrapname: _wrap_BRepBuilderAPI_MakeSolid_IsDeleted\n  * fulldecl: Standard_Boolean BRepBuilderAPI_MakeSolid::IsDeleted(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_delete_BRepBuilderAPI_MakeSolid (BRepBuilderAPI_MakeSolid *larg1) {
  BRepBuilderAPI_MakeSolid *arg1 = (BRepBuilderAPI_MakeSolid *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepBuilderAPI_MakeSolid\n  * wrapname: _wrap_delete_BRepBuilderAPI_MakeSolid\n  * fulldecl: BRepBuilderAPI_MakeSolid::~BRepBuilderAPI_MakeSolid()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepBuilderAPI_Sewing *_wrap_new_BRepBuilderAPI_Sewing__SWIG_0 (Standard_Real larg1, bool larg2, bool larg3, bool larg4) {
  BRepBuilderAPI_Sewing * lresult = (BRepBuilderAPI_Sewing *)0 ;
  Standard_Real arg1 ;
  Standard_Boolean arg2 ;
  Standard_Boolean arg3 ;
  Standard_Boolean arg4 ;
  BRepBuilderAPI_Sewing *result = 0 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  arg3 = (bool)larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_Sewing *)new BRepBuilderAPI_Sewing(arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_Sewing\n  * wrapname: _wrap_new_BRepBuilderAPI_Sewing__SWIG_0\n  * fulldecl: BRepBuilderAPI_Sewing::BRepBuilderAPI_Sewing(Standard_Real const,Standard_Boolean const,Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_Sewing *)0;
  }
}


EXPORT BRepBuilderAPI_Sewing *_wrap_new_BRepBuilderAPI_Sewing__SWIG_1 (Standard_Real larg1, bool larg2, bool larg3) {
  BRepBuilderAPI_Sewing * lresult = (BRepBuilderAPI_Sewing *)0 ;
  Standard_Real arg1 ;
  Standard_Boolean arg2 ;
  Standard_Boolean arg3 ;
  BRepBuilderAPI_Sewing *result = 0 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_Sewing *)new BRepBuilderAPI_Sewing(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_Sewing\n  * wrapname: _wrap_new_BRepBuilderAPI_Sewing__SWIG_1\n  * fulldecl: BRepBuilderAPI_Sewing::BRepBuilderAPI_Sewing(Standard_Real const,Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_Sewing *)0;
  }
}


EXPORT BRepBuilderAPI_Sewing *_wrap_new_BRepBuilderAPI_Sewing__SWIG_2 (Standard_Real larg1, bool larg2) {
  BRepBuilderAPI_Sewing * lresult = (BRepBuilderAPI_Sewing *)0 ;
  Standard_Real arg1 ;
  Standard_Boolean arg2 ;
  BRepBuilderAPI_Sewing *result = 0 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_Sewing *)new BRepBuilderAPI_Sewing(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_Sewing\n  * wrapname: _wrap_new_BRepBuilderAPI_Sewing__SWIG_2\n  * fulldecl: BRepBuilderAPI_Sewing::BRepBuilderAPI_Sewing(Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_Sewing *)0;
  }
}


EXPORT BRepBuilderAPI_Sewing *_wrap_new_BRepBuilderAPI_Sewing__SWIG_3 (Standard_Real larg1) {
  BRepBuilderAPI_Sewing * lresult = (BRepBuilderAPI_Sewing *)0 ;
  Standard_Real arg1 ;
  BRepBuilderAPI_Sewing *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_Sewing *)new BRepBuilderAPI_Sewing(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_Sewing\n  * wrapname: _wrap_new_BRepBuilderAPI_Sewing__SWIG_3\n  * fulldecl: BRepBuilderAPI_Sewing::BRepBuilderAPI_Sewing(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_Sewing *)0;
  }
}


EXPORT BRepBuilderAPI_Sewing *_wrap_new_BRepBuilderAPI_Sewing__SWIG_4 () {
  BRepBuilderAPI_Sewing * lresult = (BRepBuilderAPI_Sewing *)0 ;
  BRepBuilderAPI_Sewing *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_Sewing *)new BRepBuilderAPI_Sewing();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_Sewing\n  * wrapname: _wrap_new_BRepBuilderAPI_Sewing__SWIG_4\n  * fulldecl: BRepBuilderAPI_Sewing::BRepBuilderAPI_Sewing()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_Sewing *)0;
  }
}


EXPORT void _wrap_BRepBuilderAPI_Sewing_Init__SWIG_0 (BRepBuilderAPI_Sewing *larg1, Standard_Real larg2, bool larg3, bool larg4, bool larg5) {
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  Standard_Real arg2 ;
  Standard_Boolean arg3 ;
  Standard_Boolean arg4 ;
  Standard_Boolean arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  arg4 = (bool)larg4;
  arg5 = (bool)larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init(arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_Init\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_Init__SWIG_0\n  * fulldecl: void BRepBuilderAPI_Sewing::Init(Standard_Real const,Standard_Boolean const,Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepBuilderAPI_Sewing_Init__SWIG_1 (BRepBuilderAPI_Sewing *larg1, Standard_Real larg2, bool larg3, bool larg4) {
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  Standard_Real arg2 ;
  Standard_Boolean arg3 ;
  Standard_Boolean arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init(arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_Init\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_Init__SWIG_1\n  * fulldecl: void BRepBuilderAPI_Sewing::Init(Standard_Real const,Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepBuilderAPI_Sewing_Init__SWIG_2 (BRepBuilderAPI_Sewing *larg1, Standard_Real larg2, bool larg3) {
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  Standard_Real arg2 ;
  Standard_Boolean arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init(arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_Init\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_Init__SWIG_2\n  * fulldecl: void BRepBuilderAPI_Sewing::Init(Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepBuilderAPI_Sewing_Init__SWIG_3 (BRepBuilderAPI_Sewing *larg1, Standard_Real larg2) {
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_Init\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_Init__SWIG_3\n  * fulldecl: void BRepBuilderAPI_Sewing::Init(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepBuilderAPI_Sewing_Load (BRepBuilderAPI_Sewing *larg1, TopoDS_Shape *larg2) {
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Load((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_Load\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_Load\n  * fulldecl: void BRepBuilderAPI_Sewing::Load(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepBuilderAPI_Sewing_Add (BRepBuilderAPI_Sewing *larg1, TopoDS_Shape *larg2) {
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Add((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_Add\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_Add\n  * fulldecl: void BRepBuilderAPI_Sewing::Add(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepBuilderAPI_Sewing_Perform (BRepBuilderAPI_Sewing *larg1) {
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Perform();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_Perform\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_Perform\n  * fulldecl: void BRepBuilderAPI_Sewing::Perform()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopoDS_Shape *_wrap_BRepBuilderAPI_Sewing_SewedShape (BRepBuilderAPI_Sewing *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &((BRepBuilderAPI_Sewing const *)arg1)->SewedShape();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_SewedShape\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_SewedShape\n  * fulldecl: TopoDS_Shape const & BRepBuilderAPI_Sewing::SewedShape() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT Standard_Integer _wrap_BRepBuilderAPI_Sewing_NbFreeEdges (BRepBuilderAPI_Sewing *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((BRepBuilderAPI_Sewing const *)arg1)->NbFreeEdges();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_NbFreeEdges\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_NbFreeEdges\n  * fulldecl: Standard_Integer BRepBuilderAPI_Sewing::NbFreeEdges() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT TopoDS_Edge *_wrap_BRepBuilderAPI_Sewing_FreeEdge (BRepBuilderAPI_Sewing *larg1, Standard_Integer larg2) {
  TopoDS_Edge * lresult = (TopoDS_Edge *)0 ;
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  Standard_Integer arg2 ;
  TopoDS_Edge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Edge *) &((BRepBuilderAPI_Sewing const *)arg1)->FreeEdge(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_FreeEdge\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_FreeEdge\n  * fulldecl: TopoDS_Edge const & BRepBuilderAPI_Sewing::FreeEdge(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Edge *)0;
  }
}


EXPORT Standard_Integer _wrap_BRepBuilderAPI_Sewing_NbMultipleEdges (BRepBuilderAPI_Sewing *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((BRepBuilderAPI_Sewing const *)arg1)->NbMultipleEdges();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_NbMultipleEdges\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_NbMultipleEdges\n  * fulldecl: Standard_Integer BRepBuilderAPI_Sewing::NbMultipleEdges() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT TopoDS_Edge *_wrap_BRepBuilderAPI_Sewing_MultipleEdge (BRepBuilderAPI_Sewing *larg1, Standard_Integer larg2) {
  TopoDS_Edge * lresult = (TopoDS_Edge *)0 ;
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  Standard_Integer arg2 ;
  TopoDS_Edge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Edge *) &((BRepBuilderAPI_Sewing const *)arg1)->MultipleEdge(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_MultipleEdge\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_MultipleEdge\n  * fulldecl: TopoDS_Edge const & BRepBuilderAPI_Sewing::MultipleEdge(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Edge *)0;
  }
}


EXPORT Standard_Integer _wrap_BRepBuilderAPI_Sewing_NbDegeneratedShapes (BRepBuilderAPI_Sewing *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((BRepBuilderAPI_Sewing const *)arg1)->NbDegeneratedShapes();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_NbDegeneratedShapes\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_NbDegeneratedShapes\n  * fulldecl: Standard_Integer BRepBuilderAPI_Sewing::NbDegeneratedShapes() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT TopoDS_Shape *_wrap_BRepBuilderAPI_Sewing_DegeneratedShape (BRepBuilderAPI_Sewing *larg1, Standard_Integer larg2) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  Standard_Integer arg2 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &((BRepBuilderAPI_Sewing const *)arg1)->DegeneratedShape(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_DegeneratedShape\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_DegeneratedShape\n  * fulldecl: TopoDS_Shape const & BRepBuilderAPI_Sewing::DegeneratedShape(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT Standard_Integer _wrap_BRepBuilderAPI_Sewing_NbDeletedFaces (BRepBuilderAPI_Sewing *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((BRepBuilderAPI_Sewing const *)arg1)->NbDeletedFaces();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_NbDeletedFaces\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_NbDeletedFaces\n  * fulldecl: Standard_Integer BRepBuilderAPI_Sewing::NbDeletedFaces() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT TopoDS_Face *_wrap_BRepBuilderAPI_Sewing_DeletedFace (BRepBuilderAPI_Sewing *larg1, Standard_Integer larg2) {
  TopoDS_Face * lresult = (TopoDS_Face *)0 ;
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  Standard_Integer arg2 ;
  TopoDS_Face *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Face *) &((BRepBuilderAPI_Sewing const *)arg1)->DeletedFace(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_DeletedFace\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_DeletedFace\n  * fulldecl: TopoDS_Face const & BRepBuilderAPI_Sewing::DeletedFace(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Face *)0;
  }
}


EXPORT bool _wrap_BRepBuilderAPI_Sewing_IsDegenerated (BRepBuilderAPI_Sewing *larg1, TopoDS_Shape *larg2) {
  bool lresult = (bool)0 ;
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepBuilderAPI_Sewing const *)arg1)->IsDegenerated((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_IsDegenerated\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_IsDegenerated\n  * fulldecl: Standard_Boolean BRepBuilderAPI_Sewing::IsDegenerated(TopoDS_Shape const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepBuilderAPI_Sewing_IsModified (BRepBuilderAPI_Sewing *larg1, TopoDS_Shape *larg2) {
  bool lresult = (bool)0 ;
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepBuilderAPI_Sewing const *)arg1)->IsModified((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_IsModified\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_IsModified\n  * fulldecl: Standard_Boolean BRepBuilderAPI_Sewing::IsModified(TopoDS_Shape const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT TopoDS_Shape *_wrap_BRepBuilderAPI_Sewing_Modified (BRepBuilderAPI_Sewing *larg1, TopoDS_Shape *larg2) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &((BRepBuilderAPI_Sewing const *)arg1)->Modified((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_Modified\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_Modified\n  * fulldecl: TopoDS_Shape const & BRepBuilderAPI_Sewing::Modified(TopoDS_Shape const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT void _wrap_BRepBuilderAPI_Sewing_Dump (BRepBuilderAPI_Sewing *larg1) {
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRepBuilderAPI_Sewing const *)arg1)->Dump();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_Dump\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_Dump\n  * fulldecl: void BRepBuilderAPI_Sewing::Dump() const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_BRepBuilderAPI_Sewing_IsModifiedSubShape (BRepBuilderAPI_Sewing *larg1, TopoDS_Shape *larg2) {
  bool lresult = (bool)0 ;
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepBuilderAPI_Sewing const *)arg1)->IsModifiedSubShape((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_IsModifiedSubShape\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_IsModifiedSubShape\n  * fulldecl: Standard_Boolean BRepBuilderAPI_Sewing::IsModifiedSubShape(TopoDS_Shape const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT TopoDS_Shape *_wrap_BRepBuilderAPI_Sewing_ModifiedSubShape (BRepBuilderAPI_Sewing *larg1, TopoDS_Shape *larg2) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopoDS_Shape result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((BRepBuilderAPI_Sewing const *)arg1)->ModifiedSubShape((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_ModifiedSubShape\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_ModifiedSubShape\n  * fulldecl: TopoDS_Shape BRepBuilderAPI_Sewing::ModifiedSubShape(TopoDS_Shape const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new TopoDS_Shape(result);
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT void _wrap_delete_BRepBuilderAPI_Sewing (BRepBuilderAPI_Sewing *larg1) {
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepBuilderAPI_Sewing\n  * wrapname: _wrap_delete_BRepBuilderAPI_Sewing\n  * fulldecl: BRepBuilderAPI_Sewing::~BRepBuilderAPI_Sewing()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepBuilderAPI_NurbsConvert *_wrap_new_BRepBuilderAPI_NurbsConvert__SWIG_0 () {
  BRepBuilderAPI_NurbsConvert * lresult = (BRepBuilderAPI_NurbsConvert *)0 ;
  BRepBuilderAPI_NurbsConvert *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_NurbsConvert *)new BRepBuilderAPI_NurbsConvert();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_NurbsConvert\n  * wrapname: _wrap_new_BRepBuilderAPI_NurbsConvert__SWIG_0\n  * fulldecl: BRepBuilderAPI_NurbsConvert::BRepBuilderAPI_NurbsConvert()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_NurbsConvert *)0;
  }
}


EXPORT BRepBuilderAPI_NurbsConvert *_wrap_new_BRepBuilderAPI_NurbsConvert__SWIG_1 (TopoDS_Shape *larg1, bool larg2) {
  BRepBuilderAPI_NurbsConvert * lresult = (BRepBuilderAPI_NurbsConvert *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Boolean arg2 ;
  BRepBuilderAPI_NurbsConvert *result = 0 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_NurbsConvert *)new BRepBuilderAPI_NurbsConvert((TopoDS_Shape const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_NurbsConvert\n  * wrapname: _wrap_new_BRepBuilderAPI_NurbsConvert__SWIG_1\n  * fulldecl: BRepBuilderAPI_NurbsConvert::BRepBuilderAPI_NurbsConvert(TopoDS_Shape const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_NurbsConvert *)0;
  }
}


EXPORT BRepBuilderAPI_NurbsConvert *_wrap_new_BRepBuilderAPI_NurbsConvert__SWIG_2 (TopoDS_Shape *larg1) {
  BRepBuilderAPI_NurbsConvert * lresult = (BRepBuilderAPI_NurbsConvert *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  BRepBuilderAPI_NurbsConvert *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_NurbsConvert *)new BRepBuilderAPI_NurbsConvert((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_NurbsConvert\n  * wrapname: _wrap_new_BRepBuilderAPI_NurbsConvert__SWIG_2\n  * fulldecl: BRepBuilderAPI_NurbsConvert::BRepBuilderAPI_NurbsConvert(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_NurbsConvert *)0;
  }
}


EXPORT void _wrap_BRepBuilderAPI_NurbsConvert_Perform__SWIG_0 (BRepBuilderAPI_NurbsConvert *larg1, TopoDS_Shape *larg2, bool larg3) {
  BRepBuilderAPI_NurbsConvert *arg1 = (BRepBuilderAPI_NurbsConvert *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Perform((TopoDS_Shape const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_NurbsConvert_Perform\n  * wrapname: _wrap_BRepBuilderAPI_NurbsConvert_Perform__SWIG_0\n  * fulldecl: void BRepBuilderAPI_NurbsConvert::Perform(TopoDS_Shape const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepBuilderAPI_NurbsConvert_Perform__SWIG_1 (BRepBuilderAPI_NurbsConvert *larg1, TopoDS_Shape *larg2) {
  BRepBuilderAPI_NurbsConvert *arg1 = (BRepBuilderAPI_NurbsConvert *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Perform((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_NurbsConvert_Perform\n  * wrapname: _wrap_BRepBuilderAPI_NurbsConvert_Perform__SWIG_1\n  * fulldecl: void BRepBuilderAPI_NurbsConvert::Perform(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_BRepBuilderAPI_NurbsConvert (BRepBuilderAPI_NurbsConvert *larg1) {
  BRepBuilderAPI_NurbsConvert *arg1 = (BRepBuilderAPI_NurbsConvert *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepBuilderAPI_NurbsConvert\n  * wrapname: _wrap_delete_BRepBuilderAPI_NurbsConvert\n  * fulldecl: BRepBuilderAPI_NurbsConvert::~BRepBuilderAPI_NurbsConvert()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <BRepOffsetAPI_NormalProjection.hxx>

EXPORT BRepOffsetAPI_NormalProjection *_wrap_new_BRepOffsetAPI_NormalProjection__SWIG_0 () {
  BRepOffsetAPI_NormalProjection * lresult = (BRepOffsetAPI_NormalProjection *)0 ;
  BRepOffsetAPI_NormalProjection *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_NormalProjection *)new BRepOffsetAPI_NormalProjection();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_NormalProjection\n  * wrapname: _wrap_new_BRepOffsetAPI_NormalProjection__SWIG_0\n  * fulldecl: BRepOffsetAPI_NormalProjection::BRepOffsetAPI_NormalProjection()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_NormalProjection *)0;
  }
}


EXPORT BRepOffsetAPI_NormalProjection *_wrap_new_BRepOffsetAPI_NormalProjection__SWIG_1 (TopoDS_Shape *larg1) {
  BRepOffsetAPI_NormalProjection * lresult = (BRepOffsetAPI_NormalProjection *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  BRepOffsetAPI_NormalProjection *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_NormalProjection *)new BRepOffsetAPI_NormalProjection((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_NormalProjection\n  * wrapname: _wrap_new_BRepOffsetAPI_NormalProjection__SWIG_1\n  * fulldecl: BRepOffsetAPI_NormalProjection::BRepOffsetAPI_NormalProjection(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_NormalProjection *)0;
  }
}


EXPORT void _wrap_BRepOffsetAPI_NormalProjection_Init (BRepOffsetAPI_NormalProjection *larg1, TopoDS_Shape *larg2) {
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_NormalProjection_Init\n  * wrapname: _wrap_BRepOffsetAPI_NormalProjection_Init\n  * fulldecl: void BRepOffsetAPI_NormalProjection::Init(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_NormalProjection_Add (BRepOffsetAPI_NormalProjection *larg1, TopoDS_Shape *larg2) {
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Add((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_NormalProjection_Add\n  * wrapname: _wrap_BRepOffsetAPI_NormalProjection_Add\n  * fulldecl: void BRepOffsetAPI_NormalProjection::Add(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_NormalProjection_SetParams (BRepOffsetAPI_NormalProjection *larg1, Standard_Real larg2, Standard_Real larg3, GeomAbs_Shape larg4, Standard_Integer larg5, Standard_Integer larg6) {
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  GeomAbs_Shape arg4 ;
  Standard_Integer arg5 ;
  Standard_Integer arg6 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetParams(arg2,arg3,arg4,arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_NormalProjection_SetParams\n  * wrapname: _wrap_BRepOffsetAPI_NormalProjection_SetParams\n  * fulldecl: void BRepOffsetAPI_NormalProjection::SetParams(Standard_Real const,Standard_Real const,GeomAbs_Shape const,Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_NormalProjection_SetMaxDistance (BRepOffsetAPI_NormalProjection *larg1, Standard_Real larg2) {
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetMaxDistance(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_NormalProjection_SetMaxDistance\n  * wrapname: _wrap_BRepOffsetAPI_NormalProjection_SetMaxDistance\n  * fulldecl: void BRepOffsetAPI_NormalProjection::SetMaxDistance(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_NormalProjection_SetLimit__SWIG_0 (BRepOffsetAPI_NormalProjection *larg1, bool larg2) {
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  Standard_Boolean arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLimit(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_NormalProjection_SetLimit\n  * wrapname: _wrap_BRepOffsetAPI_NormalProjection_SetLimit__SWIG_0\n  * fulldecl: void BRepOffsetAPI_NormalProjection::SetLimit(Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_NormalProjection_SetLimit__SWIG_1 (BRepOffsetAPI_NormalProjection *larg1) {
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLimit();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_NormalProjection_SetLimit\n  * wrapname: _wrap_BRepOffsetAPI_NormalProjection_SetLimit__SWIG_1\n  * fulldecl: void BRepOffsetAPI_NormalProjection::SetLimit()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_NormalProjection_Compute3d__SWIG_0 (BRepOffsetAPI_NormalProjection *larg1, bool larg2) {
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  Standard_Boolean arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Compute3d(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_NormalProjection_Compute3d\n  * wrapname: _wrap_BRepOffsetAPI_NormalProjection_Compute3d__SWIG_0\n  * fulldecl: void BRepOffsetAPI_NormalProjection::Compute3d(Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_NormalProjection_Compute3d__SWIG_1 (BRepOffsetAPI_NormalProjection *larg1) {
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Compute3d();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_NormalProjection_Compute3d\n  * wrapname: _wrap_BRepOffsetAPI_NormalProjection_Compute3d__SWIG_1\n  * fulldecl: void BRepOffsetAPI_NormalProjection::Compute3d()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_NormalProjection_Build (BRepOffsetAPI_NormalProjection *larg1) {
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Build();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_NormalProjection_Build\n  * wrapname: _wrap_BRepOffsetAPI_NormalProjection_Build\n  * fulldecl: void BRepOffsetAPI_NormalProjection::Build()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_BRepOffsetAPI_NormalProjection_IsDone (BRepOffsetAPI_NormalProjection *larg1) {
  bool lresult = (bool)0 ;
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepOffsetAPI_NormalProjection const *)arg1)->IsDone();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_NormalProjection_IsDone\n  * wrapname: _wrap_BRepOffsetAPI_NormalProjection_IsDone\n  * fulldecl: Standard_Boolean BRepOffsetAPI_NormalProjection::IsDone() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT TopoDS_Shape *_wrap_BRepOffsetAPI_NormalProjection_Projection (BRepOffsetAPI_NormalProjection *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &((BRepOffsetAPI_NormalProjection const *)arg1)->Projection();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_NormalProjection_Projection\n  * wrapname: _wrap_BRepOffsetAPI_NormalProjection_Projection\n  * fulldecl: TopoDS_Shape const & BRepOffsetAPI_NormalProjection::Projection() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT TopoDS_Shape *_wrap_BRepOffsetAPI_NormalProjection_Couple (BRepOffsetAPI_NormalProjection *larg1, TopoDS_Edge *larg2) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  TopoDS_Edge *arg2 = 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &((BRepOffsetAPI_NormalProjection const *)arg1)->Couple((TopoDS_Edge const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_NormalProjection_Couple\n  * wrapname: _wrap_BRepOffsetAPI_NormalProjection_Couple\n  * fulldecl: TopoDS_Shape const & BRepOffsetAPI_NormalProjection::Couple(TopoDS_Edge const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT TopTools_ListOfShape *_wrap_BRepOffsetAPI_NormalProjection_Generated (BRepOffsetAPI_NormalProjection *larg1, TopoDS_Shape *larg2) {
  TopTools_ListOfShape * lresult = (TopTools_ListOfShape *)0 ;
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopTools_ListOfShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopTools_ListOfShape *) &(arg1)->Generated((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_NormalProjection_Generated\n  * wrapname: _wrap_BRepOffsetAPI_NormalProjection_Generated\n  * fulldecl: TopTools_ListOfShape const & BRepOffsetAPI_NormalProjection::Generated(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopTools_ListOfShape *)0;
  }
}


EXPORT TopoDS_Shape *_wrap_BRepOffsetAPI_NormalProjection_Ancestor (BRepOffsetAPI_NormalProjection *larg1, TopoDS_Edge *larg2) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  TopoDS_Edge *arg2 = 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &((BRepOffsetAPI_NormalProjection const *)arg1)->Ancestor((TopoDS_Edge const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_NormalProjection_Ancestor\n  * wrapname: _wrap_BRepOffsetAPI_NormalProjection_Ancestor\n  * fulldecl: TopoDS_Shape const & BRepOffsetAPI_NormalProjection::Ancestor(TopoDS_Edge const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT bool _wrap_BRepOffsetAPI_NormalProjection_BuildWire (BRepOffsetAPI_NormalProjection *larg1, TopTools_ListOfShape *larg2) {
  bool lresult = (bool)0 ;
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  TopTools_ListOfShape *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepOffsetAPI_NormalProjection const *)arg1)->BuildWire(*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_NormalProjection_BuildWire\n  * wrapname: _wrap_BRepOffsetAPI_NormalProjection_BuildWire\n  * fulldecl: Standard_Boolean BRepOffsetAPI_NormalProjection::BuildWire(TopTools_ListOfShape &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_delete_BRepOffsetAPI_NormalProjection (BRepOffsetAPI_NormalProjection *larg1) {
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepOffsetAPI_NormalProjection\n  * wrapname: _wrap_delete_BRepOffsetAPI_NormalProjection\n  * fulldecl: BRepOffsetAPI_NormalProjection::~BRepOffsetAPI_NormalProjection()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <BRepOffsetAPI_MakeOffsetShape.hxx>
  
EXPORT BRepOffsetAPI_MakeOffsetShape *_wrap_new_BRepOffsetAPI_MakeOffsetShape__SWIG_0 () {
  BRepOffsetAPI_MakeOffsetShape * lresult = (BRepOffsetAPI_MakeOffsetShape *)0 ;
  BRepOffsetAPI_MakeOffsetShape *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_MakeOffsetShape *)new BRepOffsetAPI_MakeOffsetShape();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_MakeOffsetShape\n  * wrapname: _wrap_new_BRepOffsetAPI_MakeOffsetShape__SWIG_0\n  * fulldecl: BRepOffsetAPI_MakeOffsetShape::BRepOffsetAPI_MakeOffsetShape()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_MakeOffsetShape *)0;
  }
}


EXPORT BRepOffsetAPI_MakeOffsetShape *_wrap_new_BRepOffsetAPI_MakeOffsetShape__SWIG_1 (TopoDS_Shape *larg1, Standard_Real larg2, Standard_Real larg3, BRepOffset_Mode const *larg4, bool larg5, bool larg6, GeomAbs_JoinType const *larg7, bool larg8) {
  BRepOffsetAPI_MakeOffsetShape * lresult = (BRepOffsetAPI_MakeOffsetShape *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  BRepOffset_Mode arg4 ;
  Standard_Boolean arg5 ;
  Standard_Boolean arg6 ;
  GeomAbs_JoinType arg7 ;
  Standard_Boolean arg8 ;
  BRepOffsetAPI_MakeOffsetShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = *larg4;
  arg5 = (bool)larg5;
  arg6 = (bool)larg6;
  arg7 = *larg7;
  arg8 = (bool)larg8;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_MakeOffsetShape *)new BRepOffsetAPI_MakeOffsetShape((TopoDS_Shape const &)*arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_MakeOffsetShape\n  * wrapname: _wrap_new_BRepOffsetAPI_MakeOffsetShape__SWIG_1\n  * fulldecl: BRepOffsetAPI_MakeOffsetShape::BRepOffsetAPI_MakeOffsetShape(TopoDS_Shape const &,Standard_Real const,Standard_Real const,BRepOffset_Mode const,Standard_Boolean const,Standard_Boolean const,GeomAbs_JoinType const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_MakeOffsetShape *)0;
  }
}


EXPORT BRepOffsetAPI_MakeOffsetShape *_wrap_new_BRepOffsetAPI_MakeOffsetShape__SWIG_2 (TopoDS_Shape *larg1, Standard_Real larg2, Standard_Real larg3, BRepOffset_Mode const *larg4, bool larg5, bool larg6, GeomAbs_JoinType const *larg7) {
  BRepOffsetAPI_MakeOffsetShape * lresult = (BRepOffsetAPI_MakeOffsetShape *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  BRepOffset_Mode arg4 ;
  Standard_Boolean arg5 ;
  Standard_Boolean arg6 ;
  GeomAbs_JoinType arg7 ;
  BRepOffsetAPI_MakeOffsetShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = *larg4;
  arg5 = (bool)larg5;
  arg6 = (bool)larg6;
  arg7 = *larg7;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_MakeOffsetShape *)new BRepOffsetAPI_MakeOffsetShape((TopoDS_Shape const &)*arg1,arg2,arg3,arg4,arg5,arg6,arg7);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_MakeOffsetShape\n  * wrapname: _wrap_new_BRepOffsetAPI_MakeOffsetShape__SWIG_2\n  * fulldecl: BRepOffsetAPI_MakeOffsetShape::BRepOffsetAPI_MakeOffsetShape(TopoDS_Shape const &,Standard_Real const,Standard_Real const,BRepOffset_Mode const,Standard_Boolean const,Standard_Boolean const,GeomAbs_JoinType const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_MakeOffsetShape *)0;
  }
}


EXPORT BRepOffsetAPI_MakeOffsetShape *_wrap_new_BRepOffsetAPI_MakeOffsetShape__SWIG_3 (TopoDS_Shape *larg1, Standard_Real larg2, Standard_Real larg3, BRepOffset_Mode const *larg4, bool larg5, bool larg6) {
  BRepOffsetAPI_MakeOffsetShape * lresult = (BRepOffsetAPI_MakeOffsetShape *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  BRepOffset_Mode arg4 ;
  Standard_Boolean arg5 ;
  Standard_Boolean arg6 ;
  BRepOffsetAPI_MakeOffsetShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = *larg4;
  arg5 = (bool)larg5;
  arg6 = (bool)larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_MakeOffsetShape *)new BRepOffsetAPI_MakeOffsetShape((TopoDS_Shape const &)*arg1,arg2,arg3,arg4,arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_MakeOffsetShape\n  * wrapname: _wrap_new_BRepOffsetAPI_MakeOffsetShape__SWIG_3\n  * fulldecl: BRepOffsetAPI_MakeOffsetShape::BRepOffsetAPI_MakeOffsetShape(TopoDS_Shape const &,Standard_Real const,Standard_Real const,BRepOffset_Mode const,Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_MakeOffsetShape *)0;
  }
}


EXPORT BRepOffsetAPI_MakeOffsetShape *_wrap_new_BRepOffsetAPI_MakeOffsetShape__SWIG_4 (TopoDS_Shape *larg1, Standard_Real larg2, Standard_Real larg3, BRepOffset_Mode const *larg4, bool larg5) {
  BRepOffsetAPI_MakeOffsetShape * lresult = (BRepOffsetAPI_MakeOffsetShape *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  BRepOffset_Mode arg4 ;
  Standard_Boolean arg5 ;
  BRepOffsetAPI_MakeOffsetShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = *larg4;
  arg5 = (bool)larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_MakeOffsetShape *)new BRepOffsetAPI_MakeOffsetShape((TopoDS_Shape const &)*arg1,arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_MakeOffsetShape\n  * wrapname: _wrap_new_BRepOffsetAPI_MakeOffsetShape__SWIG_4\n  * fulldecl: BRepOffsetAPI_MakeOffsetShape::BRepOffsetAPI_MakeOffsetShape(TopoDS_Shape const &,Standard_Real const,Standard_Real const,BRepOffset_Mode const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_MakeOffsetShape *)0;
  }
}


EXPORT BRepOffsetAPI_MakeOffsetShape *_wrap_new_BRepOffsetAPI_MakeOffsetShape__SWIG_5 (TopoDS_Shape *larg1, Standard_Real larg2, Standard_Real larg3, BRepOffset_Mode const *larg4) {
  BRepOffsetAPI_MakeOffsetShape * lresult = (BRepOffsetAPI_MakeOffsetShape *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  BRepOffset_Mode arg4 ;
  BRepOffsetAPI_MakeOffsetShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = *larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_MakeOffsetShape *)new BRepOffsetAPI_MakeOffsetShape((TopoDS_Shape const &)*arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_MakeOffsetShape\n  * wrapname: _wrap_new_BRepOffsetAPI_MakeOffsetShape__SWIG_5\n  * fulldecl: BRepOffsetAPI_MakeOffsetShape::BRepOffsetAPI_MakeOffsetShape(TopoDS_Shape const &,Standard_Real const,Standard_Real const,BRepOffset_Mode const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_MakeOffsetShape *)0;
  }
}


EXPORT BRepOffsetAPI_MakeOffsetShape *_wrap_new_BRepOffsetAPI_MakeOffsetShape__SWIG_6 (TopoDS_Shape *larg1, Standard_Real larg2, Standard_Real larg3) {
  BRepOffsetAPI_MakeOffsetShape * lresult = (BRepOffsetAPI_MakeOffsetShape *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  BRepOffsetAPI_MakeOffsetShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_MakeOffsetShape *)new BRepOffsetAPI_MakeOffsetShape((TopoDS_Shape const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_MakeOffsetShape\n  * wrapname: _wrap_new_BRepOffsetAPI_MakeOffsetShape__SWIG_6\n  * fulldecl: BRepOffsetAPI_MakeOffsetShape::BRepOffsetAPI_MakeOffsetShape(TopoDS_Shape const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_MakeOffsetShape *)0;
  }
}


EXPORT void _wrap_delete_BRepOffsetAPI_MakeOffsetShape (BRepOffsetAPI_MakeOffsetShape *larg1) {
  BRepOffsetAPI_MakeOffsetShape *arg1 = (BRepOffsetAPI_MakeOffsetShape *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepOffsetAPI_MakeOffsetShape\n  * wrapname: _wrap_delete_BRepOffsetAPI_MakeOffsetShape\n  * fulldecl: BRepOffsetAPI_MakeOffsetShape::~BRepOffsetAPI_MakeOffsetShape()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <BRepOffsetAPI_MakeThickSolid.hxx>
  
EXPORT BRepOffsetAPI_MakeThickSolid *_wrap_new_BRepOffsetAPI_MakeThickSolid__SWIG_0 () {
  BRepOffsetAPI_MakeThickSolid * lresult = (BRepOffsetAPI_MakeThickSolid *)0 ;
  BRepOffsetAPI_MakeThickSolid *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_MakeThickSolid *)new BRepOffsetAPI_MakeThickSolid();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_MakeThickSolid\n  * wrapname: _wrap_new_BRepOffsetAPI_MakeThickSolid__SWIG_0\n  * fulldecl: BRepOffsetAPI_MakeThickSolid::BRepOffsetAPI_MakeThickSolid()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_MakeThickSolid *)0;
  }
}


EXPORT BRepOffsetAPI_MakeThickSolid *_wrap_new_BRepOffsetAPI_MakeThickSolid__SWIG_1 (TopoDS_Shape *larg1, TopTools_ListOfShape *larg2, Standard_Real larg3, Standard_Real larg4, BRepOffset_Mode const *larg5, bool larg6, bool larg7, GeomAbs_JoinType const *larg8, bool larg9) {
  BRepOffsetAPI_MakeThickSolid * lresult = (BRepOffsetAPI_MakeThickSolid *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  TopTools_ListOfShape *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  BRepOffset_Mode arg5 ;
  Standard_Boolean arg6 ;
  Standard_Boolean arg7 ;
  GeomAbs_JoinType arg8 ;
  Standard_Boolean arg9 ;
  BRepOffsetAPI_MakeThickSolid *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = *larg5;
  arg6 = (bool)larg6;
  arg7 = (bool)larg7;
  arg8 = *larg8;
  arg9 = (bool)larg9;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_MakeThickSolid *)new BRepOffsetAPI_MakeThickSolid((TopoDS_Shape const &)*arg1,(TopTools_ListOfShape const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_MakeThickSolid\n  * wrapname: _wrap_new_BRepOffsetAPI_MakeThickSolid__SWIG_1\n  * fulldecl: BRepOffsetAPI_MakeThickSolid::BRepOffsetAPI_MakeThickSolid(TopoDS_Shape const &,TopTools_ListOfShape const &,Standard_Real const,Standard_Real const,BRepOffset_Mode const,Standard_Boolean const,Standard_Boolean const,GeomAbs_JoinType const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_MakeThickSolid *)0;
  }
}


EXPORT BRepOffsetAPI_MakeThickSolid *_wrap_new_BRepOffsetAPI_MakeThickSolid__SWIG_2 (TopoDS_Shape *larg1, TopTools_ListOfShape *larg2, Standard_Real larg3, Standard_Real larg4, BRepOffset_Mode const *larg5, bool larg6, bool larg7, GeomAbs_JoinType const *larg8) {
  BRepOffsetAPI_MakeThickSolid * lresult = (BRepOffsetAPI_MakeThickSolid *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  TopTools_ListOfShape *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  BRepOffset_Mode arg5 ;
  Standard_Boolean arg6 ;
  Standard_Boolean arg7 ;
  GeomAbs_JoinType arg8 ;
  BRepOffsetAPI_MakeThickSolid *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = *larg5;
  arg6 = (bool)larg6;
  arg7 = (bool)larg7;
  arg8 = *larg8;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_MakeThickSolid *)new BRepOffsetAPI_MakeThickSolid((TopoDS_Shape const &)*arg1,(TopTools_ListOfShape const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_MakeThickSolid\n  * wrapname: _wrap_new_BRepOffsetAPI_MakeThickSolid__SWIG_2\n  * fulldecl: BRepOffsetAPI_MakeThickSolid::BRepOffsetAPI_MakeThickSolid(TopoDS_Shape const &,TopTools_ListOfShape const &,Standard_Real const,Standard_Real const,BRepOffset_Mode const,Standard_Boolean const,Standard_Boolean const,GeomAbs_JoinType const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_MakeThickSolid *)0;
  }
}


EXPORT BRepOffsetAPI_MakeThickSolid *_wrap_new_BRepOffsetAPI_MakeThickSolid__SWIG_3 (TopoDS_Shape *larg1, TopTools_ListOfShape *larg2, Standard_Real larg3, Standard_Real larg4, BRepOffset_Mode const *larg5, bool larg6, bool larg7) {
  BRepOffsetAPI_MakeThickSolid * lresult = (BRepOffsetAPI_MakeThickSolid *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  TopTools_ListOfShape *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  BRepOffset_Mode arg5 ;
  Standard_Boolean arg6 ;
  Standard_Boolean arg7 ;
  BRepOffsetAPI_MakeThickSolid *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = *larg5;
  arg6 = (bool)larg6;
  arg7 = (bool)larg7;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_MakeThickSolid *)new BRepOffsetAPI_MakeThickSolid((TopoDS_Shape const &)*arg1,(TopTools_ListOfShape const &)*arg2,arg3,arg4,arg5,arg6,arg7);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_MakeThickSolid\n  * wrapname: _wrap_new_BRepOffsetAPI_MakeThickSolid__SWIG_3\n  * fulldecl: BRepOffsetAPI_MakeThickSolid::BRepOffsetAPI_MakeThickSolid(TopoDS_Shape const &,TopTools_ListOfShape const &,Standard_Real const,Standard_Real const,BRepOffset_Mode const,Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_MakeThickSolid *)0;
  }
}


EXPORT BRepOffsetAPI_MakeThickSolid *_wrap_new_BRepOffsetAPI_MakeThickSolid__SWIG_4 (TopoDS_Shape *larg1, TopTools_ListOfShape *larg2, Standard_Real larg3, Standard_Real larg4, BRepOffset_Mode const *larg5, bool larg6) {
  BRepOffsetAPI_MakeThickSolid * lresult = (BRepOffsetAPI_MakeThickSolid *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  TopTools_ListOfShape *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  BRepOffset_Mode arg5 ;
  Standard_Boolean arg6 ;
  BRepOffsetAPI_MakeThickSolid *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = *larg5;
  arg6 = (bool)larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_MakeThickSolid *)new BRepOffsetAPI_MakeThickSolid((TopoDS_Shape const &)*arg1,(TopTools_ListOfShape const &)*arg2,arg3,arg4,arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_MakeThickSolid\n  * wrapname: _wrap_new_BRepOffsetAPI_MakeThickSolid__SWIG_4\n  * fulldecl: BRepOffsetAPI_MakeThickSolid::BRepOffsetAPI_MakeThickSolid(TopoDS_Shape const &,TopTools_ListOfShape const &,Standard_Real const,Standard_Real const,BRepOffset_Mode const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_MakeThickSolid *)0;
  }
}


EXPORT BRepOffsetAPI_MakeThickSolid *_wrap_new_BRepOffsetAPI_MakeThickSolid__SWIG_5 (TopoDS_Shape *larg1, TopTools_ListOfShape *larg2, Standard_Real larg3, Standard_Real larg4, BRepOffset_Mode const *larg5) {
  BRepOffsetAPI_MakeThickSolid * lresult = (BRepOffsetAPI_MakeThickSolid *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  TopTools_ListOfShape *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  BRepOffset_Mode arg5 ;
  BRepOffsetAPI_MakeThickSolid *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = *larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_MakeThickSolid *)new BRepOffsetAPI_MakeThickSolid((TopoDS_Shape const &)*arg1,(TopTools_ListOfShape const &)*arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_MakeThickSolid\n  * wrapname: _wrap_new_BRepOffsetAPI_MakeThickSolid__SWIG_5\n  * fulldecl: BRepOffsetAPI_MakeThickSolid::BRepOffsetAPI_MakeThickSolid(TopoDS_Shape const &,TopTools_ListOfShape const &,Standard_Real const,Standard_Real const,BRepOffset_Mode const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_MakeThickSolid *)0;
  }
}


EXPORT BRepOffsetAPI_MakeThickSolid *_wrap_new_BRepOffsetAPI_MakeThickSolid__SWIG_6 (TopoDS_Shape *larg1, TopTools_ListOfShape *larg2, Standard_Real larg3, Standard_Real larg4) {
  BRepOffsetAPI_MakeThickSolid * lresult = (BRepOffsetAPI_MakeThickSolid *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  TopTools_ListOfShape *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  BRepOffsetAPI_MakeThickSolid *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_MakeThickSolid *)new BRepOffsetAPI_MakeThickSolid((TopoDS_Shape const &)*arg1,(TopTools_ListOfShape const &)*arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_MakeThickSolid\n  * wrapname: _wrap_new_BRepOffsetAPI_MakeThickSolid__SWIG_6\n  * fulldecl: BRepOffsetAPI_MakeThickSolid::BRepOffsetAPI_MakeThickSolid(TopoDS_Shape const &,TopTools_ListOfShape const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_MakeThickSolid *)0;
  }
}


EXPORT void _wrap_BRepOffsetAPI_MakeThickSolid_Build (BRepOffsetAPI_MakeThickSolid *larg1) {
  BRepOffsetAPI_MakeThickSolid *arg1 = (BRepOffsetAPI_MakeThickSolid *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Build();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_MakeThickSolid_Build\n  * wrapname: _wrap_BRepOffsetAPI_MakeThickSolid_Build\n  * fulldecl: void BRepOffsetAPI_MakeThickSolid::Build()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopTools_ListOfShape *_wrap_BRepOffsetAPI_MakeThickSolid_Modified (BRepOffsetAPI_MakeThickSolid *larg1, TopoDS_Shape *larg2) {
  TopTools_ListOfShape * lresult = (TopTools_ListOfShape *)0 ;
  BRepOffsetAPI_MakeThickSolid *arg1 = (BRepOffsetAPI_MakeThickSolid *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopTools_ListOfShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopTools_ListOfShape *) &(arg1)->Modified((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_MakeThickSolid_Modified\n  * wrapname: _wrap_BRepOffsetAPI_MakeThickSolid_Modified\n  * fulldecl: TopTools_ListOfShape const & BRepOffsetAPI_MakeThickSolid::Modified(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopTools_ListOfShape *)0;
  }
}


EXPORT void _wrap_delete_BRepOffsetAPI_MakeThickSolid (BRepOffsetAPI_MakeThickSolid *larg1) {
  BRepOffsetAPI_MakeThickSolid *arg1 = (BRepOffsetAPI_MakeThickSolid *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepOffsetAPI_MakeThickSolid\n  * wrapname: _wrap_delete_BRepOffsetAPI_MakeThickSolid\n  * fulldecl: BRepOffsetAPI_MakeThickSolid::~BRepOffsetAPI_MakeThickSolid()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <BRepOffsetAPI_ThruSections.hxx>
  
EXPORT BRepOffsetAPI_ThruSections *_wrap_new_BRepOffsetAPI_ThruSections__SWIG_0 (bool larg1, bool larg2, Standard_Real larg3) {
  BRepOffsetAPI_ThruSections * lresult = (BRepOffsetAPI_ThruSections *)0 ;
  Standard_Boolean arg1 ;
  Standard_Boolean arg2 ;
  Standard_Real arg3 ;
  BRepOffsetAPI_ThruSections *result = 0 ;
  
  arg1 = (bool)larg1;
  arg2 = (bool)larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_ThruSections *)new BRepOffsetAPI_ThruSections(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_ThruSections\n  * wrapname: _wrap_new_BRepOffsetAPI_ThruSections__SWIG_0\n  * fulldecl: BRepOffsetAPI_ThruSections::BRepOffsetAPI_ThruSections(Standard_Boolean const,Standard_Boolean const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_ThruSections *)0;
  }
}


EXPORT BRepOffsetAPI_ThruSections *_wrap_new_BRepOffsetAPI_ThruSections__SWIG_1 (bool larg1, bool larg2) {
  BRepOffsetAPI_ThruSections * lresult = (BRepOffsetAPI_ThruSections *)0 ;
  Standard_Boolean arg1 ;
  Standard_Boolean arg2 ;
  BRepOffsetAPI_ThruSections *result = 0 ;
  
  arg1 = (bool)larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_ThruSections *)new BRepOffsetAPI_ThruSections(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_ThruSections\n  * wrapname: _wrap_new_BRepOffsetAPI_ThruSections__SWIG_1\n  * fulldecl: BRepOffsetAPI_ThruSections::BRepOffsetAPI_ThruSections(Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_ThruSections *)0;
  }
}


EXPORT BRepOffsetAPI_ThruSections *_wrap_new_BRepOffsetAPI_ThruSections__SWIG_2 (bool larg1) {
  BRepOffsetAPI_ThruSections * lresult = (BRepOffsetAPI_ThruSections *)0 ;
  Standard_Boolean arg1 ;
  BRepOffsetAPI_ThruSections *result = 0 ;
  
  arg1 = (bool)larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_ThruSections *)new BRepOffsetAPI_ThruSections(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_ThruSections\n  * wrapname: _wrap_new_BRepOffsetAPI_ThruSections__SWIG_2\n  * fulldecl: BRepOffsetAPI_ThruSections::BRepOffsetAPI_ThruSections(Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_ThruSections *)0;
  }
}


EXPORT BRepOffsetAPI_ThruSections *_wrap_new_BRepOffsetAPI_ThruSections__SWIG_3 () {
  BRepOffsetAPI_ThruSections * lresult = (BRepOffsetAPI_ThruSections *)0 ;
  BRepOffsetAPI_ThruSections *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_ThruSections *)new BRepOffsetAPI_ThruSections();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_ThruSections\n  * wrapname: _wrap_new_BRepOffsetAPI_ThruSections__SWIG_3\n  * fulldecl: BRepOffsetAPI_ThruSections::BRepOffsetAPI_ThruSections()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_ThruSections *)0;
  }
}


EXPORT void _wrap_BRepOffsetAPI_ThruSections_Init__SWIG_0 (BRepOffsetAPI_ThruSections *larg1, bool larg2, bool larg3, Standard_Real larg4) {
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  Standard_Boolean arg2 ;
  Standard_Boolean arg3 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  arg3 = (bool)larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init(arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_Init\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_Init__SWIG_0\n  * fulldecl: void BRepOffsetAPI_ThruSections::Init(Standard_Boolean const,Standard_Boolean const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_ThruSections_Init__SWIG_1 (BRepOffsetAPI_ThruSections *larg1, bool larg2, bool larg3) {
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  Standard_Boolean arg2 ;
  Standard_Boolean arg3 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init(arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_Init\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_Init__SWIG_1\n  * fulldecl: void BRepOffsetAPI_ThruSections::Init(Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_ThruSections_Init__SWIG_2 (BRepOffsetAPI_ThruSections *larg1, bool larg2) {
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  Standard_Boolean arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_Init\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_Init__SWIG_2\n  * fulldecl: void BRepOffsetAPI_ThruSections::Init(Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_ThruSections_Init__SWIG_3 (BRepOffsetAPI_ThruSections *larg1) {
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_Init\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_Init__SWIG_3\n  * fulldecl: void BRepOffsetAPI_ThruSections::Init()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_ThruSections_AddWire (BRepOffsetAPI_ThruSections *larg1, TopoDS_Wire *larg2) {
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  TopoDS_Wire *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->AddWire((TopoDS_Wire const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_AddWire\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_AddWire\n  * fulldecl: void BRepOffsetAPI_ThruSections::AddWire(TopoDS_Wire const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_ThruSections_AddVertex (BRepOffsetAPI_ThruSections *larg1, TopoDS_Vertex *larg2) {
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->AddVertex((TopoDS_Vertex const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_AddVertex\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_AddVertex\n  * fulldecl: void BRepOffsetAPI_ThruSections::AddVertex(TopoDS_Vertex const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_ThruSections_CheckCompatibility__SWIG_0 (BRepOffsetAPI_ThruSections *larg1, bool larg2) {
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  Standard_Boolean arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->CheckCompatibility(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_CheckCompatibility\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_CheckCompatibility__SWIG_0\n  * fulldecl: void BRepOffsetAPI_ThruSections::CheckCompatibility(Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_ThruSections_CheckCompatibility__SWIG_1 (BRepOffsetAPI_ThruSections *larg1) {
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->CheckCompatibility();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_CheckCompatibility\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_CheckCompatibility__SWIG_1\n  * fulldecl: void BRepOffsetAPI_ThruSections::CheckCompatibility()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_ThruSections_SetSmoothing (BRepOffsetAPI_ThruSections *larg1, bool larg2) {
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  Standard_Boolean arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetSmoothing(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_SetSmoothing\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_SetSmoothing\n  * fulldecl: void BRepOffsetAPI_ThruSections::SetSmoothing(Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_ThruSections_SetParType (BRepOffsetAPI_ThruSections *larg1, Approx_ParametrizationType const *larg2) {
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  Approx_ParametrizationType arg2 ;
  
  arg1 = larg1;
  arg2 = *larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetParType(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_SetParType\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_SetParType\n  * fulldecl: void BRepOffsetAPI_ThruSections::SetParType(Approx_ParametrizationType const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_ThruSections_SetContinuity (BRepOffsetAPI_ThruSections *larg1, GeomAbs_Shape larg2) {
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  GeomAbs_Shape arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetContinuity(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_SetContinuity\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_SetContinuity\n  * fulldecl: void BRepOffsetAPI_ThruSections::SetContinuity(GeomAbs_Shape const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_ThruSections_SetCriteriumWeight (BRepOffsetAPI_ThruSections *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4) {
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetCriteriumWeight(arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_SetCriteriumWeight\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_SetCriteriumWeight\n  * fulldecl: void BRepOffsetAPI_ThruSections::SetCriteriumWeight(Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_ThruSections_SetMaxDegree (BRepOffsetAPI_ThruSections *larg1, Standard_Integer larg2) {
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  Standard_Integer arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetMaxDegree(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_SetMaxDegree\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_SetMaxDegree\n  * fulldecl: void BRepOffsetAPI_ThruSections::SetMaxDegree(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Approx_ParametrizationType *_wrap_BRepOffsetAPI_ThruSections_ParType (BRepOffsetAPI_ThruSections *larg1) {
  Approx_ParametrizationType * lresult = (Approx_ParametrizationType *)0 ;
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  Approx_ParametrizationType result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((BRepOffsetAPI_ThruSections const *)arg1)->ParType();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_ParType\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_ParType\n  * fulldecl: Approx_ParametrizationType BRepOffsetAPI_ThruSections::ParType() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Approx_ParametrizationType(result);
    return lresult;
  } catch (...) {
    return (Approx_ParametrizationType *)0;
  }
}


EXPORT GeomAbs_Shape _wrap_BRepOffsetAPI_ThruSections_Continuity (BRepOffsetAPI_ThruSections *larg1) {
  GeomAbs_Shape lresult = (GeomAbs_Shape)0 ;
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  GeomAbs_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAbs_Shape)((BRepOffsetAPI_ThruSections const *)arg1)->Continuity();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_Continuity\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_Continuity\n  * fulldecl: GeomAbs_Shape BRepOffsetAPI_ThruSections::Continuity() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAbs_Shape)0;
  }
}


EXPORT Standard_Integer _wrap_BRepOffsetAPI_ThruSections_MaxDegree (BRepOffsetAPI_ThruSections *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((BRepOffsetAPI_ThruSections const *)arg1)->MaxDegree();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_MaxDegree\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_MaxDegree\n  * fulldecl: Standard_Integer BRepOffsetAPI_ThruSections::MaxDegree() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT bool _wrap_BRepOffsetAPI_ThruSections_UseSmoothing (BRepOffsetAPI_ThruSections *larg1) {
  bool lresult = (bool)0 ;
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepOffsetAPI_ThruSections const *)arg1)->UseSmoothing();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_UseSmoothing\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_UseSmoothing\n  * fulldecl: Standard_Boolean BRepOffsetAPI_ThruSections::UseSmoothing() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_BRepOffsetAPI_ThruSections_CriteriumWeight (BRepOffsetAPI_ThruSections *larg1, Standard_Real *larg2, Standard_Real *larg3, Standard_Real *larg4) {
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRepOffsetAPI_ThruSections const *)arg1)->CriteriumWeight(*arg2,*arg3,*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_CriteriumWeight\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_CriteriumWeight\n  * fulldecl: void BRepOffsetAPI_ThruSections::CriteriumWeight(Standard_Real &,Standard_Real &,Standard_Real &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopoDS_Shape *_wrap_BRepOffsetAPI_ThruSections_FirstShape (BRepOffsetAPI_ThruSections *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &((BRepOffsetAPI_ThruSections const *)arg1)->FirstShape();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_FirstShape\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_FirstShape\n  * fulldecl: TopoDS_Shape const & BRepOffsetAPI_ThruSections::FirstShape() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT TopoDS_Shape *_wrap_BRepOffsetAPI_ThruSections_LastShape (BRepOffsetAPI_ThruSections *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &((BRepOffsetAPI_ThruSections const *)arg1)->LastShape();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_LastShape\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_LastShape\n  * fulldecl: TopoDS_Shape const & BRepOffsetAPI_ThruSections::LastShape() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT TopoDS_Shape *_wrap_BRepOffsetAPI_ThruSections_GeneratedFace (BRepOffsetAPI_ThruSections *larg1, TopoDS_Shape *larg2) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopoDS_Shape result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((BRepOffsetAPI_ThruSections const *)arg1)->GeneratedFace((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_GeneratedFace\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_GeneratedFace\n  * fulldecl: TopoDS_Shape BRepOffsetAPI_ThruSections::GeneratedFace(TopoDS_Shape const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new TopoDS_Shape(result);
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT void _wrap_delete_BRepOffsetAPI_ThruSections (BRepOffsetAPI_ThruSections *larg1) {
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepOffsetAPI_ThruSections\n  * wrapname: _wrap_delete_BRepOffsetAPI_ThruSections\n  * fulldecl: BRepOffsetAPI_ThruSections::~BRepOffsetAPI_ThruSections()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <BRepPrimAPI_MakeBox.hxx>
#include <BRepPrimAPI_MakeCone.hxx>
#include <BRepPrimAPI_MakeBox.hxx>
#include <BRepPrimAPI_MakeTorus.hxx>
#include <BRepPrimAPI_MakeCylinder.hxx>
#include <BRepPrimAPI_MakeSphere.hxx>
#include <BRepPrimAPI_MakePrism.hxx>
#include <BRepPrimAPI_MakeRevol.hxx>
#include <BRepOffsetAPI_MakePipe.hxx>

EXPORT BRepPrimAPI_MakeBox *_wrap_new_BRepPrimAPI_MakeBox (gp_Pnt *larg1, gp_Pnt *larg2) {
  BRepPrimAPI_MakeBox * lresult = (BRepPrimAPI_MakeBox *)0 ;
  gp_Pnt *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  BRepPrimAPI_MakeBox *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakeBox *)new BRepPrimAPI_MakeBox((gp_Pnt const &)*arg1,(gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakeBox\n  * wrapname: _wrap_new_BRepPrimAPI_MakeBox\n  * fulldecl: BRepPrimAPI_MakeBox::BRepPrimAPI_MakeBox(gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakeBox *)0;
  }
}


EXPORT void _wrap_delete_BRepPrimAPI_MakeBox (BRepPrimAPI_MakeBox *larg1) {
  BRepPrimAPI_MakeBox *arg1 = (BRepPrimAPI_MakeBox *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepPrimAPI_MakeBox\n  * wrapname: _wrap_delete_BRepPrimAPI_MakeBox\n  * fulldecl: BRepPrimAPI_MakeBox::~BRepPrimAPI_MakeBox()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepPrimAPI_MakeCone *_wrap_new_BRepPrimAPI_MakeCone (gp_Ax2 *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5) {
  BRepPrimAPI_MakeCone * lresult = (BRepPrimAPI_MakeCone *)0 ;
  gp_Ax2 *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  BRepPrimAPI_MakeCone *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakeCone *)new BRepPrimAPI_MakeCone((gp_Ax2 const &)*arg1,arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakeCone\n  * wrapname: _wrap_new_BRepPrimAPI_MakeCone\n  * fulldecl: BRepPrimAPI_MakeCone::BRepPrimAPI_MakeCone(gp_Ax2 const &,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakeCone *)0;
  }
}


EXPORT void _wrap_delete_BRepPrimAPI_MakeCone (BRepPrimAPI_MakeCone *larg1) {
  BRepPrimAPI_MakeCone *arg1 = (BRepPrimAPI_MakeCone *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepPrimAPI_MakeCone\n  * wrapname: _wrap_delete_BRepPrimAPI_MakeCone\n  * fulldecl: BRepPrimAPI_MakeCone::~BRepPrimAPI_MakeCone()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepPrimAPI_MakeCylinder *_wrap_new_BRepPrimAPI_MakeCylinder__SWIG_0 (Standard_Real larg1, Standard_Real larg2) {
  BRepPrimAPI_MakeCylinder * lresult = (BRepPrimAPI_MakeCylinder *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  BRepPrimAPI_MakeCylinder *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakeCylinder *)new BRepPrimAPI_MakeCylinder(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakeCylinder\n  * wrapname: _wrap_new_BRepPrimAPI_MakeCylinder__SWIG_0\n  * fulldecl: BRepPrimAPI_MakeCylinder::BRepPrimAPI_MakeCylinder(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakeCylinder *)0;
  }
}


EXPORT BRepPrimAPI_MakeCylinder *_wrap_new_BRepPrimAPI_MakeCylinder__SWIG_1 (Standard_Real larg1, Standard_Real larg2, Standard_Real larg3) {
  BRepPrimAPI_MakeCylinder * lresult = (BRepPrimAPI_MakeCylinder *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  BRepPrimAPI_MakeCylinder *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakeCylinder *)new BRepPrimAPI_MakeCylinder(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakeCylinder\n  * wrapname: _wrap_new_BRepPrimAPI_MakeCylinder__SWIG_1\n  * fulldecl: BRepPrimAPI_MakeCylinder::BRepPrimAPI_MakeCylinder(Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakeCylinder *)0;
  }
}


EXPORT BRepPrimAPI_MakeCylinder *_wrap_new_BRepPrimAPI_MakeCylinder__SWIG_2 (gp_Ax2 *larg1, Standard_Real larg2, Standard_Real larg3) {
  BRepPrimAPI_MakeCylinder * lresult = (BRepPrimAPI_MakeCylinder *)0 ;
  gp_Ax2 *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  BRepPrimAPI_MakeCylinder *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakeCylinder *)new BRepPrimAPI_MakeCylinder((gp_Ax2 const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakeCylinder\n  * wrapname: _wrap_new_BRepPrimAPI_MakeCylinder__SWIG_2\n  * fulldecl: BRepPrimAPI_MakeCylinder::BRepPrimAPI_MakeCylinder(gp_Ax2 const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakeCylinder *)0;
  }
}


EXPORT BRepPrimAPI_MakeCylinder *_wrap_new_BRepPrimAPI_MakeCylinder__SWIG_3 (gp_Ax2 *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4) {
  BRepPrimAPI_MakeCylinder * lresult = (BRepPrimAPI_MakeCylinder *)0 ;
  gp_Ax2 *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  BRepPrimAPI_MakeCylinder *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakeCylinder *)new BRepPrimAPI_MakeCylinder((gp_Ax2 const &)*arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakeCylinder\n  * wrapname: _wrap_new_BRepPrimAPI_MakeCylinder__SWIG_3\n  * fulldecl: BRepPrimAPI_MakeCylinder::BRepPrimAPI_MakeCylinder(gp_Ax2 const &,Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakeCylinder *)0;
  }
}


EXPORT void _wrap_delete_BRepPrimAPI_MakeCylinder (BRepPrimAPI_MakeCylinder *larg1) {
  BRepPrimAPI_MakeCylinder *arg1 = (BRepPrimAPI_MakeCylinder *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepPrimAPI_MakeCylinder\n  * wrapname: _wrap_delete_BRepPrimAPI_MakeCylinder\n  * fulldecl: BRepPrimAPI_MakeCylinder::~BRepPrimAPI_MakeCylinder()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepPrimAPI_MakeTorus *_wrap_new_BRepPrimAPI_MakeTorus__SWIG_0 (gp_Ax2 *larg1, Standard_Real larg2, Standard_Real larg3) {
  BRepPrimAPI_MakeTorus * lresult = (BRepPrimAPI_MakeTorus *)0 ;
  gp_Ax2 *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  BRepPrimAPI_MakeTorus *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakeTorus *)new BRepPrimAPI_MakeTorus((gp_Ax2 const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakeTorus\n  * wrapname: _wrap_new_BRepPrimAPI_MakeTorus__SWIG_0\n  * fulldecl: BRepPrimAPI_MakeTorus::BRepPrimAPI_MakeTorus(gp_Ax2 const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakeTorus *)0;
  }
}


EXPORT BRepPrimAPI_MakeTorus *_wrap_new_BRepPrimAPI_MakeTorus__SWIG_1 (gp_Ax2 *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5, Standard_Real larg6) {
  BRepPrimAPI_MakeTorus * lresult = (BRepPrimAPI_MakeTorus *)0 ;
  gp_Ax2 *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  Standard_Real arg6 ;
  BRepPrimAPI_MakeTorus *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakeTorus *)new BRepPrimAPI_MakeTorus((gp_Ax2 const &)*arg1,arg2,arg3,arg4,arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakeTorus\n  * wrapname: _wrap_new_BRepPrimAPI_MakeTorus__SWIG_1\n  * fulldecl: BRepPrimAPI_MakeTorus::BRepPrimAPI_MakeTorus(gp_Ax2 const &,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakeTorus *)0;
  }
}


EXPORT void _wrap_delete_BRepPrimAPI_MakeTorus (BRepPrimAPI_MakeTorus *larg1) {
  BRepPrimAPI_MakeTorus *arg1 = (BRepPrimAPI_MakeTorus *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepPrimAPI_MakeTorus\n  * wrapname: _wrap_delete_BRepPrimAPI_MakeTorus\n  * fulldecl: BRepPrimAPI_MakeTorus::~BRepPrimAPI_MakeTorus()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepPrimAPI_MakeSphere *_wrap_new_BRepPrimAPI_MakeSphere__SWIG_0 (gp_Pnt *larg1, Standard_Real larg2) {
  BRepPrimAPI_MakeSphere * lresult = (BRepPrimAPI_MakeSphere *)0 ;
  gp_Pnt *arg1 = 0 ;
  Standard_Real arg2 ;
  BRepPrimAPI_MakeSphere *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakeSphere *)new BRepPrimAPI_MakeSphere((gp_Pnt const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakeSphere\n  * wrapname: _wrap_new_BRepPrimAPI_MakeSphere__SWIG_0\n  * fulldecl: BRepPrimAPI_MakeSphere::BRepPrimAPI_MakeSphere(gp_Pnt const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakeSphere *)0;
  }
}


EXPORT BRepPrimAPI_MakeSphere *_wrap_new_BRepPrimAPI_MakeSphere__SWIG_1 (gp_Ax2 *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5) {
  BRepPrimAPI_MakeSphere * lresult = (BRepPrimAPI_MakeSphere *)0 ;
  gp_Ax2 *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  BRepPrimAPI_MakeSphere *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakeSphere *)new BRepPrimAPI_MakeSphere((gp_Ax2 const &)*arg1,arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakeSphere\n  * wrapname: _wrap_new_BRepPrimAPI_MakeSphere__SWIG_1\n  * fulldecl: BRepPrimAPI_MakeSphere::BRepPrimAPI_MakeSphere(gp_Ax2 const &,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakeSphere *)0;
  }
}


EXPORT void _wrap_delete_BRepPrimAPI_MakeSphere (BRepPrimAPI_MakeSphere *larg1) {
  BRepPrimAPI_MakeSphere *arg1 = (BRepPrimAPI_MakeSphere *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepPrimAPI_MakeSphere\n  * wrapname: _wrap_delete_BRepPrimAPI_MakeSphere\n  * fulldecl: BRepPrimAPI_MakeSphere::~BRepPrimAPI_MakeSphere()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_BRepPrimAPI_MakeSweep (BRepPrimAPI_MakeSweep *larg1) {
  BRepPrimAPI_MakeSweep *arg1 = (BRepPrimAPI_MakeSweep *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepPrimAPI_MakeSweep\n  * wrapname: _wrap_delete_BRepPrimAPI_MakeSweep\n  * fulldecl: BRepPrimAPI_MakeSweep::~BRepPrimAPI_MakeSweep()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepPrimAPI_MakePrism *_wrap_new_BRepPrimAPI_MakePrism__SWIG_0 (TopoDS_Shape *larg1, gp_Vec *larg2, bool larg3, bool larg4) {
  BRepPrimAPI_MakePrism * lresult = (BRepPrimAPI_MakePrism *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  gp_Vec *arg2 = 0 ;
  Standard_Boolean arg3 ;
  Standard_Boolean arg4 ;
  BRepPrimAPI_MakePrism *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakePrism *)new BRepPrimAPI_MakePrism((TopoDS_Shape const &)*arg1,(gp_Vec const &)*arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakePrism\n  * wrapname: _wrap_new_BRepPrimAPI_MakePrism__SWIG_0\n  * fulldecl: BRepPrimAPI_MakePrism::BRepPrimAPI_MakePrism(TopoDS_Shape const &,gp_Vec const &,Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakePrism *)0;
  }
}


EXPORT BRepPrimAPI_MakePrism *_wrap_new_BRepPrimAPI_MakePrism__SWIG_1 (TopoDS_Shape *larg1, gp_Vec *larg2, bool larg3) {
  BRepPrimAPI_MakePrism * lresult = (BRepPrimAPI_MakePrism *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  gp_Vec *arg2 = 0 ;
  Standard_Boolean arg3 ;
  BRepPrimAPI_MakePrism *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakePrism *)new BRepPrimAPI_MakePrism((TopoDS_Shape const &)*arg1,(gp_Vec const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakePrism\n  * wrapname: _wrap_new_BRepPrimAPI_MakePrism__SWIG_1\n  * fulldecl: BRepPrimAPI_MakePrism::BRepPrimAPI_MakePrism(TopoDS_Shape const &,gp_Vec const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakePrism *)0;
  }
}


EXPORT BRepPrimAPI_MakePrism *_wrap_new_BRepPrimAPI_MakePrism__SWIG_2 (TopoDS_Shape *larg1, gp_Vec *larg2) {
  BRepPrimAPI_MakePrism * lresult = (BRepPrimAPI_MakePrism *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  gp_Vec *arg2 = 0 ;
  BRepPrimAPI_MakePrism *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakePrism *)new BRepPrimAPI_MakePrism((TopoDS_Shape const &)*arg1,(gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakePrism\n  * wrapname: _wrap_new_BRepPrimAPI_MakePrism__SWIG_2\n  * fulldecl: BRepPrimAPI_MakePrism::BRepPrimAPI_MakePrism(TopoDS_Shape const &,gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakePrism *)0;
  }
}


EXPORT void _wrap_delete_BRepPrimAPI_MakePrism (BRepPrimAPI_MakePrism *larg1) {
  BRepPrimAPI_MakePrism *arg1 = (BRepPrimAPI_MakePrism *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepPrimAPI_MakePrism\n  * wrapname: _wrap_delete_BRepPrimAPI_MakePrism\n  * fulldecl: BRepPrimAPI_MakePrism::~BRepPrimAPI_MakePrism()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepPrimAPI_MakeRevol *_wrap_new_BRepPrimAPI_MakeRevol__SWIG_0 (TopoDS_Shape *larg1, gp_Ax1 *larg2, Standard_Real larg3, bool larg4) {
  BRepPrimAPI_MakeRevol * lresult = (BRepPrimAPI_MakeRevol *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean arg4 ;
  BRepPrimAPI_MakeRevol *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakeRevol *)new BRepPrimAPI_MakeRevol((TopoDS_Shape const &)*arg1,(gp_Ax1 const &)*arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakeRevol\n  * wrapname: _wrap_new_BRepPrimAPI_MakeRevol__SWIG_0\n  * fulldecl: BRepPrimAPI_MakeRevol::BRepPrimAPI_MakeRevol(TopoDS_Shape const &,gp_Ax1 const &,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakeRevol *)0;
  }
}


EXPORT BRepPrimAPI_MakeRevol *_wrap_new_BRepPrimAPI_MakeRevol__SWIG_1 (TopoDS_Shape *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  BRepPrimAPI_MakeRevol * lresult = (BRepPrimAPI_MakeRevol *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  BRepPrimAPI_MakeRevol *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakeRevol *)new BRepPrimAPI_MakeRevol((TopoDS_Shape const &)*arg1,(gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakeRevol\n  * wrapname: _wrap_new_BRepPrimAPI_MakeRevol__SWIG_1\n  * fulldecl: BRepPrimAPI_MakeRevol::BRepPrimAPI_MakeRevol(TopoDS_Shape const &,gp_Ax1 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakeRevol *)0;
  }
}


EXPORT BRepPrimAPI_MakeRevol *_wrap_new_BRepPrimAPI_MakeRevol__SWIG_2 (TopoDS_Shape *larg1, gp_Ax1 *larg2, bool larg3) {
  BRepPrimAPI_MakeRevol * lresult = (BRepPrimAPI_MakeRevol *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Boolean arg3 ;
  BRepPrimAPI_MakeRevol *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakeRevol *)new BRepPrimAPI_MakeRevol((TopoDS_Shape const &)*arg1,(gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakeRevol\n  * wrapname: _wrap_new_BRepPrimAPI_MakeRevol__SWIG_2\n  * fulldecl: BRepPrimAPI_MakeRevol::BRepPrimAPI_MakeRevol(TopoDS_Shape const &,gp_Ax1 const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakeRevol *)0;
  }
}


EXPORT BRepPrimAPI_MakeRevol *_wrap_new_BRepPrimAPI_MakeRevol__SWIG_3 (TopoDS_Shape *larg1, gp_Ax1 *larg2) {
  BRepPrimAPI_MakeRevol * lresult = (BRepPrimAPI_MakeRevol *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  gp_Ax1 *arg2 = 0 ;
  BRepPrimAPI_MakeRevol *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakeRevol *)new BRepPrimAPI_MakeRevol((TopoDS_Shape const &)*arg1,(gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakeRevol\n  * wrapname: _wrap_new_BRepPrimAPI_MakeRevol__SWIG_3\n  * fulldecl: BRepPrimAPI_MakeRevol::BRepPrimAPI_MakeRevol(TopoDS_Shape const &,gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakeRevol *)0;
  }
}


EXPORT void _wrap_delete_BRepPrimAPI_MakeRevol (BRepPrimAPI_MakeRevol *larg1) {
  BRepPrimAPI_MakeRevol *arg1 = (BRepPrimAPI_MakeRevol *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepPrimAPI_MakeRevol\n  * wrapname: _wrap_delete_BRepPrimAPI_MakeRevol\n  * fulldecl: BRepPrimAPI_MakeRevol::~BRepPrimAPI_MakeRevol()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepOffsetAPI_MakePipe *_wrap_new_BRepOffsetAPI_MakePipe (TopoDS_Wire *larg1, TopoDS_Shape *larg2) {
  BRepOffsetAPI_MakePipe * lresult = (BRepOffsetAPI_MakePipe *)0 ;
  TopoDS_Wire *arg1 = 0 ;
  TopoDS_Shape *arg2 = 0 ;
  BRepOffsetAPI_MakePipe *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_MakePipe *)new BRepOffsetAPI_MakePipe((TopoDS_Wire const &)*arg1,(TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_MakePipe\n  * wrapname: _wrap_new_BRepOffsetAPI_MakePipe\n  * fulldecl: BRepOffsetAPI_MakePipe::BRepOffsetAPI_MakePipe(TopoDS_Wire const &,TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_MakePipe *)0;
  }
}


EXPORT void _wrap_delete_BRepOffsetAPI_MakePipe (BRepOffsetAPI_MakePipe *larg1) {
  BRepOffsetAPI_MakePipe *arg1 = (BRepOffsetAPI_MakePipe *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepOffsetAPI_MakePipe\n  * wrapname: _wrap_delete_BRepOffsetAPI_MakePipe\n  * fulldecl: BRepOffsetAPI_MakePipe::~BRepOffsetAPI_MakePipe()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <BRepAlgoAPI_Algo.hxx>
#include <BRepAlgoAPI_BooleanOperation.hxx>
#include <BRepAlgoAPI_Fuse.hxx>
#include <BRepAlgoAPI_Common.hxx>
#include <BRepAlgoAPI_Cut.hxx>
#include <BRepAlgoAPI_Section.hxx>
     
EXPORT TopTools_ListOfShape *_wrap_BRepAlgoAPI_BooleanOperation_Modified (BRepAlgoAPI_BooleanOperation *larg1, TopoDS_Shape *larg2) {
  TopTools_ListOfShape * lresult = (TopTools_ListOfShape *)0 ;
  BRepAlgoAPI_BooleanOperation *arg1 = (BRepAlgoAPI_BooleanOperation *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopTools_ListOfShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopTools_ListOfShape *) &(arg1)->Modified((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepAlgoAPI_BooleanOperation_Modified\n  * wrapname: _wrap_BRepAlgoAPI_BooleanOperation_Modified\n  * fulldecl: TopTools_ListOfShape const & BRepAlgoAPI_BooleanOperation::Modified(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopTools_ListOfShape *)0;
  }
}


EXPORT bool _wrap_BRepAlgoAPI_BooleanOperation_IsDeleted (BRepAlgoAPI_BooleanOperation *larg1, TopoDS_Shape *larg2) {
  bool lresult = (bool)0 ;
  BRepAlgoAPI_BooleanOperation *arg1 = (BRepAlgoAPI_BooleanOperation *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->IsDeleted((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepAlgoAPI_BooleanOperation_IsDeleted\n  * wrapname: _wrap_BRepAlgoAPI_BooleanOperation_IsDeleted\n  * fulldecl: Standard_Boolean BRepAlgoAPI_BooleanOperation::IsDeleted(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT TopTools_ListOfShape *_wrap_BRepAlgoAPI_BooleanOperation_Generated (BRepAlgoAPI_BooleanOperation *larg1, TopoDS_Shape *larg2) {
  TopTools_ListOfShape * lresult = (TopTools_ListOfShape *)0 ;
  BRepAlgoAPI_BooleanOperation *arg1 = (BRepAlgoAPI_BooleanOperation *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopTools_ListOfShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopTools_ListOfShape *) &(arg1)->Generated((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepAlgoAPI_BooleanOperation_Generated\n  * wrapname: _wrap_BRepAlgoAPI_BooleanOperation_Generated\n  * fulldecl: TopTools_ListOfShape const & BRepAlgoAPI_BooleanOperation::Generated(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopTools_ListOfShape *)0;
  }
}


EXPORT bool _wrap_BRepAlgoAPI_BooleanOperation_HasModified (BRepAlgoAPI_BooleanOperation *larg1) {
  bool lresult = (bool)0 ;
  BRepAlgoAPI_BooleanOperation *arg1 = (BRepAlgoAPI_BooleanOperation *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepAlgoAPI_BooleanOperation const *)arg1)->HasModified();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepAlgoAPI_BooleanOperation_HasModified\n  * wrapname: _wrap_BRepAlgoAPI_BooleanOperation_HasModified\n  * fulldecl: Standard_Boolean BRepAlgoAPI_BooleanOperation::HasModified() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepAlgoAPI_BooleanOperation_HasGenerated (BRepAlgoAPI_BooleanOperation *larg1) {
  bool lresult = (bool)0 ;
  BRepAlgoAPI_BooleanOperation *arg1 = (BRepAlgoAPI_BooleanOperation *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepAlgoAPI_BooleanOperation const *)arg1)->HasGenerated();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepAlgoAPI_BooleanOperation_HasGenerated\n  * wrapname: _wrap_BRepAlgoAPI_BooleanOperation_HasGenerated\n  * fulldecl: Standard_Boolean BRepAlgoAPI_BooleanOperation::HasGenerated() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepAlgoAPI_BooleanOperation_HasDeleted (BRepAlgoAPI_BooleanOperation *larg1) {
  bool lresult = (bool)0 ;
  BRepAlgoAPI_BooleanOperation *arg1 = (BRepAlgoAPI_BooleanOperation *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepAlgoAPI_BooleanOperation const *)arg1)->HasDeleted();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepAlgoAPI_BooleanOperation_HasDeleted\n  * wrapname: _wrap_BRepAlgoAPI_BooleanOperation_HasDeleted\n  * fulldecl: Standard_Boolean BRepAlgoAPI_BooleanOperation::HasDeleted() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_delete_BRepAlgoAPI_BooleanOperation (BRepAlgoAPI_BooleanOperation *larg1) {
  BRepAlgoAPI_BooleanOperation *arg1 = (BRepAlgoAPI_BooleanOperation *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepAlgoAPI_BooleanOperation\n  * wrapname: _wrap_delete_BRepAlgoAPI_BooleanOperation\n  * fulldecl: BRepAlgoAPI_BooleanOperation::~BRepAlgoAPI_BooleanOperation()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepAlgoAPI_Fuse *_wrap_new_BRepAlgoAPI_Fuse (TopoDS_Shape *larg1, TopoDS_Shape *larg2) {
  BRepAlgoAPI_Fuse * lresult = (BRepAlgoAPI_Fuse *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  TopoDS_Shape *arg2 = 0 ;
  BRepAlgoAPI_Fuse *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepAlgoAPI_Fuse *)new BRepAlgoAPI_Fuse((TopoDS_Shape const &)*arg1,(TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepAlgoAPI_Fuse\n  * wrapname: _wrap_new_BRepAlgoAPI_Fuse\n  * fulldecl: BRepAlgoAPI_Fuse::BRepAlgoAPI_Fuse(TopoDS_Shape const &,TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepAlgoAPI_Fuse *)0;
  }
}


EXPORT void _wrap_delete_BRepAlgoAPI_Fuse (BRepAlgoAPI_Fuse *larg1) {
  BRepAlgoAPI_Fuse *arg1 = (BRepAlgoAPI_Fuse *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepAlgoAPI_Fuse\n  * wrapname: _wrap_delete_BRepAlgoAPI_Fuse\n  * fulldecl: BRepAlgoAPI_Fuse::~BRepAlgoAPI_Fuse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepAlgoAPI_Common *_wrap_new_BRepAlgoAPI_Common (TopoDS_Shape *larg1, TopoDS_Shape *larg2) {
  BRepAlgoAPI_Common * lresult = (BRepAlgoAPI_Common *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  TopoDS_Shape *arg2 = 0 ;
  BRepAlgoAPI_Common *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepAlgoAPI_Common *)new BRepAlgoAPI_Common((TopoDS_Shape const &)*arg1,(TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepAlgoAPI_Common\n  * wrapname: _wrap_new_BRepAlgoAPI_Common\n  * fulldecl: BRepAlgoAPI_Common::BRepAlgoAPI_Common(TopoDS_Shape const &,TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepAlgoAPI_Common *)0;
  }
}


EXPORT void _wrap_delete_BRepAlgoAPI_Common (BRepAlgoAPI_Common *larg1) {
  BRepAlgoAPI_Common *arg1 = (BRepAlgoAPI_Common *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepAlgoAPI_Common\n  * wrapname: _wrap_delete_BRepAlgoAPI_Common\n  * fulldecl: BRepAlgoAPI_Common::~BRepAlgoAPI_Common()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepAlgoAPI_Cut *_wrap_new_BRepAlgoAPI_Cut (TopoDS_Shape *larg1, TopoDS_Shape *larg2) {
  BRepAlgoAPI_Cut * lresult = (BRepAlgoAPI_Cut *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  TopoDS_Shape *arg2 = 0 ;
  BRepAlgoAPI_Cut *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepAlgoAPI_Cut *)new BRepAlgoAPI_Cut((TopoDS_Shape const &)*arg1,(TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepAlgoAPI_Cut\n  * wrapname: _wrap_new_BRepAlgoAPI_Cut\n  * fulldecl: BRepAlgoAPI_Cut::BRepAlgoAPI_Cut(TopoDS_Shape const &,TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepAlgoAPI_Cut *)0;
  }
}


EXPORT void _wrap_delete_BRepAlgoAPI_Cut (BRepAlgoAPI_Cut *larg1) {
  BRepAlgoAPI_Cut *arg1 = (BRepAlgoAPI_Cut *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepAlgoAPI_Cut\n  * wrapname: _wrap_delete_BRepAlgoAPI_Cut\n  * fulldecl: BRepAlgoAPI_Cut::~BRepAlgoAPI_Cut()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepAlgoAPI_Section *_wrap_new_BRepAlgoAPI_Section (TopoDS_Shape *larg1, TopoDS_Shape *larg2) {
  BRepAlgoAPI_Section * lresult = (BRepAlgoAPI_Section *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  TopoDS_Shape *arg2 = 0 ;
  BRepAlgoAPI_Section *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepAlgoAPI_Section *)new BRepAlgoAPI_Section((TopoDS_Shape const &)*arg1,(TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepAlgoAPI_Section\n  * wrapname: _wrap_new_BRepAlgoAPI_Section\n  * fulldecl: BRepAlgoAPI_Section::BRepAlgoAPI_Section(TopoDS_Shape const &,TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepAlgoAPI_Section *)0;
  }
}


EXPORT void _wrap_delete_BRepAlgoAPI_Section (BRepAlgoAPI_Section *larg1) {
  BRepAlgoAPI_Section *arg1 = (BRepAlgoAPI_Section *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepAlgoAPI_Section\n  * wrapname: _wrap_delete_BRepAlgoAPI_Section\n  * fulldecl: BRepAlgoAPI_Section::~BRepAlgoAPI_Section()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopoDS_Shape *_wrap_BRepAlgoAPI_Algo_Shape (BRepAlgoAPI_Algo *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  BRepAlgoAPI_Algo *arg1 = (BRepAlgoAPI_Algo *) 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &(arg1)->Shape();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepAlgoAPI_Algo_Shape\n  * wrapname: _wrap_BRepAlgoAPI_Algo_Shape\n  * fulldecl: TopoDS_Shape const & BRepAlgoAPI_Algo::Shape()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}



#include <Poly_Triangulation.hxx>
  
SWIGINTERN void Handle_Poly_Triangulation_Delete(Handle_Poly_Triangulation *self){
    self->~Handle_Poly_Triangulation();
  }
EXPORT void _wrap_Poly_Triangulation_Delete (Handle_Poly_Triangulation *larg1) {
  Handle_Poly_Triangulation *arg1 = (Handle_Poly_Triangulation *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Poly_Triangulation_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Triangulation_Delete\n  * wrapname: _wrap_Poly_Triangulation_Delete\n  * fulldecl: void Handle_Poly_Triangulation::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Poly_Triangulation_Deflection__SWIG_0(Handle_Poly_Triangulation const *self){
    return (*self)->Deflection();
  }
EXPORT Standard_Real _wrap_Poly_Triangulation_Deflection__SWIG_0 (Handle_Poly_Triangulation *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Poly_Triangulation *arg1 = (Handle_Poly_Triangulation *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Poly_Triangulation_Deflection__SWIG_0((Handle_Poly_Triangulation const *)arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Triangulation_Deflection\n  * wrapname: _wrap_Poly_Triangulation_Deflection__SWIG_0\n  * fulldecl: Standard_Real Handle_Poly_Triangulation::Deflection() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN void Handle_Poly_Triangulation_Deflection__SWIG_1(Handle_Poly_Triangulation *self,Standard_Real const D){
    return (*self)->Deflection(D);
  }
EXPORT void _wrap_Poly_Triangulation_Deflection__SWIG_1 (Handle_Poly_Triangulation *larg1, Standard_Real larg2) {
  Handle_Poly_Triangulation *arg1 = (Handle_Poly_Triangulation *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Poly_Triangulation_Deflection__SWIG_1(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Triangulation_Deflection\n  * wrapname: _wrap_Poly_Triangulation_Deflection__SWIG_1\n  * fulldecl: void Handle_Poly_Triangulation::Deflection(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Poly_Triangulation_RemoveUVNodes(Handle_Poly_Triangulation *self){
    return (*self)->RemoveUVNodes();
  }
EXPORT void _wrap_Poly_Triangulation_RemoveUVNodes (Handle_Poly_Triangulation *larg1) {
  Handle_Poly_Triangulation *arg1 = (Handle_Poly_Triangulation *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Poly_Triangulation_RemoveUVNodes(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Triangulation_RemoveUVNodes\n  * wrapname: _wrap_Poly_Triangulation_RemoveUVNodes\n  * fulldecl: void Handle_Poly_Triangulation::RemoveUVNodes()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Integer Handle_Poly_Triangulation_NbNodes(Handle_Poly_Triangulation const *self){
    return (*self)->NbNodes();
  }
EXPORT Standard_Integer _wrap_Poly_Triangulation_NbNodes (Handle_Poly_Triangulation *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Poly_Triangulation *arg1 = (Handle_Poly_Triangulation *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Poly_Triangulation_NbNodes((Handle_Poly_Triangulation const *)arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Triangulation_NbNodes\n  * wrapname: _wrap_Poly_Triangulation_NbNodes\n  * fulldecl: Standard_Integer Handle_Poly_Triangulation::NbNodes() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Poly_Triangulation_NbTriangles(Handle_Poly_Triangulation const *self){
    return (*self)->NbTriangles();
  }
EXPORT Standard_Integer _wrap_Poly_Triangulation_NbTriangles (Handle_Poly_Triangulation *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Poly_Triangulation *arg1 = (Handle_Poly_Triangulation *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Poly_Triangulation_NbTriangles((Handle_Poly_Triangulation const *)arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Triangulation_NbTriangles\n  * wrapname: _wrap_Poly_Triangulation_NbTriangles\n  * fulldecl: Standard_Integer Handle_Poly_Triangulation::NbTriangles() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Poly_Triangulation_HasUVNodes(Handle_Poly_Triangulation const *self){
    return (*self)->HasUVNodes();
  }
EXPORT bool _wrap_Poly_Triangulation_HasUVNodes (Handle_Poly_Triangulation *larg1) {
  bool lresult = (bool)0 ;
  Handle_Poly_Triangulation *arg1 = (Handle_Poly_Triangulation *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Poly_Triangulation_HasUVNodes((Handle_Poly_Triangulation const *)arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Triangulation_HasUVNodes\n  * wrapname: _wrap_Poly_Triangulation_HasUVNodes\n  * fulldecl: Standard_Boolean Handle_Poly_Triangulation::HasUVNodes() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Poly_Array1OfTriangle const &Handle_Poly_Triangulation_Triangles(Handle_Poly_Triangulation const *self){
    return (*self)->Triangles();
  }
EXPORT Poly_Array1OfTriangle *_wrap_Poly_Triangulation_Triangles (Handle_Poly_Triangulation *larg1) {
  Poly_Array1OfTriangle * lresult = (Poly_Array1OfTriangle *)0 ;
  Handle_Poly_Triangulation *arg1 = (Handle_Poly_Triangulation *) 0 ;
  Poly_Array1OfTriangle *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Poly_Array1OfTriangle *) &Handle_Poly_Triangulation_Triangles((Handle_Poly_Triangulation const *)arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Triangulation_Triangles\n  * wrapname: _wrap_Poly_Triangulation_Triangles\n  * fulldecl: Poly_Array1OfTriangle const & Handle_Poly_Triangulation::Triangles() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Poly_Array1OfTriangle *)0;
  }
}


SWIGINTERN TColgp_Array1OfPnt const &Handle_Poly_Triangulation_Nodes(Handle_Poly_Triangulation const *self){
    return (*self)->Nodes();
  }
EXPORT TColgp_Array1OfPnt *_wrap_Poly_Triangulation_Nodes (Handle_Poly_Triangulation *larg1) {
  TColgp_Array1OfPnt * lresult = (TColgp_Array1OfPnt *)0 ;
  Handle_Poly_Triangulation *arg1 = (Handle_Poly_Triangulation *) 0 ;
  TColgp_Array1OfPnt *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColgp_Array1OfPnt *) &Handle_Poly_Triangulation_Nodes((Handle_Poly_Triangulation const *)arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Triangulation_Nodes\n  * wrapname: _wrap_Poly_Triangulation_Nodes\n  * fulldecl: TColgp_Array1OfPnt const & Handle_Poly_Triangulation::Nodes() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColgp_Array1OfPnt *)0;
  }
}


SWIGINTERN TColgp_Array1OfPnt2d const &Handle_Poly_Triangulation_UVNodes(Handle_Poly_Triangulation const *self){
    return (*self)->UVNodes();
  }
EXPORT TColgp_Array1OfPnt2d *_wrap_Poly_Triangulation_UVNodes (Handle_Poly_Triangulation *larg1) {
  TColgp_Array1OfPnt2d * lresult = (TColgp_Array1OfPnt2d *)0 ;
  Handle_Poly_Triangulation *arg1 = (Handle_Poly_Triangulation *) 0 ;
  TColgp_Array1OfPnt2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColgp_Array1OfPnt2d *) &Handle_Poly_Triangulation_UVNodes((Handle_Poly_Triangulation const *)arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Triangulation_UVNodes\n  * wrapname: _wrap_Poly_Triangulation_UVNodes\n  * fulldecl: TColgp_Array1OfPnt2d const & Handle_Poly_Triangulation::UVNodes() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColgp_Array1OfPnt2d *)0;
  }
}


EXPORT void _wrap_delete_Poly_Triangulation (Handle_Poly_Triangulation *larg1) {
  Handle_Poly_Triangulation *arg1 = (Handle_Poly_Triangulation *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Poly_Triangulation\n  * wrapname: _wrap_delete_Poly_Triangulation\n  * fulldecl: Handle_Poly_Triangulation::~Handle_Poly_Triangulation()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Poly_Triangle *_wrap_new_Poly_Triangle__SWIG_0 () {
  Poly_Triangle * lresult = (Poly_Triangle *)0 ;
  Poly_Triangle *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Poly_Triangle *)new Poly_Triangle();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Poly_Triangle\n  * wrapname: _wrap_new_Poly_Triangle__SWIG_0\n  * fulldecl: Poly_Triangle::Poly_Triangle()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Poly_Triangle *)0;
  }
}


EXPORT Poly_Triangle *_wrap_new_Poly_Triangle__SWIG_1 (Standard_Integer larg1, Standard_Integer larg2, Standard_Integer larg3) {
  Poly_Triangle * lresult = (Poly_Triangle *)0 ;
  Standard_Integer arg1 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  Poly_Triangle *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Poly_Triangle *)new Poly_Triangle(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Poly_Triangle\n  * wrapname: _wrap_new_Poly_Triangle__SWIG_1\n  * fulldecl: Poly_Triangle::Poly_Triangle(Standard_Integer const,Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Poly_Triangle *)0;
  }
}


EXPORT Standard_Integer _wrap_Poly_Triangle_Value (Poly_Triangle *larg1, Standard_Integer larg2) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Poly_Triangle *arg1 = (Poly_Triangle *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((Poly_Triangle const *)arg1)->Value(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Triangle_Value\n  * wrapname: _wrap_Poly_Triangle_Value\n  * fulldecl: Standard_Integer Poly_Triangle::Value(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT void _wrap_delete_Poly_Triangle (Poly_Triangle *larg1) {
  Poly_Triangle *arg1 = (Poly_Triangle *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Poly_Triangle\n  * wrapname: _wrap_delete_Poly_Triangle\n  * fulldecl: Poly_Triangle::~Poly_Triangle()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Poly_Array1OfTriangle *_wrap_new_Poly_Array1OfTriangle__SWIG_0 (Standard_Integer larg1, Standard_Integer larg2) {
  Poly_Array1OfTriangle * lresult = (Poly_Array1OfTriangle *)0 ;
  Standard_Integer arg1 ;
  Standard_Integer arg2 ;
  Poly_Array1OfTriangle *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Poly_Array1OfTriangle *)new Poly_Array1OfTriangle(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Poly_Array1OfTriangle\n  * wrapname: _wrap_new_Poly_Array1OfTriangle__SWIG_0\n  * fulldecl: Poly_Array1OfTriangle::Poly_Array1OfTriangle(Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Poly_Array1OfTriangle *)0;
  }
}


EXPORT Poly_Array1OfTriangle *_wrap_new_Poly_Array1OfTriangle__SWIG_1 (Poly_Triangle *larg1, Standard_Integer larg2, Standard_Integer larg3) {
  Poly_Array1OfTriangle * lresult = (Poly_Array1OfTriangle *)0 ;
  Poly_Triangle *arg1 = 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  Poly_Array1OfTriangle *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Poly_Array1OfTriangle *)new Poly_Array1OfTriangle((Poly_Triangle const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Poly_Array1OfTriangle\n  * wrapname: _wrap_new_Poly_Array1OfTriangle__SWIG_1\n  * fulldecl: Poly_Array1OfTriangle::Poly_Array1OfTriangle(Poly_Triangle const &,Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Poly_Array1OfTriangle *)0;
  }
}


EXPORT Standard_Integer _wrap_Poly_Array1OfTriangle_Length (Poly_Array1OfTriangle *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Poly_Array1OfTriangle *arg1 = (Poly_Array1OfTriangle *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)(arg1)->Length();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Array1OfTriangle_Length\n  * wrapname: _wrap_Poly_Array1OfTriangle_Length\n  * fulldecl: Standard_Integer Poly_Array1OfTriangle::Length()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT Standard_Integer _wrap_Poly_Array1OfTriangle_Lower (Poly_Array1OfTriangle *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Poly_Array1OfTriangle *arg1 = (Poly_Array1OfTriangle *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)(arg1)->Lower();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Array1OfTriangle_Lower\n  * wrapname: _wrap_Poly_Array1OfTriangle_Lower\n  * fulldecl: Standard_Integer Poly_Array1OfTriangle::Lower()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT Standard_Integer _wrap_Poly_Array1OfTriangle_Upper (Poly_Array1OfTriangle *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Poly_Array1OfTriangle *arg1 = (Poly_Array1OfTriangle *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)(arg1)->Upper();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Array1OfTriangle_Upper\n  * wrapname: _wrap_Poly_Array1OfTriangle_Upper\n  * fulldecl: Standard_Integer Poly_Array1OfTriangle::Upper()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT Poly_Triangle *_wrap_Poly_Array1OfTriangle_Value (Poly_Array1OfTriangle *larg1, Standard_Integer larg2) {
  Poly_Triangle * lresult = (Poly_Triangle *)0 ;
  Poly_Array1OfTriangle *arg1 = (Poly_Array1OfTriangle *) 0 ;
  Standard_Integer arg2 ;
  Poly_Triangle *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Poly_Triangle *) &((Poly_Array1OfTriangle const *)arg1)->Value(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Array1OfTriangle_Value\n  * wrapname: _wrap_Poly_Array1OfTriangle_Value\n  * fulldecl: Poly_Triangle const & Poly_Array1OfTriangle::Value(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Poly_Triangle *)0;
  }
}


SWIGINTERN void Poly_Array1OfTriangle_Delete(Poly_Array1OfTriangle *self){
    self->~Poly_Array1OfTriangle();
  }
EXPORT void _wrap_Poly_Array1OfTriangle_Delete (Poly_Array1OfTriangle *larg1) {
  Poly_Array1OfTriangle *arg1 = (Poly_Array1OfTriangle *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Poly_Array1OfTriangle_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Array1OfTriangle_Delete\n  * wrapname: _wrap_Poly_Array1OfTriangle_Delete\n  * fulldecl: void Poly_Array1OfTriangle::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Poly_Polygon3D *_wrap_new_Poly_Polygon3D__SWIG_0 (TColgp_Array1OfPnt *larg1) {
  Poly_Polygon3D * lresult = (Poly_Polygon3D *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  Poly_Polygon3D *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Poly_Polygon3D *)new Poly_Polygon3D((TColgp_Array1OfPnt const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Poly_Polygon3D\n  * wrapname: _wrap_new_Poly_Polygon3D__SWIG_0\n  * fulldecl: Poly_Polygon3D::Poly_Polygon3D(TColgp_Array1OfPnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Poly_Polygon3D *)0;
  }
}


EXPORT Poly_Polygon3D *_wrap_new_Poly_Polygon3D__SWIG_1 (TColgp_Array1OfPnt *larg1, TColStd_Array1OfReal *larg2) {
  Poly_Polygon3D * lresult = (Poly_Polygon3D *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  Poly_Polygon3D *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Poly_Polygon3D *)new Poly_Polygon3D((TColgp_Array1OfPnt const &)*arg1,(TColStd_Array1OfReal const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Poly_Polygon3D\n  * wrapname: _wrap_new_Poly_Polygon3D__SWIG_1\n  * fulldecl: Poly_Polygon3D::Poly_Polygon3D(TColgp_Array1OfPnt const &,TColStd_Array1OfReal const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Poly_Polygon3D *)0;
  }
}


EXPORT Standard_Real _wrap_Poly_Polygon3D_Deflection__SWIG_0 (Poly_Polygon3D *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Poly_Polygon3D *arg1 = (Poly_Polygon3D *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)(arg1)->Deflection();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Polygon3D_Deflection\n  * wrapname: _wrap_Poly_Polygon3D_Deflection__SWIG_0\n  * fulldecl: Standard_Real Poly_Polygon3D::Deflection()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_Poly_Polygon3D_Deflection__SWIG_1 (Poly_Polygon3D *larg1, Standard_Real larg2) {
  Poly_Polygon3D *arg1 = (Poly_Polygon3D *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Deflection(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Polygon3D_Deflection\n  * wrapname: _wrap_Poly_Polygon3D_Deflection__SWIG_1\n  * fulldecl: void Poly_Polygon3D::Deflection(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Integer _wrap_Poly_Polygon3D_NbNodes (Poly_Polygon3D *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Poly_Polygon3D *arg1 = (Poly_Polygon3D *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((Poly_Polygon3D const *)arg1)->NbNodes();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Polygon3D_NbNodes\n  * wrapname: _wrap_Poly_Polygon3D_NbNodes\n  * fulldecl: Standard_Integer Poly_Polygon3D::NbNodes() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT TColgp_Array1OfPnt *_wrap_Poly_Polygon3D_Nodes (Poly_Polygon3D *larg1) {
  TColgp_Array1OfPnt * lresult = (TColgp_Array1OfPnt *)0 ;
  Poly_Polygon3D *arg1 = (Poly_Polygon3D *) 0 ;
  TColgp_Array1OfPnt *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColgp_Array1OfPnt *) &((Poly_Polygon3D const *)arg1)->Nodes();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Polygon3D_Nodes\n  * wrapname: _wrap_Poly_Polygon3D_Nodes\n  * fulldecl: TColgp_Array1OfPnt const & Poly_Polygon3D::Nodes() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColgp_Array1OfPnt *)0;
  }
}


EXPORT bool _wrap_Poly_Polygon3D_HasParameters (Poly_Polygon3D *larg1) {
  bool lresult = (bool)0 ;
  Poly_Polygon3D *arg1 = (Poly_Polygon3D *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Poly_Polygon3D const *)arg1)->HasParameters();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Polygon3D_HasParameters\n  * wrapname: _wrap_Poly_Polygon3D_HasParameters\n  * fulldecl: Standard_Boolean Poly_Polygon3D::HasParameters() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT TColStd_Array1OfReal *_wrap_Poly_Polygon3D_Parameters (Poly_Polygon3D *larg1) {
  TColStd_Array1OfReal * lresult = (TColStd_Array1OfReal *)0 ;
  Poly_Polygon3D *arg1 = (Poly_Polygon3D *) 0 ;
  TColStd_Array1OfReal *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColStd_Array1OfReal *) &((Poly_Polygon3D const *)arg1)->Parameters();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Polygon3D_Parameters\n  * wrapname: _wrap_Poly_Polygon3D_Parameters\n  * fulldecl: TColStd_Array1OfReal const & Poly_Polygon3D::Parameters() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColStd_Array1OfReal *)0;
  }
}


EXPORT TColStd_Array1OfReal *_wrap_Poly_Polygon3D_ChangeParameters (Poly_Polygon3D *larg1) {
  TColStd_Array1OfReal * lresult = (TColStd_Array1OfReal *)0 ;
  Poly_Polygon3D *arg1 = (Poly_Polygon3D *) 0 ;
  TColStd_Array1OfReal *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColStd_Array1OfReal *) &((Poly_Polygon3D const *)arg1)->ChangeParameters();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Polygon3D_ChangeParameters\n  * wrapname: _wrap_Poly_Polygon3D_ChangeParameters\n  * fulldecl: TColStd_Array1OfReal & Poly_Polygon3D::ChangeParameters() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColStd_Array1OfReal *)0;
  }
}


EXPORT void _wrap_delete_Poly_Polygon3D (Poly_Polygon3D *larg1) {
  Poly_Polygon3D *arg1 = (Poly_Polygon3D *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Poly_Polygon3D\n  * wrapname: _wrap_delete_Poly_Polygon3D\n  * fulldecl: Poly_Polygon3D::~Poly_Polygon3D()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



  #include <Poly_PolygonOnTriangulation.hxx>
  
EXPORT Poly_PolygonOnTriangulation *_wrap_new_Poly_PolygonOnTriangulation__SWIG_0 (TColStd_Array1OfInteger *larg1) {
  Poly_PolygonOnTriangulation * lresult = (Poly_PolygonOnTriangulation *)0 ;
  TColStd_Array1OfInteger *arg1 = 0 ;
  Poly_PolygonOnTriangulation *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Poly_PolygonOnTriangulation *)new Poly_PolygonOnTriangulation((TColStd_Array1OfInteger const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Poly_PolygonOnTriangulation\n  * wrapname: _wrap_new_Poly_PolygonOnTriangulation__SWIG_0\n  * fulldecl: Poly_PolygonOnTriangulation::Poly_PolygonOnTriangulation(TColStd_Array1OfInteger const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Poly_PolygonOnTriangulation *)0;
  }
}


EXPORT Poly_PolygonOnTriangulation *_wrap_new_Poly_PolygonOnTriangulation__SWIG_1 (TColStd_Array1OfInteger *larg1, TColStd_Array1OfReal *larg2) {
  Poly_PolygonOnTriangulation * lresult = (Poly_PolygonOnTriangulation *)0 ;
  TColStd_Array1OfInteger *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  Poly_PolygonOnTriangulation *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Poly_PolygonOnTriangulation *)new Poly_PolygonOnTriangulation((TColStd_Array1OfInteger const &)*arg1,(TColStd_Array1OfReal const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Poly_PolygonOnTriangulation\n  * wrapname: _wrap_new_Poly_PolygonOnTriangulation__SWIG_1\n  * fulldecl: Poly_PolygonOnTriangulation::Poly_PolygonOnTriangulation(TColStd_Array1OfInteger const &,TColStd_Array1OfReal const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Poly_PolygonOnTriangulation *)0;
  }
}


EXPORT Handle_Poly_PolygonOnTriangulation *_wrap_Poly_PolygonOnTriangulation_Copy (Poly_PolygonOnTriangulation *larg1) {
  Handle_Poly_PolygonOnTriangulation * lresult = (Handle_Poly_PolygonOnTriangulation *)0 ;
  Poly_PolygonOnTriangulation *arg1 = (Poly_PolygonOnTriangulation *) 0 ;
  Handle_Poly_PolygonOnTriangulation result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Poly_PolygonOnTriangulation const *)arg1)->Copy();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_PolygonOnTriangulation_Copy\n  * wrapname: _wrap_Poly_PolygonOnTriangulation_Copy\n  * fulldecl: Handle_Poly_PolygonOnTriangulation Poly_PolygonOnTriangulation::Copy() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Poly_PolygonOnTriangulation(result);
    return lresult;
  } catch (...) {
    return (Handle_Poly_PolygonOnTriangulation *)0;
  }
}


EXPORT Standard_Real _wrap_Poly_PolygonOnTriangulation_Deflection__SWIG_0 (Poly_PolygonOnTriangulation *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Poly_PolygonOnTriangulation *arg1 = (Poly_PolygonOnTriangulation *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((Poly_PolygonOnTriangulation const *)arg1)->Deflection();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_PolygonOnTriangulation_Deflection\n  * wrapname: _wrap_Poly_PolygonOnTriangulation_Deflection__SWIG_0\n  * fulldecl: Standard_Real Poly_PolygonOnTriangulation::Deflection() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_Poly_PolygonOnTriangulation_Deflection__SWIG_1 (Poly_PolygonOnTriangulation *larg1, Standard_Real larg2) {
  Poly_PolygonOnTriangulation *arg1 = (Poly_PolygonOnTriangulation *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Deflection(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_PolygonOnTriangulation_Deflection\n  * wrapname: _wrap_Poly_PolygonOnTriangulation_Deflection__SWIG_1\n  * fulldecl: void Poly_PolygonOnTriangulation::Deflection(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Integer _wrap_Poly_PolygonOnTriangulation_NbNodes (Poly_PolygonOnTriangulation *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Poly_PolygonOnTriangulation *arg1 = (Poly_PolygonOnTriangulation *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((Poly_PolygonOnTriangulation const *)arg1)->NbNodes();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_PolygonOnTriangulation_NbNodes\n  * wrapname: _wrap_Poly_PolygonOnTriangulation_NbNodes\n  * fulldecl: Standard_Integer Poly_PolygonOnTriangulation::NbNodes() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT TColStd_Array1OfInteger *_wrap_Poly_PolygonOnTriangulation_Nodes (Poly_PolygonOnTriangulation *larg1) {
  TColStd_Array1OfInteger * lresult = (TColStd_Array1OfInteger *)0 ;
  Poly_PolygonOnTriangulation *arg1 = (Poly_PolygonOnTriangulation *) 0 ;
  TColStd_Array1OfInteger *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColStd_Array1OfInteger *) &((Poly_PolygonOnTriangulation const *)arg1)->Nodes();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_PolygonOnTriangulation_Nodes\n  * wrapname: _wrap_Poly_PolygonOnTriangulation_Nodes\n  * fulldecl: TColStd_Array1OfInteger const & Poly_PolygonOnTriangulation::Nodes() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColStd_Array1OfInteger *)0;
  }
}


EXPORT bool _wrap_Poly_PolygonOnTriangulation_HasParameters (Poly_PolygonOnTriangulation *larg1) {
  bool lresult = (bool)0 ;
  Poly_PolygonOnTriangulation *arg1 = (Poly_PolygonOnTriangulation *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Poly_PolygonOnTriangulation const *)arg1)->HasParameters();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_PolygonOnTriangulation_HasParameters\n  * wrapname: _wrap_Poly_PolygonOnTriangulation_HasParameters\n  * fulldecl: Standard_Boolean Poly_PolygonOnTriangulation::HasParameters() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Handle_TColStd_HArray1OfReal *_wrap_Poly_PolygonOnTriangulation_Parameters (Poly_PolygonOnTriangulation *larg1) {
  Handle_TColStd_HArray1OfReal * lresult = (Handle_TColStd_HArray1OfReal *)0 ;
  Poly_PolygonOnTriangulation *arg1 = (Poly_PolygonOnTriangulation *) 0 ;
  Handle_TColStd_HArray1OfReal result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Poly_PolygonOnTriangulation const *)arg1)->Parameters();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_PolygonOnTriangulation_Parameters\n  * wrapname: _wrap_Poly_PolygonOnTriangulation_Parameters\n  * fulldecl: Handle_TColStd_HArray1OfReal Poly_PolygonOnTriangulation::Parameters() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_TColStd_HArray1OfReal(result);
    return lresult;
  } catch (...) {
    return (Handle_TColStd_HArray1OfReal *)0;
  }
}


SWIGINTERN void Poly_PolygonOnTriangulation_Delete(Poly_PolygonOnTriangulation *self){
    self->~Poly_PolygonOnTriangulation();
  }
EXPORT void _wrap_Poly_PolygonOnTriangulation_Delete (Poly_PolygonOnTriangulation *larg1) {
  Poly_PolygonOnTriangulation *arg1 = (Poly_PolygonOnTriangulation *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Poly_PolygonOnTriangulation_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_PolygonOnTriangulation_Delete\n  * wrapname: _wrap_Poly_PolygonOnTriangulation_Delete\n  * fulldecl: void Poly_PolygonOnTriangulation::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <MMgt_TShared.hxx>
#include <Geom2d_Geometry.hxx>
#include <Geom2d_Point.hxx>
#include <Geom2d_CartesianPoint.hxx>
#include <Geom2d_Vector.hxx>
#include <Geom2d_VectorWithMagnitude.hxx>
#include <Geom2d_Direction.hxx>
#include <Geom2d_AxisPlacement.hxx>
#include <Geom2d_Transformation.hxx>
#include <Geom2d_Curve.hxx>
#include <Geom2d_Line.hxx>
#include <Geom2d_OffsetCurve.hxx>
#include <Geom2d_Conic.hxx>
#include <gp_Circ2d.hxx>
#include <Geom2d_Circle.hxx>
#include <gp_Elips2d.hxx>
#include <Geom2d_Ellipse.hxx>
#include <gp_Hypr2d.hxx>
#include <Geom2d_Hyperbola.hxx>
#include <Geom2d_Parabola.hxx>
#include <Geom2d_BoundedCurve.hxx>
#include <Geom2d_BezierCurve.hxx>
#include <Geom2d_BSplineCurve.hxx>
#include <Geom2d_TrimmedCurve.hxx>
#include <Bisector_Curve.hxx>
#include <Bisector_BisecAna.hxx>
#include <Bisector_BisecCC.hxx>
#include <Bisector_BisecPC.hxx>
  
SWIGINTERN void Handle_Geom2d_Geometry_Mirror__SWIG_0(Handle_Geom2d_Geometry *self,gp_Pnt2d const &P){
    (*self)->Mirror(P);
  }
EXPORT void _wrap_Geom2d_Geometry_Mirror__SWIG_0 (Handle_Geom2d_Geometry *larg1, gp_Pnt2d *larg2) {
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Geometry_Mirror__SWIG_0(arg1,(gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Geometry_Mirror\n  * wrapname: _wrap_Geom2d_Geometry_Mirror__SWIG_0\n  * fulldecl: void Handle_Geom2d_Geometry::Mirror(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Geometry_Mirror__SWIG_1(Handle_Geom2d_Geometry *self,gp_Ax2d const &A){
    (*self)->Mirror(A);
  }
EXPORT void _wrap_Geom2d_Geometry_Mirror__SWIG_1 (Handle_Geom2d_Geometry *larg1, gp_Ax2d *larg2) {
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Geometry_Mirror__SWIG_1(arg1,(gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Geometry_Mirror\n  * wrapname: _wrap_Geom2d_Geometry_Mirror__SWIG_1\n  * fulldecl: void Handle_Geom2d_Geometry::Mirror(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Geometry_Rotate(Handle_Geom2d_Geometry *self,gp_Pnt2d const &P,Standard_Real const Ang){
    (*self)->Rotate(P, Ang);
  }
EXPORT void _wrap_Geom2d_Geometry_Rotate (Handle_Geom2d_Geometry *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Geometry_Rotate(arg1,(gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Geometry_Rotate\n  * wrapname: _wrap_Geom2d_Geometry_Rotate\n  * fulldecl: void Handle_Geom2d_Geometry::Rotate(gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Geometry_Scale(Handle_Geom2d_Geometry *self,gp_Pnt2d const &P,Standard_Real const S){
    (*self)->Scale(P, S);
  }
EXPORT void _wrap_Geom2d_Geometry_Scale (Handle_Geom2d_Geometry *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Geometry_Scale(arg1,(gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Geometry_Scale\n  * wrapname: _wrap_Geom2d_Geometry_Scale\n  * fulldecl: void Handle_Geom2d_Geometry::Scale(gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Geometry_Translate__SWIG_0(Handle_Geom2d_Geometry *self,gp_Vec2d const &V){
    (*self)->Translate(V);
  }
EXPORT void _wrap_Geom2d_Geometry_Translate__SWIG_0 (Handle_Geom2d_Geometry *larg1, gp_Vec2d *larg2) {
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Geometry_Translate__SWIG_0(arg1,(gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Geometry_Translate\n  * wrapname: _wrap_Geom2d_Geometry_Translate__SWIG_0\n  * fulldecl: void Handle_Geom2d_Geometry::Translate(gp_Vec2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Geometry_Translate__SWIG_1(Handle_Geom2d_Geometry *self,gp_Pnt2d const &P1,gp_Pnt2d const &P2){
    (*self)->Translate(P1, P2);
  }
EXPORT void _wrap_Geom2d_Geometry_Translate__SWIG_1 (Handle_Geom2d_Geometry *larg1, gp_Pnt2d *larg2, gp_Pnt2d *larg3) {
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Pnt2d *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Geometry_Translate__SWIG_1(arg1,(gp_Pnt2d const &)*arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Geometry_Translate\n  * wrapname: _wrap_Geom2d_Geometry_Translate__SWIG_1\n  * fulldecl: void Handle_Geom2d_Geometry::Translate(gp_Pnt2d const &,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_Geometry Handle_Geom2d_Geometry_Mirrored__SWIG_0(Handle_Geom2d_Geometry *self,gp_Pnt2d const &P){
    return (*self)->Mirrored(P);
  }
EXPORT Handle_Geom2d_Geometry *_wrap_Geom2d_Geometry_Mirrored__SWIG_0 (Handle_Geom2d_Geometry *larg1, gp_Pnt2d *larg2) {
  Handle_Geom2d_Geometry * lresult = (Handle_Geom2d_Geometry *)0 ;
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  SwigValueWrapper< Handle_Geom2d_Geometry > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Geometry_Mirrored__SWIG_0(arg1,(gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Geometry_Mirrored\n  * wrapname: _wrap_Geom2d_Geometry_Mirrored__SWIG_0\n  * fulldecl: Handle_Geom2d_Geometry Handle_Geom2d_Geometry::Mirrored(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Geometry *)0;
  }
}


SWIGINTERN Handle_Geom2d_Geometry Handle_Geom2d_Geometry_Mirrored__SWIG_1(Handle_Geom2d_Geometry *self,gp_Ax2d const &A){
    return (*self)->Mirrored(A);
  }
EXPORT Handle_Geom2d_Geometry *_wrap_Geom2d_Geometry_Mirrored__SWIG_1 (Handle_Geom2d_Geometry *larg1, gp_Ax2d *larg2) {
  Handle_Geom2d_Geometry * lresult = (Handle_Geom2d_Geometry *)0 ;
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  SwigValueWrapper< Handle_Geom2d_Geometry > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Geometry_Mirrored__SWIG_1(arg1,(gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Geometry_Mirrored\n  * wrapname: _wrap_Geom2d_Geometry_Mirrored__SWIG_1\n  * fulldecl: Handle_Geom2d_Geometry Handle_Geom2d_Geometry::Mirrored(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Geometry *)0;
  }
}


SWIGINTERN Handle_Geom2d_Geometry Handle_Geom2d_Geometry_Rotated(Handle_Geom2d_Geometry *self,gp_Pnt2d const &P,Standard_Real const Ang){
    return (*self)->Rotated(P, Ang);
  }
EXPORT Handle_Geom2d_Geometry *_wrap_Geom2d_Geometry_Rotated (Handle_Geom2d_Geometry *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  Handle_Geom2d_Geometry * lresult = (Handle_Geom2d_Geometry *)0 ;
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  SwigValueWrapper< Handle_Geom2d_Geometry > result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Geometry_Rotated(arg1,(gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Geometry_Rotated\n  * wrapname: _wrap_Geom2d_Geometry_Rotated\n  * fulldecl: Handle_Geom2d_Geometry Handle_Geom2d_Geometry::Rotated(gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Geometry *)0;
  }
}


SWIGINTERN Handle_Geom2d_Geometry Handle_Geom2d_Geometry_Scaled(Handle_Geom2d_Geometry *self,gp_Pnt2d const &P,Standard_Real const S){
    return (*self)->Scaled(P, S);
  }
EXPORT Handle_Geom2d_Geometry *_wrap_Geom2d_Geometry_Scaled (Handle_Geom2d_Geometry *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  Handle_Geom2d_Geometry * lresult = (Handle_Geom2d_Geometry *)0 ;
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  SwigValueWrapper< Handle_Geom2d_Geometry > result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Geometry_Scaled(arg1,(gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Geometry_Scaled\n  * wrapname: _wrap_Geom2d_Geometry_Scaled\n  * fulldecl: Handle_Geom2d_Geometry Handle_Geom2d_Geometry::Scaled(gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Geometry *)0;
  }
}


SWIGINTERN Handle_Geom2d_Geometry Handle_Geom2d_Geometry_Transformed(Handle_Geom2d_Geometry *self,gp_Trsf2d const &T){
    return (*self)->Transformed(T);
  }
EXPORT Handle_Geom2d_Geometry *_wrap_Geom2d_Geometry_Transformed (Handle_Geom2d_Geometry *larg1, gp_Trsf2d *larg2) {
  Handle_Geom2d_Geometry * lresult = (Handle_Geom2d_Geometry *)0 ;
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  SwigValueWrapper< Handle_Geom2d_Geometry > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Geometry_Transformed(arg1,(gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Geometry_Transformed\n  * wrapname: _wrap_Geom2d_Geometry_Transformed\n  * fulldecl: Handle_Geom2d_Geometry Handle_Geom2d_Geometry::Transformed(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Geometry *)0;
  }
}


SWIGINTERN Handle_Geom2d_Geometry Handle_Geom2d_Geometry_Translated__SWIG_0(Handle_Geom2d_Geometry *self,gp_Vec2d const &V){
    return (*self)->Translated(V);
  }
EXPORT Handle_Geom2d_Geometry *_wrap_Geom2d_Geometry_Translated__SWIG_0 (Handle_Geom2d_Geometry *larg1, gp_Vec2d *larg2) {
  Handle_Geom2d_Geometry * lresult = (Handle_Geom2d_Geometry *)0 ;
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  SwigValueWrapper< Handle_Geom2d_Geometry > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Geometry_Translated__SWIG_0(arg1,(gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Geometry_Translated\n  * wrapname: _wrap_Geom2d_Geometry_Translated__SWIG_0\n  * fulldecl: Handle_Geom2d_Geometry Handle_Geom2d_Geometry::Translated(gp_Vec2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Geometry *)0;
  }
}


SWIGINTERN Handle_Geom2d_Geometry Handle_Geom2d_Geometry_Translated__SWIG_1(Handle_Geom2d_Geometry *self,gp_Pnt2d const &P1,gp_Pnt2d const &P2){
    return (*self)->Translated(P1, P2);
  }
EXPORT Handle_Geom2d_Geometry *_wrap_Geom2d_Geometry_Translated__SWIG_1 (Handle_Geom2d_Geometry *larg1, gp_Pnt2d *larg2, gp_Pnt2d *larg3) {
  Handle_Geom2d_Geometry * lresult = (Handle_Geom2d_Geometry *)0 ;
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Pnt2d *arg3 = 0 ;
  SwigValueWrapper< Handle_Geom2d_Geometry > result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Geometry_Translated__SWIG_1(arg1,(gp_Pnt2d const &)*arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Geometry_Translated\n  * wrapname: _wrap_Geom2d_Geometry_Translated__SWIG_1\n  * fulldecl: Handle_Geom2d_Geometry Handle_Geom2d_Geometry::Translated(gp_Pnt2d const &,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Geometry *)0;
  }
}


SWIGINTERN void Handle_Geom2d_Geometry_Transform(Handle_Geom2d_Geometry *self,gp_Trsf2d const &T){
    (*self)->Transform(T);
  }
EXPORT void _wrap_Geom2d_Geometry_Transform (Handle_Geom2d_Geometry *larg1, gp_Trsf2d *larg2) {
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Geometry_Transform(arg1,(gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Geometry_Transform\n  * wrapname: _wrap_Geom2d_Geometry_Transform\n  * fulldecl: void Handle_Geom2d_Geometry::Transform(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_Geometry Handle_Geom2d_Geometry_Copy(Handle_Geom2d_Geometry *self){
    return (*self)->Copy();
  }
EXPORT Handle_Geom2d_Geometry *_wrap_Geom2d_Geometry_Copy (Handle_Geom2d_Geometry *larg1) {
  Handle_Geom2d_Geometry * lresult = (Handle_Geom2d_Geometry *)0 ;
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  SwigValueWrapper< Handle_Geom2d_Geometry > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Geometry_Copy(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Geometry_Copy\n  * wrapname: _wrap_Geom2d_Geometry_Copy\n  * fulldecl: Handle_Geom2d_Geometry Handle_Geom2d_Geometry::Copy()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Geometry *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Point_Distance(Handle_Geom2d_Point *self,Handle_Geom2d_Point const &Other){
    return (*self)->Distance(Other);
  }
EXPORT Standard_Real _wrap_Geom2d_Point_Distance (Handle_Geom2d_Point *larg1, Handle_Geom2d_Point *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Point *arg1 = (Handle_Geom2d_Point *) 0 ;
  Handle_Geom2d_Point *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Point_Distance(arg1,(Handle_Geom2d_Point const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Point_Distance\n  * wrapname: _wrap_Geom2d_Point_Distance\n  * fulldecl: Standard_Real Handle_Geom2d_Point::Distance(Handle_Geom2d_Point const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Point_SquareDistance(Handle_Geom2d_Point *self,Handle_Geom2d_Point const &Other){
    return (*self)->SquareDistance(Other);
  }
EXPORT Standard_Real _wrap_Geom2d_Point_SquareDistance (Handle_Geom2d_Point *larg1, Handle_Geom2d_Point *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Point *arg1 = (Handle_Geom2d_Point *) 0 ;
  Handle_Geom2d_Point *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Point_SquareDistance(arg1,(Handle_Geom2d_Point const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Point_SquareDistance\n  * wrapname: _wrap_Geom2d_Point_SquareDistance\n  * fulldecl: Standard_Real Handle_Geom2d_Point::SquareDistance(Handle_Geom2d_Point const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN void Handle_Geom2d_Point_Coord(Handle_Geom2d_Point *self,Standard_Real &X,Standard_Real &Y){
    (*self)->Coord(X, Y);
  }
EXPORT void _wrap_Geom2d_Point_Coord (Handle_Geom2d_Point *larg1, Standard_Real *larg2, Standard_Real *larg3) {
  Handle_Geom2d_Point *arg1 = (Handle_Geom2d_Point *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Point_Coord(arg1,*arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Point_Coord\n  * wrapname: _wrap_Geom2d_Point_Coord\n  * fulldecl: void Handle_Geom2d_Point::Coord(Standard_Real &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Pnt2d Handle_Geom2d_Point_Pnt2d(Handle_Geom2d_Point *self){
    return (*self)->Pnt2d();
  }
EXPORT gp_Pnt2d *_wrap_Geom2d_Point_Pnt2d (Handle_Geom2d_Point *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Handle_Geom2d_Point *arg1 = (Handle_Geom2d_Point *) 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Point_Pnt2d(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Point_Pnt2d\n  * wrapname: _wrap_Geom2d_Point_Pnt2d\n  * fulldecl: gp_Pnt2d Handle_Geom2d_Point::Pnt2d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Point_X(Handle_Geom2d_Point *self){
    return (*self)->X();
  }
EXPORT Standard_Real _wrap_Geom2d_Point_X (Handle_Geom2d_Point *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Point *arg1 = (Handle_Geom2d_Point *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Point_X(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Point_X\n  * wrapname: _wrap_Geom2d_Point_X\n  * fulldecl: Standard_Real Handle_Geom2d_Point::X()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Point_Y(Handle_Geom2d_Point *self){
    return (*self)->Y();
  }
EXPORT Standard_Real _wrap_Geom2d_Point_Y (Handle_Geom2d_Point *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Point *arg1 = (Handle_Geom2d_Point *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Point_Y(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Point_Y\n  * wrapname: _wrap_Geom2d_Point_Y\n  * fulldecl: Standard_Real Handle_Geom2d_Point::Y()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Handle_Geom2d_CartesianPoint *new_Handle_Geom2d_CartesianPoint__SWIG_0(gp_Pnt2d const &P){
    return new Handle_Geom2d_CartesianPoint(new Geom2d_CartesianPoint(P));
  }
EXPORT Handle_Geom2d_CartesianPoint *_wrap_new_Geom2d_CartesianPoint__SWIG_0 (gp_Pnt2d *larg1) {
  Handle_Geom2d_CartesianPoint * lresult = (Handle_Geom2d_CartesianPoint *)0 ;
  gp_Pnt2d *arg1 = 0 ;
  Handle_Geom2d_CartesianPoint *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_CartesianPoint *)new_Handle_Geom2d_CartesianPoint__SWIG_0((gp_Pnt2d const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_CartesianPoint\n  * wrapname: _wrap_new_Geom2d_CartesianPoint__SWIG_0\n  * fulldecl: Handle_Geom2d_CartesianPoint::Handle_Geom2d_CartesianPoint(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_CartesianPoint *)0;
  }
}


SWIGINTERN Handle_Geom2d_CartesianPoint *new_Handle_Geom2d_CartesianPoint__SWIG_1(Standard_Real const X,Standard_Real const Y){
    return new Handle_Geom2d_CartesianPoint(new Geom2d_CartesianPoint(X, Y));
  }
EXPORT Handle_Geom2d_CartesianPoint *_wrap_new_Geom2d_CartesianPoint__SWIG_1 (Standard_Real larg1, Standard_Real larg2) {
  Handle_Geom2d_CartesianPoint * lresult = (Handle_Geom2d_CartesianPoint *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  Handle_Geom2d_CartesianPoint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_CartesianPoint *)new_Handle_Geom2d_CartesianPoint__SWIG_1(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_CartesianPoint\n  * wrapname: _wrap_new_Geom2d_CartesianPoint__SWIG_1\n  * fulldecl: Handle_Geom2d_CartesianPoint::Handle_Geom2d_CartesianPoint(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_CartesianPoint *)0;
  }
}


SWIGINTERN void Handle_Geom2d_CartesianPoint_Delete(Handle_Geom2d_CartesianPoint *self){
    self->~Handle_Geom2d_CartesianPoint();
  }
EXPORT void _wrap_Geom2d_CartesianPoint_Delete (Handle_Geom2d_CartesianPoint *larg1) {
  Handle_Geom2d_CartesianPoint *arg1 = (Handle_Geom2d_CartesianPoint *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_CartesianPoint_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_CartesianPoint_Delete\n  * wrapname: _wrap_Geom2d_CartesianPoint_Delete\n  * fulldecl: void Handle_Geom2d_CartesianPoint::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_CartesianPoint_SetCoord(Handle_Geom2d_CartesianPoint *self,Standard_Real const X,Standard_Real const Y){
    (*self)->SetCoord(X, Y);
  }
EXPORT void _wrap_Geom2d_CartesianPoint_SetCoord (Handle_Geom2d_CartesianPoint *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom2d_CartesianPoint *arg1 = (Handle_Geom2d_CartesianPoint *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_CartesianPoint_SetCoord(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_CartesianPoint_SetCoord\n  * wrapname: _wrap_Geom2d_CartesianPoint_SetCoord\n  * fulldecl: void Handle_Geom2d_CartesianPoint::SetCoord(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_CartesianPoint_SetPnt2d(Handle_Geom2d_CartesianPoint *self,gp_Pnt2d const &P){
    (*self)->SetPnt2d(P);
  }
EXPORT void _wrap_Geom2d_CartesianPoint_SetPnt2d (Handle_Geom2d_CartesianPoint *larg1, gp_Pnt2d *larg2) {
  Handle_Geom2d_CartesianPoint *arg1 = (Handle_Geom2d_CartesianPoint *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_CartesianPoint_SetPnt2d(arg1,(gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_CartesianPoint_SetPnt2d\n  * wrapname: _wrap_Geom2d_CartesianPoint_SetPnt2d\n  * fulldecl: void Handle_Geom2d_CartesianPoint::SetPnt2d(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_CartesianPoint_SetX(Handle_Geom2d_CartesianPoint *self,Standard_Real const X){
    (*self)->SetX(X);
  }
EXPORT void _wrap_Geom2d_CartesianPoint_SetX (Handle_Geom2d_CartesianPoint *larg1, Standard_Real larg2) {
  Handle_Geom2d_CartesianPoint *arg1 = (Handle_Geom2d_CartesianPoint *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_CartesianPoint_SetX(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_CartesianPoint_SetX\n  * wrapname: _wrap_Geom2d_CartesianPoint_SetX\n  * fulldecl: void Handle_Geom2d_CartesianPoint::SetX(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_CartesianPoint_SetY(Handle_Geom2d_CartesianPoint *self,Standard_Real const Y){
    (*self)->SetY(Y);
  }
EXPORT void _wrap_Geom2d_CartesianPoint_SetY (Handle_Geom2d_CartesianPoint *larg1, Standard_Real larg2) {
  Handle_Geom2d_CartesianPoint *arg1 = (Handle_Geom2d_CartesianPoint *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_CartesianPoint_SetY(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_CartesianPoint_SetY\n  * wrapname: _wrap_Geom2d_CartesianPoint_SetY\n  * fulldecl: void Handle_Geom2d_CartesianPoint::SetY(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Vector_Reverse(Handle_Geom2d_Vector *self){
    (*self)->Reverse();
  }
EXPORT void _wrap_Geom2d_Vector_Reverse (Handle_Geom2d_Vector *larg1) {
  Handle_Geom2d_Vector *arg1 = (Handle_Geom2d_Vector *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Vector_Reverse(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Vector_Reverse\n  * wrapname: _wrap_Geom2d_Vector_Reverse\n  * fulldecl: void Handle_Geom2d_Vector::Reverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_Vector Handle_Geom2d_Vector_Reversed(Handle_Geom2d_Vector *self){
    return (*self)->Reversed();
  }
EXPORT Handle_Geom2d_Vector *_wrap_Geom2d_Vector_Reversed (Handle_Geom2d_Vector *larg1) {
  Handle_Geom2d_Vector * lresult = (Handle_Geom2d_Vector *)0 ;
  Handle_Geom2d_Vector *arg1 = (Handle_Geom2d_Vector *) 0 ;
  SwigValueWrapper< Handle_Geom2d_Vector > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Vector_Reversed(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Vector_Reversed\n  * wrapname: _wrap_Geom2d_Vector_Reversed\n  * fulldecl: Handle_Geom2d_Vector Handle_Geom2d_Vector::Reversed()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Vector(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Vector *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Vector_Angle(Handle_Geom2d_Vector *self,Handle_Geom2d_Vector const &Other){
    return (*self)->Angle(Other);
  }
EXPORT Standard_Real _wrap_Geom2d_Vector_Angle (Handle_Geom2d_Vector *larg1, Handle_Geom2d_Vector *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Vector *arg1 = (Handle_Geom2d_Vector *) 0 ;
  Handle_Geom2d_Vector *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Vector_Angle(arg1,(Handle_Geom2d_Vector const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Vector_Angle\n  * wrapname: _wrap_Geom2d_Vector_Angle\n  * fulldecl: Standard_Real Handle_Geom2d_Vector::Angle(Handle_Geom2d_Vector const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN void Handle_Geom2d_Vector_Coord(Handle_Geom2d_Vector *self,Standard_Real &X,Standard_Real &Y){
    (*self)->Coord(X, Y);
  }
EXPORT void _wrap_Geom2d_Vector_Coord (Handle_Geom2d_Vector *larg1, Standard_Real *larg2, Standard_Real *larg3) {
  Handle_Geom2d_Vector *arg1 = (Handle_Geom2d_Vector *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Vector_Coord(arg1,*arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Vector_Coord\n  * wrapname: _wrap_Geom2d_Vector_Coord\n  * fulldecl: void Handle_Geom2d_Vector::Coord(Standard_Real &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Vector_Magnitude(Handle_Geom2d_Vector *self){
    return (*self)->Magnitude();
  }
EXPORT Standard_Real _wrap_Geom2d_Vector_Magnitude (Handle_Geom2d_Vector *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Vector *arg1 = (Handle_Geom2d_Vector *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Vector_Magnitude(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Vector_Magnitude\n  * wrapname: _wrap_Geom2d_Vector_Magnitude\n  * fulldecl: Standard_Real Handle_Geom2d_Vector::Magnitude()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Vector_SquareMagnitude(Handle_Geom2d_Vector *self){
    return (*self)->SquareMagnitude();
  }
EXPORT Standard_Real _wrap_Geom2d_Vector_SquareMagnitude (Handle_Geom2d_Vector *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Vector *arg1 = (Handle_Geom2d_Vector *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Vector_SquareMagnitude(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Vector_SquareMagnitude\n  * wrapname: _wrap_Geom2d_Vector_SquareMagnitude\n  * fulldecl: Standard_Real Handle_Geom2d_Vector::SquareMagnitude()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Vector_X(Handle_Geom2d_Vector *self){
    return (*self)->X();
  }
EXPORT Standard_Real _wrap_Geom2d_Vector_X (Handle_Geom2d_Vector *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Vector *arg1 = (Handle_Geom2d_Vector *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Vector_X(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Vector_X\n  * wrapname: _wrap_Geom2d_Vector_X\n  * fulldecl: Standard_Real Handle_Geom2d_Vector::X()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Vector_Y(Handle_Geom2d_Vector *self){
    return (*self)->Y();
  }
EXPORT Standard_Real _wrap_Geom2d_Vector_Y (Handle_Geom2d_Vector *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Vector *arg1 = (Handle_Geom2d_Vector *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Vector_Y(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Vector_Y\n  * wrapname: _wrap_Geom2d_Vector_Y\n  * fulldecl: Standard_Real Handle_Geom2d_Vector::Y()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Vector_Crossed(Handle_Geom2d_Vector *self,Handle_Geom2d_Vector const &Other){
    return (*self)->Crossed(Other);
  }
EXPORT Standard_Real _wrap_Geom2d_Vector_Crossed (Handle_Geom2d_Vector *larg1, Handle_Geom2d_Vector *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Vector *arg1 = (Handle_Geom2d_Vector *) 0 ;
  Handle_Geom2d_Vector *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Vector_Crossed(arg1,(Handle_Geom2d_Vector const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Vector_Crossed\n  * wrapname: _wrap_Geom2d_Vector_Crossed\n  * fulldecl: Standard_Real Handle_Geom2d_Vector::Crossed(Handle_Geom2d_Vector const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Vector_Dot(Handle_Geom2d_Vector *self,Handle_Geom2d_Vector const &Other){
    return (*self)->Dot(Other);
  }
EXPORT Standard_Real _wrap_Geom2d_Vector_Dot (Handle_Geom2d_Vector *larg1, Handle_Geom2d_Vector *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Vector *arg1 = (Handle_Geom2d_Vector *) 0 ;
  Handle_Geom2d_Vector *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Vector_Dot(arg1,(Handle_Geom2d_Vector const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Vector_Dot\n  * wrapname: _wrap_Geom2d_Vector_Dot\n  * fulldecl: Standard_Real Handle_Geom2d_Vector::Dot(Handle_Geom2d_Vector const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN gp_Vec2d Handle_Geom2d_Vector_Vec2d(Handle_Geom2d_Vector *self){
    return (*self)->Vec2d();
  }
EXPORT gp_Vec2d *_wrap_Geom2d_Vector_Vec2d (Handle_Geom2d_Vector *larg1) {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  Handle_Geom2d_Vector *arg1 = (Handle_Geom2d_Vector *) 0 ;
  gp_Vec2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Vector_Vec2d(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Vector_Vec2d\n  * wrapname: _wrap_Geom2d_Vector_Vec2d\n  * fulldecl: gp_Vec2d Handle_Geom2d_Vector::Vec2d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec2d(result);
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom2d_Vector_GeometryType(Handle_Geom2d_Vector *self){
    if (STANDARD_TYPE(Geom2d_VectorWithMagnitude) == (*self)->DynamicType())
      {
	return 312;
      }
    if (STANDARD_TYPE(Geom2d_Direction) == (*self)->DynamicType())
      {
	return 313;
      }
    return -1;
  }
EXPORT Standard_Integer _wrap_Geom2d_Vector_GeometryType (Handle_Geom2d_Vector *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom2d_Vector *arg1 = (Handle_Geom2d_Vector *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom2d_Vector_GeometryType(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Vector_GeometryType\n  * wrapname: _wrap_Geom2d_Vector_GeometryType\n  * fulldecl: Standard_Integer Handle_Geom2d_Vector::GeometryType()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Handle_Geom2d_VectorWithMagnitude *new_Handle_Geom2d_VectorWithMagnitude__SWIG_0(gp_Vec2d const &V){
    return new Handle_Geom2d_VectorWithMagnitude(new Geom2d_VectorWithMagnitude(V));
  }
EXPORT Handle_Geom2d_VectorWithMagnitude *_wrap_new_Geom2d_VectorWithMagnitude__SWIG_0 (gp_Vec2d *larg1) {
  Handle_Geom2d_VectorWithMagnitude * lresult = (Handle_Geom2d_VectorWithMagnitude *)0 ;
  gp_Vec2d *arg1 = 0 ;
  Handle_Geom2d_VectorWithMagnitude *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_VectorWithMagnitude *)new_Handle_Geom2d_VectorWithMagnitude__SWIG_0((gp_Vec2d const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_VectorWithMagnitude\n  * wrapname: _wrap_new_Geom2d_VectorWithMagnitude__SWIG_0\n  * fulldecl: Handle_Geom2d_VectorWithMagnitude::Handle_Geom2d_VectorWithMagnitude(gp_Vec2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_VectorWithMagnitude *)0;
  }
}


SWIGINTERN Handle_Geom2d_VectorWithMagnitude *new_Handle_Geom2d_VectorWithMagnitude__SWIG_1(Standard_Real const X,Standard_Real const Y){
    return new Handle_Geom2d_VectorWithMagnitude(new Geom2d_VectorWithMagnitude(X, Y));
  }
EXPORT Handle_Geom2d_VectorWithMagnitude *_wrap_new_Geom2d_VectorWithMagnitude__SWIG_1 (Standard_Real larg1, Standard_Real larg2) {
  Handle_Geom2d_VectorWithMagnitude * lresult = (Handle_Geom2d_VectorWithMagnitude *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  Handle_Geom2d_VectorWithMagnitude *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_VectorWithMagnitude *)new_Handle_Geom2d_VectorWithMagnitude__SWIG_1(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_VectorWithMagnitude\n  * wrapname: _wrap_new_Geom2d_VectorWithMagnitude__SWIG_1\n  * fulldecl: Handle_Geom2d_VectorWithMagnitude::Handle_Geom2d_VectorWithMagnitude(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_VectorWithMagnitude *)0;
  }
}


SWIGINTERN Handle_Geom2d_VectorWithMagnitude *new_Handle_Geom2d_VectorWithMagnitude__SWIG_2(gp_Pnt2d const &P1,gp_Pnt2d const &P2){
    return new Handle_Geom2d_VectorWithMagnitude(new Geom2d_VectorWithMagnitude(P1, P2));
  }
EXPORT Handle_Geom2d_VectorWithMagnitude *_wrap_new_Geom2d_VectorWithMagnitude__SWIG_2 (gp_Pnt2d *larg1, gp_Pnt2d *larg2) {
  Handle_Geom2d_VectorWithMagnitude * lresult = (Handle_Geom2d_VectorWithMagnitude *)0 ;
  gp_Pnt2d *arg1 = 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Handle_Geom2d_VectorWithMagnitude *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_VectorWithMagnitude *)new_Handle_Geom2d_VectorWithMagnitude__SWIG_2((gp_Pnt2d const &)*arg1,(gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_VectorWithMagnitude\n  * wrapname: _wrap_new_Geom2d_VectorWithMagnitude__SWIG_2\n  * fulldecl: Handle_Geom2d_VectorWithMagnitude::Handle_Geom2d_VectorWithMagnitude(gp_Pnt2d const &,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_VectorWithMagnitude *)0;
  }
}


SWIGINTERN void Handle_Geom2d_VectorWithMagnitude_Delete(Handle_Geom2d_VectorWithMagnitude *self){
    self->~Handle_Geom2d_VectorWithMagnitude();
  }
EXPORT void _wrap_Geom2d_VectorWithMagnitude_Delete (Handle_Geom2d_VectorWithMagnitude *larg1) {
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_VectorWithMagnitude_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_Delete\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_Delete\n  * fulldecl: void Handle_Geom2d_VectorWithMagnitude::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_VectorWithMagnitude_SetCoord(Handle_Geom2d_VectorWithMagnitude *self,Standard_Real const X,Standard_Real const Y){
    (*self)->SetCoord(X, Y);
  }
EXPORT void _wrap_Geom2d_VectorWithMagnitude_SetCoord (Handle_Geom2d_VectorWithMagnitude *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_VectorWithMagnitude_SetCoord(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_SetCoord\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_SetCoord\n  * fulldecl: void Handle_Geom2d_VectorWithMagnitude::SetCoord(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_VectorWithMagnitude_SetVec2d(Handle_Geom2d_VectorWithMagnitude *self,gp_Vec2d const &V){
    (*self)->SetVec2d(V);
  }
EXPORT void _wrap_Geom2d_VectorWithMagnitude_SetVec2d (Handle_Geom2d_VectorWithMagnitude *larg1, gp_Vec2d *larg2) {
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_VectorWithMagnitude_SetVec2d(arg1,(gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_SetVec2d\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_SetVec2d\n  * fulldecl: void Handle_Geom2d_VectorWithMagnitude::SetVec2d(gp_Vec2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_VectorWithMagnitude_SetX(Handle_Geom2d_VectorWithMagnitude *self,Standard_Real const X){
    (*self)->SetX(X);
  }
EXPORT void _wrap_Geom2d_VectorWithMagnitude_SetX (Handle_Geom2d_VectorWithMagnitude *larg1, Standard_Real larg2) {
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_VectorWithMagnitude_SetX(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_SetX\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_SetX\n  * fulldecl: void Handle_Geom2d_VectorWithMagnitude::SetX(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_VectorWithMagnitude_SetY(Handle_Geom2d_VectorWithMagnitude *self,Standard_Real const Y){
    (*self)->SetY(Y);
  }
EXPORT void _wrap_Geom2d_VectorWithMagnitude_SetY (Handle_Geom2d_VectorWithMagnitude *larg1, Standard_Real larg2) {
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_VectorWithMagnitude_SetY(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_SetY\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_SetY\n  * fulldecl: void Handle_Geom2d_VectorWithMagnitude::SetY(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_VectorWithMagnitude_Add(Handle_Geom2d_VectorWithMagnitude *self,Handle_Geom2d_Vector const &Other){
    (*self)->Add(Other);
  }
EXPORT void _wrap_Geom2d_VectorWithMagnitude_Add (Handle_Geom2d_VectorWithMagnitude *larg1, Handle_Geom2d_Vector *larg2) {
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  Handle_Geom2d_Vector *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_VectorWithMagnitude_Add(arg1,(Handle_Geom2d_Vector const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_Add\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_Add\n  * fulldecl: void Handle_Geom2d_VectorWithMagnitude::Add(Handle_Geom2d_Vector const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_VectorWithMagnitude Handle_Geom2d_VectorWithMagnitude_Added(Handle_Geom2d_VectorWithMagnitude *self,Handle_Geom2d_Vector const &Other){
    return (*self)->Added(Other);
  }
EXPORT Handle_Geom2d_VectorWithMagnitude *_wrap_Geom2d_VectorWithMagnitude_Added (Handle_Geom2d_VectorWithMagnitude *larg1, Handle_Geom2d_Vector *larg2) {
  Handle_Geom2d_VectorWithMagnitude * lresult = (Handle_Geom2d_VectorWithMagnitude *)0 ;
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  Handle_Geom2d_Vector *arg2 = 0 ;
  SwigValueWrapper< Handle_Geom2d_VectorWithMagnitude > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_VectorWithMagnitude_Added(arg1,(Handle_Geom2d_Vector const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_Added\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_Added\n  * fulldecl: Handle_Geom2d_VectorWithMagnitude Handle_Geom2d_VectorWithMagnitude::Added(Handle_Geom2d_Vector const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_VectorWithMagnitude(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_VectorWithMagnitude *)0;
  }
}


SWIGINTERN void Handle_Geom2d_VectorWithMagnitude_Divide(Handle_Geom2d_VectorWithMagnitude *self,Standard_Real const Scalar){
    (*self)->Divide(Scalar);
  }
EXPORT void _wrap_Geom2d_VectorWithMagnitude_Divide (Handle_Geom2d_VectorWithMagnitude *larg1, Standard_Real larg2) {
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_VectorWithMagnitude_Divide(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_Divide\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_Divide\n  * fulldecl: void Handle_Geom2d_VectorWithMagnitude::Divide(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_VectorWithMagnitude Handle_Geom2d_VectorWithMagnitude_Divided(Handle_Geom2d_VectorWithMagnitude *self,Standard_Real const Scalar){
    return (*self)->Divided(Scalar);
  }
EXPORT Handle_Geom2d_VectorWithMagnitude *_wrap_Geom2d_VectorWithMagnitude_Divided (Handle_Geom2d_VectorWithMagnitude *larg1, Standard_Real larg2) {
  Handle_Geom2d_VectorWithMagnitude * lresult = (Handle_Geom2d_VectorWithMagnitude *)0 ;
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  Standard_Real arg2 ;
  SwigValueWrapper< Handle_Geom2d_VectorWithMagnitude > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_VectorWithMagnitude_Divided(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_Divided\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_Divided\n  * fulldecl: Handle_Geom2d_VectorWithMagnitude Handle_Geom2d_VectorWithMagnitude::Divided(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_VectorWithMagnitude(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_VectorWithMagnitude *)0;
  }
}


SWIGINTERN Handle_Geom2d_VectorWithMagnitude Handle_Geom2d_VectorWithMagnitude_Multiplied(Handle_Geom2d_VectorWithMagnitude *self,Standard_Real const Scalar){
    return (*self)->Multiplied(Scalar);
  }
EXPORT Handle_Geom2d_VectorWithMagnitude *_wrap_Geom2d_VectorWithMagnitude_Multiplied (Handle_Geom2d_VectorWithMagnitude *larg1, Standard_Real larg2) {
  Handle_Geom2d_VectorWithMagnitude * lresult = (Handle_Geom2d_VectorWithMagnitude *)0 ;
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  Standard_Real arg2 ;
  SwigValueWrapper< Handle_Geom2d_VectorWithMagnitude > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_VectorWithMagnitude_Multiplied(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_Multiplied\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_Multiplied\n  * fulldecl: Handle_Geom2d_VectorWithMagnitude Handle_Geom2d_VectorWithMagnitude::Multiplied(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_VectorWithMagnitude(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_VectorWithMagnitude *)0;
  }
}


SWIGINTERN void Handle_Geom2d_VectorWithMagnitude_Multiply(Handle_Geom2d_VectorWithMagnitude *self,Standard_Real const Scalar){
    (*self)->Multiply(Scalar);
  }
EXPORT void _wrap_Geom2d_VectorWithMagnitude_Multiply (Handle_Geom2d_VectorWithMagnitude *larg1, Standard_Real larg2) {
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_VectorWithMagnitude_Multiply(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_Multiply\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_Multiply\n  * fulldecl: void Handle_Geom2d_VectorWithMagnitude::Multiply(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_VectorWithMagnitude_Normalize(Handle_Geom2d_VectorWithMagnitude *self){
    (*self)->Normalize();
  }
EXPORT void _wrap_Geom2d_VectorWithMagnitude_Normalize (Handle_Geom2d_VectorWithMagnitude *larg1) {
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_VectorWithMagnitude_Normalize(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_Normalize\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_Normalize\n  * fulldecl: void Handle_Geom2d_VectorWithMagnitude::Normalize()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_VectorWithMagnitude Handle_Geom2d_VectorWithMagnitude_Normalized(Handle_Geom2d_VectorWithMagnitude *self){
    return (*self)->Normalized();
  }
EXPORT Handle_Geom2d_VectorWithMagnitude *_wrap_Geom2d_VectorWithMagnitude_Normalized (Handle_Geom2d_VectorWithMagnitude *larg1) {
  Handle_Geom2d_VectorWithMagnitude * lresult = (Handle_Geom2d_VectorWithMagnitude *)0 ;
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  SwigValueWrapper< Handle_Geom2d_VectorWithMagnitude > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_VectorWithMagnitude_Normalized(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_Normalized\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_Normalized\n  * fulldecl: Handle_Geom2d_VectorWithMagnitude Handle_Geom2d_VectorWithMagnitude::Normalized()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_VectorWithMagnitude(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_VectorWithMagnitude *)0;
  }
}


SWIGINTERN void Handle_Geom2d_VectorWithMagnitude_Subtract(Handle_Geom2d_VectorWithMagnitude *self,Handle_Geom2d_Vector const &Other){
    (*self)->Subtract(Other);
  }
EXPORT void _wrap_Geom2d_VectorWithMagnitude_Subtract (Handle_Geom2d_VectorWithMagnitude *larg1, Handle_Geom2d_Vector *larg2) {
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  Handle_Geom2d_Vector *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_VectorWithMagnitude_Subtract(arg1,(Handle_Geom2d_Vector const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_Subtract\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_Subtract\n  * fulldecl: void Handle_Geom2d_VectorWithMagnitude::Subtract(Handle_Geom2d_Vector const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_VectorWithMagnitude Handle_Geom2d_VectorWithMagnitude_Subtracted(Handle_Geom2d_VectorWithMagnitude *self,Handle_Geom2d_Vector const &Other){
    return (*self)->Subtracted(Other);
  }
EXPORT Handle_Geom2d_VectorWithMagnitude *_wrap_Geom2d_VectorWithMagnitude_Subtracted (Handle_Geom2d_VectorWithMagnitude *larg1, Handle_Geom2d_Vector *larg2) {
  Handle_Geom2d_VectorWithMagnitude * lresult = (Handle_Geom2d_VectorWithMagnitude *)0 ;
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  Handle_Geom2d_Vector *arg2 = 0 ;
  SwigValueWrapper< Handle_Geom2d_VectorWithMagnitude > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_VectorWithMagnitude_Subtracted(arg1,(Handle_Geom2d_Vector const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_Subtracted\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_Subtracted\n  * fulldecl: Handle_Geom2d_VectorWithMagnitude Handle_Geom2d_VectorWithMagnitude::Subtracted(Handle_Geom2d_Vector const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_VectorWithMagnitude(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_VectorWithMagnitude *)0;
  }
}


SWIGINTERN void Handle_Geom2d_VectorWithMagnitude_Transform(Handle_Geom2d_VectorWithMagnitude *self,gp_Trsf2d const &T){
    (*self)->Transform(T);
  }
EXPORT void _wrap_Geom2d_VectorWithMagnitude_Transform (Handle_Geom2d_VectorWithMagnitude *larg1, gp_Trsf2d *larg2) {
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_VectorWithMagnitude_Transform(arg1,(gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_Transform\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_Transform\n  * fulldecl: void Handle_Geom2d_VectorWithMagnitude::Transform(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_Geometry Handle_Geom2d_VectorWithMagnitude_Copy(Handle_Geom2d_VectorWithMagnitude *self){
    return (*self)->Copy();
  }
EXPORT Handle_Geom2d_Geometry *_wrap_Geom2d_VectorWithMagnitude_Copy (Handle_Geom2d_VectorWithMagnitude *larg1) {
  Handle_Geom2d_Geometry * lresult = (Handle_Geom2d_Geometry *)0 ;
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  SwigValueWrapper< Handle_Geom2d_Geometry > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_VectorWithMagnitude_Copy(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_Copy\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_Copy\n  * fulldecl: Handle_Geom2d_Geometry Handle_Geom2d_VectorWithMagnitude::Copy()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Geometry *)0;
  }
}


SWIGINTERN Handle_Geom2d_Direction *new_Handle_Geom2d_Direction__SWIG_0(Standard_Real const X,Standard_Real const Y){
    return new Handle_Geom2d_Direction(new Geom2d_Direction(X, Y));
  }
EXPORT Handle_Geom2d_Direction *_wrap_new_Geom2d_Direction__SWIG_0 (Standard_Real larg1, Standard_Real larg2) {
  Handle_Geom2d_Direction * lresult = (Handle_Geom2d_Direction *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  Handle_Geom2d_Direction *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Direction *)new_Handle_Geom2d_Direction__SWIG_0(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Direction\n  * wrapname: _wrap_new_Geom2d_Direction__SWIG_0\n  * fulldecl: Handle_Geom2d_Direction::Handle_Geom2d_Direction(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Direction *)0;
  }
}


SWIGINTERN Handle_Geom2d_Direction *new_Handle_Geom2d_Direction__SWIG_1(gp_Dir2d const &V){
    return new Handle_Geom2d_Direction(new Geom2d_Direction(V));
  }
EXPORT Handle_Geom2d_Direction *_wrap_new_Geom2d_Direction__SWIG_1 (gp_Dir2d *larg1) {
  Handle_Geom2d_Direction * lresult = (Handle_Geom2d_Direction *)0 ;
  gp_Dir2d *arg1 = 0 ;
  Handle_Geom2d_Direction *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Direction *)new_Handle_Geom2d_Direction__SWIG_1((gp_Dir2d const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Direction\n  * wrapname: _wrap_new_Geom2d_Direction__SWIG_1\n  * fulldecl: Handle_Geom2d_Direction::Handle_Geom2d_Direction(gp_Dir2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Direction *)0;
  }
}


SWIGINTERN void Handle_Geom2d_Direction_Delete(Handle_Geom2d_Direction *self){
    self->~Handle_Geom2d_Direction();
  }
EXPORT void _wrap_Geom2d_Direction_Delete (Handle_Geom2d_Direction *larg1) {
  Handle_Geom2d_Direction *arg1 = (Handle_Geom2d_Direction *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Direction_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Direction_Delete\n  * wrapname: _wrap_Geom2d_Direction_Delete\n  * fulldecl: void Handle_Geom2d_Direction::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Direction_SetCoord(Handle_Geom2d_Direction *self,Standard_Real const X,Standard_Real const Y){
    (*self)->SetCoord(X, Y);
  }
EXPORT void _wrap_Geom2d_Direction_SetCoord (Handle_Geom2d_Direction *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom2d_Direction *arg1 = (Handle_Geom2d_Direction *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Direction_SetCoord(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Direction_SetCoord\n  * wrapname: _wrap_Geom2d_Direction_SetCoord\n  * fulldecl: void Handle_Geom2d_Direction::SetCoord(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Direction_SetDir2d(Handle_Geom2d_Direction *self,gp_Dir2d const &V){
    (*self)->SetDir2d(V);
  }
EXPORT void _wrap_Geom2d_Direction_SetDir2d (Handle_Geom2d_Direction *larg1, gp_Dir2d *larg2) {
  Handle_Geom2d_Direction *arg1 = (Handle_Geom2d_Direction *) 0 ;
  gp_Dir2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Direction_SetDir2d(arg1,(gp_Dir2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Direction_SetDir2d\n  * wrapname: _wrap_Geom2d_Direction_SetDir2d\n  * fulldecl: void Handle_Geom2d_Direction::SetDir2d(gp_Dir2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Direction_SetX(Handle_Geom2d_Direction *self,Standard_Real const X){
    (*self)->SetX(X);
  }
EXPORT void _wrap_Geom2d_Direction_SetX (Handle_Geom2d_Direction *larg1, Standard_Real larg2) {
  Handle_Geom2d_Direction *arg1 = (Handle_Geom2d_Direction *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Direction_SetX(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Direction_SetX\n  * wrapname: _wrap_Geom2d_Direction_SetX\n  * fulldecl: void Handle_Geom2d_Direction::SetX(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Direction_SetY(Handle_Geom2d_Direction *self,Standard_Real const Y){
    (*self)->SetY(Y);
  }
EXPORT void _wrap_Geom2d_Direction_SetY (Handle_Geom2d_Direction *larg1, Standard_Real larg2) {
  Handle_Geom2d_Direction *arg1 = (Handle_Geom2d_Direction *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Direction_SetY(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Direction_SetY\n  * wrapname: _wrap_Geom2d_Direction_SetY\n  * fulldecl: void Handle_Geom2d_Direction::SetY(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Dir2d Handle_Geom2d_Direction_Dir2d(Handle_Geom2d_Direction *self){
    return (*self)->Dir2d();
  }
EXPORT gp_Dir2d *_wrap_Geom2d_Direction_Dir2d (Handle_Geom2d_Direction *larg1) {
  gp_Dir2d * lresult = (gp_Dir2d *)0 ;
  Handle_Geom2d_Direction *arg1 = (Handle_Geom2d_Direction *) 0 ;
  gp_Dir2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Direction_Dir2d(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Direction_Dir2d\n  * wrapname: _wrap_Geom2d_Direction_Dir2d\n  * fulldecl: gp_Dir2d Handle_Geom2d_Direction::Dir2d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Dir2d(result);
    return lresult;
  } catch (...) {
    return (gp_Dir2d *)0;
  }
}


SWIGINTERN Handle_Geom2d_AxisPlacement *new_Handle_Geom2d_AxisPlacement__SWIG_0(gp_Ax2d const &A){
    return new Handle_Geom2d_AxisPlacement(new Geom2d_AxisPlacement(A));
  }
EXPORT Handle_Geom2d_AxisPlacement *_wrap_new_Geom2d_AxisPlacement__SWIG_0 (gp_Ax2d *larg1) {
  Handle_Geom2d_AxisPlacement * lresult = (Handle_Geom2d_AxisPlacement *)0 ;
  gp_Ax2d *arg1 = 0 ;
  Handle_Geom2d_AxisPlacement *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_AxisPlacement *)new_Handle_Geom2d_AxisPlacement__SWIG_0((gp_Ax2d const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_AxisPlacement\n  * wrapname: _wrap_new_Geom2d_AxisPlacement__SWIG_0\n  * fulldecl: Handle_Geom2d_AxisPlacement::Handle_Geom2d_AxisPlacement(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_AxisPlacement *)0;
  }
}


SWIGINTERN Handle_Geom2d_AxisPlacement *new_Handle_Geom2d_AxisPlacement__SWIG_1(gp_Pnt2d const &P,gp_Dir2d const &V){
    return new Handle_Geom2d_AxisPlacement(new Geom2d_AxisPlacement(P, V));
  }
EXPORT Handle_Geom2d_AxisPlacement *_wrap_new_Geom2d_AxisPlacement__SWIG_1 (gp_Pnt2d *larg1, gp_Dir2d *larg2) {
  Handle_Geom2d_AxisPlacement * lresult = (Handle_Geom2d_AxisPlacement *)0 ;
  gp_Pnt2d *arg1 = 0 ;
  gp_Dir2d *arg2 = 0 ;
  Handle_Geom2d_AxisPlacement *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_AxisPlacement *)new_Handle_Geom2d_AxisPlacement__SWIG_1((gp_Pnt2d const &)*arg1,(gp_Dir2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_AxisPlacement\n  * wrapname: _wrap_new_Geom2d_AxisPlacement__SWIG_1\n  * fulldecl: Handle_Geom2d_AxisPlacement::Handle_Geom2d_AxisPlacement(gp_Pnt2d const &,gp_Dir2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_AxisPlacement *)0;
  }
}


SWIGINTERN void Handle_Geom2d_AxisPlacement_Delete(Handle_Geom2d_AxisPlacement *self){
    self->~Handle_Geom2d_AxisPlacement();
  }
EXPORT void _wrap_Geom2d_AxisPlacement_Delete (Handle_Geom2d_AxisPlacement *larg1) {
  Handle_Geom2d_AxisPlacement *arg1 = (Handle_Geom2d_AxisPlacement *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_AxisPlacement_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_AxisPlacement_Delete\n  * wrapname: _wrap_Geom2d_AxisPlacement_Delete\n  * fulldecl: void Handle_Geom2d_AxisPlacement::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_AxisPlacement_Reverse(Handle_Geom2d_AxisPlacement *self){
    (*self)->Reverse();
  }
EXPORT void _wrap_Geom2d_AxisPlacement_Reverse (Handle_Geom2d_AxisPlacement *larg1) {
  Handle_Geom2d_AxisPlacement *arg1 = (Handle_Geom2d_AxisPlacement *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_AxisPlacement_Reverse(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_AxisPlacement_Reverse\n  * wrapname: _wrap_Geom2d_AxisPlacement_Reverse\n  * fulldecl: void Handle_Geom2d_AxisPlacement::Reverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_AxisPlacement Handle_Geom2d_AxisPlacement_Reversed(Handle_Geom2d_AxisPlacement *self){
    return (*self)->Reversed();
  }
EXPORT Handle_Geom2d_AxisPlacement *_wrap_Geom2d_AxisPlacement_Reversed (Handle_Geom2d_AxisPlacement *larg1) {
  Handle_Geom2d_AxisPlacement * lresult = (Handle_Geom2d_AxisPlacement *)0 ;
  Handle_Geom2d_AxisPlacement *arg1 = (Handle_Geom2d_AxisPlacement *) 0 ;
  SwigValueWrapper< Handle_Geom2d_AxisPlacement > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_AxisPlacement_Reversed(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_AxisPlacement_Reversed\n  * wrapname: _wrap_Geom2d_AxisPlacement_Reversed\n  * fulldecl: Handle_Geom2d_AxisPlacement Handle_Geom2d_AxisPlacement::Reversed()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_AxisPlacement(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_AxisPlacement *)0;
  }
}


SWIGINTERN void Handle_Geom2d_AxisPlacement_SetAxis(Handle_Geom2d_AxisPlacement *self,gp_Ax2d const &A){
    (*self)->SetAxis(A);
  }
EXPORT void _wrap_Geom2d_AxisPlacement_SetAxis (Handle_Geom2d_AxisPlacement *larg1, gp_Ax2d *larg2) {
  Handle_Geom2d_AxisPlacement *arg1 = (Handle_Geom2d_AxisPlacement *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_AxisPlacement_SetAxis(arg1,(gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_AxisPlacement_SetAxis\n  * wrapname: _wrap_Geom2d_AxisPlacement_SetAxis\n  * fulldecl: void Handle_Geom2d_AxisPlacement::SetAxis(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_AxisPlacement_SetDirection(Handle_Geom2d_AxisPlacement *self,gp_Dir2d const &V){
    (*self)->SetDirection(V);
  }
EXPORT void _wrap_Geom2d_AxisPlacement_SetDirection (Handle_Geom2d_AxisPlacement *larg1, gp_Dir2d *larg2) {
  Handle_Geom2d_AxisPlacement *arg1 = (Handle_Geom2d_AxisPlacement *) 0 ;
  gp_Dir2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_AxisPlacement_SetDirection(arg1,(gp_Dir2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_AxisPlacement_SetDirection\n  * wrapname: _wrap_Geom2d_AxisPlacement_SetDirection\n  * fulldecl: void Handle_Geom2d_AxisPlacement::SetDirection(gp_Dir2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_AxisPlacement_SetLocation(Handle_Geom2d_AxisPlacement *self,gp_Pnt2d const &P){
    (*self)->SetLocation(P);
  }
EXPORT void _wrap_Geom2d_AxisPlacement_SetLocation (Handle_Geom2d_AxisPlacement *larg1, gp_Pnt2d *larg2) {
  Handle_Geom2d_AxisPlacement *arg1 = (Handle_Geom2d_AxisPlacement *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_AxisPlacement_SetLocation(arg1,(gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_AxisPlacement_SetLocation\n  * wrapname: _wrap_Geom2d_AxisPlacement_SetLocation\n  * fulldecl: void Handle_Geom2d_AxisPlacement::SetLocation(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_AxisPlacement_Angle(Handle_Geom2d_AxisPlacement *self,Handle_Geom2d_AxisPlacement const &Other){
    return (*self)->Angle(Other);
  }
EXPORT Standard_Real _wrap_Geom2d_AxisPlacement_Angle (Handle_Geom2d_AxisPlacement *larg1, Handle_Geom2d_AxisPlacement *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_AxisPlacement *arg1 = (Handle_Geom2d_AxisPlacement *) 0 ;
  Handle_Geom2d_AxisPlacement *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_AxisPlacement_Angle(arg1,(Handle_Geom2d_AxisPlacement const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_AxisPlacement_Angle\n  * wrapname: _wrap_Geom2d_AxisPlacement_Angle\n  * fulldecl: Standard_Real Handle_Geom2d_AxisPlacement::Angle(Handle_Geom2d_AxisPlacement const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN gp_Ax2d Handle_Geom2d_AxisPlacement_Ax2d(Handle_Geom2d_AxisPlacement *self){
    return (*self)->Ax2d();
  }
EXPORT gp_Ax2d *_wrap_Geom2d_AxisPlacement_Ax2d (Handle_Geom2d_AxisPlacement *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  Handle_Geom2d_AxisPlacement *arg1 = (Handle_Geom2d_AxisPlacement *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_AxisPlacement_Ax2d(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_AxisPlacement_Ax2d\n  * wrapname: _wrap_Geom2d_AxisPlacement_Ax2d\n  * fulldecl: gp_Ax2d Handle_Geom2d_AxisPlacement::Ax2d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


SWIGINTERN gp_Dir2d Handle_Geom2d_AxisPlacement_Direction(Handle_Geom2d_AxisPlacement *self){
    return (*self)->Direction();
  }
EXPORT gp_Dir2d *_wrap_Geom2d_AxisPlacement_Direction (Handle_Geom2d_AxisPlacement *larg1) {
  gp_Dir2d * lresult = (gp_Dir2d *)0 ;
  Handle_Geom2d_AxisPlacement *arg1 = (Handle_Geom2d_AxisPlacement *) 0 ;
  gp_Dir2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_AxisPlacement_Direction(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_AxisPlacement_Direction\n  * wrapname: _wrap_Geom2d_AxisPlacement_Direction\n  * fulldecl: gp_Dir2d Handle_Geom2d_AxisPlacement::Direction()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Dir2d(result);
    return lresult;
  } catch (...) {
    return (gp_Dir2d *)0;
  }
}


SWIGINTERN gp_Pnt2d Handle_Geom2d_AxisPlacement_Location(Handle_Geom2d_AxisPlacement *self){
    return (*self)->Location();
  }
EXPORT gp_Pnt2d *_wrap_Geom2d_AxisPlacement_Location (Handle_Geom2d_AxisPlacement *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Handle_Geom2d_AxisPlacement *arg1 = (Handle_Geom2d_AxisPlacement *) 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_AxisPlacement_Location(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_AxisPlacement_Location\n  * wrapname: _wrap_Geom2d_AxisPlacement_Location\n  * fulldecl: gp_Pnt2d Handle_Geom2d_AxisPlacement::Location()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


SWIGINTERN Handle_Geom2d_Transformation *new_Handle_Geom2d_Transformation__SWIG_0(){
    return new Handle_Geom2d_Transformation(new Geom2d_Transformation());
  }
EXPORT Handle_Geom2d_Transformation *_wrap_new_Geom2d_Transformation__SWIG_0 () {
  Handle_Geom2d_Transformation * lresult = (Handle_Geom2d_Transformation *)0 ;
  Handle_Geom2d_Transformation *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Transformation *)new_Handle_Geom2d_Transformation__SWIG_0();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Transformation\n  * wrapname: _wrap_new_Geom2d_Transformation__SWIG_0\n  * fulldecl: Handle_Geom2d_Transformation::Handle_Geom2d_Transformation()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Transformation *)0;
  }
}


SWIGINTERN Handle_Geom2d_Transformation *new_Handle_Geom2d_Transformation__SWIG_1(gp_Trsf2d const &T){
    return new Handle_Geom2d_Transformation(new Geom2d_Transformation(T));
  }
EXPORT Handle_Geom2d_Transformation *_wrap_new_Geom2d_Transformation__SWIG_1 (gp_Trsf2d *larg1) {
  Handle_Geom2d_Transformation * lresult = (Handle_Geom2d_Transformation *)0 ;
  gp_Trsf2d *arg1 = 0 ;
  Handle_Geom2d_Transformation *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Transformation *)new_Handle_Geom2d_Transformation__SWIG_1((gp_Trsf2d const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Transformation\n  * wrapname: _wrap_new_Geom2d_Transformation__SWIG_1\n  * fulldecl: Handle_Geom2d_Transformation::Handle_Geom2d_Transformation(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Transformation *)0;
  }
}


SWIGINTERN void Handle_Geom2d_Transformation_Delete(Handle_Geom2d_Transformation *self){
    self->~Handle_Geom2d_Transformation();
  }
EXPORT void _wrap_Geom2d_Transformation_Delete (Handle_Geom2d_Transformation *larg1) {
  Handle_Geom2d_Transformation *arg1 = (Handle_Geom2d_Transformation *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Transformation_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Transformation_Delete\n  * wrapname: _wrap_Geom2d_Transformation_Delete\n  * fulldecl: void Handle_Geom2d_Transformation::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Transformation_SetMirror__SWIG_0(Handle_Geom2d_Transformation *self,gp_Pnt2d const &P){
    (*self)->SetMirror(P);
  }
EXPORT void _wrap_Geom2d_Transformation_SetMirror__SWIG_0 (Handle_Geom2d_Transformation *larg1, gp_Pnt2d *larg2) {
  Handle_Geom2d_Transformation *arg1 = (Handle_Geom2d_Transformation *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Transformation_SetMirror__SWIG_0(arg1,(gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Transformation_SetMirror\n  * wrapname: _wrap_Geom2d_Transformation_SetMirror__SWIG_0\n  * fulldecl: void Handle_Geom2d_Transformation::SetMirror(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Transformation_SetMirror__SWIG_1(Handle_Geom2d_Transformation *self,gp_Ax2d const &A){
    (*self)->SetMirror(A);
  }
EXPORT void _wrap_Geom2d_Transformation_SetMirror__SWIG_1 (Handle_Geom2d_Transformation *larg1, gp_Ax2d *larg2) {
  Handle_Geom2d_Transformation *arg1 = (Handle_Geom2d_Transformation *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Transformation_SetMirror__SWIG_1(arg1,(gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Transformation_SetMirror\n  * wrapname: _wrap_Geom2d_Transformation_SetMirror__SWIG_1\n  * fulldecl: void Handle_Geom2d_Transformation::SetMirror(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Transformation_SetRotation(Handle_Geom2d_Transformation *self,gp_Pnt2d const &P,Standard_Real const Ang){
    (*self)->SetRotation(P, Ang);
  }
EXPORT void _wrap_Geom2d_Transformation_SetRotation (Handle_Geom2d_Transformation *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  Handle_Geom2d_Transformation *arg1 = (Handle_Geom2d_Transformation *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Transformation_SetRotation(arg1,(gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Transformation_SetRotation\n  * wrapname: _wrap_Geom2d_Transformation_SetRotation\n  * fulldecl: void Handle_Geom2d_Transformation::SetRotation(gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Transformation_SetScale(Handle_Geom2d_Transformation *self,gp_Pnt2d const &P,Standard_Real const S){
    (*self)->SetScale(P, S);
  }
EXPORT void _wrap_Geom2d_Transformation_SetScale (Handle_Geom2d_Transformation *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  Handle_Geom2d_Transformation *arg1 = (Handle_Geom2d_Transformation *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Transformation_SetScale(arg1,(gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Transformation_SetScale\n  * wrapname: _wrap_Geom2d_Transformation_SetScale\n  * fulldecl: void Handle_Geom2d_Transformation::SetScale(gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Transformation_SetTransformation__SWIG_0(Handle_Geom2d_Transformation *self,gp_Ax2d const &FromSystem1,gp_Ax2d const &ToSystem2){
    (*self)->SetTransformation(FromSystem1, ToSystem2);
  }
EXPORT void _wrap_Geom2d_Transformation_SetTransformation__SWIG_0 (Handle_Geom2d_Transformation *larg1, gp_Ax2d *larg2, gp_Ax2d *larg3) {
  Handle_Geom2d_Transformation *arg1 = (Handle_Geom2d_Transformation *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  gp_Ax2d *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Transformation_SetTransformation__SWIG_0(arg1,(gp_Ax2d const &)*arg2,(gp_Ax2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Transformation_SetTransformation\n  * wrapname: _wrap_Geom2d_Transformation_SetTransformation__SWIG_0\n  * fulldecl: void Handle_Geom2d_Transformation::SetTransformation(gp_Ax2d const &,gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Transformation_SetTransformation__SWIG_1(Handle_Geom2d_Transformation *self,gp_Ax2d const &ToSystem){
    (*self)->SetTransformation(ToSystem);
  }
EXPORT void _wrap_Geom2d_Transformation_SetTransformation__SWIG_1 (Handle_Geom2d_Transformation *larg1, gp_Ax2d *larg2) {
  Handle_Geom2d_Transformation *arg1 = (Handle_Geom2d_Transformation *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Transformation_SetTransformation__SWIG_1(arg1,(gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Transformation_SetTransformation\n  * wrapname: _wrap_Geom2d_Transformation_SetTransformation__SWIG_1\n  * fulldecl: void Handle_Geom2d_Transformation::SetTransformation(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Transformation_SetTranslation__SWIG_0(Handle_Geom2d_Transformation *self,gp_Vec2d const &V){
    (*self)->SetTranslation(V);
  }
EXPORT void _wrap_Geom2d_Transformation_SetTranslation__SWIG_0 (Handle_Geom2d_Transformation *larg1, gp_Vec2d *larg2) {
  Handle_Geom2d_Transformation *arg1 = (Handle_Geom2d_Transformation *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Transformation_SetTranslation__SWIG_0(arg1,(gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Transformation_SetTranslation\n  * wrapname: _wrap_Geom2d_Transformation_SetTranslation__SWIG_0\n  * fulldecl: void Handle_Geom2d_Transformation::SetTranslation(gp_Vec2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Transformation_SetTranslation__SWIG_1(Handle_Geom2d_Transformation *self,gp_Pnt2d const &P1,gp_Pnt2d const &P2){
    (*self)->SetTranslation(P1, P2);
  }
EXPORT void _wrap_Geom2d_Transformation_SetTranslation__SWIG_1 (Handle_Geom2d_Transformation *larg1, gp_Pnt2d *larg2, gp_Pnt2d *larg3) {
  Handle_Geom2d_Transformation *arg1 = (Handle_Geom2d_Transformation *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Pnt2d *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Transformation_SetTranslation__SWIG_1(arg1,(gp_Pnt2d const &)*arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Transformation_SetTranslation\n  * wrapname: _wrap_Geom2d_Transformation_SetTranslation__SWIG_1\n  * fulldecl: void Handle_Geom2d_Transformation::SetTranslation(gp_Pnt2d const &,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Transformation_SetTrsf2d(Handle_Geom2d_Transformation *self,gp_Trsf2d const &T){
    (*self)->SetTrsf2d(T);
  }
EXPORT void _wrap_Geom2d_Transformation_SetTrsf2d (Handle_Geom2d_Transformation *larg1, gp_Trsf2d *larg2) {
  Handle_Geom2d_Transformation *arg1 = (Handle_Geom2d_Transformation *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Transformation_SetTrsf2d(arg1,(gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Transformation_SetTrsf2d\n  * wrapname: _wrap_Geom2d_Transformation_SetTrsf2d\n  * fulldecl: void Handle_Geom2d_Transformation::SetTrsf2d(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Boolean Handle_Geom2d_Transformation_IsNegative(Handle_Geom2d_Transformation *self){
    return (*self)->IsNegative();
  }
EXPORT bool _wrap_Geom2d_Transformation_IsNegative (Handle_Geom2d_Transformation *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom2d_Transformation *arg1 = (Handle_Geom2d_Transformation *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom2d_Transformation_IsNegative(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Transformation_IsNegative\n  * wrapname: _wrap_Geom2d_Transformation_IsNegative\n  * fulldecl: Standard_Boolean Handle_Geom2d_Transformation::IsNegative()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN gp_TrsfForm Handle_Geom2d_Transformation_Form(Handle_Geom2d_Transformation *self){
    return (*self)->Form();
  }
EXPORT gp_TrsfForm _wrap_Geom2d_Transformation_Form (Handle_Geom2d_Transformation *larg1) {
  gp_TrsfForm lresult = (gp_TrsfForm)0 ;
  Handle_Geom2d_Transformation *arg1 = (Handle_Geom2d_Transformation *) 0 ;
  gp_TrsfForm result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_TrsfForm)Handle_Geom2d_Transformation_Form(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Transformation_Form\n  * wrapname: _wrap_Geom2d_Transformation_Form\n  * fulldecl: gp_TrsfForm Handle_Geom2d_Transformation::Form()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_TrsfForm)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Transformation_ScaleFactor(Handle_Geom2d_Transformation *self){
    return (*self)->ScaleFactor();
  }
EXPORT Standard_Real _wrap_Geom2d_Transformation_ScaleFactor (Handle_Geom2d_Transformation *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Transformation *arg1 = (Handle_Geom2d_Transformation *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Transformation_ScaleFactor(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Transformation_ScaleFactor\n  * wrapname: _wrap_Geom2d_Transformation_ScaleFactor\n  * fulldecl: Standard_Real Handle_Geom2d_Transformation::ScaleFactor()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN gp_Trsf2d Handle_Geom2d_Transformation_Trsf2d(Handle_Geom2d_Transformation *self){
    return (*self)->Trsf2d();
  }
EXPORT gp_Trsf2d *_wrap_Geom2d_Transformation_Trsf2d (Handle_Geom2d_Transformation *larg1) {
  gp_Trsf2d * lresult = (gp_Trsf2d *)0 ;
  Handle_Geom2d_Transformation *arg1 = (Handle_Geom2d_Transformation *) 0 ;
  gp_Trsf2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Transformation_Trsf2d(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Transformation_Trsf2d\n  * wrapname: _wrap_Geom2d_Transformation_Trsf2d\n  * fulldecl: gp_Trsf2d Handle_Geom2d_Transformation::Trsf2d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Trsf2d(result);
    return lresult;
  } catch (...) {
    return (gp_Trsf2d *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Transformation_Value(Handle_Geom2d_Transformation *self,Standard_Integer const Row,Standard_Integer const Col){
    return (*self)->Value(Row, Col);
  }
EXPORT Standard_Real _wrap_Geom2d_Transformation_Value (Handle_Geom2d_Transformation *larg1, Standard_Integer larg2, Standard_Integer larg3) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Transformation *arg1 = (Handle_Geom2d_Transformation *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Transformation_Value(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Transformation_Value\n  * wrapname: _wrap_Geom2d_Transformation_Value\n  * fulldecl: Standard_Real Handle_Geom2d_Transformation::Value(Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN void Handle_Geom2d_Transformation_Invert(Handle_Geom2d_Transformation *self){
    (*self)->Invert();
  }
EXPORT void _wrap_Geom2d_Transformation_Invert (Handle_Geom2d_Transformation *larg1) {
  Handle_Geom2d_Transformation *arg1 = (Handle_Geom2d_Transformation *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Transformation_Invert(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Transformation_Invert\n  * wrapname: _wrap_Geom2d_Transformation_Invert\n  * fulldecl: void Handle_Geom2d_Transformation::Invert()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_Transformation Handle_Geom2d_Transformation_Inverted(Handle_Geom2d_Transformation *self){
    return (*self)->Inverted();
  }
EXPORT Handle_Geom2d_Transformation *_wrap_Geom2d_Transformation_Inverted (Handle_Geom2d_Transformation *larg1) {
  Handle_Geom2d_Transformation * lresult = (Handle_Geom2d_Transformation *)0 ;
  Handle_Geom2d_Transformation *arg1 = (Handle_Geom2d_Transformation *) 0 ;
  SwigValueWrapper< Handle_Geom2d_Transformation > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Transformation_Inverted(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Transformation_Inverted\n  * wrapname: _wrap_Geom2d_Transformation_Inverted\n  * fulldecl: Handle_Geom2d_Transformation Handle_Geom2d_Transformation::Inverted()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Transformation(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Transformation *)0;
  }
}


SWIGINTERN Handle_Geom2d_Transformation Handle_Geom2d_Transformation_Multiplied(Handle_Geom2d_Transformation *self,Handle_Geom2d_Transformation const &Other){
    return (*self)->Multiplied(Other);
  }
EXPORT Handle_Geom2d_Transformation *_wrap_Geom2d_Transformation_Multiplied (Handle_Geom2d_Transformation *larg1, Handle_Geom2d_Transformation *larg2) {
  Handle_Geom2d_Transformation * lresult = (Handle_Geom2d_Transformation *)0 ;
  Handle_Geom2d_Transformation *arg1 = (Handle_Geom2d_Transformation *) 0 ;
  Handle_Geom2d_Transformation *arg2 = 0 ;
  SwigValueWrapper< Handle_Geom2d_Transformation > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Transformation_Multiplied(arg1,(Handle_Geom2d_Transformation const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Transformation_Multiplied\n  * wrapname: _wrap_Geom2d_Transformation_Multiplied\n  * fulldecl: Handle_Geom2d_Transformation Handle_Geom2d_Transformation::Multiplied(Handle_Geom2d_Transformation const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Transformation(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Transformation *)0;
  }
}


SWIGINTERN void Handle_Geom2d_Transformation_Multiply(Handle_Geom2d_Transformation *self,Handle_Geom2d_Transformation const &Other){
    (*self)->Multiply(Other);
  }
EXPORT void _wrap_Geom2d_Transformation_Multiply (Handle_Geom2d_Transformation *larg1, Handle_Geom2d_Transformation *larg2) {
  Handle_Geom2d_Transformation *arg1 = (Handle_Geom2d_Transformation *) 0 ;
  Handle_Geom2d_Transformation *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Transformation_Multiply(arg1,(Handle_Geom2d_Transformation const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Transformation_Multiply\n  * wrapname: _wrap_Geom2d_Transformation_Multiply\n  * fulldecl: void Handle_Geom2d_Transformation::Multiply(Handle_Geom2d_Transformation const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Transformation_Power(Handle_Geom2d_Transformation *self,Standard_Integer const N){
    (*self)->Power(N);
  }
EXPORT void _wrap_Geom2d_Transformation_Power (Handle_Geom2d_Transformation *larg1, Standard_Integer larg2) {
  Handle_Geom2d_Transformation *arg1 = (Handle_Geom2d_Transformation *) 0 ;
  Standard_Integer arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Transformation_Power(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Transformation_Power\n  * wrapname: _wrap_Geom2d_Transformation_Power\n  * fulldecl: void Handle_Geom2d_Transformation::Power(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_Transformation Handle_Geom2d_Transformation_Powered(Handle_Geom2d_Transformation *self,Standard_Integer const N){
    return (*self)->Powered(N);
  }
EXPORT Handle_Geom2d_Transformation *_wrap_Geom2d_Transformation_Powered (Handle_Geom2d_Transformation *larg1, Standard_Integer larg2) {
  Handle_Geom2d_Transformation * lresult = (Handle_Geom2d_Transformation *)0 ;
  Handle_Geom2d_Transformation *arg1 = (Handle_Geom2d_Transformation *) 0 ;
  Standard_Integer arg2 ;
  SwigValueWrapper< Handle_Geom2d_Transformation > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Transformation_Powered(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Transformation_Powered\n  * wrapname: _wrap_Geom2d_Transformation_Powered\n  * fulldecl: Handle_Geom2d_Transformation Handle_Geom2d_Transformation::Powered(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Transformation(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Transformation *)0;
  }
}


SWIGINTERN void Handle_Geom2d_Transformation_PreMultiply(Handle_Geom2d_Transformation *self,Handle_Geom2d_Transformation const &Other){
    (*self)->PreMultiply(Other);
  }
EXPORT void _wrap_Geom2d_Transformation_PreMultiply (Handle_Geom2d_Transformation *larg1, Handle_Geom2d_Transformation *larg2) {
  Handle_Geom2d_Transformation *arg1 = (Handle_Geom2d_Transformation *) 0 ;
  Handle_Geom2d_Transformation *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Transformation_PreMultiply(arg1,(Handle_Geom2d_Transformation const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Transformation_PreMultiply\n  * wrapname: _wrap_Geom2d_Transformation_PreMultiply\n  * fulldecl: void Handle_Geom2d_Transformation::PreMultiply(Handle_Geom2d_Transformation const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Transformation_Transforms(Handle_Geom2d_Transformation *self,Standard_Real &X,Standard_Real &Y){
    (*self)->Transforms(X, Y);
  }
EXPORT void _wrap_Geom2d_Transformation_Transforms (Handle_Geom2d_Transformation *larg1, Standard_Real *larg2, Standard_Real *larg3) {
  Handle_Geom2d_Transformation *arg1 = (Handle_Geom2d_Transformation *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Transformation_Transforms(arg1,*arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Transformation_Transforms\n  * wrapname: _wrap_Geom2d_Transformation_Transforms\n  * fulldecl: void Handle_Geom2d_Transformation::Transforms(Standard_Real &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_Transformation Handle_Geom2d_Transformation_Copy(Handle_Geom2d_Transformation *self){
    return (*self)->Copy();
  }
EXPORT Handle_Geom2d_Transformation *_wrap_Geom2d_Transformation_Copy (Handle_Geom2d_Transformation *larg1) {
  Handle_Geom2d_Transformation * lresult = (Handle_Geom2d_Transformation *)0 ;
  Handle_Geom2d_Transformation *arg1 = (Handle_Geom2d_Transformation *) 0 ;
  SwigValueWrapper< Handle_Geom2d_Transformation > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Transformation_Copy(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Transformation_Copy\n  * wrapname: _wrap_Geom2d_Transformation_Copy\n  * fulldecl: Handle_Geom2d_Transformation Handle_Geom2d_Transformation::Copy()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Transformation(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Transformation *)0;
  }
}


SWIGINTERN void Handle_Geom2d_Curve_Reverse(Handle_Geom2d_Curve *self){
    (*self)->Reverse();
  }
EXPORT void _wrap_Geom2d_Curve_Reverse (Handle_Geom2d_Curve *larg1) {
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Curve_Reverse(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_Reverse\n  * wrapname: _wrap_Geom2d_Curve_Reverse\n  * fulldecl: void Handle_Geom2d_Curve::Reverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Curve_ReversedParameter(Handle_Geom2d_Curve *self,Standard_Real const U){
    return (*self)->ReversedParameter(U);
  }
EXPORT Standard_Real _wrap_Geom2d_Curve_ReversedParameter (Handle_Geom2d_Curve *larg1, Standard_Real larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  Standard_Real arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Curve_ReversedParameter(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_ReversedParameter\n  * wrapname: _wrap_Geom2d_Curve_ReversedParameter\n  * fulldecl: Standard_Real Handle_Geom2d_Curve::ReversedParameter(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Curve_TransformedParameter(Handle_Geom2d_Curve *self,Standard_Real const U,gp_Trsf2d const &T){
    return (*self)->TransformedParameter(U, T);
  }
EXPORT Standard_Real _wrap_Geom2d_Curve_TransformedParameter (Handle_Geom2d_Curve *larg1, Standard_Real larg2, gp_Trsf2d *larg3) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Trsf2d *arg3 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Curve_TransformedParameter(arg1,arg2,(gp_Trsf2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_TransformedParameter\n  * wrapname: _wrap_Geom2d_Curve_TransformedParameter\n  * fulldecl: Standard_Real Handle_Geom2d_Curve::TransformedParameter(Standard_Real const,gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Curve_ParametricTransformation(Handle_Geom2d_Curve *self,gp_Trsf2d const &T){
    return (*self)->ParametricTransformation(T);
  }
EXPORT Standard_Real _wrap_Geom2d_Curve_ParametricTransformation (Handle_Geom2d_Curve *larg1, gp_Trsf2d *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Curve_ParametricTransformation(arg1,(gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_ParametricTransformation\n  * wrapname: _wrap_Geom2d_Curve_ParametricTransformation\n  * fulldecl: Standard_Real Handle_Geom2d_Curve::ParametricTransformation(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Handle_Geom2d_Curve Handle_Geom2d_Curve_Reversed(Handle_Geom2d_Curve *self){
    return (*self)->Reversed();
  }
EXPORT Handle_Geom2d_Curve *_wrap_Geom2d_Curve_Reversed (Handle_Geom2d_Curve *larg1) {
  Handle_Geom2d_Curve * lresult = (Handle_Geom2d_Curve *)0 ;
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  SwigValueWrapper< Handle_Geom2d_Curve > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Curve_Reversed(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_Reversed\n  * wrapname: _wrap_Geom2d_Curve_Reversed\n  * fulldecl: Handle_Geom2d_Curve Handle_Geom2d_Curve::Reversed()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Curve(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Curve *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Curve_FirstParameter(Handle_Geom2d_Curve *self){
    return (*self)->FirstParameter();
  }
EXPORT Standard_Real _wrap_Geom2d_Curve_FirstParameter (Handle_Geom2d_Curve *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Curve_FirstParameter(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_FirstParameter\n  * wrapname: _wrap_Geom2d_Curve_FirstParameter\n  * fulldecl: Standard_Real Handle_Geom2d_Curve::FirstParameter()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Curve_LastParameter(Handle_Geom2d_Curve *self){
    return (*self)->LastParameter();
  }
EXPORT Standard_Real _wrap_Geom2d_Curve_LastParameter (Handle_Geom2d_Curve *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Curve_LastParameter(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_LastParameter\n  * wrapname: _wrap_Geom2d_Curve_LastParameter\n  * fulldecl: Standard_Real Handle_Geom2d_Curve::LastParameter()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom2d_Curve_IsClosed(Handle_Geom2d_Curve *self){
    return (*self)->IsClosed();
  }
EXPORT bool _wrap_Geom2d_Curve_IsClosed (Handle_Geom2d_Curve *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom2d_Curve_IsClosed(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_IsClosed\n  * wrapname: _wrap_Geom2d_Curve_IsClosed\n  * fulldecl: Standard_Boolean Handle_Geom2d_Curve::IsClosed()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom2d_Curve_IsPeriodic(Handle_Geom2d_Curve *self){
    return (*self)->IsPeriodic();
  }
EXPORT bool _wrap_Geom2d_Curve_IsPeriodic (Handle_Geom2d_Curve *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom2d_Curve_IsPeriodic(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_IsPeriodic\n  * wrapname: _wrap_Geom2d_Curve_IsPeriodic\n  * fulldecl: Standard_Boolean Handle_Geom2d_Curve::IsPeriodic()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Curve_Period(Handle_Geom2d_Curve *self){
    return (*self)->Period();
  }
EXPORT Standard_Real _wrap_Geom2d_Curve_Period (Handle_Geom2d_Curve *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Curve_Period(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_Period\n  * wrapname: _wrap_Geom2d_Curve_Period\n  * fulldecl: Standard_Real Handle_Geom2d_Curve::Period()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN GeomAbs_Shape Handle_Geom2d_Curve_Continuity(Handle_Geom2d_Curve *self){
    return (*self)->Continuity();
  }
EXPORT GeomAbs_Shape _wrap_Geom2d_Curve_Continuity (Handle_Geom2d_Curve *larg1) {
  GeomAbs_Shape lresult = (GeomAbs_Shape)0 ;
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  GeomAbs_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAbs_Shape)Handle_Geom2d_Curve_Continuity(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_Continuity\n  * wrapname: _wrap_Geom2d_Curve_Continuity\n  * fulldecl: GeomAbs_Shape Handle_Geom2d_Curve::Continuity()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAbs_Shape)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom2d_Curve_IsCN(Handle_Geom2d_Curve *self,Standard_Integer const N){
    return (*self)->IsCN(N);
  }
EXPORT bool _wrap_Geom2d_Curve_IsCN (Handle_Geom2d_Curve *larg1, Standard_Integer larg2) {
  bool lresult = (bool)0 ;
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom2d_Curve_IsCN(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_IsCN\n  * wrapname: _wrap_Geom2d_Curve_IsCN\n  * fulldecl: Standard_Boolean Handle_Geom2d_Curve::IsCN(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN void Handle_Geom2d_Curve_D0(Handle_Geom2d_Curve *self,Standard_Real const U,gp_Pnt2d &P){
    (*self)->D0(U, P);
  }
EXPORT void _wrap_Geom2d_Curve_D0 (Handle_Geom2d_Curve *larg1, Standard_Real larg2, gp_Pnt2d *larg3) {
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Curve_D0(arg1,arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_D0\n  * wrapname: _wrap_Geom2d_Curve_D0\n  * fulldecl: void Handle_Geom2d_Curve::D0(Standard_Real const,gp_Pnt2d &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Curve_D1(Handle_Geom2d_Curve *self,Standard_Real const U,gp_Pnt2d &P,gp_Vec2d &V1){
    (*self)->D1(U, P, V1);
  }
EXPORT void _wrap_Geom2d_Curve_D1 (Handle_Geom2d_Curve *larg1, Standard_Real larg2, gp_Pnt2d *larg3, gp_Vec2d *larg4) {
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  gp_Vec2d *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Curve_D1(arg1,arg2,*arg3,*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_D1\n  * wrapname: _wrap_Geom2d_Curve_D1\n  * fulldecl: void Handle_Geom2d_Curve::D1(Standard_Real const,gp_Pnt2d &,gp_Vec2d &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Curve_D2(Handle_Geom2d_Curve *self,Standard_Real const U,gp_Pnt2d &P,gp_Vec2d &V1,gp_Vec2d &V2){
    (*self)->D2(U, P, V1, V2);
  }
EXPORT void _wrap_Geom2d_Curve_D2 (Handle_Geom2d_Curve *larg1, Standard_Real larg2, gp_Pnt2d *larg3, gp_Vec2d *larg4, gp_Vec2d *larg5) {
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  gp_Vec2d *arg4 = 0 ;
  gp_Vec2d *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Curve_D2(arg1,arg2,*arg3,*arg4,*arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_D2\n  * wrapname: _wrap_Geom2d_Curve_D2\n  * fulldecl: void Handle_Geom2d_Curve::D2(Standard_Real const,gp_Pnt2d &,gp_Vec2d &,gp_Vec2d &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Curve_D3(Handle_Geom2d_Curve *self,Standard_Real const U,gp_Pnt2d &P,gp_Vec2d &V1,gp_Vec2d &V2,gp_Vec2d &V3){
    (*self)->D3(U, P, V1, V2, V3);
  }
EXPORT void _wrap_Geom2d_Curve_D3 (Handle_Geom2d_Curve *larg1, Standard_Real larg2, gp_Pnt2d *larg3, gp_Vec2d *larg4, gp_Vec2d *larg5, gp_Vec2d *larg6) {
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  gp_Vec2d *arg4 = 0 ;
  gp_Vec2d *arg5 = 0 ;
  gp_Vec2d *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Curve_D3(arg1,arg2,*arg3,*arg4,*arg5,*arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_D3\n  * wrapname: _wrap_Geom2d_Curve_D3\n  * fulldecl: void Handle_Geom2d_Curve::D3(Standard_Real const,gp_Pnt2d &,gp_Vec2d &,gp_Vec2d &,gp_Vec2d &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Vec2d Handle_Geom2d_Curve_DN(Handle_Geom2d_Curve *self,Standard_Real const U,Standard_Integer const N){
    return (*self)->DN(U, N);
  }
EXPORT gp_Vec2d *_wrap_Geom2d_Curve_DN (Handle_Geom2d_Curve *larg1, Standard_Real larg2, Standard_Integer larg3) {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  Standard_Real arg2 ;
  Standard_Integer arg3 ;
  gp_Vec2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Curve_DN(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_DN\n  * wrapname: _wrap_Geom2d_Curve_DN\n  * fulldecl: gp_Vec2d Handle_Geom2d_Curve::DN(Standard_Real const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec2d(result);
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


SWIGINTERN gp_Pnt2d Handle_Geom2d_Curve_Value(Handle_Geom2d_Curve *self,Standard_Real const U){
    return (*self)->Value(U);
  }
EXPORT gp_Pnt2d *_wrap_Geom2d_Curve_Value (Handle_Geom2d_Curve *larg1, Standard_Real larg2) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Curve_Value(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_Value\n  * wrapname: _wrap_Geom2d_Curve_Value\n  * fulldecl: gp_Pnt2d Handle_Geom2d_Curve::Value(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom2d_Curve_GeometryType(Handle_Geom2d_Curve *self){
    if (STANDARD_TYPE(Geom2d_Line) == (*self)->DynamicType())
      {
	return 300;
      }
    else if (STANDARD_TYPE(Geom2d_Circle) == (*self)->DynamicType())
      {
	return 301;
      }
    else if (STANDARD_TYPE(Geom2d_Ellipse) == (*self)->DynamicType())
      {
	return 302;
      }
    else if (STANDARD_TYPE(Geom2d_Hyperbola) == (*self)->DynamicType())
      {
	return 303;
      }
    else if (STANDARD_TYPE(Geom2d_Parabola) == (*self)->DynamicType())
      {
	return 304;
      }
    else if (STANDARD_TYPE(Geom2d_OffsetCurve) == (*self)->DynamicType())
      {
	return 305;
      }
    else if (STANDARD_TYPE(Geom2d_BezierCurve) == (*self)->DynamicType())
      {
	return 306;
      }
    else if (STANDARD_TYPE(Geom2d_BSplineCurve) == (*self)->DynamicType())
      {
	return 307;
      }
    else if (STANDARD_TYPE(Geom2d_TrimmedCurve) == (*self)->DynamicType())
      {
	return 308;
      }
    else if (STANDARD_TYPE(Bisector_BisecAna) == (*self)->DynamicType())
      {
	return 309;
      }
    else if (STANDARD_TYPE(Bisector_BisecCC) == (*self)->DynamicType())
      {
	return 310;
      }
    else if (STANDARD_TYPE(Bisector_BisecPC) == (*self)->DynamicType())
      {
	return 311;
      }
		
    return -1;
  }
EXPORT Standard_Integer _wrap_Geom2d_Curve_GeometryType (Handle_Geom2d_Curve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom2d_Curve_GeometryType(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_GeometryType\n  * wrapname: _wrap_Geom2d_Curve_GeometryType\n  * fulldecl: Standard_Integer Handle_Geom2d_Curve::GeometryType()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Real Handle_Bisector_Curve_Parameter(Handle_Bisector_Curve *self,gp_Pnt2d const &P){
		return (*self)->Parameter(P);
	}
EXPORT Standard_Real _wrap_Bisector_Curve_Parameter (Handle_Bisector_Curve *larg1, gp_Pnt2d *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Bisector_Curve *arg1 = (Handle_Bisector_Curve *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Bisector_Curve_Parameter(arg1,(gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bisector_Curve_Parameter\n  * wrapname: _wrap_Bisector_Curve_Parameter\n  * fulldecl: Standard_Real Handle_Bisector_Curve::Parameter(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Bisector_Curve_IsExtendAtStart(Handle_Bisector_Curve *self){
		return (*self)->IsExtendAtStart();
	}
EXPORT bool _wrap_Bisector_Curve_IsExtendAtStart (Handle_Bisector_Curve *larg1) {
  bool lresult = (bool)0 ;
  Handle_Bisector_Curve *arg1 = (Handle_Bisector_Curve *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Bisector_Curve_IsExtendAtStart(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bisector_Curve_IsExtendAtStart\n  * wrapname: _wrap_Bisector_Curve_IsExtendAtStart\n  * fulldecl: Standard_Boolean Handle_Bisector_Curve::IsExtendAtStart()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Bisector_Curve_IsExtendAtEnd(Handle_Bisector_Curve *self){
		return (*self)->IsExtendAtEnd();
	}
EXPORT bool _wrap_Bisector_Curve_IsExtendAtEnd (Handle_Bisector_Curve *larg1) {
  bool lresult = (bool)0 ;
  Handle_Bisector_Curve *arg1 = (Handle_Bisector_Curve *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Bisector_Curve_IsExtendAtEnd(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bisector_Curve_IsExtendAtEnd\n  * wrapname: _wrap_Bisector_Curve_IsExtendAtEnd\n  * fulldecl: Standard_Boolean Handle_Bisector_Curve::IsExtendAtEnd()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Integer Handle_Bisector_Curve_NbIntervals(Handle_Bisector_Curve *self){
		return (*self)->NbIntervals();
	}
EXPORT Standard_Integer _wrap_Bisector_Curve_NbIntervals (Handle_Bisector_Curve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Bisector_Curve *arg1 = (Handle_Bisector_Curve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Bisector_Curve_NbIntervals(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bisector_Curve_NbIntervals\n  * wrapname: _wrap_Bisector_Curve_NbIntervals\n  * fulldecl: Standard_Integer Handle_Bisector_Curve::NbIntervals()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Real Handle_Bisector_Curve_IntervalFirst(Handle_Bisector_Curve *self,Standard_Integer const index){
		return (*self)->IntervalFirst(index);
	}
EXPORT Standard_Real _wrap_Bisector_Curve_IntervalFirst (Handle_Bisector_Curve *larg1, Standard_Integer larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Bisector_Curve *arg1 = (Handle_Bisector_Curve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Bisector_Curve_IntervalFirst(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bisector_Curve_IntervalFirst\n  * wrapname: _wrap_Bisector_Curve_IntervalFirst\n  * fulldecl: Standard_Real Handle_Bisector_Curve::IntervalFirst(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Bisector_Curve_IntervalLast(Handle_Bisector_Curve *self,Standard_Integer const index){
		return (*self)->IntervalLast(index);
	}
EXPORT Standard_Real _wrap_Bisector_Curve_IntervalLast (Handle_Bisector_Curve *larg1, Standard_Integer larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Bisector_Curve *arg1 = (Handle_Bisector_Curve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Bisector_Curve_IntervalLast(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bisector_Curve_IntervalLast\n  * wrapname: _wrap_Bisector_Curve_IntervalLast\n  * fulldecl: Standard_Real Handle_Bisector_Curve::IntervalLast(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Handle_Bisector_BisecCC *new_Handle_Bisector_BisecCC__SWIG_0(Handle_Geom2d_Curve const &Cu1,Handle_Geom2d_Curve const &Cu2,Standard_Real const Side1,Standard_Real const Side2,gp_Pnt2d const &Origin,Standard_Real const DistMax=500){
    return new Handle_Bisector_BisecCC(new Bisector_BisecCC(Cu1, Cu2, Side1, Side2, Origin, DistMax));
    }
EXPORT Handle_Bisector_BisecCC *_wrap_new_Bisector_BisecCC__SWIG_0 (Handle_Geom2d_Curve *larg1, Handle_Geom2d_Curve *larg2, Standard_Real larg3, Standard_Real larg4, gp_Pnt2d *larg5, Standard_Real larg6) {
  Handle_Bisector_BisecCC * lresult = (Handle_Bisector_BisecCC *)0 ;
  Handle_Geom2d_Curve *arg1 = 0 ;
  Handle_Geom2d_Curve *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  gp_Pnt2d *arg5 = 0 ;
  Standard_Real arg6 ;
  Handle_Bisector_BisecCC *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Bisector_BisecCC *)new_Handle_Bisector_BisecCC__SWIG_0((Handle_Geom2d_Curve const &)*arg1,(Handle_Geom2d_Curve const &)*arg2,arg3,arg4,(gp_Pnt2d const &)*arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Bisector_BisecCC\n  * wrapname: _wrap_new_Bisector_BisecCC__SWIG_0\n  * fulldecl: Handle_Bisector_BisecCC::Handle_Bisector_BisecCC(Handle_Geom2d_Curve const &,Handle_Geom2d_Curve const &,Standard_Real const,Standard_Real const,gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Bisector_BisecCC *)0;
  }
}


EXPORT Handle_Bisector_BisecCC *_wrap_new_Bisector_BisecCC__SWIG_1 (Handle_Geom2d_Curve *larg1, Handle_Geom2d_Curve *larg2, Standard_Real larg3, Standard_Real larg4, gp_Pnt2d *larg5) {
  Handle_Bisector_BisecCC * lresult = (Handle_Bisector_BisecCC *)0 ;
  Handle_Geom2d_Curve *arg1 = 0 ;
  Handle_Geom2d_Curve *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  gp_Pnt2d *arg5 = 0 ;
  Handle_Bisector_BisecCC *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Bisector_BisecCC *)new_Handle_Bisector_BisecCC__SWIG_0((Handle_Geom2d_Curve const &)*arg1,(Handle_Geom2d_Curve const &)*arg2,arg3,arg4,(gp_Pnt2d const &)*arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Bisector_BisecCC\n  * wrapname: _wrap_new_Bisector_BisecCC__SWIG_1\n  * fulldecl: Handle_Bisector_BisecCC::Handle_Bisector_BisecCC(Handle_Geom2d_Curve const &,Handle_Geom2d_Curve const &,Standard_Real const,Standard_Real const,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Bisector_BisecCC *)0;
  }
}


SWIGINTERN Handle_Bisector_BisecPC *new_Handle_Bisector_BisecPC__SWIG_0(Handle_Geom2d_Curve const &Cu,gp_Pnt2d const &P,Standard_Real const Side,Standard_Real const DistMax=500){
        return new Handle_Bisector_BisecPC(new Bisector_BisecPC(Cu, P, Side, DistMax));
    }
EXPORT Handle_Bisector_BisecPC *_wrap_new_Bisector_BisecPC__SWIG_0 (Handle_Geom2d_Curve *larg1, gp_Pnt2d *larg2, Standard_Real larg3, Standard_Real larg4) {
  Handle_Bisector_BisecPC * lresult = (Handle_Bisector_BisecPC *)0 ;
  Handle_Geom2d_Curve *arg1 = 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Handle_Bisector_BisecPC *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Bisector_BisecPC *)new_Handle_Bisector_BisecPC__SWIG_0((Handle_Geom2d_Curve const &)*arg1,(gp_Pnt2d const &)*arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Bisector_BisecPC\n  * wrapname: _wrap_new_Bisector_BisecPC__SWIG_0\n  * fulldecl: Handle_Bisector_BisecPC::Handle_Bisector_BisecPC(Handle_Geom2d_Curve const &,gp_Pnt2d const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Bisector_BisecPC *)0;
  }
}


EXPORT Handle_Bisector_BisecPC *_wrap_new_Bisector_BisecPC__SWIG_1 (Handle_Geom2d_Curve *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  Handle_Bisector_BisecPC * lresult = (Handle_Bisector_BisecPC *)0 ;
  Handle_Geom2d_Curve *arg1 = 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  Handle_Bisector_BisecPC *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Bisector_BisecPC *)new_Handle_Bisector_BisecPC__SWIG_0((Handle_Geom2d_Curve const &)*arg1,(gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Bisector_BisecPC\n  * wrapname: _wrap_new_Bisector_BisecPC__SWIG_1\n  * fulldecl: Handle_Bisector_BisecPC::Handle_Bisector_BisecPC(Handle_Geom2d_Curve const &,gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Bisector_BisecPC *)0;
  }
}


SWIGINTERN Handle_Geom2d_Line *new_Handle_Geom2d_Line__SWIG_0(gp_Ax2d const &A){
		return new Handle_Geom2d_Line(new Geom2d_Line(A));
	}
EXPORT Handle_Geom2d_Line *_wrap_new_Geom2d_Line__SWIG_0 (gp_Ax2d *larg1) {
  Handle_Geom2d_Line * lresult = (Handle_Geom2d_Line *)0 ;
  gp_Ax2d *arg1 = 0 ;
  Handle_Geom2d_Line *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Line *)new_Handle_Geom2d_Line__SWIG_0((gp_Ax2d const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Line\n  * wrapname: _wrap_new_Geom2d_Line__SWIG_0\n  * fulldecl: Handle_Geom2d_Line::Handle_Geom2d_Line(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Line *)0;
  }
}


SWIGINTERN Handle_Geom2d_Line *new_Handle_Geom2d_Line__SWIG_1(gp_Lin2d const &L){
		return new Handle_Geom2d_Line(new Geom2d_Line(L));
	}
EXPORT Handle_Geom2d_Line *_wrap_new_Geom2d_Line__SWIG_1 (gp_Lin2d *larg1) {
  Handle_Geom2d_Line * lresult = (Handle_Geom2d_Line *)0 ;
  gp_Lin2d *arg1 = 0 ;
  Handle_Geom2d_Line *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Line *)new_Handle_Geom2d_Line__SWIG_1((gp_Lin2d const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Line\n  * wrapname: _wrap_new_Geom2d_Line__SWIG_1\n  * fulldecl: Handle_Geom2d_Line::Handle_Geom2d_Line(gp_Lin2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Line *)0;
  }
}


SWIGINTERN Handle_Geom2d_Line *new_Handle_Geom2d_Line__SWIG_2(gp_Pnt2d const &P,gp_Dir2d const &V){
		return new Handle_Geom2d_Line(new Geom2d_Line(P, V));
	}
EXPORT Handle_Geom2d_Line *_wrap_new_Geom2d_Line__SWIG_2 (gp_Pnt2d *larg1, gp_Dir2d *larg2) {
  Handle_Geom2d_Line * lresult = (Handle_Geom2d_Line *)0 ;
  gp_Pnt2d *arg1 = 0 ;
  gp_Dir2d *arg2 = 0 ;
  Handle_Geom2d_Line *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Line *)new_Handle_Geom2d_Line__SWIG_2((gp_Pnt2d const &)*arg1,(gp_Dir2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Line\n  * wrapname: _wrap_new_Geom2d_Line__SWIG_2\n  * fulldecl: Handle_Geom2d_Line::Handle_Geom2d_Line(gp_Pnt2d const &,gp_Dir2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Line *)0;
  }
}


SWIGINTERN void Handle_Geom2d_Line_Delete(Handle_Geom2d_Line *self){
	  self->~Handle_Geom2d_Line();
	}
EXPORT void _wrap_Geom2d_Line_Delete (Handle_Geom2d_Line *larg1) {
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Line_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_Delete\n  * wrapname: _wrap_Geom2d_Line_Delete\n  * fulldecl: void Handle_Geom2d_Line::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Lin2d Handle_Geom2d_Line_Lin2d(Handle_Geom2d_Line *self){
	  return (*self)->Lin2d();
	}
EXPORT gp_Lin2d *_wrap_Geom2d_Line_Lin2d (Handle_Geom2d_Line *larg1) {
  gp_Lin2d * lresult = (gp_Lin2d *)0 ;
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  gp_Lin2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Line_Lin2d(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_Lin2d\n  * wrapname: _wrap_Geom2d_Line_Lin2d\n  * fulldecl: gp_Lin2d Handle_Geom2d_Line::Lin2d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Lin2d(result);
    return lresult;
  } catch (...) {
    return (gp_Lin2d *)0;
  }
}


SWIGINTERN void Handle_Geom2d_Line_SetLin2d(Handle_Geom2d_Line *self,gp_Lin2d const &L){
	  (*self)->SetLin2d(L);
	}
EXPORT void _wrap_Geom2d_Line_SetLin2d (Handle_Geom2d_Line *larg1, gp_Lin2d *larg2) {
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  gp_Lin2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Line_SetLin2d(arg1,(gp_Lin2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_SetLin2d\n  * wrapname: _wrap_Geom2d_Line_SetLin2d\n  * fulldecl: void Handle_Geom2d_Line::SetLin2d(gp_Lin2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Line_SetDirection(Handle_Geom2d_Line *self,gp_Dir2d const &V){
	  (*self)->SetDirection(V);
	}
EXPORT void _wrap_Geom2d_Line_SetDirection (Handle_Geom2d_Line *larg1, gp_Dir2d *larg2) {
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  gp_Dir2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Line_SetDirection(arg1,(gp_Dir2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_SetDirection\n  * wrapname: _wrap_Geom2d_Line_SetDirection\n  * fulldecl: void Handle_Geom2d_Line::SetDirection(gp_Dir2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Dir2d const Handle_Geom2d_Line_Direction(Handle_Geom2d_Line *self){
	  //return (gp_Dir2d *)&(*self)->Direction();
	  return (*self)->Direction();
	}
EXPORT gp_Dir2d const *_wrap_Geom2d_Line_Direction (Handle_Geom2d_Line *larg1) {
  gp_Dir2d const * lresult = (gp_Dir2d const *)0 ;
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  gp_Dir2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Line_Direction(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_Direction\n  * wrapname: _wrap_Geom2d_Line_Direction\n  * fulldecl: gp_Dir2d const Handle_Geom2d_Line::Direction()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Dir2d const(result);
    return lresult;
  } catch (...) {
    return (gp_Dir2d const *)0;
  }
}


SWIGINTERN void Handle_Geom2d_Line_SetLocation(Handle_Geom2d_Line *self,gp_Pnt2d const &P){
	  (*self)->SetLocation(P);
	}
EXPORT void _wrap_Geom2d_Line_SetLocation (Handle_Geom2d_Line *larg1, gp_Pnt2d *larg2) {
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Line_SetLocation(arg1,(gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_SetLocation\n  * wrapname: _wrap_Geom2d_Line_SetLocation\n  * fulldecl: void Handle_Geom2d_Line::SetLocation(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Pnt2d Handle_Geom2d_Line_Location(Handle_Geom2d_Line *self){
	  //return (gp_Pnt2d *)&(*self)->Location();
	  return (*self)->Location();
	}
EXPORT gp_Pnt2d *_wrap_Geom2d_Line_Location (Handle_Geom2d_Line *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Line_Location(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_Location\n  * wrapname: _wrap_Geom2d_Line_Location\n  * fulldecl: gp_Pnt2d Handle_Geom2d_Line::Location()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


SWIGINTERN void Handle_Geom2d_Line_SetPosition(Handle_Geom2d_Line *self,gp_Ax2d const &A){
	  (*self)->SetPosition(A);
	}
EXPORT void _wrap_Geom2d_Line_SetPosition (Handle_Geom2d_Line *larg1, gp_Ax2d *larg2) {
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Line_SetPosition(arg1,(gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_SetPosition\n  * wrapname: _wrap_Geom2d_Line_SetPosition\n  * fulldecl: void Handle_Geom2d_Line::SetPosition(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Ax2d Handle_Geom2d_Line_Position(Handle_Geom2d_Line *self){
	  //return (gp_Ax2d *)&(*self)->Position();
	  return (*self)->Position();
	}
EXPORT gp_Ax2d *_wrap_Geom2d_Line_Position (Handle_Geom2d_Line *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Line_Position(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_Position\n  * wrapname: _wrap_Geom2d_Line_Position\n  * fulldecl: gp_Ax2d Handle_Geom2d_Line::Position()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


SWIGINTERN void Handle_Geom2d_Line_Reverse(Handle_Geom2d_Line *self){
	  (*self)->Reverse();
	}
EXPORT void _wrap_Geom2d_Line_Reverse (Handle_Geom2d_Line *larg1) {
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Line_Reverse(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_Reverse\n  * wrapname: _wrap_Geom2d_Line_Reverse\n  * fulldecl: void Handle_Geom2d_Line::Reverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Line_ReversedParameter(Handle_Geom2d_Line *self,Standard_Real const U){
	  return (*self)->ReversedParameter(U);
	}
EXPORT Standard_Real _wrap_Geom2d_Line_ReversedParameter (Handle_Geom2d_Line *larg1, Standard_Real larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  Standard_Real arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Line_ReversedParameter(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_ReversedParameter\n  * wrapname: _wrap_Geom2d_Line_ReversedParameter\n  * fulldecl: Standard_Real Handle_Geom2d_Line::ReversedParameter(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Line_FirstParameter(Handle_Geom2d_Line *self){
	  return (*self)->FirstParameter();
	}
EXPORT Standard_Real _wrap_Geom2d_Line_FirstParameter (Handle_Geom2d_Line *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Line_FirstParameter(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_FirstParameter\n  * wrapname: _wrap_Geom2d_Line_FirstParameter\n  * fulldecl: Standard_Real Handle_Geom2d_Line::FirstParameter()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Line_LastParameter(Handle_Geom2d_Line *self){
	  return (*self)->LastParameter();
	}
EXPORT Standard_Real _wrap_Geom2d_Line_LastParameter (Handle_Geom2d_Line *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Line_LastParameter(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_LastParameter\n  * wrapname: _wrap_Geom2d_Line_LastParameter\n  * fulldecl: Standard_Real Handle_Geom2d_Line::LastParameter()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom2d_Line_IsClosed(Handle_Geom2d_Line *self){
	  return (*self)->IsClosed();
	}
EXPORT bool _wrap_Geom2d_Line_IsClosed (Handle_Geom2d_Line *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom2d_Line_IsClosed(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_IsClosed\n  * wrapname: _wrap_Geom2d_Line_IsClosed\n  * fulldecl: Standard_Boolean Handle_Geom2d_Line::IsClosed()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom2d_Line_IsPeriodic(Handle_Geom2d_Line *self){
	  return (*self)->IsPeriodic();
	}
EXPORT bool _wrap_Geom2d_Line_IsPeriodic (Handle_Geom2d_Line *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom2d_Line_IsPeriodic(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_IsPeriodic\n  * wrapname: _wrap_Geom2d_Line_IsPeriodic\n  * fulldecl: Standard_Boolean Handle_Geom2d_Line::IsPeriodic()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN GeomAbs_Shape Handle_Geom2d_Line_Continuity(Handle_Geom2d_Line *self){
	  return (*self)->Continuity();
	}
EXPORT GeomAbs_Shape _wrap_Geom2d_Line_Continuity (Handle_Geom2d_Line *larg1) {
  GeomAbs_Shape lresult = (GeomAbs_Shape)0 ;
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  GeomAbs_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAbs_Shape)Handle_Geom2d_Line_Continuity(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_Continuity\n  * wrapname: _wrap_Geom2d_Line_Continuity\n  * fulldecl: GeomAbs_Shape Handle_Geom2d_Line::Continuity()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAbs_Shape)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Line_Distance(Handle_Geom2d_Line *self,gp_Pnt2d const &P){
	  return (*self)->Distance(P);
	}
EXPORT Standard_Real _wrap_Geom2d_Line_Distance (Handle_Geom2d_Line *larg1, gp_Pnt2d *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Line_Distance(arg1,(gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_Distance\n  * wrapname: _wrap_Geom2d_Line_Distance\n  * fulldecl: Standard_Real Handle_Geom2d_Line::Distance(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom2d_Line_IsCN(Handle_Geom2d_Line *self,Standard_Integer const N){
	  return (*self)->IsCN(N);
	}
EXPORT bool _wrap_Geom2d_Line_IsCN (Handle_Geom2d_Line *larg1, Standard_Integer larg2) {
  bool lresult = (bool)0 ;
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  Standard_Integer arg2 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom2d_Line_IsCN(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_IsCN\n  * wrapname: _wrap_Geom2d_Line_IsCN\n  * fulldecl: Standard_Boolean Handle_Geom2d_Line::IsCN(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN void Handle_Geom2d_Line_Transform(Handle_Geom2d_Line *self,gp_Trsf2d const &T){
	  (*self)->Transform(T);
	}
EXPORT void _wrap_Geom2d_Line_Transform (Handle_Geom2d_Line *larg1, gp_Trsf2d *larg2) {
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Line_Transform(arg1,(gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_Transform\n  * wrapname: _wrap_Geom2d_Line_Transform\n  * fulldecl: void Handle_Geom2d_Line::Transform(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Line_TransformedParameter(Handle_Geom2d_Line *self,Standard_Real const U,gp_Trsf2d const &T){
	  return (*self)->TransformedParameter(U, T);
	}
EXPORT Standard_Real _wrap_Geom2d_Line_TransformedParameter (Handle_Geom2d_Line *larg1, Standard_Real larg2, gp_Trsf2d *larg3) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  Standard_Real arg2 ;
  gp_Trsf2d *arg3 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Line_TransformedParameter(arg1,arg2,(gp_Trsf2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_TransformedParameter\n  * wrapname: _wrap_Geom2d_Line_TransformedParameter\n  * fulldecl: Standard_Real Handle_Geom2d_Line::TransformedParameter(Standard_Real const,gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Line_ParametricTransformation(Handle_Geom2d_Line *self,gp_Trsf2d const &T){
	  return (*self)->ParametricTransformation(T);
	}
EXPORT Standard_Real _wrap_Geom2d_Line_ParametricTransformation (Handle_Geom2d_Line *larg1, gp_Trsf2d *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Line_ParametricTransformation(arg1,(gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_ParametricTransformation\n  * wrapname: _wrap_Geom2d_Line_ParametricTransformation\n  * fulldecl: Standard_Real Handle_Geom2d_Line::ParametricTransformation(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Handle_Geom2d_OffsetCurve *new_Handle_Geom2d_OffsetCurve(Handle_Geom2d_Curve const &C,Standard_Real const Offset){
		return new Handle_Geom2d_OffsetCurve(new Geom2d_OffsetCurve(C, Offset));
	}
EXPORT Handle_Geom2d_OffsetCurve *_wrap_new_Geom2d_OffsetCurve (Handle_Geom2d_Curve *larg1, Standard_Real larg2) {
  Handle_Geom2d_OffsetCurve * lresult = (Handle_Geom2d_OffsetCurve *)0 ;
  Handle_Geom2d_Curve *arg1 = 0 ;
  Standard_Real arg2 ;
  Handle_Geom2d_OffsetCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_OffsetCurve *)new_Handle_Geom2d_OffsetCurve((Handle_Geom2d_Curve const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_OffsetCurve\n  * wrapname: _wrap_new_Geom2d_OffsetCurve\n  * fulldecl: Handle_Geom2d_OffsetCurve::Handle_Geom2d_OffsetCurve(Handle_Geom2d_Curve const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_OffsetCurve *)0;
  }
}


SWIGINTERN void Handle_Geom2d_OffsetCurve_Delete(Handle_Geom2d_OffsetCurve *self){
	  self->~Handle_Geom2d_OffsetCurve();
	}
EXPORT void _wrap_Geom2d_OffsetCurve_Delete (Handle_Geom2d_OffsetCurve *larg1) {
  Handle_Geom2d_OffsetCurve *arg1 = (Handle_Geom2d_OffsetCurve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_OffsetCurve_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_OffsetCurve_Delete\n  * wrapname: _wrap_Geom2d_OffsetCurve_Delete\n  * fulldecl: void Handle_Geom2d_OffsetCurve::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_OffsetCurve_SetBasisCurve__SWIG_0(Handle_Geom2d_OffsetCurve *self,Handle_Geom2d_Curve const &C,Standard_Boolean const isNotCheckC0=Standard_False){
	  (*self)->SetBasisCurve(C, isNotCheckC0);

	}
EXPORT void _wrap_Geom2d_OffsetCurve_SetBasisCurve__SWIG_0 (Handle_Geom2d_OffsetCurve *larg1, Handle_Geom2d_Curve *larg2, bool larg3) {
  Handle_Geom2d_OffsetCurve *arg1 = (Handle_Geom2d_OffsetCurve *) 0 ;
  Handle_Geom2d_Curve *arg2 = 0 ;
  Standard_Boolean arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_OffsetCurve_SetBasisCurve__SWIG_0(arg1,(Handle_Geom2d_Curve const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_OffsetCurve_SetBasisCurve\n  * wrapname: _wrap_Geom2d_OffsetCurve_SetBasisCurve__SWIG_0\n  * fulldecl: void Handle_Geom2d_OffsetCurve::SetBasisCurve(Handle_Geom2d_Curve const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Geom2d_OffsetCurve_SetBasisCurve__SWIG_1 (Handle_Geom2d_OffsetCurve *larg1, Handle_Geom2d_Curve *larg2) {
  Handle_Geom2d_OffsetCurve *arg1 = (Handle_Geom2d_OffsetCurve *) 0 ;
  Handle_Geom2d_Curve *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_OffsetCurve_SetBasisCurve__SWIG_0(arg1,(Handle_Geom2d_Curve const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_OffsetCurve_SetBasisCurve\n  * wrapname: _wrap_Geom2d_OffsetCurve_SetBasisCurve__SWIG_1\n  * fulldecl: void Handle_Geom2d_OffsetCurve::SetBasisCurve(Handle_Geom2d_Curve const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_OffsetCurve_SetOffsetValue(Handle_Geom2d_OffsetCurve *self,Standard_Real const D){
	  (*self)->SetOffsetValue(D);
	}
EXPORT void _wrap_Geom2d_OffsetCurve_SetOffsetValue (Handle_Geom2d_OffsetCurve *larg1, Standard_Real larg2) {
  Handle_Geom2d_OffsetCurve *arg1 = (Handle_Geom2d_OffsetCurve *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_OffsetCurve_SetOffsetValue(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_OffsetCurve_SetOffsetValue\n  * wrapname: _wrap_Geom2d_OffsetCurve_SetOffsetValue\n  * fulldecl: void Handle_Geom2d_OffsetCurve::SetOffsetValue(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_Curve Handle_Geom2d_OffsetCurve_BasisCurve(Handle_Geom2d_OffsetCurve *self){
	  return (*self)->BasisCurve();
	}
EXPORT Handle_Geom2d_Curve *_wrap_Geom2d_OffsetCurve_BasisCurve (Handle_Geom2d_OffsetCurve *larg1) {
  Handle_Geom2d_Curve * lresult = (Handle_Geom2d_Curve *)0 ;
  Handle_Geom2d_OffsetCurve *arg1 = (Handle_Geom2d_OffsetCurve *) 0 ;
  SwigValueWrapper< Handle_Geom2d_Curve > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_OffsetCurve_BasisCurve(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_OffsetCurve_BasisCurve\n  * wrapname: _wrap_Geom2d_OffsetCurve_BasisCurve\n  * fulldecl: Handle_Geom2d_Curve Handle_Geom2d_OffsetCurve::BasisCurve()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Curve(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Curve *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_OffsetCurve_Offset(Handle_Geom2d_OffsetCurve *self){
	  return (*self)->Offset();
	}
EXPORT Standard_Real _wrap_Geom2d_OffsetCurve_Offset (Handle_Geom2d_OffsetCurve *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_OffsetCurve *arg1 = (Handle_Geom2d_OffsetCurve *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_OffsetCurve_Offset(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_OffsetCurve_Offset\n  * wrapname: _wrap_Geom2d_OffsetCurve_Offset\n  * fulldecl: Standard_Real Handle_Geom2d_OffsetCurve::Offset()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN GeomAbs_Shape Handle_Geom2d_OffsetCurve_GetBasisCurveContinuity(Handle_Geom2d_OffsetCurve *self){
	  return (*self)->GetBasisCurveContinuity();
	}
EXPORT GeomAbs_Shape _wrap_Geom2d_OffsetCurve_GetBasisCurveContinuity (Handle_Geom2d_OffsetCurve *larg1) {
  GeomAbs_Shape lresult = (GeomAbs_Shape)0 ;
  Handle_Geom2d_OffsetCurve *arg1 = (Handle_Geom2d_OffsetCurve *) 0 ;
  GeomAbs_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAbs_Shape)Handle_Geom2d_OffsetCurve_GetBasisCurveContinuity(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_OffsetCurve_GetBasisCurveContinuity\n  * wrapname: _wrap_Geom2d_OffsetCurve_GetBasisCurveContinuity\n  * fulldecl: GeomAbs_Shape Handle_Geom2d_OffsetCurve::GetBasisCurveContinuity()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAbs_Shape)0;
  }
}


SWIGINTERN void Handle_Geom2d_Conic_SetAxis(Handle_Geom2d_Conic *self,gp_Ax22d const &A){
    (*self)->SetAxis(A);
  }
EXPORT void _wrap_Geom2d_Conic_SetAxis (Handle_Geom2d_Conic *larg1, gp_Ax22d *larg2) {
  Handle_Geom2d_Conic *arg1 = (Handle_Geom2d_Conic *) 0 ;
  gp_Ax22d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Conic_SetAxis(arg1,(gp_Ax22d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Conic_SetAxis\n  * wrapname: _wrap_Geom2d_Conic_SetAxis\n  * fulldecl: void Handle_Geom2d_Conic::SetAxis(gp_Ax22d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Conic_SetXAxis(Handle_Geom2d_Conic *self,gp_Ax2d const &A){
    (*self)->SetXAxis(A);
  }
EXPORT void _wrap_Geom2d_Conic_SetXAxis (Handle_Geom2d_Conic *larg1, gp_Ax2d *larg2) {
  Handle_Geom2d_Conic *arg1 = (Handle_Geom2d_Conic *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Conic_SetXAxis(arg1,(gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Conic_SetXAxis\n  * wrapname: _wrap_Geom2d_Conic_SetXAxis\n  * fulldecl: void Handle_Geom2d_Conic::SetXAxis(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Conic_SetYAxis(Handle_Geom2d_Conic *self,gp_Ax2d const &A){
    (*self)->SetYAxis(A);
  }
EXPORT void _wrap_Geom2d_Conic_SetYAxis (Handle_Geom2d_Conic *larg1, gp_Ax2d *larg2) {
  Handle_Geom2d_Conic *arg1 = (Handle_Geom2d_Conic *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Conic_SetYAxis(arg1,(gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Conic_SetYAxis\n  * wrapname: _wrap_Geom2d_Conic_SetYAxis\n  * fulldecl: void Handle_Geom2d_Conic::SetYAxis(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Conic_SetLocation(Handle_Geom2d_Conic *self,gp_Pnt2d const &P){
    (*self)->SetLocation(P);
  }
EXPORT void _wrap_Geom2d_Conic_SetLocation (Handle_Geom2d_Conic *larg1, gp_Pnt2d *larg2) {
  Handle_Geom2d_Conic *arg1 = (Handle_Geom2d_Conic *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Conic_SetLocation(arg1,(gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Conic_SetLocation\n  * wrapname: _wrap_Geom2d_Conic_SetLocation\n  * fulldecl: void Handle_Geom2d_Conic::SetLocation(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Ax2d Handle_Geom2d_Conic_XAxis(Handle_Geom2d_Conic *self){
		return (*self)->XAxis();
	}
EXPORT gp_Ax2d *_wrap_Geom2d_Conic_XAxis (Handle_Geom2d_Conic *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  Handle_Geom2d_Conic *arg1 = (Handle_Geom2d_Conic *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Conic_XAxis(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Conic_XAxis\n  * wrapname: _wrap_Geom2d_Conic_XAxis\n  * fulldecl: gp_Ax2d Handle_Geom2d_Conic::XAxis()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


SWIGINTERN gp_Ax2d Handle_Geom2d_Conic_YAxis(Handle_Geom2d_Conic *self){
		return (*self)->YAxis();
	}
EXPORT gp_Ax2d *_wrap_Geom2d_Conic_YAxis (Handle_Geom2d_Conic *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  Handle_Geom2d_Conic *arg1 = (Handle_Geom2d_Conic *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Conic_YAxis(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Conic_YAxis\n  * wrapname: _wrap_Geom2d_Conic_YAxis\n  * fulldecl: gp_Ax2d Handle_Geom2d_Conic::YAxis()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Conic_Eccentricity(Handle_Geom2d_Conic *self){
		return (*self)->Eccentricity();
	}
EXPORT Standard_Real _wrap_Geom2d_Conic_Eccentricity (Handle_Geom2d_Conic *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Conic *arg1 = (Handle_Geom2d_Conic *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Conic_Eccentricity(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Conic_Eccentricity\n  * wrapname: _wrap_Geom2d_Conic_Eccentricity\n  * fulldecl: Standard_Real Handle_Geom2d_Conic::Eccentricity()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN gp_Pnt2d Handle_Geom2d_Conic_Location(Handle_Geom2d_Conic *self){
		return (*self)->Location();
	}
EXPORT gp_Pnt2d *_wrap_Geom2d_Conic_Location (Handle_Geom2d_Conic *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Handle_Geom2d_Conic *arg1 = (Handle_Geom2d_Conic *) 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Conic_Location(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Conic_Location\n  * wrapname: _wrap_Geom2d_Conic_Location\n  * fulldecl: gp_Pnt2d Handle_Geom2d_Conic::Location()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


SWIGINTERN gp_Ax22d Handle_Geom2d_Conic_Position(Handle_Geom2d_Conic *self){
		return (*self)->Position();
	}
EXPORT gp_Ax22d *_wrap_Geom2d_Conic_Position (Handle_Geom2d_Conic *larg1) {
  gp_Ax22d * lresult = (gp_Ax22d *)0 ;
  Handle_Geom2d_Conic *arg1 = (Handle_Geom2d_Conic *) 0 ;
  gp_Ax22d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Conic_Position(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Conic_Position\n  * wrapname: _wrap_Geom2d_Conic_Position\n  * fulldecl: gp_Ax22d Handle_Geom2d_Conic::Position()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax22d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax22d *)0;
  }
}


SWIGINTERN Handle_Geom2d_Circle *new_Handle_Geom2d_Circle__SWIG_0(gp_Circ2d const &C){
    return new Handle_Geom2d_Circle(new Geom2d_Circle(C));
  }
EXPORT Handle_Geom2d_Circle *_wrap_new_Geom2d_Circle__SWIG_0 (gp_Circ2d *larg1) {
  Handle_Geom2d_Circle * lresult = (Handle_Geom2d_Circle *)0 ;
  gp_Circ2d *arg1 = 0 ;
  Handle_Geom2d_Circle *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Circle *)new_Handle_Geom2d_Circle__SWIG_0((gp_Circ2d const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Circle\n  * wrapname: _wrap_new_Geom2d_Circle__SWIG_0\n  * fulldecl: Handle_Geom2d_Circle::Handle_Geom2d_Circle(gp_Circ2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Circle *)0;
  }
}


SWIGINTERN Handle_Geom2d_Circle *new_Handle_Geom2d_Circle__SWIG_1(gp_Ax2d const &A,Standard_Real const Radius,Standard_Boolean const Sense=Standard_True){
    return new Handle_Geom2d_Circle(new Geom2d_Circle(A, Radius, Sense));
  }
EXPORT Handle_Geom2d_Circle *_wrap_new_Geom2d_Circle__SWIG_1 (gp_Ax2d *larg1, Standard_Real larg2, bool larg3) {
  Handle_Geom2d_Circle * lresult = (Handle_Geom2d_Circle *)0 ;
  gp_Ax2d *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Boolean arg3 ;
  Handle_Geom2d_Circle *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Circle *)new_Handle_Geom2d_Circle__SWIG_1((gp_Ax2d const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Circle\n  * wrapname: _wrap_new_Geom2d_Circle__SWIG_1\n  * fulldecl: Handle_Geom2d_Circle::Handle_Geom2d_Circle(gp_Ax2d const &,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Circle *)0;
  }
}


EXPORT Handle_Geom2d_Circle *_wrap_new_Geom2d_Circle__SWIG_2 (gp_Ax2d *larg1, Standard_Real larg2) {
  Handle_Geom2d_Circle * lresult = (Handle_Geom2d_Circle *)0 ;
  gp_Ax2d *arg1 = 0 ;
  Standard_Real arg2 ;
  Handle_Geom2d_Circle *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Circle *)new_Handle_Geom2d_Circle__SWIG_1((gp_Ax2d const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Circle\n  * wrapname: _wrap_new_Geom2d_Circle__SWIG_2\n  * fulldecl: Handle_Geom2d_Circle::Handle_Geom2d_Circle(gp_Ax2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Circle *)0;
  }
}


SWIGINTERN Handle_Geom2d_Circle *new_Handle_Geom2d_Circle__SWIG_3(gp_Ax22d const &A,Standard_Real const R){
    return new Handle_Geom2d_Circle(new Geom2d_Circle(A, R));
  }
EXPORT Handle_Geom2d_Circle *_wrap_new_Geom2d_Circle__SWIG_3 (gp_Ax22d *larg1, Standard_Real larg2) {
  Handle_Geom2d_Circle * lresult = (Handle_Geom2d_Circle *)0 ;
  gp_Ax22d *arg1 = 0 ;
  Standard_Real arg2 ;
  Handle_Geom2d_Circle *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Circle *)new_Handle_Geom2d_Circle__SWIG_3((gp_Ax22d const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Circle\n  * wrapname: _wrap_new_Geom2d_Circle__SWIG_3\n  * fulldecl: Handle_Geom2d_Circle::Handle_Geom2d_Circle(gp_Ax22d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Circle *)0;
  }
}


SWIGINTERN void Handle_Geom2d_Circle_Delete(Handle_Geom2d_Circle *self){
    self->~Handle_Geom2d_Circle();
  }
EXPORT void _wrap_Geom2d_Circle_Delete (Handle_Geom2d_Circle *larg1) {
  Handle_Geom2d_Circle *arg1 = (Handle_Geom2d_Circle *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Circle_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Circle_Delete\n  * wrapname: _wrap_Geom2d_Circle_Delete\n  * fulldecl: void Handle_Geom2d_Circle::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Circle_SetCirc2d(Handle_Geom2d_Circle *self,gp_Circ2d const &C){
    (*self)->SetCirc2d(C);
  }
EXPORT void _wrap_Geom2d_Circle_SetCirc2d (Handle_Geom2d_Circle *larg1, gp_Circ2d *larg2) {
  Handle_Geom2d_Circle *arg1 = (Handle_Geom2d_Circle *) 0 ;
  gp_Circ2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Circle_SetCirc2d(arg1,(gp_Circ2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Circle_SetCirc2d\n  * wrapname: _wrap_Geom2d_Circle_SetCirc2d\n  * fulldecl: void Handle_Geom2d_Circle::SetCirc2d(gp_Circ2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Circle_SetRadius(Handle_Geom2d_Circle *self,Standard_Real const R){
    (*self)->SetRadius(R);
  }
EXPORT void _wrap_Geom2d_Circle_SetRadius (Handle_Geom2d_Circle *larg1, Standard_Real larg2) {
  Handle_Geom2d_Circle *arg1 = (Handle_Geom2d_Circle *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Circle_SetRadius(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Circle_SetRadius\n  * wrapname: _wrap_Geom2d_Circle_SetRadius\n  * fulldecl: void Handle_Geom2d_Circle::SetRadius(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Circ2d Handle_Geom2d_Circle_Circ2d(Handle_Geom2d_Circle *self){
    return (*self)->Circ2d();
  }
EXPORT gp_Circ2d *_wrap_Geom2d_Circle_Circ2d (Handle_Geom2d_Circle *larg1) {
  gp_Circ2d * lresult = (gp_Circ2d *)0 ;
  Handle_Geom2d_Circle *arg1 = (Handle_Geom2d_Circle *) 0 ;
  gp_Circ2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Circle_Circ2d(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Circle_Circ2d\n  * wrapname: _wrap_Geom2d_Circle_Circ2d\n  * fulldecl: gp_Circ2d Handle_Geom2d_Circle::Circ2d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Circ2d(result);
    return lresult;
  } catch (...) {
    return (gp_Circ2d *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Circle_Radius(Handle_Geom2d_Circle *self){
    return (*self)->Radius();
  }
EXPORT Standard_Real _wrap_Geom2d_Circle_Radius (Handle_Geom2d_Circle *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Circle *arg1 = (Handle_Geom2d_Circle *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Circle_Radius(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Circle_Radius\n  * wrapname: _wrap_Geom2d_Circle_Radius\n  * fulldecl: Standard_Real Handle_Geom2d_Circle::Radius()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Handle_Geom2d_Ellipse *new_Handle_Geom2d_Ellipse__SWIG_0(gp_Elips2d const &E){
    return new Handle_Geom2d_Ellipse(new Geom2d_Ellipse(E));
  }
EXPORT Handle_Geom2d_Ellipse *_wrap_new_Geom2d_Ellipse__SWIG_0 (gp_Elips2d *larg1) {
  Handle_Geom2d_Ellipse * lresult = (Handle_Geom2d_Ellipse *)0 ;
  gp_Elips2d *arg1 = 0 ;
  Handle_Geom2d_Ellipse *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Ellipse *)new_Handle_Geom2d_Ellipse__SWIG_0((gp_Elips2d const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Ellipse\n  * wrapname: _wrap_new_Geom2d_Ellipse__SWIG_0\n  * fulldecl: Handle_Geom2d_Ellipse::Handle_Geom2d_Ellipse(gp_Elips2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Ellipse *)0;
  }
}


SWIGINTERN Handle_Geom2d_Ellipse *new_Handle_Geom2d_Ellipse__SWIG_1(gp_Ax2d const &MajorAxis,Standard_Real const MajorRadius,Standard_Real const MinorRadius,Standard_Boolean const Sense=Standard_True){
    return new Handle_Geom2d_Ellipse(new Geom2d_Ellipse(MajorAxis, MajorRadius, MinorRadius, Sense));
  }
EXPORT Handle_Geom2d_Ellipse *_wrap_new_Geom2d_Ellipse__SWIG_1 (gp_Ax2d *larg1, Standard_Real larg2, Standard_Real larg3, bool larg4) {
  Handle_Geom2d_Ellipse * lresult = (Handle_Geom2d_Ellipse *)0 ;
  gp_Ax2d *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Boolean arg4 ;
  Handle_Geom2d_Ellipse *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Ellipse *)new_Handle_Geom2d_Ellipse__SWIG_1((gp_Ax2d const &)*arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Ellipse\n  * wrapname: _wrap_new_Geom2d_Ellipse__SWIG_1\n  * fulldecl: Handle_Geom2d_Ellipse::Handle_Geom2d_Ellipse(gp_Ax2d const &,Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Ellipse *)0;
  }
}


EXPORT Handle_Geom2d_Ellipse *_wrap_new_Geom2d_Ellipse__SWIG_2 (gp_Ax2d *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom2d_Ellipse * lresult = (Handle_Geom2d_Ellipse *)0 ;
  gp_Ax2d *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Handle_Geom2d_Ellipse *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Ellipse *)new_Handle_Geom2d_Ellipse__SWIG_1((gp_Ax2d const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Ellipse\n  * wrapname: _wrap_new_Geom2d_Ellipse__SWIG_2\n  * fulldecl: Handle_Geom2d_Ellipse::Handle_Geom2d_Ellipse(gp_Ax2d const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Ellipse *)0;
  }
}


SWIGINTERN Handle_Geom2d_Ellipse *new_Handle_Geom2d_Ellipse__SWIG_3(gp_Ax22d const &Axis,Standard_Real const MajorRadius,Standard_Real const MinorRadius){
    return new Handle_Geom2d_Ellipse(new Geom2d_Ellipse(Axis, MajorRadius, MinorRadius));
  }
EXPORT Handle_Geom2d_Ellipse *_wrap_new_Geom2d_Ellipse__SWIG_3 (gp_Ax22d *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom2d_Ellipse * lresult = (Handle_Geom2d_Ellipse *)0 ;
  gp_Ax22d *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Handle_Geom2d_Ellipse *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Ellipse *)new_Handle_Geom2d_Ellipse__SWIG_3((gp_Ax22d const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Ellipse\n  * wrapname: _wrap_new_Geom2d_Ellipse__SWIG_3\n  * fulldecl: Handle_Geom2d_Ellipse::Handle_Geom2d_Ellipse(gp_Ax22d const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Ellipse *)0;
  }
}


SWIGINTERN void Handle_Geom2d_Ellipse_Delete(Handle_Geom2d_Ellipse *self){
    self->~Handle_Geom2d_Ellipse();
  }
EXPORT void _wrap_Geom2d_Ellipse_Delete (Handle_Geom2d_Ellipse *larg1) {
  Handle_Geom2d_Ellipse *arg1 = (Handle_Geom2d_Ellipse *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Ellipse_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Ellipse_Delete\n  * wrapname: _wrap_Geom2d_Ellipse_Delete\n  * fulldecl: void Handle_Geom2d_Ellipse::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Ellipse_SetElips2d(Handle_Geom2d_Ellipse *self,gp_Elips2d const &E){
    (*self)->SetElips2d(E);
  }
EXPORT void _wrap_Geom2d_Ellipse_SetElips2d (Handle_Geom2d_Ellipse *larg1, gp_Elips2d *larg2) {
  Handle_Geom2d_Ellipse *arg1 = (Handle_Geom2d_Ellipse *) 0 ;
  gp_Elips2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Ellipse_SetElips2d(arg1,(gp_Elips2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Ellipse_SetElips2d\n  * wrapname: _wrap_Geom2d_Ellipse_SetElips2d\n  * fulldecl: void Handle_Geom2d_Ellipse::SetElips2d(gp_Elips2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Ellipse_SetMajorRadius(Handle_Geom2d_Ellipse *self,Standard_Real const MajorRadius){
    (*self)->SetMajorRadius(MajorRadius);
  }
EXPORT void _wrap_Geom2d_Ellipse_SetMajorRadius (Handle_Geom2d_Ellipse *larg1, Standard_Real larg2) {
  Handle_Geom2d_Ellipse *arg1 = (Handle_Geom2d_Ellipse *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Ellipse_SetMajorRadius(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Ellipse_SetMajorRadius\n  * wrapname: _wrap_Geom2d_Ellipse_SetMajorRadius\n  * fulldecl: void Handle_Geom2d_Ellipse::SetMajorRadius(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Ellipse_SetMinorRadius(Handle_Geom2d_Ellipse *self,Standard_Real const MinorRadius){
    (*self)->SetMinorRadius(MinorRadius);
  }
EXPORT void _wrap_Geom2d_Ellipse_SetMinorRadius (Handle_Geom2d_Ellipse *larg1, Standard_Real larg2) {
  Handle_Geom2d_Ellipse *arg1 = (Handle_Geom2d_Ellipse *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Ellipse_SetMinorRadius(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Ellipse_SetMinorRadius\n  * wrapname: _wrap_Geom2d_Ellipse_SetMinorRadius\n  * fulldecl: void Handle_Geom2d_Ellipse::SetMinorRadius(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Elips2d Handle_Geom2d_Ellipse_Elips2d(Handle_Geom2d_Ellipse *self){
    return (*self)->Elips2d();
  }
EXPORT gp_Elips2d *_wrap_Geom2d_Ellipse_Elips2d (Handle_Geom2d_Ellipse *larg1) {
  gp_Elips2d * lresult = (gp_Elips2d *)0 ;
  Handle_Geom2d_Ellipse *arg1 = (Handle_Geom2d_Ellipse *) 0 ;
  gp_Elips2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Ellipse_Elips2d(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Ellipse_Elips2d\n  * wrapname: _wrap_Geom2d_Ellipse_Elips2d\n  * fulldecl: gp_Elips2d Handle_Geom2d_Ellipse::Elips2d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Elips2d(result);
    return lresult;
  } catch (...) {
    return (gp_Elips2d *)0;
  }
}


SWIGINTERN gp_Ax2d Handle_Geom2d_Ellipse_Directrix1(Handle_Geom2d_Ellipse *self){
    return (*self)->Directrix1();
  }
EXPORT gp_Ax2d *_wrap_Geom2d_Ellipse_Directrix1 (Handle_Geom2d_Ellipse *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  Handle_Geom2d_Ellipse *arg1 = (Handle_Geom2d_Ellipse *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Ellipse_Directrix1(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Ellipse_Directrix1\n  * wrapname: _wrap_Geom2d_Ellipse_Directrix1\n  * fulldecl: gp_Ax2d Handle_Geom2d_Ellipse::Directrix1()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


SWIGINTERN gp_Ax2d Handle_Geom2d_Ellipse_Directrix2(Handle_Geom2d_Ellipse *self){
    return (*self)->Directrix2();
  }
EXPORT gp_Ax2d *_wrap_Geom2d_Ellipse_Directrix2 (Handle_Geom2d_Ellipse *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  Handle_Geom2d_Ellipse *arg1 = (Handle_Geom2d_Ellipse *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Ellipse_Directrix2(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Ellipse_Directrix2\n  * wrapname: _wrap_Geom2d_Ellipse_Directrix2\n  * fulldecl: gp_Ax2d Handle_Geom2d_Ellipse::Directrix2()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Ellipse_Focal(Handle_Geom2d_Ellipse *self){
    return (*self)->Focal();
  }
EXPORT Standard_Real _wrap_Geom2d_Ellipse_Focal (Handle_Geom2d_Ellipse *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Ellipse *arg1 = (Handle_Geom2d_Ellipse *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Ellipse_Focal(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Ellipse_Focal\n  * wrapname: _wrap_Geom2d_Ellipse_Focal\n  * fulldecl: Standard_Real Handle_Geom2d_Ellipse::Focal()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN gp_Pnt2d Handle_Geom2d_Ellipse_Focus1(Handle_Geom2d_Ellipse *self){
    return (*self)->Focus1();
  }
EXPORT gp_Pnt2d *_wrap_Geom2d_Ellipse_Focus1 (Handle_Geom2d_Ellipse *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Handle_Geom2d_Ellipse *arg1 = (Handle_Geom2d_Ellipse *) 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Ellipse_Focus1(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Ellipse_Focus1\n  * wrapname: _wrap_Geom2d_Ellipse_Focus1\n  * fulldecl: gp_Pnt2d Handle_Geom2d_Ellipse::Focus1()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


SWIGINTERN gp_Pnt2d Handle_Geom2d_Ellipse_Focus2(Handle_Geom2d_Ellipse *self){
    return (*self)->Focus2();
  }
EXPORT gp_Pnt2d *_wrap_Geom2d_Ellipse_Focus2 (Handle_Geom2d_Ellipse *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Handle_Geom2d_Ellipse *arg1 = (Handle_Geom2d_Ellipse *) 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Ellipse_Focus2(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Ellipse_Focus2\n  * wrapname: _wrap_Geom2d_Ellipse_Focus2\n  * fulldecl: gp_Pnt2d Handle_Geom2d_Ellipse::Focus2()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Ellipse_MajorRadius(Handle_Geom2d_Ellipse *self){
    return (*self)->MajorRadius();
  }
EXPORT Standard_Real _wrap_Geom2d_Ellipse_MajorRadius (Handle_Geom2d_Ellipse *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Ellipse *arg1 = (Handle_Geom2d_Ellipse *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Ellipse_MajorRadius(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Ellipse_MajorRadius\n  * wrapname: _wrap_Geom2d_Ellipse_MajorRadius\n  * fulldecl: Standard_Real Handle_Geom2d_Ellipse::MajorRadius()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Ellipse_MinorRadius(Handle_Geom2d_Ellipse *self){
    return (*self)->MinorRadius();
  }
EXPORT Standard_Real _wrap_Geom2d_Ellipse_MinorRadius (Handle_Geom2d_Ellipse *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Ellipse *arg1 = (Handle_Geom2d_Ellipse *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Ellipse_MinorRadius(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Ellipse_MinorRadius\n  * wrapname: _wrap_Geom2d_Ellipse_MinorRadius\n  * fulldecl: Standard_Real Handle_Geom2d_Ellipse::MinorRadius()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Ellipse_Parameter(Handle_Geom2d_Ellipse *self){
    return (*self)->Parameter();
  }
EXPORT Standard_Real _wrap_Geom2d_Ellipse_Parameter (Handle_Geom2d_Ellipse *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Ellipse *arg1 = (Handle_Geom2d_Ellipse *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Ellipse_Parameter(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Ellipse_Parameter\n  * wrapname: _wrap_Geom2d_Ellipse_Parameter\n  * fulldecl: Standard_Real Handle_Geom2d_Ellipse::Parameter()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Handle_Geom2d_Hyperbola *new_Handle_Geom2d_Hyperbola__SWIG_0(gp_Hypr2d const &H){
    return new Handle_Geom2d_Hyperbola(new Geom2d_Hyperbola(H));
  }
EXPORT Handle_Geom2d_Hyperbola *_wrap_new_Geom2d_Hyperbola__SWIG_0 (gp_Hypr2d *larg1) {
  Handle_Geom2d_Hyperbola * lresult = (Handle_Geom2d_Hyperbola *)0 ;
  gp_Hypr2d *arg1 = 0 ;
  Handle_Geom2d_Hyperbola *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Hyperbola *)new_Handle_Geom2d_Hyperbola__SWIG_0((gp_Hypr2d const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Hyperbola\n  * wrapname: _wrap_new_Geom2d_Hyperbola__SWIG_0\n  * fulldecl: Handle_Geom2d_Hyperbola::Handle_Geom2d_Hyperbola(gp_Hypr2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Hyperbola *)0;
  }
}


SWIGINTERN Handle_Geom2d_Hyperbola *new_Handle_Geom2d_Hyperbola__SWIG_1(gp_Ax2d const &MajorAxis,Standard_Real const MajorRadius,Standard_Real const MinorRadius,Standard_Boolean const Sense=Standard_True){
    return new Handle_Geom2d_Hyperbola(new Geom2d_Hyperbola(MajorAxis, MajorRadius, MinorRadius, Sense));
  }
EXPORT Handle_Geom2d_Hyperbola *_wrap_new_Geom2d_Hyperbola__SWIG_1 (gp_Ax2d *larg1, Standard_Real larg2, Standard_Real larg3, bool larg4) {
  Handle_Geom2d_Hyperbola * lresult = (Handle_Geom2d_Hyperbola *)0 ;
  gp_Ax2d *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Boolean arg4 ;
  Handle_Geom2d_Hyperbola *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Hyperbola *)new_Handle_Geom2d_Hyperbola__SWIG_1((gp_Ax2d const &)*arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Hyperbola\n  * wrapname: _wrap_new_Geom2d_Hyperbola__SWIG_1\n  * fulldecl: Handle_Geom2d_Hyperbola::Handle_Geom2d_Hyperbola(gp_Ax2d const &,Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Hyperbola *)0;
  }
}


EXPORT Handle_Geom2d_Hyperbola *_wrap_new_Geom2d_Hyperbola__SWIG_2 (gp_Ax2d *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom2d_Hyperbola * lresult = (Handle_Geom2d_Hyperbola *)0 ;
  gp_Ax2d *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Handle_Geom2d_Hyperbola *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Hyperbola *)new_Handle_Geom2d_Hyperbola__SWIG_1((gp_Ax2d const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Hyperbola\n  * wrapname: _wrap_new_Geom2d_Hyperbola__SWIG_2\n  * fulldecl: Handle_Geom2d_Hyperbola::Handle_Geom2d_Hyperbola(gp_Ax2d const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Hyperbola *)0;
  }
}


SWIGINTERN Handle_Geom2d_Hyperbola *new_Handle_Geom2d_Hyperbola__SWIG_3(gp_Ax22d const &Axis,Standard_Real const MajorRadius,Standard_Real const MinorRadius){
    return new Handle_Geom2d_Hyperbola(new Geom2d_Hyperbola(Axis, MajorRadius, MinorRadius));
  }
EXPORT Handle_Geom2d_Hyperbola *_wrap_new_Geom2d_Hyperbola__SWIG_3 (gp_Ax22d *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom2d_Hyperbola * lresult = (Handle_Geom2d_Hyperbola *)0 ;
  gp_Ax22d *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Handle_Geom2d_Hyperbola *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Hyperbola *)new_Handle_Geom2d_Hyperbola__SWIG_3((gp_Ax22d const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Hyperbola\n  * wrapname: _wrap_new_Geom2d_Hyperbola__SWIG_3\n  * fulldecl: Handle_Geom2d_Hyperbola::Handle_Geom2d_Hyperbola(gp_Ax22d const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Hyperbola *)0;
  }
}


SWIGINTERN void Handle_Geom2d_Hyperbola_Delete(Handle_Geom2d_Hyperbola *self){
    self->~Handle_Geom2d_Hyperbola();
  }
EXPORT void _wrap_Geom2d_Hyperbola_Delete (Handle_Geom2d_Hyperbola *larg1) {
  Handle_Geom2d_Hyperbola *arg1 = (Handle_Geom2d_Hyperbola *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Hyperbola_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Hyperbola_Delete\n  * wrapname: _wrap_Geom2d_Hyperbola_Delete\n  * fulldecl: void Handle_Geom2d_Hyperbola::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Hyperbola_SetHypr2d(Handle_Geom2d_Hyperbola *self,gp_Hypr2d const &H){
    (*self)->SetHypr2d(H);
  }
EXPORT void _wrap_Geom2d_Hyperbola_SetHypr2d (Handle_Geom2d_Hyperbola *larg1, gp_Hypr2d *larg2) {
  Handle_Geom2d_Hyperbola *arg1 = (Handle_Geom2d_Hyperbola *) 0 ;
  gp_Hypr2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Hyperbola_SetHypr2d(arg1,(gp_Hypr2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Hyperbola_SetHypr2d\n  * wrapname: _wrap_Geom2d_Hyperbola_SetHypr2d\n  * fulldecl: void Handle_Geom2d_Hyperbola::SetHypr2d(gp_Hypr2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Hyperbola_SetMajorRadius(Handle_Geom2d_Hyperbola *self,Standard_Real const MajorRadius){
    (*self)->SetMajorRadius(MajorRadius);
  }
EXPORT void _wrap_Geom2d_Hyperbola_SetMajorRadius (Handle_Geom2d_Hyperbola *larg1, Standard_Real larg2) {
  Handle_Geom2d_Hyperbola *arg1 = (Handle_Geom2d_Hyperbola *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Hyperbola_SetMajorRadius(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Hyperbola_SetMajorRadius\n  * wrapname: _wrap_Geom2d_Hyperbola_SetMajorRadius\n  * fulldecl: void Handle_Geom2d_Hyperbola::SetMajorRadius(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Hyperbola_SetMinorRadius(Handle_Geom2d_Hyperbola *self,Standard_Real const MinorRadius){
    (*self)->SetMinorRadius(MinorRadius);
  }
EXPORT void _wrap_Geom2d_Hyperbola_SetMinorRadius (Handle_Geom2d_Hyperbola *larg1, Standard_Real larg2) {
  Handle_Geom2d_Hyperbola *arg1 = (Handle_Geom2d_Hyperbola *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Hyperbola_SetMinorRadius(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Hyperbola_SetMinorRadius\n  * wrapname: _wrap_Geom2d_Hyperbola_SetMinorRadius\n  * fulldecl: void Handle_Geom2d_Hyperbola::SetMinorRadius(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Hypr2d Handle_Geom2d_Hyperbola_Hypr2d(Handle_Geom2d_Hyperbola *self){
    return (*self)->Hypr2d();
  }
EXPORT gp_Hypr2d *_wrap_Geom2d_Hyperbola_Hypr2d (Handle_Geom2d_Hyperbola *larg1) {
  gp_Hypr2d * lresult = (gp_Hypr2d *)0 ;
  Handle_Geom2d_Hyperbola *arg1 = (Handle_Geom2d_Hyperbola *) 0 ;
  gp_Hypr2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Hyperbola_Hypr2d(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Hyperbola_Hypr2d\n  * wrapname: _wrap_Geom2d_Hyperbola_Hypr2d\n  * fulldecl: gp_Hypr2d Handle_Geom2d_Hyperbola::Hypr2d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr2d(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr2d *)0;
  }
}


SWIGINTERN gp_Ax2d Handle_Geom2d_Hyperbola_Asymptote1(Handle_Geom2d_Hyperbola *self){
    return (*self)->Asymptote1();
  }
EXPORT gp_Ax2d *_wrap_Geom2d_Hyperbola_Asymptote1 (Handle_Geom2d_Hyperbola *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  Handle_Geom2d_Hyperbola *arg1 = (Handle_Geom2d_Hyperbola *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Hyperbola_Asymptote1(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Hyperbola_Asymptote1\n  * wrapname: _wrap_Geom2d_Hyperbola_Asymptote1\n  * fulldecl: gp_Ax2d Handle_Geom2d_Hyperbola::Asymptote1()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


SWIGINTERN gp_Ax2d Handle_Geom2d_Hyperbola_Asymptote2(Handle_Geom2d_Hyperbola *self){
    return (*self)->Asymptote2();
  }
EXPORT gp_Ax2d *_wrap_Geom2d_Hyperbola_Asymptote2 (Handle_Geom2d_Hyperbola *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  Handle_Geom2d_Hyperbola *arg1 = (Handle_Geom2d_Hyperbola *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Hyperbola_Asymptote2(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Hyperbola_Asymptote2\n  * wrapname: _wrap_Geom2d_Hyperbola_Asymptote2\n  * fulldecl: gp_Ax2d Handle_Geom2d_Hyperbola::Asymptote2()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


SWIGINTERN gp_Hypr2d Handle_Geom2d_Hyperbola_ConjugateBranch1(Handle_Geom2d_Hyperbola *self){
    return (*self)->ConjugateBranch1();
  }
EXPORT gp_Hypr2d *_wrap_Geom2d_Hyperbola_ConjugateBranch1 (Handle_Geom2d_Hyperbola *larg1) {
  gp_Hypr2d * lresult = (gp_Hypr2d *)0 ;
  Handle_Geom2d_Hyperbola *arg1 = (Handle_Geom2d_Hyperbola *) 0 ;
  gp_Hypr2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Hyperbola_ConjugateBranch1(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Hyperbola_ConjugateBranch1\n  * wrapname: _wrap_Geom2d_Hyperbola_ConjugateBranch1\n  * fulldecl: gp_Hypr2d Handle_Geom2d_Hyperbola::ConjugateBranch1()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr2d(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr2d *)0;
  }
}


SWIGINTERN gp_Hypr2d Handle_Geom2d_Hyperbola_ConjugateBranch2(Handle_Geom2d_Hyperbola *self){
    return (*self)->ConjugateBranch2();
  }
EXPORT gp_Hypr2d *_wrap_Geom2d_Hyperbola_ConjugateBranch2 (Handle_Geom2d_Hyperbola *larg1) {
  gp_Hypr2d * lresult = (gp_Hypr2d *)0 ;
  Handle_Geom2d_Hyperbola *arg1 = (Handle_Geom2d_Hyperbola *) 0 ;
  gp_Hypr2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Hyperbola_ConjugateBranch2(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Hyperbola_ConjugateBranch2\n  * wrapname: _wrap_Geom2d_Hyperbola_ConjugateBranch2\n  * fulldecl: gp_Hypr2d Handle_Geom2d_Hyperbola::ConjugateBranch2()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr2d(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr2d *)0;
  }
}


SWIGINTERN gp_Ax2d Handle_Geom2d_Hyperbola_Directrix1(Handle_Geom2d_Hyperbola *self){
    return (*self)->Directrix1();
  }
EXPORT gp_Ax2d *_wrap_Geom2d_Hyperbola_Directrix1 (Handle_Geom2d_Hyperbola *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  Handle_Geom2d_Hyperbola *arg1 = (Handle_Geom2d_Hyperbola *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Hyperbola_Directrix1(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Hyperbola_Directrix1\n  * wrapname: _wrap_Geom2d_Hyperbola_Directrix1\n  * fulldecl: gp_Ax2d Handle_Geom2d_Hyperbola::Directrix1()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


SWIGINTERN gp_Ax2d Handle_Geom2d_Hyperbola_Directrix2(Handle_Geom2d_Hyperbola *self){
    return (*self)->Directrix2();
  }
EXPORT gp_Ax2d *_wrap_Geom2d_Hyperbola_Directrix2 (Handle_Geom2d_Hyperbola *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  Handle_Geom2d_Hyperbola *arg1 = (Handle_Geom2d_Hyperbola *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Hyperbola_Directrix2(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Hyperbola_Directrix2\n  * wrapname: _wrap_Geom2d_Hyperbola_Directrix2\n  * fulldecl: gp_Ax2d Handle_Geom2d_Hyperbola::Directrix2()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Hyperbola_Focal(Handle_Geom2d_Hyperbola *self){
    return (*self)->Focal();
  }
EXPORT Standard_Real _wrap_Geom2d_Hyperbola_Focal (Handle_Geom2d_Hyperbola *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Hyperbola *arg1 = (Handle_Geom2d_Hyperbola *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Hyperbola_Focal(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Hyperbola_Focal\n  * wrapname: _wrap_Geom2d_Hyperbola_Focal\n  * fulldecl: Standard_Real Handle_Geom2d_Hyperbola::Focal()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN gp_Pnt2d Handle_Geom2d_Hyperbola_Focus1(Handle_Geom2d_Hyperbola *self){
    return (*self)->Focus1();
  }
EXPORT gp_Pnt2d *_wrap_Geom2d_Hyperbola_Focus1 (Handle_Geom2d_Hyperbola *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Handle_Geom2d_Hyperbola *arg1 = (Handle_Geom2d_Hyperbola *) 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Hyperbola_Focus1(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Hyperbola_Focus1\n  * wrapname: _wrap_Geom2d_Hyperbola_Focus1\n  * fulldecl: gp_Pnt2d Handle_Geom2d_Hyperbola::Focus1()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


SWIGINTERN gp_Pnt2d Handle_Geom2d_Hyperbola_Focus2(Handle_Geom2d_Hyperbola *self){
    return (*self)->Focus2();
  }
EXPORT gp_Pnt2d *_wrap_Geom2d_Hyperbola_Focus2 (Handle_Geom2d_Hyperbola *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Handle_Geom2d_Hyperbola *arg1 = (Handle_Geom2d_Hyperbola *) 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Hyperbola_Focus2(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Hyperbola_Focus2\n  * wrapname: _wrap_Geom2d_Hyperbola_Focus2\n  * fulldecl: gp_Pnt2d Handle_Geom2d_Hyperbola::Focus2()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Hyperbola_MajorRadius(Handle_Geom2d_Hyperbola *self){
    return (*self)->MajorRadius();
  }
EXPORT Standard_Real _wrap_Geom2d_Hyperbola_MajorRadius (Handle_Geom2d_Hyperbola *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Hyperbola *arg1 = (Handle_Geom2d_Hyperbola *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Hyperbola_MajorRadius(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Hyperbola_MajorRadius\n  * wrapname: _wrap_Geom2d_Hyperbola_MajorRadius\n  * fulldecl: Standard_Real Handle_Geom2d_Hyperbola::MajorRadius()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Hyperbola_MinorRadius(Handle_Geom2d_Hyperbola *self){
    return (*self)->MinorRadius();
  }
EXPORT Standard_Real _wrap_Geom2d_Hyperbola_MinorRadius (Handle_Geom2d_Hyperbola *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Hyperbola *arg1 = (Handle_Geom2d_Hyperbola *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Hyperbola_MinorRadius(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Hyperbola_MinorRadius\n  * wrapname: _wrap_Geom2d_Hyperbola_MinorRadius\n  * fulldecl: Standard_Real Handle_Geom2d_Hyperbola::MinorRadius()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN gp_Hypr2d Handle_Geom2d_Hyperbola_OtherBranch(Handle_Geom2d_Hyperbola *self){
    return (*self)->OtherBranch();
  }
EXPORT gp_Hypr2d *_wrap_Geom2d_Hyperbola_OtherBranch (Handle_Geom2d_Hyperbola *larg1) {
  gp_Hypr2d * lresult = (gp_Hypr2d *)0 ;
  Handle_Geom2d_Hyperbola *arg1 = (Handle_Geom2d_Hyperbola *) 0 ;
  gp_Hypr2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Hyperbola_OtherBranch(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Hyperbola_OtherBranch\n  * wrapname: _wrap_Geom2d_Hyperbola_OtherBranch\n  * fulldecl: gp_Hypr2d Handle_Geom2d_Hyperbola::OtherBranch()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr2d(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr2d *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Hyperbola_Parameter(Handle_Geom2d_Hyperbola *self){
    return (*self)->Parameter();
  }
EXPORT Standard_Real _wrap_Geom2d_Hyperbola_Parameter (Handle_Geom2d_Hyperbola *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Hyperbola *arg1 = (Handle_Geom2d_Hyperbola *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Hyperbola_Parameter(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Hyperbola_Parameter\n  * wrapname: _wrap_Geom2d_Hyperbola_Parameter\n  * fulldecl: Standard_Real Handle_Geom2d_Hyperbola::Parameter()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Handle_Geom2d_Parabola *new_Handle_Geom2d_Parabola__SWIG_0(gp_Parab2d const &Prb){
    return new Handle_Geom2d_Parabola(new Geom2d_Parabola(Prb));
  }
EXPORT Handle_Geom2d_Parabola *_wrap_new_Geom2d_Parabola__SWIG_0 (gp_Parab2d *larg1) {
  Handle_Geom2d_Parabola * lresult = (Handle_Geom2d_Parabola *)0 ;
  gp_Parab2d *arg1 = 0 ;
  Handle_Geom2d_Parabola *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Parabola *)new_Handle_Geom2d_Parabola__SWIG_0((gp_Parab2d const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Parabola\n  * wrapname: _wrap_new_Geom2d_Parabola__SWIG_0\n  * fulldecl: Handle_Geom2d_Parabola::Handle_Geom2d_Parabola(gp_Parab2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Parabola *)0;
  }
}


SWIGINTERN Handle_Geom2d_Parabola *new_Handle_Geom2d_Parabola__SWIG_1(gp_Ax2d const &MirrorAxis,Standard_Real const Focal,Standard_Boolean const Sense=Standard_True){
    return new Handle_Geom2d_Parabola(new Geom2d_Parabola(MirrorAxis, Focal, Sense));
  }
EXPORT Handle_Geom2d_Parabola *_wrap_new_Geom2d_Parabola__SWIG_1 (gp_Ax2d *larg1, Standard_Real larg2, bool larg3) {
  Handle_Geom2d_Parabola * lresult = (Handle_Geom2d_Parabola *)0 ;
  gp_Ax2d *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Boolean arg3 ;
  Handle_Geom2d_Parabola *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Parabola *)new_Handle_Geom2d_Parabola__SWIG_1((gp_Ax2d const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Parabola\n  * wrapname: _wrap_new_Geom2d_Parabola__SWIG_1\n  * fulldecl: Handle_Geom2d_Parabola::Handle_Geom2d_Parabola(gp_Ax2d const &,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Parabola *)0;
  }
}


EXPORT Handle_Geom2d_Parabola *_wrap_new_Geom2d_Parabola__SWIG_2 (gp_Ax2d *larg1, Standard_Real larg2) {
  Handle_Geom2d_Parabola * lresult = (Handle_Geom2d_Parabola *)0 ;
  gp_Ax2d *arg1 = 0 ;
  Standard_Real arg2 ;
  Handle_Geom2d_Parabola *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Parabola *)new_Handle_Geom2d_Parabola__SWIG_1((gp_Ax2d const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Parabola\n  * wrapname: _wrap_new_Geom2d_Parabola__SWIG_2\n  * fulldecl: Handle_Geom2d_Parabola::Handle_Geom2d_Parabola(gp_Ax2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Parabola *)0;
  }
}


SWIGINTERN Handle_Geom2d_Parabola *new_Handle_Geom2d_Parabola__SWIG_3(gp_Ax22d const &Axis,Standard_Real const Focal){
    return new Handle_Geom2d_Parabola(new Geom2d_Parabola(Axis, Focal));
  }
EXPORT Handle_Geom2d_Parabola *_wrap_new_Geom2d_Parabola__SWIG_3 (gp_Ax22d *larg1, Standard_Real larg2) {
  Handle_Geom2d_Parabola * lresult = (Handle_Geom2d_Parabola *)0 ;
  gp_Ax22d *arg1 = 0 ;
  Standard_Real arg2 ;
  Handle_Geom2d_Parabola *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Parabola *)new_Handle_Geom2d_Parabola__SWIG_3((gp_Ax22d const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Parabola\n  * wrapname: _wrap_new_Geom2d_Parabola__SWIG_3\n  * fulldecl: Handle_Geom2d_Parabola::Handle_Geom2d_Parabola(gp_Ax22d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Parabola *)0;
  }
}


SWIGINTERN Handle_Geom2d_Parabola *new_Handle_Geom2d_Parabola__SWIG_4(gp_Ax2d const &D,gp_Pnt2d const &F){
    return new Handle_Geom2d_Parabola(new Geom2d_Parabola(D, F));
  }
EXPORT Handle_Geom2d_Parabola *_wrap_new_Geom2d_Parabola__SWIG_4 (gp_Ax2d *larg1, gp_Pnt2d *larg2) {
  Handle_Geom2d_Parabola * lresult = (Handle_Geom2d_Parabola *)0 ;
  gp_Ax2d *arg1 = 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Handle_Geom2d_Parabola *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Parabola *)new_Handle_Geom2d_Parabola__SWIG_4((gp_Ax2d const &)*arg1,(gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Parabola\n  * wrapname: _wrap_new_Geom2d_Parabola__SWIG_4\n  * fulldecl: Handle_Geom2d_Parabola::Handle_Geom2d_Parabola(gp_Ax2d const &,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Parabola *)0;
  }
}


SWIGINTERN void Handle_Geom2d_Parabola_Delete(Handle_Geom2d_Parabola *self){
    self->~Handle_Geom2d_Parabola();
  }
EXPORT void _wrap_Geom2d_Parabola_Delete (Handle_Geom2d_Parabola *larg1) {
  Handle_Geom2d_Parabola *arg1 = (Handle_Geom2d_Parabola *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Parabola_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Parabola_Delete\n  * wrapname: _wrap_Geom2d_Parabola_Delete\n  * fulldecl: void Handle_Geom2d_Parabola::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Parabola_SetFocal(Handle_Geom2d_Parabola *self,Standard_Real const Focal){
    (*self)->SetFocal(Focal);
  }
EXPORT void _wrap_Geom2d_Parabola_SetFocal (Handle_Geom2d_Parabola *larg1, Standard_Real larg2) {
  Handle_Geom2d_Parabola *arg1 = (Handle_Geom2d_Parabola *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Parabola_SetFocal(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Parabola_SetFocal\n  * wrapname: _wrap_Geom2d_Parabola_SetFocal\n  * fulldecl: void Handle_Geom2d_Parabola::SetFocal(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Parabola_SetParab2d(Handle_Geom2d_Parabola *self,gp_Parab2d const &Prb){
    (*self)->SetParab2d(Prb);
  }
EXPORT void _wrap_Geom2d_Parabola_SetParab2d (Handle_Geom2d_Parabola *larg1, gp_Parab2d *larg2) {
  Handle_Geom2d_Parabola *arg1 = (Handle_Geom2d_Parabola *) 0 ;
  gp_Parab2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Parabola_SetParab2d(arg1,(gp_Parab2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Parabola_SetParab2d\n  * wrapname: _wrap_Geom2d_Parabola_SetParab2d\n  * fulldecl: void Handle_Geom2d_Parabola::SetParab2d(gp_Parab2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Parab2d Handle_Geom2d_Parabola_Parab2d(Handle_Geom2d_Parabola *self){
    return (*self)->Parab2d();
  }
EXPORT gp_Parab2d *_wrap_Geom2d_Parabola_Parab2d (Handle_Geom2d_Parabola *larg1) {
  gp_Parab2d * lresult = (gp_Parab2d *)0 ;
  Handle_Geom2d_Parabola *arg1 = (Handle_Geom2d_Parabola *) 0 ;
  gp_Parab2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Parabola_Parab2d(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Parabola_Parab2d\n  * wrapname: _wrap_Geom2d_Parabola_Parab2d\n  * fulldecl: gp_Parab2d Handle_Geom2d_Parabola::Parab2d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Parab2d(result);
    return lresult;
  } catch (...) {
    return (gp_Parab2d *)0;
  }
}


SWIGINTERN gp_Ax2d Handle_Geom2d_Parabola_Directrix(Handle_Geom2d_Parabola *self){
    return (*self)->Directrix();
  }
EXPORT gp_Ax2d *_wrap_Geom2d_Parabola_Directrix (Handle_Geom2d_Parabola *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  Handle_Geom2d_Parabola *arg1 = (Handle_Geom2d_Parabola *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Parabola_Directrix(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Parabola_Directrix\n  * wrapname: _wrap_Geom2d_Parabola_Directrix\n  * fulldecl: gp_Ax2d Handle_Geom2d_Parabola::Directrix()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


SWIGINTERN gp_Pnt2d Handle_Geom2d_Parabola_Focus(Handle_Geom2d_Parabola *self){
    return (*self)->Focus();
  }
EXPORT gp_Pnt2d *_wrap_Geom2d_Parabola_Focus (Handle_Geom2d_Parabola *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Handle_Geom2d_Parabola *arg1 = (Handle_Geom2d_Parabola *) 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Parabola_Focus(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Parabola_Focus\n  * wrapname: _wrap_Geom2d_Parabola_Focus\n  * fulldecl: gp_Pnt2d Handle_Geom2d_Parabola::Focus()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Parabola_Focal(Handle_Geom2d_Parabola *self){
    return (*self)->Focal();
  }
EXPORT Standard_Real _wrap_Geom2d_Parabola_Focal (Handle_Geom2d_Parabola *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Parabola *arg1 = (Handle_Geom2d_Parabola *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Parabola_Focal(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Parabola_Focal\n  * wrapname: _wrap_Geom2d_Parabola_Focal\n  * fulldecl: Standard_Real Handle_Geom2d_Parabola::Focal()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Parabola_Parameter(Handle_Geom2d_Parabola *self){
    return (*self)->Parameter();
  }
EXPORT Standard_Real _wrap_Geom2d_Parabola_Parameter (Handle_Geom2d_Parabola *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Parabola *arg1 = (Handle_Geom2d_Parabola *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Parabola_Parameter(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Parabola_Parameter\n  * wrapname: _wrap_Geom2d_Parabola_Parameter\n  * fulldecl: Standard_Real Handle_Geom2d_Parabola::Parameter()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN gp_Pnt2d Handle_Geom2d_BoundedCurve_EndPoint(Handle_Geom2d_BoundedCurve *self){
		return (*self)->EndPoint();
	}
EXPORT gp_Pnt2d *_wrap_Geom2d_BoundedCurve_EndPoint (Handle_Geom2d_BoundedCurve *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Handle_Geom2d_BoundedCurve *arg1 = (Handle_Geom2d_BoundedCurve *) 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_BoundedCurve_EndPoint(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BoundedCurve_EndPoint\n  * wrapname: _wrap_Geom2d_BoundedCurve_EndPoint\n  * fulldecl: gp_Pnt2d Handle_Geom2d_BoundedCurve::EndPoint()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


SWIGINTERN gp_Pnt2d Handle_Geom2d_BoundedCurve_StartPoint(Handle_Geom2d_BoundedCurve *self){
		return (*self)->StartPoint();
	}
EXPORT gp_Pnt2d *_wrap_Geom2d_BoundedCurve_StartPoint (Handle_Geom2d_BoundedCurve *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Handle_Geom2d_BoundedCurve *arg1 = (Handle_Geom2d_BoundedCurve *) 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_BoundedCurve_StartPoint(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BoundedCurve_StartPoint\n  * wrapname: _wrap_Geom2d_BoundedCurve_StartPoint\n  * fulldecl: gp_Pnt2d Handle_Geom2d_BoundedCurve::StartPoint()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


SWIGINTERN Handle_Geom2d_BezierCurve *new_Handle_Geom2d_BezierCurve__SWIG_0(TColgp_Array1OfPnt2d const &CurvePoles){
    return new Handle_Geom2d_BezierCurve(new Geom2d_BezierCurve(CurvePoles));
  }
EXPORT Handle_Geom2d_BezierCurve *_wrap_new_Geom2d_BezierCurve__SWIG_0 (TColgp_Array1OfPnt2d *larg1) {
  Handle_Geom2d_BezierCurve * lresult = (Handle_Geom2d_BezierCurve *)0 ;
  TColgp_Array1OfPnt2d *arg1 = 0 ;
  Handle_Geom2d_BezierCurve *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_BezierCurve *)new_Handle_Geom2d_BezierCurve__SWIG_0((TColgp_Array1OfPnt2d const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_BezierCurve\n  * wrapname: _wrap_new_Geom2d_BezierCurve__SWIG_0\n  * fulldecl: Handle_Geom2d_BezierCurve::Handle_Geom2d_BezierCurve(TColgp_Array1OfPnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_BezierCurve *)0;
  }
}


SWIGINTERN Handle_Geom2d_BezierCurve *new_Handle_Geom2d_BezierCurve__SWIG_1(TColgp_Array1OfPnt2d const &CurvePoles,TColStd_Array1OfReal const &PoleWeights){
    return new Handle_Geom2d_BezierCurve(new Geom2d_BezierCurve(CurvePoles, PoleWeights));
  }
EXPORT Handle_Geom2d_BezierCurve *_wrap_new_Geom2d_BezierCurve__SWIG_1 (TColgp_Array1OfPnt2d *larg1, TColStd_Array1OfReal *larg2) {
  Handle_Geom2d_BezierCurve * lresult = (Handle_Geom2d_BezierCurve *)0 ;
  TColgp_Array1OfPnt2d *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  Handle_Geom2d_BezierCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_BezierCurve *)new_Handle_Geom2d_BezierCurve__SWIG_1((TColgp_Array1OfPnt2d const &)*arg1,(TColStd_Array1OfReal const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_BezierCurve\n  * wrapname: _wrap_new_Geom2d_BezierCurve__SWIG_1\n  * fulldecl: Handle_Geom2d_BezierCurve::Handle_Geom2d_BezierCurve(TColgp_Array1OfPnt2d const &,TColStd_Array1OfReal const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_BezierCurve *)0;
  }
}


SWIGINTERN void Handle_Geom2d_BezierCurve_Delete(Handle_Geom2d_BezierCurve *self){
    self->~Handle_Geom2d_BezierCurve();
  }
EXPORT void _wrap_Geom2d_BezierCurve_Delete (Handle_Geom2d_BezierCurve *larg1) {
  Handle_Geom2d_BezierCurve *arg1 = (Handle_Geom2d_BezierCurve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BezierCurve_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BezierCurve_Delete\n  * wrapname: _wrap_Geom2d_BezierCurve_Delete\n  * fulldecl: void Handle_Geom2d_BezierCurve::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BezierCurve_Increase(Handle_Geom2d_BezierCurve *self,Standard_Integer const Degree){
    (*self)->Increase(Degree);
  }
EXPORT void _wrap_Geom2d_BezierCurve_Increase (Handle_Geom2d_BezierCurve *larg1, Standard_Integer larg2) {
  Handle_Geom2d_BezierCurve *arg1 = (Handle_Geom2d_BezierCurve *) 0 ;
  Standard_Integer arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BezierCurve_Increase(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BezierCurve_Increase\n  * wrapname: _wrap_Geom2d_BezierCurve_Increase\n  * fulldecl: void Handle_Geom2d_BezierCurve::Increase(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BezierCurve_InsertPoleAfter__SWIG_0(Handle_Geom2d_BezierCurve *self,Standard_Integer const Index,gp_Pnt2d const &P,Standard_Real const Weight=1.0){
    (*self)->InsertPoleAfter(Index, P, Weight);
  }
EXPORT void _wrap_Geom2d_BezierCurve_InsertPoleAfter__SWIG_0 (Handle_Geom2d_BezierCurve *larg1, Standard_Integer larg2, gp_Pnt2d *larg3, Standard_Real larg4) {
  Handle_Geom2d_BezierCurve *arg1 = (Handle_Geom2d_BezierCurve *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BezierCurve_InsertPoleAfter__SWIG_0(arg1,arg2,(gp_Pnt2d const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BezierCurve_InsertPoleAfter\n  * wrapname: _wrap_Geom2d_BezierCurve_InsertPoleAfter__SWIG_0\n  * fulldecl: void Handle_Geom2d_BezierCurve::InsertPoleAfter(Standard_Integer const,gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Geom2d_BezierCurve_InsertPoleAfter__SWIG_1 (Handle_Geom2d_BezierCurve *larg1, Standard_Integer larg2, gp_Pnt2d *larg3) {
  Handle_Geom2d_BezierCurve *arg1 = (Handle_Geom2d_BezierCurve *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BezierCurve_InsertPoleAfter__SWIG_0(arg1,arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BezierCurve_InsertPoleAfter\n  * wrapname: _wrap_Geom2d_BezierCurve_InsertPoleAfter__SWIG_1\n  * fulldecl: void Handle_Geom2d_BezierCurve::InsertPoleAfter(Standard_Integer const,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BezierCurve_InsertPoleBefore__SWIG_0(Handle_Geom2d_BezierCurve *self,Standard_Integer const Index,gp_Pnt2d const &P,Standard_Real const Weight=1.0){
    (*self)->InsertPoleAfter(Index, P, Weight);
  }
EXPORT void _wrap_Geom2d_BezierCurve_InsertPoleBefore__SWIG_0 (Handle_Geom2d_BezierCurve *larg1, Standard_Integer larg2, gp_Pnt2d *larg3, Standard_Real larg4) {
  Handle_Geom2d_BezierCurve *arg1 = (Handle_Geom2d_BezierCurve *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BezierCurve_InsertPoleBefore__SWIG_0(arg1,arg2,(gp_Pnt2d const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BezierCurve_InsertPoleBefore\n  * wrapname: _wrap_Geom2d_BezierCurve_InsertPoleBefore__SWIG_0\n  * fulldecl: void Handle_Geom2d_BezierCurve::InsertPoleBefore(Standard_Integer const,gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Geom2d_BezierCurve_InsertPoleBefore__SWIG_1 (Handle_Geom2d_BezierCurve *larg1, Standard_Integer larg2, gp_Pnt2d *larg3) {
  Handle_Geom2d_BezierCurve *arg1 = (Handle_Geom2d_BezierCurve *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BezierCurve_InsertPoleBefore__SWIG_0(arg1,arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BezierCurve_InsertPoleBefore\n  * wrapname: _wrap_Geom2d_BezierCurve_InsertPoleBefore__SWIG_1\n  * fulldecl: void Handle_Geom2d_BezierCurve::InsertPoleBefore(Standard_Integer const,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BezierCurve_RemovePole(Handle_Geom2d_BezierCurve *self,Standard_Integer const Index){
    (*self)->RemovePole(Index);
  }
EXPORT void _wrap_Geom2d_BezierCurve_RemovePole (Handle_Geom2d_BezierCurve *larg1, Standard_Integer larg2) {
  Handle_Geom2d_BezierCurve *arg1 = (Handle_Geom2d_BezierCurve *) 0 ;
  Standard_Integer arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BezierCurve_RemovePole(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BezierCurve_RemovePole\n  * wrapname: _wrap_Geom2d_BezierCurve_RemovePole\n  * fulldecl: void Handle_Geom2d_BezierCurve::RemovePole(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BezierCurve_Segment(Handle_Geom2d_BezierCurve *self,Standard_Real const U1,Standard_Real const U2){
    (*self)->Segment(U1, U2);
  }
EXPORT void _wrap_Geom2d_BezierCurve_Segment (Handle_Geom2d_BezierCurve *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom2d_BezierCurve *arg1 = (Handle_Geom2d_BezierCurve *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BezierCurve_Segment(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BezierCurve_Segment\n  * wrapname: _wrap_Geom2d_BezierCurve_Segment\n  * fulldecl: void Handle_Geom2d_BezierCurve::Segment(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BezierCurve_SetPole__SWIG_0(Handle_Geom2d_BezierCurve *self,Standard_Integer const Index,gp_Pnt2d const &P){
    (*self)->SetPole(Index, P);
  }
EXPORT void _wrap_Geom2d_BezierCurve_SetPole__SWIG_0 (Handle_Geom2d_BezierCurve *larg1, Standard_Integer larg2, gp_Pnt2d *larg3) {
  Handle_Geom2d_BezierCurve *arg1 = (Handle_Geom2d_BezierCurve *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BezierCurve_SetPole__SWIG_0(arg1,arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BezierCurve_SetPole\n  * wrapname: _wrap_Geom2d_BezierCurve_SetPole__SWIG_0\n  * fulldecl: void Handle_Geom2d_BezierCurve::SetPole(Standard_Integer const,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BezierCurve_SetPole__SWIG_1(Handle_Geom2d_BezierCurve *self,Standard_Integer const Index,gp_Pnt2d const &P,Standard_Real const Weight){
    (*self)->SetPole(Index, P, Weight);
  }
EXPORT void _wrap_Geom2d_BezierCurve_SetPole__SWIG_1 (Handle_Geom2d_BezierCurve *larg1, Standard_Integer larg2, gp_Pnt2d *larg3, Standard_Real larg4) {
  Handle_Geom2d_BezierCurve *arg1 = (Handle_Geom2d_BezierCurve *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BezierCurve_SetPole__SWIG_1(arg1,arg2,(gp_Pnt2d const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BezierCurve_SetPole\n  * wrapname: _wrap_Geom2d_BezierCurve_SetPole__SWIG_1\n  * fulldecl: void Handle_Geom2d_BezierCurve::SetPole(Standard_Integer const,gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BezierCurve_SetWeight(Handle_Geom2d_BezierCurve *self,Standard_Integer const Index,Standard_Real const Weight){
    (*self)->SetWeight(Index, Weight);
  }
EXPORT void _wrap_Geom2d_BezierCurve_SetWeight (Handle_Geom2d_BezierCurve *larg1, Standard_Integer larg2, Standard_Real larg3) {
  Handle_Geom2d_BezierCurve *arg1 = (Handle_Geom2d_BezierCurve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BezierCurve_SetWeight(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BezierCurve_SetWeight\n  * wrapname: _wrap_Geom2d_BezierCurve_SetWeight\n  * fulldecl: void Handle_Geom2d_BezierCurve::SetWeight(Standard_Integer const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Boolean Handle_Geom2d_BezierCurve_IsRational(Handle_Geom2d_BezierCurve *self){
    return (*self)->IsRational();
  }
EXPORT bool _wrap_Geom2d_BezierCurve_IsRational (Handle_Geom2d_BezierCurve *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom2d_BezierCurve *arg1 = (Handle_Geom2d_BezierCurve *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom2d_BezierCurve_IsRational(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BezierCurve_IsRational\n  * wrapname: _wrap_Geom2d_BezierCurve_IsRational\n  * fulldecl: Standard_Boolean Handle_Geom2d_BezierCurve::IsRational()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom2d_BezierCurve_Degree(Handle_Geom2d_BezierCurve *self){
    return (*self)->Degree();
  }
EXPORT Standard_Integer _wrap_Geom2d_BezierCurve_Degree (Handle_Geom2d_BezierCurve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom2d_BezierCurve *arg1 = (Handle_Geom2d_BezierCurve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom2d_BezierCurve_Degree(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BezierCurve_Degree\n  * wrapname: _wrap_Geom2d_BezierCurve_Degree\n  * fulldecl: Standard_Integer Handle_Geom2d_BezierCurve::Degree()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom2d_BezierCurve_NbPoles(Handle_Geom2d_BezierCurve *self){
    return (*self)->NbPoles();
  }
EXPORT Standard_Integer _wrap_Geom2d_BezierCurve_NbPoles (Handle_Geom2d_BezierCurve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom2d_BezierCurve *arg1 = (Handle_Geom2d_BezierCurve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom2d_BezierCurve_NbPoles(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BezierCurve_NbPoles\n  * wrapname: _wrap_Geom2d_BezierCurve_NbPoles\n  * fulldecl: Standard_Integer Handle_Geom2d_BezierCurve::NbPoles()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN gp_Pnt2d const Handle_Geom2d_BezierCurve_Pole(Handle_Geom2d_BezierCurve *self,Standard_Integer const Index){
    return (*self)->Pole(Index);
  }
EXPORT gp_Pnt2d const *_wrap_Geom2d_BezierCurve_Pole (Handle_Geom2d_BezierCurve *larg1, Standard_Integer larg2) {
  gp_Pnt2d const * lresult = (gp_Pnt2d const *)0 ;
  Handle_Geom2d_BezierCurve *arg1 = (Handle_Geom2d_BezierCurve *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_BezierCurve_Pole(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BezierCurve_Pole\n  * wrapname: _wrap_Geom2d_BezierCurve_Pole\n  * fulldecl: gp_Pnt2d const Handle_Geom2d_BezierCurve::Pole(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d const(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d const *)0;
  }
}


SWIGINTERN TColgp_Array1OfPnt2d const Handle_Geom2d_BezierCurve_Poles(Handle_Geom2d_BezierCurve *self){
    return (*self)->Poles();
  }
EXPORT TColgp_Array1OfPnt2d const *_wrap_Geom2d_BezierCurve_Poles (Handle_Geom2d_BezierCurve *larg1) {
  TColgp_Array1OfPnt2d const * lresult = (TColgp_Array1OfPnt2d const *)0 ;
  Handle_Geom2d_BezierCurve *arg1 = (Handle_Geom2d_BezierCurve *) 0 ;
  SwigValueWrapper< TColgp_Array1OfPnt2d > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_BezierCurve_Poles(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BezierCurve_Poles\n  * wrapname: _wrap_Geom2d_BezierCurve_Poles\n  * fulldecl: TColgp_Array1OfPnt2d const Handle_Geom2d_BezierCurve::Poles()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new TColgp_Array1OfPnt2d const(result);
    return lresult;
  } catch (...) {
    return (TColgp_Array1OfPnt2d const *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_BezierCurve_Weight(Handle_Geom2d_BezierCurve *self,Standard_Integer const Index){
    return (*self)->Weight(Index);
  }
EXPORT Standard_Real _wrap_Geom2d_BezierCurve_Weight (Handle_Geom2d_BezierCurve *larg1, Standard_Integer larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_BezierCurve *arg1 = (Handle_Geom2d_BezierCurve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_BezierCurve_Weight(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BezierCurve_Weight\n  * wrapname: _wrap_Geom2d_BezierCurve_Weight\n  * fulldecl: Standard_Real Handle_Geom2d_BezierCurve::Weight(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN TColStd_Array1OfReal const *Handle_Geom2d_BezierCurve_Weights(Handle_Geom2d_BezierCurve *self){
    return (*self)->Weights();
  }
EXPORT TColStd_Array1OfReal *_wrap_Geom2d_BezierCurve_Weights (Handle_Geom2d_BezierCurve *larg1) {
  TColStd_Array1OfReal * lresult = (TColStd_Array1OfReal *)0 ;
  Handle_Geom2d_BezierCurve *arg1 = (Handle_Geom2d_BezierCurve *) 0 ;
  TColStd_Array1OfReal *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColStd_Array1OfReal *)Handle_Geom2d_BezierCurve_Weights(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BezierCurve_Weights\n  * wrapname: _wrap_Geom2d_BezierCurve_Weights\n  * fulldecl: TColStd_Array1OfReal const * Handle_Geom2d_BezierCurve::Weights()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColStd_Array1OfReal *)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom2d_BezierCurve_MaxDegree(){
    return Geom2d_BezierCurve::MaxDegree();
  }
EXPORT Standard_Integer _wrap_Geom2d_BezierCurve_MaxDegree () {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Standard_Integer result;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom2d_BezierCurve_MaxDegree();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BezierCurve_MaxDegree\n  * wrapname: _wrap_Geom2d_BezierCurve_MaxDegree\n  * fulldecl: Standard_Integer Handle_Geom2d_BezierCurve::Handle_Geom2d_BezierCurve_MaxDegree()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN void Handle_Geom2d_BezierCurve_Resolution(Handle_Geom2d_BezierCurve *self,Standard_Real const ToleranceUV,Standard_Real &UTolerance){
    (*self)->Resolution(ToleranceUV, UTolerance);
  }
EXPORT void _wrap_Geom2d_BezierCurve_Resolution (Handle_Geom2d_BezierCurve *larg1, Standard_Real larg2, Standard_Real *larg3) {
  Handle_Geom2d_BezierCurve *arg1 = (Handle_Geom2d_BezierCurve *) 0 ;
  Standard_Real arg2 ;
  Standard_Real *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BezierCurve_Resolution(arg1,arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BezierCurve_Resolution\n  * wrapname: _wrap_Geom2d_BezierCurve_Resolution\n  * fulldecl: void Handle_Geom2d_BezierCurve::Resolution(Standard_Real const,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_BSplineCurve *new_Handle_Geom2d_BSplineCurve__SWIG_0(TColgp_Array1OfPnt2d const &Poles,TColStd_Array1OfReal const &Knots,TColStd_Array1OfInteger const &Multiplicities,Standard_Integer const Degree,Standard_Boolean const Periodic=Standard_False){
	    return new Handle_Geom2d_BSplineCurve(new Geom2d_BSplineCurve(Poles, Knots, Multiplicities,
            Degree, Periodic));
	}
EXPORT Handle_Geom2d_BSplineCurve *_wrap_new_Geom2d_BSplineCurve__SWIG_0 (TColgp_Array1OfPnt2d *larg1, TColStd_Array1OfReal *larg2, TColStd_Array1OfInteger *larg3, Standard_Integer larg4, bool larg5) {
  Handle_Geom2d_BSplineCurve * lresult = (Handle_Geom2d_BSplineCurve *)0 ;
  TColgp_Array1OfPnt2d *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  TColStd_Array1OfInteger *arg3 = 0 ;
  Standard_Integer arg4 ;
  Standard_Boolean arg5 ;
  Handle_Geom2d_BSplineCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = (bool)larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_BSplineCurve *)new_Handle_Geom2d_BSplineCurve__SWIG_0((TColgp_Array1OfPnt2d const &)*arg1,(TColStd_Array1OfReal const &)*arg2,(TColStd_Array1OfInteger const &)*arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_BSplineCurve\n  * wrapname: _wrap_new_Geom2d_BSplineCurve__SWIG_0\n  * fulldecl: Handle_Geom2d_BSplineCurve::Handle_Geom2d_BSplineCurve(TColgp_Array1OfPnt2d const &,TColStd_Array1OfReal const &,TColStd_Array1OfInteger const &,Standard_Integer const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_BSplineCurve *)0;
  }
}


EXPORT Handle_Geom2d_BSplineCurve *_wrap_new_Geom2d_BSplineCurve__SWIG_1 (TColgp_Array1OfPnt2d *larg1, TColStd_Array1OfReal *larg2, TColStd_Array1OfInteger *larg3, Standard_Integer larg4) {
  Handle_Geom2d_BSplineCurve * lresult = (Handle_Geom2d_BSplineCurve *)0 ;
  TColgp_Array1OfPnt2d *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  TColStd_Array1OfInteger *arg3 = 0 ;
  Standard_Integer arg4 ;
  Handle_Geom2d_BSplineCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_BSplineCurve *)new_Handle_Geom2d_BSplineCurve__SWIG_0((TColgp_Array1OfPnt2d const &)*arg1,(TColStd_Array1OfReal const &)*arg2,(TColStd_Array1OfInteger const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_BSplineCurve\n  * wrapname: _wrap_new_Geom2d_BSplineCurve__SWIG_1\n  * fulldecl: Handle_Geom2d_BSplineCurve::Handle_Geom2d_BSplineCurve(TColgp_Array1OfPnt2d const &,TColStd_Array1OfReal const &,TColStd_Array1OfInteger const &,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_BSplineCurve *)0;
  }
}


SWIGINTERN Handle_Geom2d_BSplineCurve *new_Handle_Geom2d_BSplineCurve__SWIG_2(TColgp_Array1OfPnt2d const &Poles,TColStd_Array1OfReal const &Weights,TColStd_Array1OfReal const &Knots,TColStd_Array1OfInteger const &Multiplicities,Standard_Integer const Degree,Standard_Boolean const Periodic=Standard_False){
        return new Handle_Geom2d_BSplineCurve(new Geom2d_BSplineCurve(Poles, Weights, Knots, 
            Multiplicities, Degree, Periodic));
    }
EXPORT Handle_Geom2d_BSplineCurve *_wrap_new_Geom2d_BSplineCurve__SWIG_2 (TColgp_Array1OfPnt2d *larg1, TColStd_Array1OfReal *larg2, TColStd_Array1OfReal *larg3, TColStd_Array1OfInteger *larg4, Standard_Integer larg5, bool larg6) {
  Handle_Geom2d_BSplineCurve * lresult = (Handle_Geom2d_BSplineCurve *)0 ;
  TColgp_Array1OfPnt2d *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  TColStd_Array1OfReal *arg3 = 0 ;
  TColStd_Array1OfInteger *arg4 = 0 ;
  Standard_Integer arg5 ;
  Standard_Boolean arg6 ;
  Handle_Geom2d_BSplineCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = (bool)larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_BSplineCurve *)new_Handle_Geom2d_BSplineCurve__SWIG_2((TColgp_Array1OfPnt2d const &)*arg1,(TColStd_Array1OfReal const &)*arg2,(TColStd_Array1OfReal const &)*arg3,(TColStd_Array1OfInteger const &)*arg4,arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_BSplineCurve\n  * wrapname: _wrap_new_Geom2d_BSplineCurve__SWIG_2\n  * fulldecl: Handle_Geom2d_BSplineCurve::Handle_Geom2d_BSplineCurve(TColgp_Array1OfPnt2d const &,TColStd_Array1OfReal const &,TColStd_Array1OfReal const &,TColStd_Array1OfInteger const &,Standard_Integer const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_BSplineCurve *)0;
  }
}


EXPORT Handle_Geom2d_BSplineCurve *_wrap_new_Geom2d_BSplineCurve__SWIG_3 (TColgp_Array1OfPnt2d *larg1, TColStd_Array1OfReal *larg2, TColStd_Array1OfReal *larg3, TColStd_Array1OfInteger *larg4, Standard_Integer larg5) {
  Handle_Geom2d_BSplineCurve * lresult = (Handle_Geom2d_BSplineCurve *)0 ;
  TColgp_Array1OfPnt2d *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  TColStd_Array1OfReal *arg3 = 0 ;
  TColStd_Array1OfInteger *arg4 = 0 ;
  Standard_Integer arg5 ;
  Handle_Geom2d_BSplineCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_BSplineCurve *)new_Handle_Geom2d_BSplineCurve__SWIG_2((TColgp_Array1OfPnt2d const &)*arg1,(TColStd_Array1OfReal const &)*arg2,(TColStd_Array1OfReal const &)*arg3,(TColStd_Array1OfInteger const &)*arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_BSplineCurve\n  * wrapname: _wrap_new_Geom2d_BSplineCurve__SWIG_3\n  * fulldecl: Handle_Geom2d_BSplineCurve::Handle_Geom2d_BSplineCurve(TColgp_Array1OfPnt2d const &,TColStd_Array1OfReal const &,TColStd_Array1OfReal const &,TColStd_Array1OfInteger const &,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_BSplineCurve *)0;
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_Delete(Handle_Geom2d_BSplineCurve *self){
      self->~Handle_Geom2d_BSplineCurve();
    }
EXPORT void _wrap_Geom2d_BSplineCurve_Delete (Handle_Geom2d_BSplineCurve *larg1) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_Delete\n  * wrapname: _wrap_Geom2d_BSplineCurve_Delete\n  * fulldecl: void Handle_Geom2d_BSplineCurve::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_IncreaseDegree(Handle_Geom2d_BSplineCurve *self,Standard_Integer const Degree){
      (*self)->IncreaseDegree(Degree);
    }
EXPORT void _wrap_Geom2d_BSplineCurve_IncreaseDegree (Handle_Geom2d_BSplineCurve *larg1, Standard_Integer larg2) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_IncreaseDegree(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_IncreaseDegree\n  * wrapname: _wrap_Geom2d_BSplineCurve_IncreaseDegree\n  * fulldecl: void Handle_Geom2d_BSplineCurve::IncreaseDegree(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_IncreaseMultiplicity__SWIG_0(Handle_Geom2d_BSplineCurve *self,Standard_Integer const Index,Standard_Integer const M){
      (*self)->IncreaseMultiplicity(Index, M);
    }
EXPORT void _wrap_Geom2d_BSplineCurve_IncreaseMultiplicity__SWIG_0 (Handle_Geom2d_BSplineCurve *larg1, Standard_Integer larg2, Standard_Integer larg3) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_IncreaseMultiplicity__SWIG_0(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_IncreaseMultiplicity\n  * wrapname: _wrap_Geom2d_BSplineCurve_IncreaseMultiplicity__SWIG_0\n  * fulldecl: void Handle_Geom2d_BSplineCurve::IncreaseMultiplicity(Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_IncreaseMultiplicity__SWIG_1(Handle_Geom2d_BSplineCurve *self,Standard_Integer const I1,Standard_Integer const I2,Standard_Integer const M){
      (*self)->IncreaseMultiplicity(I1, I2, M);
    }
EXPORT void _wrap_Geom2d_BSplineCurve_IncreaseMultiplicity__SWIG_1 (Handle_Geom2d_BSplineCurve *larg1, Standard_Integer larg2, Standard_Integer larg3, Standard_Integer larg4) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  Standard_Integer arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_IncreaseMultiplicity__SWIG_1(arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_IncreaseMultiplicity\n  * wrapname: _wrap_Geom2d_BSplineCurve_IncreaseMultiplicity__SWIG_1\n  * fulldecl: void Handle_Geom2d_BSplineCurve::IncreaseMultiplicity(Standard_Integer const,Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_IncrementMultiplicity(Handle_Geom2d_BSplineCurve *self,Standard_Integer const I1,Standard_Integer const I2,Standard_Integer const M){
      (*self)->IncrementMultiplicity(I1, I2, M);
    }
EXPORT void _wrap_Geom2d_BSplineCurve_IncrementMultiplicity (Handle_Geom2d_BSplineCurve *larg1, Standard_Integer larg2, Standard_Integer larg3, Standard_Integer larg4) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  Standard_Integer arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_IncrementMultiplicity(arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_IncrementMultiplicity\n  * wrapname: _wrap_Geom2d_BSplineCurve_IncrementMultiplicity\n  * fulldecl: void Handle_Geom2d_BSplineCurve::IncrementMultiplicity(Standard_Integer const,Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_InsertKnot__SWIG_0(Handle_Geom2d_BSplineCurve *self,Standard_Real const U,Standard_Integer const M=1,Standard_Real const ParametricTolerance=0.0){
      (*self)->InsertKnot(U, M, ParametricTolerance);
    }
EXPORT void _wrap_Geom2d_BSplineCurve_InsertKnot__SWIG_0 (Handle_Geom2d_BSplineCurve *larg1, Standard_Real larg2, Standard_Integer larg3, Standard_Real larg4) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Real arg2 ;
  Standard_Integer arg3 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_InsertKnot__SWIG_0(arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_InsertKnot\n  * wrapname: _wrap_Geom2d_BSplineCurve_InsertKnot__SWIG_0\n  * fulldecl: void Handle_Geom2d_BSplineCurve::InsertKnot(Standard_Real const,Standard_Integer const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Geom2d_BSplineCurve_InsertKnot__SWIG_1 (Handle_Geom2d_BSplineCurve *larg1, Standard_Real larg2, Standard_Integer larg3) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Real arg2 ;
  Standard_Integer arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_InsertKnot__SWIG_0(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_InsertKnot\n  * wrapname: _wrap_Geom2d_BSplineCurve_InsertKnot__SWIG_1\n  * fulldecl: void Handle_Geom2d_BSplineCurve::InsertKnot(Standard_Real const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Geom2d_BSplineCurve_InsertKnot__SWIG_2 (Handle_Geom2d_BSplineCurve *larg1, Standard_Real larg2) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_InsertKnot__SWIG_0(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_InsertKnot\n  * wrapname: _wrap_Geom2d_BSplineCurve_InsertKnot__SWIG_2\n  * fulldecl: void Handle_Geom2d_BSplineCurve::InsertKnot(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_InsertKnots__SWIG_0(Handle_Geom2d_BSplineCurve *self,TColStd_Array1OfReal const &Knots,TColStd_Array1OfInteger const &Mults,Standard_Real const ParametricTolerance=0.0,Standard_Boolean const Add=Standard_False){
      (*self)->InsertKnots(Knots, Mults, ParametricTolerance, Add);
    }
EXPORT void _wrap_Geom2d_BSplineCurve_InsertKnots__SWIG_0 (Handle_Geom2d_BSplineCurve *larg1, TColStd_Array1OfReal *larg2, TColStd_Array1OfInteger *larg3, Standard_Real larg4, bool larg5) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  TColStd_Array1OfInteger *arg3 = 0 ;
  Standard_Real arg4 ;
  Standard_Boolean arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = (bool)larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_InsertKnots__SWIG_0(arg1,(TColStd_Array1OfReal const &)*arg2,(TColStd_Array1OfInteger const &)*arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_InsertKnots\n  * wrapname: _wrap_Geom2d_BSplineCurve_InsertKnots__SWIG_0\n  * fulldecl: void Handle_Geom2d_BSplineCurve::InsertKnots(TColStd_Array1OfReal const &,TColStd_Array1OfInteger const &,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Geom2d_BSplineCurve_InsertKnots__SWIG_1 (Handle_Geom2d_BSplineCurve *larg1, TColStd_Array1OfReal *larg2, TColStd_Array1OfInteger *larg3, Standard_Real larg4) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  TColStd_Array1OfInteger *arg3 = 0 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_InsertKnots__SWIG_0(arg1,(TColStd_Array1OfReal const &)*arg2,(TColStd_Array1OfInteger const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_InsertKnots\n  * wrapname: _wrap_Geom2d_BSplineCurve_InsertKnots__SWIG_1\n  * fulldecl: void Handle_Geom2d_BSplineCurve::InsertKnots(TColStd_Array1OfReal const &,TColStd_Array1OfInteger const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Geom2d_BSplineCurve_InsertKnots__SWIG_2 (Handle_Geom2d_BSplineCurve *larg1, TColStd_Array1OfReal *larg2, TColStd_Array1OfInteger *larg3) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  TColStd_Array1OfInteger *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_InsertKnots__SWIG_0(arg1,(TColStd_Array1OfReal const &)*arg2,(TColStd_Array1OfInteger const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_InsertKnots\n  * wrapname: _wrap_Geom2d_BSplineCurve_InsertKnots__SWIG_2\n  * fulldecl: void Handle_Geom2d_BSplineCurve::InsertKnots(TColStd_Array1OfReal const &,TColStd_Array1OfInteger const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Boolean Handle_Geom2d_BSplineCurve_RemoveKnot(Handle_Geom2d_BSplineCurve *self,Standard_Integer const Index,Standard_Integer const M,Standard_Real const Tolerance){
      return (*self)->RemoveKnot(Index, M, Tolerance);
    }
EXPORT bool _wrap_Geom2d_BSplineCurve_RemoveKnot (Handle_Geom2d_BSplineCurve *larg1, Standard_Integer larg2, Standard_Integer larg3, Standard_Real larg4) {
  bool lresult = (bool)0 ;
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  Standard_Real arg4 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom2d_BSplineCurve_RemoveKnot(arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_RemoveKnot\n  * wrapname: _wrap_Geom2d_BSplineCurve_RemoveKnot\n  * fulldecl: Standard_Boolean Handle_Geom2d_BSplineCurve::RemoveKnot(Standard_Integer const,Standard_Integer const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_InsertPoleAfter__SWIG_0(Handle_Geom2d_BSplineCurve *self,Standard_Integer const Index,gp_Pnt2d const &P,Standard_Real const Weight=1.0){
      (*self)->InsertPoleAfter(Index, P, Weight);
    }
EXPORT void _wrap_Geom2d_BSplineCurve_InsertPoleAfter__SWIG_0 (Handle_Geom2d_BSplineCurve *larg1, Standard_Integer larg2, gp_Pnt2d *larg3, Standard_Real larg4) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_InsertPoleAfter__SWIG_0(arg1,arg2,(gp_Pnt2d const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_InsertPoleAfter\n  * wrapname: _wrap_Geom2d_BSplineCurve_InsertPoleAfter__SWIG_0\n  * fulldecl: void Handle_Geom2d_BSplineCurve::InsertPoleAfter(Standard_Integer const,gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Geom2d_BSplineCurve_InsertPoleAfter__SWIG_1 (Handle_Geom2d_BSplineCurve *larg1, Standard_Integer larg2, gp_Pnt2d *larg3) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_InsertPoleAfter__SWIG_0(arg1,arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_InsertPoleAfter\n  * wrapname: _wrap_Geom2d_BSplineCurve_InsertPoleAfter__SWIG_1\n  * fulldecl: void Handle_Geom2d_BSplineCurve::InsertPoleAfter(Standard_Integer const,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_InsertPoleBefore__SWIG_0(Handle_Geom2d_BSplineCurve *self,Standard_Integer const Index,gp_Pnt2d const &P,Standard_Real const Weight=1.0){
      (*self)->InsertPoleBefore(Index, P, Weight);
    }
EXPORT void _wrap_Geom2d_BSplineCurve_InsertPoleBefore__SWIG_0 (Handle_Geom2d_BSplineCurve *larg1, Standard_Integer larg2, gp_Pnt2d *larg3, Standard_Real larg4) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_InsertPoleBefore__SWIG_0(arg1,arg2,(gp_Pnt2d const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_InsertPoleBefore\n  * wrapname: _wrap_Geom2d_BSplineCurve_InsertPoleBefore__SWIG_0\n  * fulldecl: void Handle_Geom2d_BSplineCurve::InsertPoleBefore(Standard_Integer const,gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Geom2d_BSplineCurve_InsertPoleBefore__SWIG_1 (Handle_Geom2d_BSplineCurve *larg1, Standard_Integer larg2, gp_Pnt2d *larg3) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_InsertPoleBefore__SWIG_0(arg1,arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_InsertPoleBefore\n  * wrapname: _wrap_Geom2d_BSplineCurve_InsertPoleBefore__SWIG_1\n  * fulldecl: void Handle_Geom2d_BSplineCurve::InsertPoleBefore(Standard_Integer const,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_RemovePole(Handle_Geom2d_BSplineCurve *self,Standard_Integer const Index){
      (*self)->RemovePole(Index);
    }
EXPORT void _wrap_Geom2d_BSplineCurve_RemovePole (Handle_Geom2d_BSplineCurve *larg1, Standard_Integer larg2) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_RemovePole(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_RemovePole\n  * wrapname: _wrap_Geom2d_BSplineCurve_RemovePole\n  * fulldecl: void Handle_Geom2d_BSplineCurve::RemovePole(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_Segment(Handle_Geom2d_BSplineCurve *self,Standard_Real const U1,Standard_Real const U2){
      (*self)->Segment(U1, U2);
    }
EXPORT void _wrap_Geom2d_BSplineCurve_Segment (Handle_Geom2d_BSplineCurve *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_Segment(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_Segment\n  * wrapname: _wrap_Geom2d_BSplineCurve_Segment\n  * fulldecl: void Handle_Geom2d_BSplineCurve::Segment(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_SetKnot__SWIG_0(Handle_Geom2d_BSplineCurve *self,Standard_Integer const Index,Standard_Real const K){
      (*self)->SetKnot(Index, K);
    }
EXPORT void _wrap_Geom2d_BSplineCurve_SetKnot__SWIG_0 (Handle_Geom2d_BSplineCurve *larg1, Standard_Integer larg2, Standard_Real larg3) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_SetKnot__SWIG_0(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_SetKnot\n  * wrapname: _wrap_Geom2d_BSplineCurve_SetKnot__SWIG_0\n  * fulldecl: void Handle_Geom2d_BSplineCurve::SetKnot(Standard_Integer const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_SetKnots(Handle_Geom2d_BSplineCurve *self,TColStd_Array1OfReal const &K){
      (*self)->SetKnots(K);
    }
EXPORT void _wrap_Geom2d_BSplineCurve_SetKnots (Handle_Geom2d_BSplineCurve *larg1, TColStd_Array1OfReal *larg2) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_SetKnots(arg1,(TColStd_Array1OfReal const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_SetKnots\n  * wrapname: _wrap_Geom2d_BSplineCurve_SetKnots\n  * fulldecl: void Handle_Geom2d_BSplineCurve::SetKnots(TColStd_Array1OfReal const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_SetKnot__SWIG_1(Handle_Geom2d_BSplineCurve *self,Standard_Integer const Index,Standard_Real const K,Standard_Integer const M){
      (*self)->SetKnot(Index, K, M);
    }
EXPORT void _wrap_Geom2d_BSplineCurve_SetKnot__SWIG_1 (Handle_Geom2d_BSplineCurve *larg1, Standard_Integer larg2, Standard_Real larg3, Standard_Integer larg4) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real arg3 ;
  Standard_Integer arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_SetKnot__SWIG_1(arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_SetKnot\n  * wrapname: _wrap_Geom2d_BSplineCurve_SetKnot__SWIG_1\n  * fulldecl: void Handle_Geom2d_BSplineCurve::SetKnot(Standard_Integer const,Standard_Real const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_PeriodicNormalization(Handle_Geom2d_BSplineCurve *self,Standard_Real &U){
      (*self)->PeriodicNormalization(U);
    }
EXPORT void _wrap_Geom2d_BSplineCurve_PeriodicNormalization (Handle_Geom2d_BSplineCurve *larg1, Standard_Real *larg2) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Real *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_PeriodicNormalization(arg1,*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_PeriodicNormalization\n  * wrapname: _wrap_Geom2d_BSplineCurve_PeriodicNormalization\n  * fulldecl: void Handle_Geom2d_BSplineCurve::PeriodicNormalization(Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_SetPeriodic(Handle_Geom2d_BSplineCurve *self){
      (*self)->SetPeriodic();
    }
EXPORT void _wrap_Geom2d_BSplineCurve_SetPeriodic (Handle_Geom2d_BSplineCurve *larg1) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_SetPeriodic(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_SetPeriodic\n  * wrapname: _wrap_Geom2d_BSplineCurve_SetPeriodic\n  * fulldecl: void Handle_Geom2d_BSplineCurve::SetPeriodic()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_SetOrigin(Handle_Geom2d_BSplineCurve *self,Standard_Integer const Index){
      (*self)->SetOrigin(Index);
    }
EXPORT void _wrap_Geom2d_BSplineCurve_SetOrigin (Handle_Geom2d_BSplineCurve *larg1, Standard_Integer larg2) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_SetOrigin(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_SetOrigin\n  * wrapname: _wrap_Geom2d_BSplineCurve_SetOrigin\n  * fulldecl: void Handle_Geom2d_BSplineCurve::SetOrigin(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_SetNotPeriodic(Handle_Geom2d_BSplineCurve *self){
      (*self)->SetNotPeriodic();
    }
EXPORT void _wrap_Geom2d_BSplineCurve_SetNotPeriodic (Handle_Geom2d_BSplineCurve *larg1) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_SetNotPeriodic(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_SetNotPeriodic\n  * wrapname: _wrap_Geom2d_BSplineCurve_SetNotPeriodic\n  * fulldecl: void Handle_Geom2d_BSplineCurve::SetNotPeriodic()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_SetPole__SWIG_0(Handle_Geom2d_BSplineCurve *self,Standard_Integer const Index,gp_Pnt2d const &P){
      (*self)->SetPole(Index, P);
    }
EXPORT void _wrap_Geom2d_BSplineCurve_SetPole__SWIG_0 (Handle_Geom2d_BSplineCurve *larg1, Standard_Integer larg2, gp_Pnt2d *larg3) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_SetPole__SWIG_0(arg1,arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_SetPole\n  * wrapname: _wrap_Geom2d_BSplineCurve_SetPole__SWIG_0\n  * fulldecl: void Handle_Geom2d_BSplineCurve::SetPole(Standard_Integer const,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_SetPole__SWIG_1(Handle_Geom2d_BSplineCurve *self,Standard_Integer const Index,gp_Pnt2d const &P,Standard_Real const Weight){
      (*self)->SetPole(Index, P, Weight);
    }
EXPORT void _wrap_Geom2d_BSplineCurve_SetPole__SWIG_1 (Handle_Geom2d_BSplineCurve *larg1, Standard_Integer larg2, gp_Pnt2d *larg3, Standard_Real larg4) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_SetPole__SWIG_1(arg1,arg2,(gp_Pnt2d const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_SetPole\n  * wrapname: _wrap_Geom2d_BSplineCurve_SetPole__SWIG_1\n  * fulldecl: void Handle_Geom2d_BSplineCurve::SetPole(Standard_Integer const,gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_SetWeight(Handle_Geom2d_BSplineCurve *self,Standard_Integer const Index,Standard_Real const Weight){
      (*self)->SetWeight(Index, Weight);
    }
EXPORT void _wrap_Geom2d_BSplineCurve_SetWeight (Handle_Geom2d_BSplineCurve *larg1, Standard_Integer larg2, Standard_Real larg3) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_SetWeight(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_SetWeight\n  * wrapname: _wrap_Geom2d_BSplineCurve_SetWeight\n  * fulldecl: void Handle_Geom2d_BSplineCurve::SetWeight(Standard_Integer const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_MovePoint(Handle_Geom2d_BSplineCurve *self,Standard_Real const U,gp_Pnt2d const &P,Standard_Integer const Index1,Standard_Integer const Index2,Standard_Integer &FirstModifiedPole,Standard_Integer &LastModifiedPole){
      (*self)->MovePoint(U, P, Index1, Index2, FirstModifiedPole, LastModifiedPole);
    }
EXPORT void _wrap_Geom2d_BSplineCurve_MovePoint (Handle_Geom2d_BSplineCurve *larg1, Standard_Real larg2, gp_Pnt2d *larg3, Standard_Integer larg4, Standard_Integer larg5, Standard_Integer *larg6, Standard_Integer *larg7) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  Standard_Integer arg4 ;
  Standard_Integer arg5 ;
  Standard_Integer *arg6 = 0 ;
  Standard_Integer *arg7 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_MovePoint(arg1,arg2,(gp_Pnt2d const &)*arg3,arg4,arg5,*arg6,*arg7);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_MovePoint\n  * wrapname: _wrap_Geom2d_BSplineCurve_MovePoint\n  * fulldecl: void Handle_Geom2d_BSplineCurve::MovePoint(Standard_Real const,gp_Pnt2d const &,Standard_Integer const,Standard_Integer const,Standard_Integer &,Standard_Integer &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_MovePointAndTangent(Handle_Geom2d_BSplineCurve *self,Standard_Real const U,gp_Pnt2d const &P,gp_Vec2d const &Tangent,Standard_Real const Tolerance,Standard_Integer const StartingCondition,Standard_Integer const EndingCondition,Standard_Integer &ErrorStatus){
      return (*self)->MovePointAndTangent(U, P, Tangent, Tolerance, StartingCondition, EndingCondition, ErrorStatus);
    }
EXPORT void _wrap_Geom2d_BSplineCurve_MovePointAndTangent (Handle_Geom2d_BSplineCurve *larg1, Standard_Real larg2, gp_Pnt2d *larg3, gp_Vec2d *larg4, Standard_Real larg5, Standard_Integer larg6, Standard_Integer larg7, Standard_Integer *larg8) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  gp_Vec2d *arg4 = 0 ;
  Standard_Real arg5 ;
  Standard_Integer arg6 ;
  Standard_Integer arg7 ;
  Standard_Integer *arg8 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_MovePointAndTangent(arg1,arg2,(gp_Pnt2d const &)*arg3,(gp_Vec2d const &)*arg4,arg5,arg6,arg7,*arg8);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_MovePointAndTangent\n  * wrapname: _wrap_Geom2d_BSplineCurve_MovePointAndTangent\n  * fulldecl: void Handle_Geom2d_BSplineCurve::MovePointAndTangent(Standard_Real const,gp_Pnt2d const &,gp_Vec2d const &,Standard_Real const,Standard_Integer const,Standard_Integer const,Standard_Integer &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Boolean Handle_Geom2d_BSplineCurve_IsG1(Handle_Geom2d_BSplineCurve *self,Standard_Real const theTf,Standard_Real const theTl,Standard_Real const theAngTol){
      return (*self)->IsG1(theTf, theTl, theAngTol);
    }
EXPORT bool _wrap_Geom2d_BSplineCurve_IsG1 (Handle_Geom2d_BSplineCurve *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4) {
  bool lresult = (bool)0 ;
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom2d_BSplineCurve_IsG1(arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_IsG1\n  * wrapname: _wrap_Geom2d_BSplineCurve_IsG1\n  * fulldecl: Standard_Boolean Handle_Geom2d_BSplineCurve::IsG1(Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom2d_BSplineCurve_IsRational(Handle_Geom2d_BSplineCurve *self){
      return (*self)->IsRational();
    }
EXPORT bool _wrap_Geom2d_BSplineCurve_IsRational (Handle_Geom2d_BSplineCurve *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom2d_BSplineCurve_IsRational(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_IsRational\n  * wrapname: _wrap_Geom2d_BSplineCurve_IsRational\n  * fulldecl: Standard_Boolean Handle_Geom2d_BSplineCurve::IsRational()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom2d_BSplineCurve_Degree(Handle_Geom2d_BSplineCurve *self){
      return (*self)->Degree();
    }
EXPORT Standard_Integer _wrap_Geom2d_BSplineCurve_Degree (Handle_Geom2d_BSplineCurve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom2d_BSplineCurve_Degree(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_Degree\n  * wrapname: _wrap_Geom2d_BSplineCurve_Degree\n  * fulldecl: Standard_Integer Handle_Geom2d_BSplineCurve::Degree()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN gp_Pnt2d Handle_Geom2d_BSplineCurve_LocalValue(Handle_Geom2d_BSplineCurve *self,Standard_Real const U,Standard_Integer const FromK1,Standard_Integer const ToK2){
      return (*self)->LocalValue(U, FromK1, ToK2);
    }
EXPORT gp_Pnt2d *_wrap_Geom2d_BSplineCurve_LocalValue (Handle_Geom2d_BSplineCurve *larg1, Standard_Real larg2, Standard_Integer larg3, Standard_Integer larg4) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Real arg2 ;
  Standard_Integer arg3 ;
  Standard_Integer arg4 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_BSplineCurve_LocalValue(arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_LocalValue\n  * wrapname: _wrap_Geom2d_BSplineCurve_LocalValue\n  * fulldecl: gp_Pnt2d Handle_Geom2d_BSplineCurve::LocalValue(Standard_Real const,Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_LocalD0(Handle_Geom2d_BSplineCurve *self,Standard_Real const U,Standard_Integer const FromK1,Standard_Integer const ToK2,gp_Pnt2d &P){
      (*self)->LocalD0(U, FromK1, ToK2, P);
    }
EXPORT void _wrap_Geom2d_BSplineCurve_LocalD0 (Handle_Geom2d_BSplineCurve *larg1, Standard_Real larg2, Standard_Integer larg3, Standard_Integer larg4, gp_Pnt2d *larg5) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Real arg2 ;
  Standard_Integer arg3 ;
  Standard_Integer arg4 ;
  gp_Pnt2d *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_LocalD0(arg1,arg2,arg3,arg4,*arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_LocalD0\n  * wrapname: _wrap_Geom2d_BSplineCurve_LocalD0\n  * fulldecl: void Handle_Geom2d_BSplineCurve::LocalD0(Standard_Real const,Standard_Integer const,Standard_Integer const,gp_Pnt2d &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_LocalD1(Handle_Geom2d_BSplineCurve *self,Standard_Real const U,Standard_Integer const FromK1,Standard_Integer const ToK2,gp_Pnt2d &P,gp_Vec2d &V1){
      (*self)->LocalD1(U, FromK1, ToK2, P, V1);
    }
EXPORT void _wrap_Geom2d_BSplineCurve_LocalD1 (Handle_Geom2d_BSplineCurve *larg1, Standard_Real larg2, Standard_Integer larg3, Standard_Integer larg4, gp_Pnt2d *larg5, gp_Vec2d *larg6) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Real arg2 ;
  Standard_Integer arg3 ;
  Standard_Integer arg4 ;
  gp_Pnt2d *arg5 = 0 ;
  gp_Vec2d *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_LocalD1(arg1,arg2,arg3,arg4,*arg5,*arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_LocalD1\n  * wrapname: _wrap_Geom2d_BSplineCurve_LocalD1\n  * fulldecl: void Handle_Geom2d_BSplineCurve::LocalD1(Standard_Real const,Standard_Integer const,Standard_Integer const,gp_Pnt2d &,gp_Vec2d &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_LocalD2(Handle_Geom2d_BSplineCurve *self,Standard_Real const U,Standard_Integer const FromK1,Standard_Integer const ToK2,gp_Pnt2d &P,gp_Vec2d &V1,gp_Vec2d &V2){
      (*self)->LocalD2(U, FromK1, ToK2, P, V1, V2);
    }
EXPORT void _wrap_Geom2d_BSplineCurve_LocalD2 (Handle_Geom2d_BSplineCurve *larg1, Standard_Real larg2, Standard_Integer larg3, Standard_Integer larg4, gp_Pnt2d *larg5, gp_Vec2d *larg6, gp_Vec2d *larg7) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Real arg2 ;
  Standard_Integer arg3 ;
  Standard_Integer arg4 ;
  gp_Pnt2d *arg5 = 0 ;
  gp_Vec2d *arg6 = 0 ;
  gp_Vec2d *arg7 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_LocalD2(arg1,arg2,arg3,arg4,*arg5,*arg6,*arg7);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_LocalD2\n  * wrapname: _wrap_Geom2d_BSplineCurve_LocalD2\n  * fulldecl: void Handle_Geom2d_BSplineCurve::LocalD2(Standard_Real const,Standard_Integer const,Standard_Integer const,gp_Pnt2d &,gp_Vec2d &,gp_Vec2d &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_LocalD3(Handle_Geom2d_BSplineCurve *self,Standard_Real const U,Standard_Integer const FromK1,Standard_Integer const ToK2,gp_Pnt2d &P,gp_Vec2d &V1,gp_Vec2d &V2,gp_Vec2d &V3){
      (*self)->LocalD3(U, FromK1, ToK2, P, V1, V2, V3);
    }
EXPORT void _wrap_Geom2d_BSplineCurve_LocalD3 (Handle_Geom2d_BSplineCurve *larg1, Standard_Real larg2, Standard_Integer larg3, Standard_Integer larg4, gp_Pnt2d *larg5, gp_Vec2d *larg6, gp_Vec2d *larg7, gp_Vec2d *larg8) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Real arg2 ;
  Standard_Integer arg3 ;
  Standard_Integer arg4 ;
  gp_Pnt2d *arg5 = 0 ;
  gp_Vec2d *arg6 = 0 ;
  gp_Vec2d *arg7 = 0 ;
  gp_Vec2d *arg8 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_LocalD3(arg1,arg2,arg3,arg4,*arg5,*arg6,*arg7,*arg8);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_LocalD3\n  * wrapname: _wrap_Geom2d_BSplineCurve_LocalD3\n  * fulldecl: void Handle_Geom2d_BSplineCurve::LocalD3(Standard_Real const,Standard_Integer const,Standard_Integer const,gp_Pnt2d &,gp_Vec2d &,gp_Vec2d &,gp_Vec2d &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Vec2d Handle_Geom2d_BSplineCurve_LocalDN(Handle_Geom2d_BSplineCurve *self,Standard_Real const U,Standard_Integer const FromK1,Standard_Integer const ToK2,Standard_Integer const N){
      return (*self)->LocalDN(U, FromK1, ToK2, N);
    }
EXPORT gp_Vec2d *_wrap_Geom2d_BSplineCurve_LocalDN (Handle_Geom2d_BSplineCurve *larg1, Standard_Real larg2, Standard_Integer larg3, Standard_Integer larg4, Standard_Integer larg5) {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Real arg2 ;
  Standard_Integer arg3 ;
  Standard_Integer arg4 ;
  Standard_Integer arg5 ;
  gp_Vec2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_BSplineCurve_LocalDN(arg1,arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_LocalDN\n  * wrapname: _wrap_Geom2d_BSplineCurve_LocalDN\n  * fulldecl: gp_Vec2d Handle_Geom2d_BSplineCurve::LocalDN(Standard_Real const,Standard_Integer const,Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec2d(result);
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom2d_BSplineCurve_FirstUKnotIndex(Handle_Geom2d_BSplineCurve *self){
      return (*self)->FirstUKnotIndex();
    }
EXPORT Standard_Integer _wrap_Geom2d_BSplineCurve_FirstUKnotIndex (Handle_Geom2d_BSplineCurve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom2d_BSplineCurve_FirstUKnotIndex(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_FirstUKnotIndex\n  * wrapname: _wrap_Geom2d_BSplineCurve_FirstUKnotIndex\n  * fulldecl: Standard_Integer Handle_Geom2d_BSplineCurve::FirstUKnotIndex()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_BSplineCurve_Knot(Handle_Geom2d_BSplineCurve *self,Standard_Integer const Index){
        return (*self)->Knot(Index);
    }
EXPORT Standard_Real _wrap_Geom2d_BSplineCurve_Knot (Handle_Geom2d_BSplineCurve *larg1, Standard_Integer larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_BSplineCurve_Knot(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_Knot\n  * wrapname: _wrap_Geom2d_BSplineCurve_Knot\n  * fulldecl: Standard_Real Handle_Geom2d_BSplineCurve::Knot(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN TColStd_Array1OfReal const &Handle_Geom2d_BSplineCurve_Knots(Handle_Geom2d_BSplineCurve *self){
      return (*self)->Knots();
    }
EXPORT TColStd_Array1OfReal *_wrap_Geom2d_BSplineCurve_Knots (Handle_Geom2d_BSplineCurve *larg1) {
  TColStd_Array1OfReal * lresult = (TColStd_Array1OfReal *)0 ;
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  TColStd_Array1OfReal *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColStd_Array1OfReal *) &Handle_Geom2d_BSplineCurve_Knots(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_Knots\n  * wrapname: _wrap_Geom2d_BSplineCurve_Knots\n  * fulldecl: TColStd_Array1OfReal const & Handle_Geom2d_BSplineCurve::Knots()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColStd_Array1OfReal *)0;
  }
}


SWIGINTERN TColStd_Array1OfReal const &Handle_Geom2d_BSplineCurve_KnotSequence(Handle_Geom2d_BSplineCurve *self){
      return (*self)->KnotSequence();
    }
EXPORT TColStd_Array1OfReal *_wrap_Geom2d_BSplineCurve_KnotSequence (Handle_Geom2d_BSplineCurve *larg1) {
  TColStd_Array1OfReal * lresult = (TColStd_Array1OfReal *)0 ;
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  TColStd_Array1OfReal *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColStd_Array1OfReal *) &Handle_Geom2d_BSplineCurve_KnotSequence(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_KnotSequence\n  * wrapname: _wrap_Geom2d_BSplineCurve_KnotSequence\n  * fulldecl: TColStd_Array1OfReal const & Handle_Geom2d_BSplineCurve::KnotSequence()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColStd_Array1OfReal *)0;
  }
}


SWIGINTERN GeomAbs_BSplKnotDistribution Handle_Geom2d_BSplineCurve_KnotDistribution(Handle_Geom2d_BSplineCurve *self){
      return (*self)->KnotDistribution();
    }
EXPORT GeomAbs_BSplKnotDistribution *_wrap_Geom2d_BSplineCurve_KnotDistribution (Handle_Geom2d_BSplineCurve *larg1) {
  GeomAbs_BSplKnotDistribution * lresult = (GeomAbs_BSplKnotDistribution *)0 ;
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  GeomAbs_BSplKnotDistribution result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_BSplineCurve_KnotDistribution(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_KnotDistribution\n  * wrapname: _wrap_Geom2d_BSplineCurve_KnotDistribution\n  * fulldecl: GeomAbs_BSplKnotDistribution Handle_Geom2d_BSplineCurve::KnotDistribution()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new GeomAbs_BSplKnotDistribution(result);
    return lresult;
  } catch (...) {
    return (GeomAbs_BSplKnotDistribution *)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom2d_BSplineCurve_LastUKnotIndex(Handle_Geom2d_BSplineCurve *self){
      return (*self)->LastUKnotIndex();
    }
EXPORT Standard_Integer _wrap_Geom2d_BSplineCurve_LastUKnotIndex (Handle_Geom2d_BSplineCurve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom2d_BSplineCurve_LastUKnotIndex(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_LastUKnotIndex\n  * wrapname: _wrap_Geom2d_BSplineCurve_LastUKnotIndex\n  * fulldecl: Standard_Integer Handle_Geom2d_BSplineCurve::LastUKnotIndex()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_LocateU__SWIG_0(Handle_Geom2d_BSplineCurve *self,Standard_Real const U,Standard_Real const ParametricTolerance,Standard_Integer &I1,Standard_Integer &I2,Standard_Boolean const WithKnotRepetition=Standard_False){
      (*self)->LocateU(U,  ParametricTolerance, I1, I2, WithKnotRepetition);
    }
EXPORT void _wrap_Geom2d_BSplineCurve_LocateU__SWIG_0 (Handle_Geom2d_BSplineCurve *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Integer *larg4, Standard_Integer *larg5, bool larg6) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Integer *arg4 = 0 ;
  Standard_Integer *arg5 = 0 ;
  Standard_Boolean arg6 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = (bool)larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_LocateU__SWIG_0(arg1,arg2,arg3,*arg4,*arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_LocateU\n  * wrapname: _wrap_Geom2d_BSplineCurve_LocateU__SWIG_0\n  * fulldecl: void Handle_Geom2d_BSplineCurve::LocateU(Standard_Real const,Standard_Real const,Standard_Integer &,Standard_Integer &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Geom2d_BSplineCurve_LocateU__SWIG_1 (Handle_Geom2d_BSplineCurve *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Integer *larg4, Standard_Integer *larg5) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Integer *arg4 = 0 ;
  Standard_Integer *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_LocateU__SWIG_0(arg1,arg2,arg3,*arg4,*arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_LocateU\n  * wrapname: _wrap_Geom2d_BSplineCurve_LocateU__SWIG_1\n  * fulldecl: void Handle_Geom2d_BSplineCurve::LocateU(Standard_Real const,Standard_Real const,Standard_Integer &,Standard_Integer &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Integer Handle_Geom2d_BSplineCurve_Multiplicity(Handle_Geom2d_BSplineCurve *self,Standard_Integer const Index){
        return (*self)->Multiplicity(Index);
    }
EXPORT Standard_Integer _wrap_Geom2d_BSplineCurve_Multiplicity (Handle_Geom2d_BSplineCurve *larg1, Standard_Integer larg2) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom2d_BSplineCurve_Multiplicity(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_Multiplicity\n  * wrapname: _wrap_Geom2d_BSplineCurve_Multiplicity\n  * fulldecl: Standard_Integer Handle_Geom2d_BSplineCurve::Multiplicity(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN TColStd_Array1OfInteger const &Handle_Geom2d_BSplineCurve_Multiplicities(Handle_Geom2d_BSplineCurve *self){
      return (*self)->Multiplicities();
    }
EXPORT TColStd_Array1OfInteger *_wrap_Geom2d_BSplineCurve_Multiplicities (Handle_Geom2d_BSplineCurve *larg1) {
  TColStd_Array1OfInteger * lresult = (TColStd_Array1OfInteger *)0 ;
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  TColStd_Array1OfInteger *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColStd_Array1OfInteger *) &Handle_Geom2d_BSplineCurve_Multiplicities(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_Multiplicities\n  * wrapname: _wrap_Geom2d_BSplineCurve_Multiplicities\n  * fulldecl: TColStd_Array1OfInteger const & Handle_Geom2d_BSplineCurve::Multiplicities()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColStd_Array1OfInteger *)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom2d_BSplineCurve_NbKnots(Handle_Geom2d_BSplineCurve *self){
        return(*self)->NbKnots();
    }
EXPORT Standard_Integer _wrap_Geom2d_BSplineCurve_NbKnots (Handle_Geom2d_BSplineCurve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom2d_BSplineCurve_NbKnots(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_NbKnots\n  * wrapname: _wrap_Geom2d_BSplineCurve_NbKnots\n  * fulldecl: Standard_Integer Handle_Geom2d_BSplineCurve::NbKnots()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom2d_BSplineCurve_NbPoles(Handle_Geom2d_BSplineCurve *self){
        return(*self)->NbPoles();
    }
EXPORT Standard_Integer _wrap_Geom2d_BSplineCurve_NbPoles (Handle_Geom2d_BSplineCurve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom2d_BSplineCurve_NbPoles(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_NbPoles\n  * wrapname: _wrap_Geom2d_BSplineCurve_NbPoles\n  * fulldecl: Standard_Integer Handle_Geom2d_BSplineCurve::NbPoles()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN gp_Pnt2d const &Handle_Geom2d_BSplineCurve_Pole(Handle_Geom2d_BSplineCurve *self,Standard_Integer const Index){
        return (*self)->Pole(Index);
    }
EXPORT gp_Pnt2d *_wrap_Geom2d_BSplineCurve_Pole (Handle_Geom2d_BSplineCurve *larg1, Standard_Integer larg2) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt2d *) &Handle_Geom2d_BSplineCurve_Pole(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_Pole\n  * wrapname: _wrap_Geom2d_BSplineCurve_Pole\n  * fulldecl: gp_Pnt2d const & Handle_Geom2d_BSplineCurve::Pole(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


SWIGINTERN TColgp_Array1OfPnt2d const &Handle_Geom2d_BSplineCurve_Poles(Handle_Geom2d_BSplineCurve *self){
      return (*self)->Poles();
    }
EXPORT TColgp_Array1OfPnt2d *_wrap_Geom2d_BSplineCurve_Poles (Handle_Geom2d_BSplineCurve *larg1) {
  TColgp_Array1OfPnt2d * lresult = (TColgp_Array1OfPnt2d *)0 ;
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  TColgp_Array1OfPnt2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColgp_Array1OfPnt2d *) &Handle_Geom2d_BSplineCurve_Poles(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_Poles\n  * wrapname: _wrap_Geom2d_BSplineCurve_Poles\n  * fulldecl: TColgp_Array1OfPnt2d const & Handle_Geom2d_BSplineCurve::Poles()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColgp_Array1OfPnt2d *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_BSplineCurve_Weight(Handle_Geom2d_BSplineCurve *self,Standard_Integer const Index){
        return (*self)->Weight(Index);
    }
EXPORT Standard_Real _wrap_Geom2d_BSplineCurve_Weight (Handle_Geom2d_BSplineCurve *larg1, Standard_Integer larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_BSplineCurve_Weight(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_Weight\n  * wrapname: _wrap_Geom2d_BSplineCurve_Weight\n  * fulldecl: Standard_Real Handle_Geom2d_BSplineCurve::Weight(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN TColStd_Array1OfReal const *Handle_Geom2d_BSplineCurve_Weights(Handle_Geom2d_BSplineCurve *self){
      return (*self)->Weights();
    }
EXPORT TColStd_Array1OfReal *_wrap_Geom2d_BSplineCurve_Weights (Handle_Geom2d_BSplineCurve *larg1) {
  TColStd_Array1OfReal * lresult = (TColStd_Array1OfReal *)0 ;
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  TColStd_Array1OfReal *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColStd_Array1OfReal *)Handle_Geom2d_BSplineCurve_Weights(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_Weights\n  * wrapname: _wrap_Geom2d_BSplineCurve_Weights\n  * fulldecl: TColStd_Array1OfReal const * Handle_Geom2d_BSplineCurve::Weights()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColStd_Array1OfReal *)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom2d_BSplineCurve_MaxDegree(){
      return Geom2d_BSplineCurve::MaxDegree();
    }
EXPORT Standard_Integer _wrap_Geom2d_BSplineCurve_MaxDegree () {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Standard_Integer result;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom2d_BSplineCurve_MaxDegree();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_MaxDegree\n  * wrapname: _wrap_Geom2d_BSplineCurve_MaxDegree\n  * fulldecl: Standard_Integer Handle_Geom2d_BSplineCurve::Handle_Geom2d_BSplineCurve_MaxDegree()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_Resolution(Handle_Geom2d_BSplineCurve *self,Standard_Real const ToleranceUV,Standard_Real &UTolerance){
      (*self)->Resolution(ToleranceUV, UTolerance);
    }
EXPORT void _wrap_Geom2d_BSplineCurve_Resolution (Handle_Geom2d_BSplineCurve *larg1, Standard_Real larg2, Standard_Real *larg3) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Real arg2 ;
  Standard_Real *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_Resolution(arg1,arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_Resolution\n  * wrapname: _wrap_Geom2d_BSplineCurve_Resolution\n  * fulldecl: void Handle_Geom2d_BSplineCurve::Resolution(Standard_Real const,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_TrimmedCurve *new_Handle_Geom2d_TrimmedCurve__SWIG_0(Handle_Geom2d_Curve const &C,Standard_Real const U1,Standard_Real const U2,Standard_Boolean const Sense=Standard_True){
      return new Handle_Geom2d_TrimmedCurve(new Geom2d_TrimmedCurve(C, U1, U2, Sense));
    }
EXPORT Handle_Geom2d_TrimmedCurve *_wrap_new_Geom2d_TrimmedCurve__SWIG_0 (Handle_Geom2d_Curve *larg1, Standard_Real larg2, Standard_Real larg3, bool larg4) {
  Handle_Geom2d_TrimmedCurve * lresult = (Handle_Geom2d_TrimmedCurve *)0 ;
  Handle_Geom2d_Curve *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Boolean arg4 ;
  Handle_Geom2d_TrimmedCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_TrimmedCurve *)new_Handle_Geom2d_TrimmedCurve__SWIG_0((Handle_Geom2d_Curve const &)*arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_TrimmedCurve\n  * wrapname: _wrap_new_Geom2d_TrimmedCurve__SWIG_0\n  * fulldecl: Handle_Geom2d_TrimmedCurve::Handle_Geom2d_TrimmedCurve(Handle_Geom2d_Curve const &,Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_TrimmedCurve *)0;
  }
}


EXPORT Handle_Geom2d_TrimmedCurve *_wrap_new_Geom2d_TrimmedCurve__SWIG_1 (Handle_Geom2d_Curve *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom2d_TrimmedCurve * lresult = (Handle_Geom2d_TrimmedCurve *)0 ;
  Handle_Geom2d_Curve *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Handle_Geom2d_TrimmedCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_TrimmedCurve *)new_Handle_Geom2d_TrimmedCurve__SWIG_0((Handle_Geom2d_Curve const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_TrimmedCurve\n  * wrapname: _wrap_new_Geom2d_TrimmedCurve__SWIG_1\n  * fulldecl: Handle_Geom2d_TrimmedCurve::Handle_Geom2d_TrimmedCurve(Handle_Geom2d_Curve const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_TrimmedCurve *)0;
  }
}


SWIGINTERN void Handle_Geom2d_TrimmedCurve_Delete(Handle_Geom2d_TrimmedCurve *self){
    self->~Handle_Geom2d_TrimmedCurve();
  }
EXPORT void _wrap_Geom2d_TrimmedCurve_Delete (Handle_Geom2d_TrimmedCurve *larg1) {
  Handle_Geom2d_TrimmedCurve *arg1 = (Handle_Geom2d_TrimmedCurve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_TrimmedCurve_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_TrimmedCurve_Delete\n  * wrapname: _wrap_Geom2d_TrimmedCurve_Delete\n  * fulldecl: void Handle_Geom2d_TrimmedCurve::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_Curve Handle_Geom2d_TrimmedCurve_BasisCurve(Handle_Geom2d_TrimmedCurve *self){
    return (*self)->BasisCurve();
  }
EXPORT Handle_Geom2d_Curve *_wrap_Geom2d_TrimmedCurve_BasisCurve (Handle_Geom2d_TrimmedCurve *larg1) {
  Handle_Geom2d_Curve * lresult = (Handle_Geom2d_Curve *)0 ;
  Handle_Geom2d_TrimmedCurve *arg1 = (Handle_Geom2d_TrimmedCurve *) 0 ;
  SwigValueWrapper< Handle_Geom2d_Curve > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_TrimmedCurve_BasisCurve(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_TrimmedCurve_BasisCurve\n  * wrapname: _wrap_Geom2d_TrimmedCurve_BasisCurve\n  * fulldecl: Handle_Geom2d_Curve Handle_Geom2d_TrimmedCurve::BasisCurve()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Curve(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Curve *)0;
  }
}


SWIGINTERN void Handle_Geom2d_TrimmedCurve_SetTrim__SWIG_0(Handle_Geom2d_TrimmedCurve *self,Standard_Real const U1,Standard_Real const U2,Standard_Boolean const Sense=Standard_True,Standard_Boolean const theAdjustPeriodic=Standard_True){
    (*self)->SetTrim(U1, U2, Sense, theAdjustPeriodic);
  }
EXPORT void _wrap_Geom2d_TrimmedCurve_SetTrim__SWIG_0 (Handle_Geom2d_TrimmedCurve *larg1, Standard_Real larg2, Standard_Real larg3, bool larg4, bool larg5) {
  Handle_Geom2d_TrimmedCurve *arg1 = (Handle_Geom2d_TrimmedCurve *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Boolean arg4 ;
  Standard_Boolean arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  arg5 = (bool)larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_TrimmedCurve_SetTrim__SWIG_0(arg1,arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_TrimmedCurve_SetTrim\n  * wrapname: _wrap_Geom2d_TrimmedCurve_SetTrim__SWIG_0\n  * fulldecl: void Handle_Geom2d_TrimmedCurve::SetTrim(Standard_Real const,Standard_Real const,Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Geom2d_TrimmedCurve_SetTrim__SWIG_1 (Handle_Geom2d_TrimmedCurve *larg1, Standard_Real larg2, Standard_Real larg3, bool larg4) {
  Handle_Geom2d_TrimmedCurve *arg1 = (Handle_Geom2d_TrimmedCurve *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Boolean arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_TrimmedCurve_SetTrim__SWIG_0(arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_TrimmedCurve_SetTrim\n  * wrapname: _wrap_Geom2d_TrimmedCurve_SetTrim__SWIG_1\n  * fulldecl: void Handle_Geom2d_TrimmedCurve::SetTrim(Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Geom2d_TrimmedCurve_SetTrim__SWIG_2 (Handle_Geom2d_TrimmedCurve *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom2d_TrimmedCurve *arg1 = (Handle_Geom2d_TrimmedCurve *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_TrimmedCurve_SetTrim__SWIG_0(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_TrimmedCurve_SetTrim\n  * wrapname: _wrap_Geom2d_TrimmedCurve_SetTrim__SWIG_2\n  * fulldecl: void Handle_Geom2d_TrimmedCurve::SetTrim(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <Geom_Curve.hxx>
#include <gp_GTrsf2d.hxx>
#include <Geom_Surface.hxx>
#include <Geom_Geometry.hxx>
#include <Geom_BoundedCurve.hxx>
#include <Geom_BoundedSurface.hxx>
#include <Geom_BezierCurve.hxx>
#include <Geom_BezierSurface.hxx>
#include <Geom_BSplineCurve.hxx>
#include <Geom_BSplineSurface.hxx>
#include <Geom_Circle.hxx>
#include <Geom_Conic.hxx>
#include <Geom_ConicalSurface.hxx>
#include <Geom_CylindricalSurface.hxx>
#include <Geom_Ellipse.hxx>
#include <Geom_ElementarySurface.hxx>
#include <Geom_Hyperbola.hxx>
#include <Geom_Line.hxx>
#include <Geom_OffsetCurve.hxx>
#include <Geom_OffsetSurface.hxx>
#include <Geom_Parabola.hxx>
#include <Geom_Plane.hxx>
#include <Geom_RectangularTrimmedSurface.hxx>
#include <Geom_SphericalSurface.hxx>
#include <Geom_SurfaceOfLinearExtrusion.hxx>
#include <Geom_SurfaceOfRevolution.hxx>
#include <Geom_SweptSurface.hxx>
#include <Geom_ToroidalSurface.hxx>
#include <Geom_TrimmedCurve.hxx>
#include <Geom2d_Geometry.hxx>
#include <Geom2d_Curve.hxx>
#include <Geom2d_Line.hxx>
#include <Geom2d_OffsetCurve.hxx>
#include <Geom2d_Conic.hxx>
#include <Geom2d_Circle.hxx>
#include <Geom2d_Ellipse.hxx>
#include <Geom2d_Hyperbola.hxx>
#include <Geom2d_Parabola.hxx>
#include <Geom2d_BoundedCurve.hxx>
#include <Geom2d_BezierCurve.hxx>
#include <Geom2d_BSplineCurve.hxx>
#include <Geom2d_TrimmedCurve.hxx>


SWIGINTERN void Handle_Geom_Geometry_Mirror__SWIG_0(Handle_Geom_Geometry *self,gp_Pnt const &P){
    (*self)->Mirror(P);
  }
EXPORT void _wrap_Geom_Geometry_Mirror__SWIG_0 (Handle_Geom_Geometry *larg1, gp_Pnt *larg2) {
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Geometry_Mirror__SWIG_0(arg1,(gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Mirror\n  * wrapname: _wrap_Geom_Geometry_Mirror__SWIG_0\n  * fulldecl: void Handle_Geom_Geometry::Mirror(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_Geometry_Mirror__SWIG_1(Handle_Geom_Geometry *self,gp_Ax1 const &A1){
    (*self)->Mirror(A1);
  }
EXPORT void _wrap_Geom_Geometry_Mirror__SWIG_1 (Handle_Geom_Geometry *larg1, gp_Ax1 *larg2) {
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Geometry_Mirror__SWIG_1(arg1,(gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Mirror\n  * wrapname: _wrap_Geom_Geometry_Mirror__SWIG_1\n  * fulldecl: void Handle_Geom_Geometry::Mirror(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_Geometry_Mirror__SWIG_2(Handle_Geom_Geometry *self,gp_Ax2 const &A2){
    (*self)->Mirror(A2);
  }
EXPORT void _wrap_Geom_Geometry_Mirror__SWIG_2 (Handle_Geom_Geometry *larg1, gp_Ax2 *larg2) {
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Geometry_Mirror__SWIG_2(arg1,(gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Mirror\n  * wrapname: _wrap_Geom_Geometry_Mirror__SWIG_2\n  * fulldecl: void Handle_Geom_Geometry::Mirror(gp_Ax2 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_Geometry_Rotate(Handle_Geom_Geometry *self,gp_Ax1 const &A1,Standard_Real const Ang){
    (*self)->Rotate(A1, Ang);
  }
EXPORT void _wrap_Geom_Geometry_Rotate (Handle_Geom_Geometry *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Geometry_Rotate(arg1,(gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Rotate\n  * wrapname: _wrap_Geom_Geometry_Rotate\n  * fulldecl: void Handle_Geom_Geometry::Rotate(gp_Ax1 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_Geometry_Scale(Handle_Geom_Geometry *self,gp_Pnt const &P,Standard_Real const S){
    (*self)->Scale(P, S);
  }
EXPORT void _wrap_Geom_Geometry_Scale (Handle_Geom_Geometry *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Geometry_Scale(arg1,(gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Scale\n  * wrapname: _wrap_Geom_Geometry_Scale\n  * fulldecl: void Handle_Geom_Geometry::Scale(gp_Pnt const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_Geometry_Translate__SWIG_0(Handle_Geom_Geometry *self,gp_Vec const &V){
    (*self)->Translate(V);
  }
EXPORT void _wrap_Geom_Geometry_Translate__SWIG_0 (Handle_Geom_Geometry *larg1, gp_Vec *larg2) {
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Vec *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Geometry_Translate__SWIG_0(arg1,(gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Translate\n  * wrapname: _wrap_Geom_Geometry_Translate__SWIG_0\n  * fulldecl: void Handle_Geom_Geometry::Translate(gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_Geometry_Translate__SWIG_1(Handle_Geom_Geometry *self,gp_Pnt const &P1,gp_Pnt const &P2){
    (*self)->Translate(P1, P2);
  }
EXPORT void _wrap_Geom_Geometry_Translate__SWIG_1 (Handle_Geom_Geometry *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Geometry_Translate__SWIG_1(arg1,(gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Translate\n  * wrapname: _wrap_Geom_Geometry_Translate__SWIG_1\n  * fulldecl: void Handle_Geom_Geometry::Translate(gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_Geometry_Transform(Handle_Geom_Geometry *self,gp_Trsf const &T){
    (*self)->Transform(T);
  }
EXPORT void _wrap_Geom_Geometry_Transform (Handle_Geom_Geometry *larg1, gp_Trsf *larg2) {
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Trsf *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Geometry_Transform(arg1,(gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Transform\n  * wrapname: _wrap_Geom_Geometry_Transform\n  * fulldecl: void Handle_Geom_Geometry::Transform(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom_Geometry Handle_Geom_Geometry_Mirrored__SWIG_0(Handle_Geom_Geometry *self,gp_Pnt const &P){
    return (*self)->Mirrored(P);
  }
EXPORT Handle_Geom_Geometry *_wrap_Geom_Geometry_Mirrored__SWIG_0 (Handle_Geom_Geometry *larg1, gp_Pnt *larg2) {
  Handle_Geom_Geometry * lresult = (Handle_Geom_Geometry *)0 ;
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Pnt *arg2 = 0 ;
  SwigValueWrapper< Handle_Geom_Geometry > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Geometry_Mirrored__SWIG_0(arg1,(gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Mirrored\n  * wrapname: _wrap_Geom_Geometry_Mirrored__SWIG_0\n  * fulldecl: Handle_Geom_Geometry Handle_Geom_Geometry::Mirrored(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Geometry *)0;
  }
}


SWIGINTERN Handle_Geom_Geometry Handle_Geom_Geometry_Mirrored__SWIG_1(Handle_Geom_Geometry *self,gp_Ax1 const &A1){
    return (*self)->Mirrored(A1);
  }
EXPORT Handle_Geom_Geometry *_wrap_Geom_Geometry_Mirrored__SWIG_1 (Handle_Geom_Geometry *larg1, gp_Ax1 *larg2) {
  Handle_Geom_Geometry * lresult = (Handle_Geom_Geometry *)0 ;
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  SwigValueWrapper< Handle_Geom_Geometry > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Geometry_Mirrored__SWIG_1(arg1,(gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Mirrored\n  * wrapname: _wrap_Geom_Geometry_Mirrored__SWIG_1\n  * fulldecl: Handle_Geom_Geometry Handle_Geom_Geometry::Mirrored(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Geometry *)0;
  }
}


SWIGINTERN Handle_Geom_Geometry Handle_Geom_Geometry_Mirrored__SWIG_2(Handle_Geom_Geometry *self,gp_Ax2 const &A2){
    return (*self)->Mirrored(A2);
  }
EXPORT Handle_Geom_Geometry *_wrap_Geom_Geometry_Mirrored__SWIG_2 (Handle_Geom_Geometry *larg1, gp_Ax2 *larg2) {
  Handle_Geom_Geometry * lresult = (Handle_Geom_Geometry *)0 ;
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  SwigValueWrapper< Handle_Geom_Geometry > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Geometry_Mirrored__SWIG_2(arg1,(gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Mirrored\n  * wrapname: _wrap_Geom_Geometry_Mirrored__SWIG_2\n  * fulldecl: Handle_Geom_Geometry Handle_Geom_Geometry::Mirrored(gp_Ax2 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Geometry *)0;
  }
}


SWIGINTERN Handle_Geom_Geometry Handle_Geom_Geometry_Rotated(Handle_Geom_Geometry *self,gp_Ax1 const &A1,Standard_Real const Ang){
    return (*self)->Rotated(A1, Ang);
  }
EXPORT Handle_Geom_Geometry *_wrap_Geom_Geometry_Rotated (Handle_Geom_Geometry *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  Handle_Geom_Geometry * lresult = (Handle_Geom_Geometry *)0 ;
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  SwigValueWrapper< Handle_Geom_Geometry > result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Geometry_Rotated(arg1,(gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Rotated\n  * wrapname: _wrap_Geom_Geometry_Rotated\n  * fulldecl: Handle_Geom_Geometry Handle_Geom_Geometry::Rotated(gp_Ax1 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Geometry *)0;
  }
}


SWIGINTERN Handle_Geom_Geometry Handle_Geom_Geometry_Scaled(Handle_Geom_Geometry *self,gp_Pnt const &P,Standard_Real const S){
    return (*self)->Scaled(P, S);
  }
EXPORT Handle_Geom_Geometry *_wrap_Geom_Geometry_Scaled (Handle_Geom_Geometry *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  Handle_Geom_Geometry * lresult = (Handle_Geom_Geometry *)0 ;
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  SwigValueWrapper< Handle_Geom_Geometry > result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Geometry_Scaled(arg1,(gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Scaled\n  * wrapname: _wrap_Geom_Geometry_Scaled\n  * fulldecl: Handle_Geom_Geometry Handle_Geom_Geometry::Scaled(gp_Pnt const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Geometry *)0;
  }
}


SWIGINTERN Handle_Geom_Geometry Handle_Geom_Geometry_Transformed(Handle_Geom_Geometry *self,gp_Trsf const &T){
    return (*self)->Transformed(T);
  }
EXPORT Handle_Geom_Geometry *_wrap_Geom_Geometry_Transformed (Handle_Geom_Geometry *larg1, gp_Trsf *larg2) {
  Handle_Geom_Geometry * lresult = (Handle_Geom_Geometry *)0 ;
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Trsf *arg2 = 0 ;
  SwigValueWrapper< Handle_Geom_Geometry > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Geometry_Transformed(arg1,(gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Transformed\n  * wrapname: _wrap_Geom_Geometry_Transformed\n  * fulldecl: Handle_Geom_Geometry Handle_Geom_Geometry::Transformed(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Geometry *)0;
  }
}


SWIGINTERN Handle_Geom_Geometry Handle_Geom_Geometry_Translated__SWIG_0(Handle_Geom_Geometry *self,gp_Vec const &V){
    return (*self)->Translated(V);
  }
EXPORT Handle_Geom_Geometry *_wrap_Geom_Geometry_Translated__SWIG_0 (Handle_Geom_Geometry *larg1, gp_Vec *larg2) {
  Handle_Geom_Geometry * lresult = (Handle_Geom_Geometry *)0 ;
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Vec *arg2 = 0 ;
  SwigValueWrapper< Handle_Geom_Geometry > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Geometry_Translated__SWIG_0(arg1,(gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Translated\n  * wrapname: _wrap_Geom_Geometry_Translated__SWIG_0\n  * fulldecl: Handle_Geom_Geometry Handle_Geom_Geometry::Translated(gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Geometry *)0;
  }
}


SWIGINTERN Handle_Geom_Geometry Handle_Geom_Geometry_Translated__SWIG_1(Handle_Geom_Geometry *self,gp_Pnt const &P1,gp_Pnt const &P2){
    return (*self)->Translated(P1, P2);
  }
EXPORT Handle_Geom_Geometry *_wrap_Geom_Geometry_Translated__SWIG_1 (Handle_Geom_Geometry *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  Handle_Geom_Geometry * lresult = (Handle_Geom_Geometry *)0 ;
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  SwigValueWrapper< Handle_Geom_Geometry > result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Geometry_Translated__SWIG_1(arg1,(gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Translated\n  * wrapname: _wrap_Geom_Geometry_Translated__SWIG_1\n  * fulldecl: Handle_Geom_Geometry Handle_Geom_Geometry::Translated(gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Geometry *)0;
  }
}


SWIGINTERN Handle_Geom_Geometry Handle_Geom_Geometry_Copy(Handle_Geom_Geometry *self){
    return (*self)->Copy();
  }
EXPORT Handle_Geom_Geometry *_wrap_Geom_Geometry_Copy (Handle_Geom_Geometry *larg1) {
  Handle_Geom_Geometry * lresult = (Handle_Geom_Geometry *)0 ;
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  SwigValueWrapper< Handle_Geom_Geometry > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Geometry_Copy(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Copy\n  * wrapname: _wrap_Geom_Geometry_Copy\n  * fulldecl: Handle_Geom_Geometry Handle_Geom_Geometry::Copy()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Geometry *)0;
  }
}


SWIGINTERN void Handle_Geom_Curve_Reverse(Handle_Geom_Curve *self){
    (*self)->Reverse();
  }
EXPORT void _wrap_Geom_Curve_Reverse (Handle_Geom_Curve *larg1) {
  Handle_Geom_Curve *arg1 = (Handle_Geom_Curve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Curve_Reverse(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Curve_Reverse\n  * wrapname: _wrap_Geom_Curve_Reverse\n  * fulldecl: void Handle_Geom_Curve::Reverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Geom_Curve_ReversedParameter(Handle_Geom_Curve *self,Standard_Real const U){
    return (*self)->ReversedParameter(U);
  }
EXPORT Standard_Real _wrap_Geom_Curve_ReversedParameter (Handle_Geom_Curve *larg1, Standard_Real larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Curve *arg1 = (Handle_Geom_Curve *) 0 ;
  Standard_Real arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Curve_ReversedParameter(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Curve_ReversedParameter\n  * wrapname: _wrap_Geom_Curve_ReversedParameter\n  * fulldecl: Standard_Real Handle_Geom_Curve::ReversedParameter(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Curve_TransformedParameter(Handle_Geom_Curve *self,Standard_Real const U,gp_Trsf const &T){
    return (*self)->TransformedParameter(U, T);
  }
EXPORT Standard_Real _wrap_Geom_Curve_TransformedParameter (Handle_Geom_Curve *larg1, Standard_Real larg2, gp_Trsf *larg3) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Curve *arg1 = (Handle_Geom_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Trsf *arg3 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Curve_TransformedParameter(arg1,arg2,(gp_Trsf const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Curve_TransformedParameter\n  * wrapname: _wrap_Geom_Curve_TransformedParameter\n  * fulldecl: Standard_Real Handle_Geom_Curve::TransformedParameter(Standard_Real const,gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Curve_ParametricTransformation(Handle_Geom_Curve *self,gp_Trsf const &T){
    return (*self)->ParametricTransformation(T);
  }
EXPORT Standard_Real _wrap_Geom_Curve_ParametricTransformation (Handle_Geom_Curve *larg1, gp_Trsf *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Curve *arg1 = (Handle_Geom_Curve *) 0 ;
  gp_Trsf *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Curve_ParametricTransformation(arg1,(gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Curve_ParametricTransformation\n  * wrapname: _wrap_Geom_Curve_ParametricTransformation\n  * fulldecl: Standard_Real Handle_Geom_Curve::ParametricTransformation(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Handle_Geom_Curve Handle_Geom_Curve_Reversed(Handle_Geom_Curve *self){
    return (*self)->Reversed();
  }
EXPORT Handle_Geom_Curve *_wrap_Geom_Curve_Reversed (Handle_Geom_Curve *larg1) {
  Handle_Geom_Curve * lresult = (Handle_Geom_Curve *)0 ;
  Handle_Geom_Curve *arg1 = (Handle_Geom_Curve *) 0 ;
  SwigValueWrapper< Handle_Geom_Curve > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Curve_Reversed(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Curve_Reversed\n  * wrapname: _wrap_Geom_Curve_Reversed\n  * fulldecl: Handle_Geom_Curve Handle_Geom_Curve::Reversed()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Curve(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Curve *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Curve_FirstParameter(Handle_Geom_Curve *self){
    return (*self)->FirstParameter();
  }
EXPORT Standard_Real _wrap_Geom_Curve_FirstParameter (Handle_Geom_Curve *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Curve *arg1 = (Handle_Geom_Curve *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Curve_FirstParameter(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Curve_FirstParameter\n  * wrapname: _wrap_Geom_Curve_FirstParameter\n  * fulldecl: Standard_Real Handle_Geom_Curve::FirstParameter()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Curve_LastParameter(Handle_Geom_Curve *self){
    return (*self)->LastParameter();
  }
EXPORT Standard_Real _wrap_Geom_Curve_LastParameter (Handle_Geom_Curve *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Curve *arg1 = (Handle_Geom_Curve *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Curve_LastParameter(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Curve_LastParameter\n  * wrapname: _wrap_Geom_Curve_LastParameter\n  * fulldecl: Standard_Real Handle_Geom_Curve::LastParameter()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom_Curve_IsClosed(Handle_Geom_Curve *self){
    return (*self)->IsClosed();
  }
EXPORT bool _wrap_Geom_Curve_IsClosed (Handle_Geom_Curve *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom_Curve *arg1 = (Handle_Geom_Curve *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom_Curve_IsClosed(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Curve_IsClosed\n  * wrapname: _wrap_Geom_Curve_IsClosed\n  * fulldecl: Standard_Boolean Handle_Geom_Curve::IsClosed()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom_Curve_IsPeriodic(Handle_Geom_Curve *self){
    return (*self)->IsPeriodic();
  }
EXPORT bool _wrap_Geom_Curve_IsPeriodic (Handle_Geom_Curve *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom_Curve *arg1 = (Handle_Geom_Curve *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom_Curve_IsPeriodic(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Curve_IsPeriodic\n  * wrapname: _wrap_Geom_Curve_IsPeriodic\n  * fulldecl: Standard_Boolean Handle_Geom_Curve::IsPeriodic()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Curve_Period(Handle_Geom_Curve *self){
    return (*self)->Period();
  }
EXPORT Standard_Real _wrap_Geom_Curve_Period (Handle_Geom_Curve *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Curve *arg1 = (Handle_Geom_Curve *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Curve_Period(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Curve_Period\n  * wrapname: _wrap_Geom_Curve_Period\n  * fulldecl: Standard_Real Handle_Geom_Curve::Period()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN GeomAbs_Shape Handle_Geom_Curve_Continuity(Handle_Geom_Curve *self){
    return (*self)->Continuity();
  }
EXPORT GeomAbs_Shape _wrap_Geom_Curve_Continuity (Handle_Geom_Curve *larg1) {
  GeomAbs_Shape lresult = (GeomAbs_Shape)0 ;
  Handle_Geom_Curve *arg1 = (Handle_Geom_Curve *) 0 ;
  GeomAbs_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAbs_Shape)Handle_Geom_Curve_Continuity(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Curve_Continuity\n  * wrapname: _wrap_Geom_Curve_Continuity\n  * fulldecl: GeomAbs_Shape Handle_Geom_Curve::Continuity()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAbs_Shape)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom_Curve_IsCN(Handle_Geom_Curve *self,Standard_Integer const N){
    return (*self)->IsCN(N);
  }
EXPORT bool _wrap_Geom_Curve_IsCN (Handle_Geom_Curve *larg1, Standard_Integer larg2) {
  bool lresult = (bool)0 ;
  Handle_Geom_Curve *arg1 = (Handle_Geom_Curve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom_Curve_IsCN(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Curve_IsCN\n  * wrapname: _wrap_Geom_Curve_IsCN\n  * fulldecl: Standard_Boolean Handle_Geom_Curve::IsCN(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN void Handle_Geom_Curve_D0(Handle_Geom_Curve *self,Standard_Real const U,gp_Pnt &P){
    (*self)->D0(U, P);
  }
EXPORT void _wrap_Geom_Curve_D0 (Handle_Geom_Curve *larg1, Standard_Real larg2, gp_Pnt *larg3) {
  Handle_Geom_Curve *arg1 = (Handle_Geom_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Curve_D0(arg1,arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Curve_D0\n  * wrapname: _wrap_Geom_Curve_D0\n  * fulldecl: void Handle_Geom_Curve::D0(Standard_Real const,gp_Pnt &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_Curve_D1(Handle_Geom_Curve *self,Standard_Real const U,gp_Pnt &P,gp_Vec &V1){
    (*self)->D1(U, P, V1);
  }
EXPORT void _wrap_Geom_Curve_D1 (Handle_Geom_Curve *larg1, Standard_Real larg2, gp_Pnt *larg3, gp_Vec *larg4) {
  Handle_Geom_Curve *arg1 = (Handle_Geom_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt *arg3 = 0 ;
  gp_Vec *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Curve_D1(arg1,arg2,*arg3,*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Curve_D1\n  * wrapname: _wrap_Geom_Curve_D1\n  * fulldecl: void Handle_Geom_Curve::D1(Standard_Real const,gp_Pnt &,gp_Vec &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_Curve_D2(Handle_Geom_Curve *self,Standard_Real const U,gp_Pnt &P,gp_Vec &V1,gp_Vec &V2){
    (*self)->D2(U, P, V1, V2);
  }
EXPORT void _wrap_Geom_Curve_D2 (Handle_Geom_Curve *larg1, Standard_Real larg2, gp_Pnt *larg3, gp_Vec *larg4, gp_Vec *larg5) {
  Handle_Geom_Curve *arg1 = (Handle_Geom_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt *arg3 = 0 ;
  gp_Vec *arg4 = 0 ;
  gp_Vec *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Curve_D2(arg1,arg2,*arg3,*arg4,*arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Curve_D2\n  * wrapname: _wrap_Geom_Curve_D2\n  * fulldecl: void Handle_Geom_Curve::D2(Standard_Real const,gp_Pnt &,gp_Vec &,gp_Vec &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_Curve_D3(Handle_Geom_Curve *self,Standard_Real const U,gp_Pnt &P,gp_Vec &V1,gp_Vec &V2,gp_Vec &V3){
    (*self)->D3(U, P, V1, V2, V3);
  }
EXPORT void _wrap_Geom_Curve_D3 (Handle_Geom_Curve *larg1, Standard_Real larg2, gp_Pnt *larg3, gp_Vec *larg4, gp_Vec *larg5, gp_Vec *larg6) {
  Handle_Geom_Curve *arg1 = (Handle_Geom_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt *arg3 = 0 ;
  gp_Vec *arg4 = 0 ;
  gp_Vec *arg5 = 0 ;
  gp_Vec *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Curve_D3(arg1,arg2,*arg3,*arg4,*arg5,*arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Curve_D3\n  * wrapname: _wrap_Geom_Curve_D3\n  * fulldecl: void Handle_Geom_Curve::D3(Standard_Real const,gp_Pnt &,gp_Vec &,gp_Vec &,gp_Vec &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Vec Handle_Geom_Curve_DN(Handle_Geom_Curve *self,Standard_Real const U,Standard_Integer const N){
    return (*self)->DN(U, N);
  }
EXPORT gp_Vec *_wrap_Geom_Curve_DN (Handle_Geom_Curve *larg1, Standard_Real larg2, Standard_Integer larg3) {
  gp_Vec * lresult = (gp_Vec *)0 ;
  Handle_Geom_Curve *arg1 = (Handle_Geom_Curve *) 0 ;
  Standard_Real arg2 ;
  Standard_Integer arg3 ;
  gp_Vec result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Curve_DN(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Curve_DN\n  * wrapname: _wrap_Geom_Curve_DN\n  * fulldecl: gp_Vec Handle_Geom_Curve::DN(Standard_Real const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec(result);
    return lresult;
  } catch (...) {
    return (gp_Vec *)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_Curve_Value(Handle_Geom_Curve *self,Standard_Real const U){
    return (*self)->Value(U);
  }
EXPORT gp_Pnt *_wrap_Geom_Curve_Value (Handle_Geom_Curve *larg1, Standard_Real larg2) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_Curve *arg1 = (Handle_Geom_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Curve_Value(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Curve_Value\n  * wrapname: _wrap_Geom_Curve_Value\n  * fulldecl: gp_Pnt Handle_Geom_Curve::Value(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_Curve_GeometryType(Handle_Geom_Curve *self){
    if (STANDARD_TYPE(Geom_BezierCurve) == (*self)->DynamicType())
      {
	return 100;
      }
    else if (STANDARD_TYPE(Geom_BSplineCurve) == (*self)->DynamicType())
      {
	return 101;
      }
    else if (STANDARD_TYPE(Geom_Circle) == (*self)->DynamicType())
      {
	return 102;
      }
    else if (STANDARD_TYPE(Geom_Ellipse) == (*self)->DynamicType())
      {
	return 103;
      }
    else if (STANDARD_TYPE(Geom_TrimmedCurve) == (*self)->DynamicType())
      {
	return 104;
      }
    else if (STANDARD_TYPE(Geom_OffsetCurve) == (*self)->DynamicType())
      {
	return 105;
      }
    else if (STANDARD_TYPE(Geom_Hyperbola) == (*self)->DynamicType())
      {
	return 106;
      }
    else if (STANDARD_TYPE(Geom_Line) == (*self)->DynamicType())
      {
	return 107;
      }
    else if (STANDARD_TYPE(Geom_Parabola) == (*self)->DynamicType())
      {
	return 108;
      }
    
    return -1;
  }
EXPORT Standard_Integer _wrap_Geom_Curve_GeometryType (Handle_Geom_Curve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_Curve *arg1 = (Handle_Geom_Curve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_Curve_GeometryType(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Curve_GeometryType\n  * wrapname: _wrap_Geom_Curve_GeometryType\n  * fulldecl: Standard_Integer Handle_Geom_Curve::GeometryType()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN void Handle_Geom_Surface_UReverse(Handle_Geom_Surface *self){
    (*self)->UReverse();
  }
EXPORT void _wrap_Geom_Surface_UReverse (Handle_Geom_Surface *larg1) {
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Surface_UReverse(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_UReverse\n  * wrapname: _wrap_Geom_Surface_UReverse\n  * fulldecl: void Handle_Geom_Surface::UReverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom_Surface Handle_Geom_Surface_UReversed(Handle_Geom_Surface *self){
    return (*self)->UReversed();
  }
EXPORT Handle_Geom_Surface *_wrap_Geom_Surface_UReversed (Handle_Geom_Surface *larg1) {
  Handle_Geom_Surface * lresult = (Handle_Geom_Surface *)0 ;
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  SwigValueWrapper< Handle_Geom_Surface > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Surface_UReversed(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_UReversed\n  * wrapname: _wrap_Geom_Surface_UReversed\n  * fulldecl: Handle_Geom_Surface Handle_Geom_Surface::UReversed()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Surface(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Surface *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Surface_UReversedParameter(Handle_Geom_Surface *self,Standard_Real const U){
    return (*self)->UReversedParameter(U);
  }
EXPORT Standard_Real _wrap_Geom_Surface_UReversedParameter (Handle_Geom_Surface *larg1, Standard_Real larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Real arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Surface_UReversedParameter(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_UReversedParameter\n  * wrapname: _wrap_Geom_Surface_UReversedParameter\n  * fulldecl: Standard_Real Handle_Geom_Surface::UReversedParameter(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN void Handle_Geom_Surface_VReverse(Handle_Geom_Surface *self){
    (*self)->VReverse();
  }
EXPORT void _wrap_Geom_Surface_VReverse (Handle_Geom_Surface *larg1) {
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Surface_VReverse(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_VReverse\n  * wrapname: _wrap_Geom_Surface_VReverse\n  * fulldecl: void Handle_Geom_Surface::VReverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Geom_Surface_VReversedParameter(Handle_Geom_Surface *self,Standard_Real const V){
    return (*self)->VReversedParameter(V);
  }
EXPORT Standard_Real _wrap_Geom_Surface_VReversedParameter (Handle_Geom_Surface *larg1, Standard_Real larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Real arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Surface_VReversedParameter(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_VReversedParameter\n  * wrapname: _wrap_Geom_Surface_VReversedParameter\n  * fulldecl: Standard_Real Handle_Geom_Surface::VReversedParameter(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN void Handle_Geom_Surface_TransformParameters(Handle_Geom_Surface *self,Standard_Real &U,Standard_Real &V,gp_Trsf const &T){
    (*self)->TransformParameters(U, V, T);
  }
EXPORT void _wrap_Geom_Surface_TransformParameters (Handle_Geom_Surface *larg1, Standard_Real *larg2, Standard_Real *larg3, gp_Trsf *larg4) {
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  gp_Trsf *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Surface_TransformParameters(arg1,*arg2,*arg3,(gp_Trsf const &)*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_TransformParameters\n  * wrapname: _wrap_Geom_Surface_TransformParameters\n  * fulldecl: void Handle_Geom_Surface::TransformParameters(Standard_Real &,Standard_Real &,gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_GTrsf2d Handle_Geom_Surface_ParametricTransformation(Handle_Geom_Surface *self,gp_Trsf const &T){
    return (*self)->ParametricTransformation(T);
  }
EXPORT gp_GTrsf2d *_wrap_Geom_Surface_ParametricTransformation (Handle_Geom_Surface *larg1, gp_Trsf *larg2) {
  gp_GTrsf2d * lresult = (gp_GTrsf2d *)0 ;
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  gp_Trsf *arg2 = 0 ;
  gp_GTrsf2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Surface_ParametricTransformation(arg1,(gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_ParametricTransformation\n  * wrapname: _wrap_Geom_Surface_ParametricTransformation\n  * fulldecl: gp_GTrsf2d Handle_Geom_Surface::ParametricTransformation(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_GTrsf2d(result);
    return lresult;
  } catch (...) {
    return (gp_GTrsf2d *)0;
  }
}


SWIGINTERN void Handle_Geom_Surface_Bounds(Handle_Geom_Surface *self,Standard_Real &U1,Standard_Real &U2,Standard_Real &V1,Standard_Real &V2){
    (*self)->Bounds(U1, U2, V1, V2);
  }
EXPORT void _wrap_Geom_Surface_Bounds (Handle_Geom_Surface *larg1, Standard_Real *larg2, Standard_Real *larg3, Standard_Real *larg4, Standard_Real *larg5) {
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  Standard_Real *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Surface_Bounds(arg1,*arg2,*arg3,*arg4,*arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_Bounds\n  * wrapname: _wrap_Geom_Surface_Bounds\n  * fulldecl: void Handle_Geom_Surface::Bounds(Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Boolean Handle_Geom_Surface_IsUClosed(Handle_Geom_Surface *self){
    return (*self)->IsUClosed();
  }
EXPORT bool _wrap_Geom_Surface_IsUClosed (Handle_Geom_Surface *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom_Surface_IsUClosed(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_IsUClosed\n  * wrapname: _wrap_Geom_Surface_IsUClosed\n  * fulldecl: Standard_Boolean Handle_Geom_Surface::IsUClosed()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom_Surface_IsVClosed(Handle_Geom_Surface *self){
    return (*self)->IsVClosed();
  }
EXPORT bool _wrap_Geom_Surface_IsVClosed (Handle_Geom_Surface *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom_Surface_IsVClosed(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_IsVClosed\n  * wrapname: _wrap_Geom_Surface_IsVClosed\n  * fulldecl: Standard_Boolean Handle_Geom_Surface::IsVClosed()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom_Surface_IsUPeriodic(Handle_Geom_Surface *self){
    return (*self)->IsUPeriodic();
  }
EXPORT bool _wrap_Geom_Surface_IsUPeriodic (Handle_Geom_Surface *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom_Surface_IsUPeriodic(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_IsUPeriodic\n  * wrapname: _wrap_Geom_Surface_IsUPeriodic\n  * fulldecl: Standard_Boolean Handle_Geom_Surface::IsUPeriodic()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Surface_UPeriod(Handle_Geom_Surface *self){
    return (*self)->UPeriod();
  }
EXPORT Standard_Real _wrap_Geom_Surface_UPeriod (Handle_Geom_Surface *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Surface_UPeriod(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_UPeriod\n  * wrapname: _wrap_Geom_Surface_UPeriod\n  * fulldecl: Standard_Real Handle_Geom_Surface::UPeriod()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom_Surface_IsVPeriodic(Handle_Geom_Surface *self){
    return (*self)->IsVPeriodic();
  }
EXPORT bool _wrap_Geom_Surface_IsVPeriodic (Handle_Geom_Surface *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom_Surface_IsVPeriodic(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_IsVPeriodic\n  * wrapname: _wrap_Geom_Surface_IsVPeriodic\n  * fulldecl: Standard_Boolean Handle_Geom_Surface::IsVPeriodic()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Surface_VPeriod(Handle_Geom_Surface *self){
    return (*self)->VPeriod();
  }
EXPORT Standard_Real _wrap_Geom_Surface_VPeriod (Handle_Geom_Surface *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Surface_VPeriod(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_VPeriod\n  * wrapname: _wrap_Geom_Surface_VPeriod\n  * fulldecl: Standard_Real Handle_Geom_Surface::VPeriod()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Handle_Geom_Curve Handle_Geom_Surface_UIso(Handle_Geom_Surface *self,Standard_Real const U){
    return (*self)->UIso(U);
  }
EXPORT Handle_Geom_Curve *_wrap_Geom_Surface_UIso (Handle_Geom_Surface *larg1, Standard_Real larg2) {
  Handle_Geom_Curve * lresult = (Handle_Geom_Curve *)0 ;
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Real arg2 ;
  SwigValueWrapper< Handle_Geom_Curve > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Surface_UIso(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_UIso\n  * wrapname: _wrap_Geom_Surface_UIso\n  * fulldecl: Handle_Geom_Curve Handle_Geom_Surface::UIso(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Curve(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Curve *)0;
  }
}


SWIGINTERN Handle_Geom_Curve Handle_Geom_Surface_VIso(Handle_Geom_Surface *self,Standard_Real const V){
    return (*self)->VIso(V);
  }
EXPORT Handle_Geom_Curve *_wrap_Geom_Surface_VIso (Handle_Geom_Surface *larg1, Standard_Real larg2) {
  Handle_Geom_Curve * lresult = (Handle_Geom_Curve *)0 ;
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Real arg2 ;
  SwigValueWrapper< Handle_Geom_Curve > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Surface_VIso(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_VIso\n  * wrapname: _wrap_Geom_Surface_VIso\n  * fulldecl: Handle_Geom_Curve Handle_Geom_Surface::VIso(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Curve(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Curve *)0;
  }
}


SWIGINTERN GeomAbs_Shape Handle_Geom_Surface_Continuity(Handle_Geom_Surface *self){
    return (*self)->Continuity();
  }
EXPORT GeomAbs_Shape _wrap_Geom_Surface_Continuity (Handle_Geom_Surface *larg1) {
  GeomAbs_Shape lresult = (GeomAbs_Shape)0 ;
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  GeomAbs_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAbs_Shape)Handle_Geom_Surface_Continuity(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_Continuity\n  * wrapname: _wrap_Geom_Surface_Continuity\n  * fulldecl: GeomAbs_Shape Handle_Geom_Surface::Continuity()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAbs_Shape)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom_Surface_IsCNu(Handle_Geom_Surface *self,Standard_Integer const N){
    return (*self)->IsCNu(N);
  }
EXPORT bool _wrap_Geom_Surface_IsCNu (Handle_Geom_Surface *larg1, Standard_Integer larg2) {
  bool lresult = (bool)0 ;
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Integer arg2 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom_Surface_IsCNu(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_IsCNu\n  * wrapname: _wrap_Geom_Surface_IsCNu\n  * fulldecl: Standard_Boolean Handle_Geom_Surface::IsCNu(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom_Surface_IsCNv(Handle_Geom_Surface *self,Standard_Integer const N){
    return (*self)->IsCNv(N);
  }
EXPORT bool _wrap_Geom_Surface_IsCNv (Handle_Geom_Surface *larg1, Standard_Integer larg2) {
  bool lresult = (bool)0 ;
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Integer arg2 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom_Surface_IsCNv(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_IsCNv\n  * wrapname: _wrap_Geom_Surface_IsCNv\n  * fulldecl: Standard_Boolean Handle_Geom_Surface::IsCNv(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN void Handle_Geom_Surface_D0(Handle_Geom_Surface *self,Standard_Real const U,Standard_Real const V,gp_Pnt &P){
    (*self)->D0(U, V, P);
  }
EXPORT void _wrap_Geom_Surface_D0 (Handle_Geom_Surface *larg1, Standard_Real larg2, Standard_Real larg3, gp_Pnt *larg4) {
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  gp_Pnt *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Surface_D0(arg1,arg2,arg3,*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_D0\n  * wrapname: _wrap_Geom_Surface_D0\n  * fulldecl: void Handle_Geom_Surface::D0(Standard_Real const,Standard_Real const,gp_Pnt &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_Surface_D1(Handle_Geom_Surface *self,Standard_Real const U,Standard_Real const V,gp_Pnt &P,gp_Vec &D1U,gp_Vec &D1V){
    (*self)->D1(U, V, P, D1U, D1V);
  }
EXPORT void _wrap_Geom_Surface_D1 (Handle_Geom_Surface *larg1, Standard_Real larg2, Standard_Real larg3, gp_Pnt *larg4, gp_Vec *larg5, gp_Vec *larg6) {
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  gp_Pnt *arg4 = 0 ;
  gp_Vec *arg5 = 0 ;
  gp_Vec *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Surface_D1(arg1,arg2,arg3,*arg4,*arg5,*arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_D1\n  * wrapname: _wrap_Geom_Surface_D1\n  * fulldecl: void Handle_Geom_Surface::D1(Standard_Real const,Standard_Real const,gp_Pnt &,gp_Vec &,gp_Vec &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_Surface_D3(Handle_Geom_Surface *self,Standard_Real const U,Standard_Real const V,gp_Pnt &P,gp_Vec &D1U,gp_Vec &D1V,gp_Vec &D2U,gp_Vec &D2V,gp_Vec &D2UV,gp_Vec &D3U,gp_Vec &D3V,gp_Vec &D3UUV,gp_Vec &D3UVV){
    (*self)->D3(U, V, P, D1U, D1V, D2U, D2V, D2UV, D3U, D3V, D3UUV, D3UVV);
  }
EXPORT void _wrap_Geom_Surface_D3 (Handle_Geom_Surface *larg1, Standard_Real larg2, Standard_Real larg3, gp_Pnt *larg4, gp_Vec *larg5, gp_Vec *larg6, gp_Vec *larg7, gp_Vec *larg8, gp_Vec *larg9, gp_Vec *larg10, gp_Vec *larg11, gp_Vec *larg12, gp_Vec *larg13) {
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  gp_Pnt *arg4 = 0 ;
  gp_Vec *arg5 = 0 ;
  gp_Vec *arg6 = 0 ;
  gp_Vec *arg7 = 0 ;
  gp_Vec *arg8 = 0 ;
  gp_Vec *arg9 = 0 ;
  gp_Vec *arg10 = 0 ;
  gp_Vec *arg11 = 0 ;
  gp_Vec *arg12 = 0 ;
  gp_Vec *arg13 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  arg11 = larg11;
  arg12 = larg12;
  arg13 = larg13;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Surface_D3(arg1,arg2,arg3,*arg4,*arg5,*arg6,*arg7,*arg8,*arg9,*arg10,*arg11,*arg12,*arg13);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_D3\n  * wrapname: _wrap_Geom_Surface_D3\n  * fulldecl: void Handle_Geom_Surface::D3(Standard_Real const,Standard_Real const,gp_Pnt &,gp_Vec &,gp_Vec &,gp_Vec &,gp_Vec &,gp_Vec &,gp_Vec &,gp_Vec &,gp_Vec &,gp_Vec &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Vec Handle_Geom_Surface_DN(Handle_Geom_Surface *self,Standard_Real const U,Standard_Real const V,Standard_Integer const Nu,Standard_Integer const Nv){
    return (*self)->DN(U, V, Nu, Nv);
  }
EXPORT gp_Vec *_wrap_Geom_Surface_DN (Handle_Geom_Surface *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Integer larg4, Standard_Integer larg5) {
  gp_Vec * lresult = (gp_Vec *)0 ;
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Integer arg4 ;
  Standard_Integer arg5 ;
  gp_Vec result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Surface_DN(arg1,arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_DN\n  * wrapname: _wrap_Geom_Surface_DN\n  * fulldecl: gp_Vec Handle_Geom_Surface::DN(Standard_Real const,Standard_Real const,Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec(result);
    return lresult;
  } catch (...) {
    return (gp_Vec *)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_Surface_Value(Handle_Geom_Surface *self,Standard_Real const U,Standard_Real const V){
    return (*self)->Value(U, V);
  }
EXPORT gp_Pnt *_wrap_Geom_Surface_Value (Handle_Geom_Surface *larg1, Standard_Real larg2, Standard_Real larg3) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  gp_Pnt result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Surface_Value(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_Value\n  * wrapname: _wrap_Geom_Surface_Value\n  * fulldecl: gp_Pnt Handle_Geom_Surface::Value(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_Surface_GeometryType(Handle_Geom_Surface *self){
    if (STANDARD_TYPE(Geom_BezierSurface) == (*self)->DynamicType())
      {
	return 200;
      }
    else if (STANDARD_TYPE(Geom_BSplineSurface) == (*self)->DynamicType())
      {
	return 201;
      }
    else if (STANDARD_TYPE(Geom_RectangularTrimmedSurface) == (*self)->DynamicType())
      {
	return 202;
      }
    else if (STANDARD_TYPE(Geom_SphericalSurface) == (*self)->DynamicType())
      {
	return 203;
      }
    else if (STANDARD_TYPE(Geom_ToroidalSurface) == (*self)->DynamicType())
      {
	return 204;
      }
    else if (STANDARD_TYPE(Geom_OffsetSurface) == (*self)->DynamicType())
      {
	return 205;
      }
    else if (STANDARD_TYPE(Geom_SurfaceOfRevolution) == (*self)->DynamicType())
      {
	return 206;
      }
    else if (STANDARD_TYPE(Geom_ConicalSurface) == (*self)->DynamicType())
      {
	return 207;
      }
    else if (STANDARD_TYPE(Geom_CylindricalSurface) == (*self)->DynamicType())
      {
	return 208;
      }
    else if (STANDARD_TYPE(Geom_SurfaceOfLinearExtrusion) == (*self)->DynamicType())
      {
	return 209;
      }
    else if (STANDARD_TYPE(Geom_Plane) == (*self)->DynamicType())
      {
	return 210;
      }
    
    return -1;
  }
EXPORT Standard_Integer _wrap_Geom_Surface_GeometryType (Handle_Geom_Surface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_Surface_GeometryType(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_GeometryType\n  * wrapname: _wrap_Geom_Surface_GeometryType\n  * fulldecl: Standard_Integer Handle_Geom_Surface::GeometryType()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_BoundedCurve_EndPoint(Handle_Geom_BoundedCurve *self){
	  return (*self)->EndPoint();
	}
EXPORT gp_Pnt *_wrap_Geom_BoundedCurve_EndPoint (Handle_Geom_BoundedCurve *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_BoundedCurve *arg1 = (Handle_Geom_BoundedCurve *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_BoundedCurve_EndPoint(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BoundedCurve_EndPoint\n  * wrapname: _wrap_Geom_BoundedCurve_EndPoint\n  * fulldecl: gp_Pnt Handle_Geom_BoundedCurve::EndPoint()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_BoundedCurve_StartPoint(Handle_Geom_BoundedCurve *self){
	  return (*self)->StartPoint();
	}
EXPORT gp_Pnt *_wrap_Geom_BoundedCurve_StartPoint (Handle_Geom_BoundedCurve *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_BoundedCurve *arg1 = (Handle_Geom_BoundedCurve *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_BoundedCurve_StartPoint(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BoundedCurve_StartPoint\n  * wrapname: _wrap_Geom_BoundedCurve_StartPoint\n  * fulldecl: gp_Pnt Handle_Geom_BoundedCurve::StartPoint()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN void Handle_Geom_Conic_SetAxis(Handle_Geom_Conic *self,gp_Ax1 const &A1){
    (*self)->SetAxis(A1);
  }
EXPORT void _wrap_Geom_Conic_SetAxis (Handle_Geom_Conic *larg1, gp_Ax1 *larg2) {
  Handle_Geom_Conic *arg1 = (Handle_Geom_Conic *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Conic_SetAxis(arg1,(gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Conic_SetAxis\n  * wrapname: _wrap_Geom_Conic_SetAxis\n  * fulldecl: void Handle_Geom_Conic::SetAxis(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_Conic_SetLocation(Handle_Geom_Conic *self,gp_Pnt const &P){
    (*self)->SetLocation(P);
  }
EXPORT void _wrap_Geom_Conic_SetLocation (Handle_Geom_Conic *larg1, gp_Pnt *larg2) {
  Handle_Geom_Conic *arg1 = (Handle_Geom_Conic *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Conic_SetLocation(arg1,(gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Conic_SetLocation\n  * wrapname: _wrap_Geom_Conic_SetLocation\n  * fulldecl: void Handle_Geom_Conic::SetLocation(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_Conic_SetPosition(Handle_Geom_Conic *self,gp_Ax2 const &A2){
    (*self)->SetPosition(A2);
  }
EXPORT void _wrap_Geom_Conic_SetPosition (Handle_Geom_Conic *larg1, gp_Ax2 *larg2) {
  Handle_Geom_Conic *arg1 = (Handle_Geom_Conic *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Conic_SetPosition(arg1,(gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Conic_SetPosition\n  * wrapname: _wrap_Geom_Conic_SetPosition\n  * fulldecl: void Handle_Geom_Conic::SetPosition(gp_Ax2 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Ax1 Handle_Geom_Conic_Axis(Handle_Geom_Conic *self){
    return (*self)->Axis();
  }
EXPORT gp_Ax1 *_wrap_Geom_Conic_Axis (Handle_Geom_Conic *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  Handle_Geom_Conic *arg1 = (Handle_Geom_Conic *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Conic_Axis(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Conic_Axis\n  * wrapname: _wrap_Geom_Conic_Axis\n  * fulldecl: gp_Ax1 Handle_Geom_Conic::Axis()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Conic_Eccentricity(Handle_Geom_Conic *self){
    return (*self)->Eccentricity();
  }
EXPORT Standard_Real _wrap_Geom_Conic_Eccentricity (Handle_Geom_Conic *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Conic *arg1 = (Handle_Geom_Conic *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Conic_Eccentricity(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Conic_Eccentricity\n  * wrapname: _wrap_Geom_Conic_Eccentricity\n  * fulldecl: Standard_Real Handle_Geom_Conic::Eccentricity()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_Conic_Location(Handle_Geom_Conic *self){
    return (*self)->Location();
  }
EXPORT gp_Pnt *_wrap_Geom_Conic_Location (Handle_Geom_Conic *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_Conic *arg1 = (Handle_Geom_Conic *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Conic_Location(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Conic_Location\n  * wrapname: _wrap_Geom_Conic_Location\n  * fulldecl: gp_Pnt Handle_Geom_Conic::Location()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN gp_Ax2 Handle_Geom_Conic_Position(Handle_Geom_Conic *self){
    return (*self)->Position();
  }
EXPORT gp_Ax2 *_wrap_Geom_Conic_Position (Handle_Geom_Conic *larg1) {
  gp_Ax2 * lresult = (gp_Ax2 *)0 ;
  Handle_Geom_Conic *arg1 = (Handle_Geom_Conic *) 0 ;
  gp_Ax2 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Conic_Position(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Conic_Position\n  * wrapname: _wrap_Geom_Conic_Position\n  * fulldecl: gp_Ax2 Handle_Geom_Conic::Position()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2 *)0;
  }
}


SWIGINTERN gp_Ax1 Handle_Geom_Conic_XAxis(Handle_Geom_Conic *self){
    return (*self)->XAxis();
  }
EXPORT gp_Ax1 *_wrap_Geom_Conic_XAxis (Handle_Geom_Conic *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  Handle_Geom_Conic *arg1 = (Handle_Geom_Conic *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Conic_XAxis(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Conic_XAxis\n  * wrapname: _wrap_Geom_Conic_XAxis\n  * fulldecl: gp_Ax1 Handle_Geom_Conic::XAxis()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


SWIGINTERN gp_Ax1 Handle_Geom_Conic_YAxis(Handle_Geom_Conic *self){
    return (*self)->YAxis();
  }
EXPORT gp_Ax1 *_wrap_Geom_Conic_YAxis (Handle_Geom_Conic *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  Handle_Geom_Conic *arg1 = (Handle_Geom_Conic *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Conic_YAxis(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Conic_YAxis\n  * wrapname: _wrap_Geom_Conic_YAxis\n  * fulldecl: gp_Ax1 Handle_Geom_Conic::YAxis()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


SWIGINTERN gp_Ax1 Handle_Geom_ElementarySurface_Axis(Handle_Geom_ElementarySurface *self){
		return (*self)->Axis();
	}
EXPORT gp_Ax1 *_wrap_Geom_ElementarySurface_Axis (Handle_Geom_ElementarySurface *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  Handle_Geom_ElementarySurface *arg1 = (Handle_Geom_ElementarySurface *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_ElementarySurface_Axis(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_ElementarySurface_Axis\n  * wrapname: _wrap_Geom_ElementarySurface_Axis\n  * fulldecl: gp_Ax1 Handle_Geom_ElementarySurface::Axis()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_ElementarySurface_Location(Handle_Geom_ElementarySurface *self){
		return (*self)->Location();
	}
EXPORT gp_Pnt *_wrap_Geom_ElementarySurface_Location (Handle_Geom_ElementarySurface *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_ElementarySurface *arg1 = (Handle_Geom_ElementarySurface *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_ElementarySurface_Location(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_ElementarySurface_Location\n  * wrapname: _wrap_Geom_ElementarySurface_Location\n  * fulldecl: gp_Pnt Handle_Geom_ElementarySurface::Location()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN gp_Ax3 Handle_Geom_ElementarySurface_Position(Handle_Geom_ElementarySurface *self){
		return (*self)->Position();
	}
EXPORT gp_Ax3 *_wrap_Geom_ElementarySurface_Position (Handle_Geom_ElementarySurface *larg1) {
  gp_Ax3 * lresult = (gp_Ax3 *)0 ;
  Handle_Geom_ElementarySurface *arg1 = (Handle_Geom_ElementarySurface *) 0 ;
  gp_Ax3 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_ElementarySurface_Position(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_ElementarySurface_Position\n  * wrapname: _wrap_Geom_ElementarySurface_Position\n  * fulldecl: gp_Ax3 Handle_Geom_ElementarySurface::Position()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax3(result);
    return lresult;
  } catch (...) {
    return (gp_Ax3 *)0;
  }
}


SWIGINTERN gp_Dir Handle_Geom_SweptSurface_Direction(Handle_Geom_SweptSurface *self){
		return (*self)->Direction();
	}
EXPORT gp_Dir *_wrap_Geom_SweptSurface_Direction (Handle_Geom_SweptSurface *larg1) {
  gp_Dir * lresult = (gp_Dir *)0 ;
  Handle_Geom_SweptSurface *arg1 = (Handle_Geom_SweptSurface *) 0 ;
  gp_Dir result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_SweptSurface_Direction(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_SweptSurface_Direction\n  * wrapname: _wrap_Geom_SweptSurface_Direction\n  * fulldecl: gp_Dir Handle_Geom_SweptSurface::Direction()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Dir(result);
    return lresult;
  } catch (...) {
    return (gp_Dir *)0;
  }
}


SWIGINTERN Handle_Geom_Curve Handle_Geom_SweptSurface_BasisCurve(Handle_Geom_SweptSurface *self){
		return (*self)->BasisCurve();
	}
EXPORT Handle_Geom_Curve *_wrap_Geom_SweptSurface_BasisCurve (Handle_Geom_SweptSurface *larg1) {
  Handle_Geom_Curve * lresult = (Handle_Geom_Curve *)0 ;
  Handle_Geom_SweptSurface *arg1 = (Handle_Geom_SweptSurface *) 0 ;
  SwigValueWrapper< Handle_Geom_Curve > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_SweptSurface_BasisCurve(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_SweptSurface_BasisCurve\n  * wrapname: _wrap_Geom_SweptSurface_BasisCurve\n  * fulldecl: Handle_Geom_Curve Handle_Geom_SweptSurface::BasisCurve()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Curve(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Curve *)0;
  }
}


SWIGINTERN Handle_Geom_BezierCurve *new_Handle_Geom_BezierCurve__SWIG_0(TColgp_Array1OfPnt const &CurvePoles){
    return new Handle_Geom_BezierCurve(new Geom_BezierCurve(CurvePoles));
  }
EXPORT Handle_Geom_BezierCurve *_wrap_new_Geom_BezierCurve__SWIG_0 (TColgp_Array1OfPnt *larg1) {
  Handle_Geom_BezierCurve * lresult = (Handle_Geom_BezierCurve *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  Handle_Geom_BezierCurve *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_BezierCurve *)new_Handle_Geom_BezierCurve__SWIG_0((TColgp_Array1OfPnt const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_BezierCurve\n  * wrapname: _wrap_new_Geom_BezierCurve__SWIG_0\n  * fulldecl: Handle_Geom_BezierCurve::Handle_Geom_BezierCurve(TColgp_Array1OfPnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_BezierCurve *)0;
  }
}


SWIGINTERN Handle_Geom_BezierCurve *new_Handle_Geom_BezierCurve__SWIG_1(TColgp_Array1OfPnt const &CurvePoles,TColStd_Array1OfReal const &PoleWeights){
    return new Handle_Geom_BezierCurve(new Geom_BezierCurve(CurvePoles, PoleWeights));
  }
EXPORT Handle_Geom_BezierCurve *_wrap_new_Geom_BezierCurve__SWIG_1 (TColgp_Array1OfPnt *larg1, TColStd_Array1OfReal *larg2) {
  Handle_Geom_BezierCurve * lresult = (Handle_Geom_BezierCurve *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  Handle_Geom_BezierCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_BezierCurve *)new_Handle_Geom_BezierCurve__SWIG_1((TColgp_Array1OfPnt const &)*arg1,(TColStd_Array1OfReal const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_BezierCurve\n  * wrapname: _wrap_new_Geom_BezierCurve__SWIG_1\n  * fulldecl: Handle_Geom_BezierCurve::Handle_Geom_BezierCurve(TColgp_Array1OfPnt const &,TColStd_Array1OfReal const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_BezierCurve *)0;
  }
}


SWIGINTERN void Handle_Geom_BezierCurve_Delete(Handle_Geom_BezierCurve *self){
    self->~Handle_Geom_BezierCurve();
  }
EXPORT void _wrap_Geom_BezierCurve_Delete (Handle_Geom_BezierCurve *larg1) {
  Handle_Geom_BezierCurve *arg1 = (Handle_Geom_BezierCurve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BezierCurve_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierCurve_Delete\n  * wrapname: _wrap_Geom_BezierCurve_Delete\n  * fulldecl: void Handle_Geom_BezierCurve::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_BezierCurve_Increase(Handle_Geom_BezierCurve *self,Standard_Integer const Degree){
    (*self)->Increase(Degree);
  }
EXPORT void _wrap_Geom_BezierCurve_Increase (Handle_Geom_BezierCurve *larg1, Standard_Integer larg2) {
  Handle_Geom_BezierCurve *arg1 = (Handle_Geom_BezierCurve *) 0 ;
  Standard_Integer arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BezierCurve_Increase(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierCurve_Increase\n  * wrapname: _wrap_Geom_BezierCurve_Increase\n  * fulldecl: void Handle_Geom_BezierCurve::Increase(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_BezierCurve_InsertPoleAfter__SWIG_0(Handle_Geom_BezierCurve *self,Standard_Integer const Index,gp_Pnt const &P){
    (*self)->InsertPoleAfter(Index, P);
  }
EXPORT void _wrap_Geom_BezierCurve_InsertPoleAfter__SWIG_0 (Handle_Geom_BezierCurve *larg1, Standard_Integer larg2, gp_Pnt *larg3) {
  Handle_Geom_BezierCurve *arg1 = (Handle_Geom_BezierCurve *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BezierCurve_InsertPoleAfter__SWIG_0(arg1,arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierCurve_InsertPoleAfter\n  * wrapname: _wrap_Geom_BezierCurve_InsertPoleAfter__SWIG_0\n  * fulldecl: void Handle_Geom_BezierCurve::InsertPoleAfter(Standard_Integer const,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_BezierCurve_InsertPoleAfter__SWIG_1(Handle_Geom_BezierCurve *self,Standard_Integer const Index,gp_Pnt const &P,Standard_Real const Weight){

    (*self)->InsertPoleAfter(Index, P, Weight);
  }
EXPORT void _wrap_Geom_BezierCurve_InsertPoleAfter__SWIG_1 (Handle_Geom_BezierCurve *larg1, Standard_Integer larg2, gp_Pnt *larg3, Standard_Real larg4) {
  Handle_Geom_BezierCurve *arg1 = (Handle_Geom_BezierCurve *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt *arg3 = 0 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BezierCurve_InsertPoleAfter__SWIG_1(arg1,arg2,(gp_Pnt const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierCurve_InsertPoleAfter\n  * wrapname: _wrap_Geom_BezierCurve_InsertPoleAfter__SWIG_1\n  * fulldecl: void Handle_Geom_BezierCurve::InsertPoleAfter(Standard_Integer const,gp_Pnt const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_BezierCurve_InsertPoleBefore__SWIG_0(Handle_Geom_BezierCurve *self,Standard_Integer const Index,gp_Pnt const &P){
    (*self)->InsertPoleBefore(Index, P);
  }
EXPORT void _wrap_Geom_BezierCurve_InsertPoleBefore__SWIG_0 (Handle_Geom_BezierCurve *larg1, Standard_Integer larg2, gp_Pnt *larg3) {
  Handle_Geom_BezierCurve *arg1 = (Handle_Geom_BezierCurve *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BezierCurve_InsertPoleBefore__SWIG_0(arg1,arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierCurve_InsertPoleBefore\n  * wrapname: _wrap_Geom_BezierCurve_InsertPoleBefore__SWIG_0\n  * fulldecl: void Handle_Geom_BezierCurve::InsertPoleBefore(Standard_Integer const,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_BezierCurve_InsertPoleBefore__SWIG_1(Handle_Geom_BezierCurve *self,Standard_Integer const Index,gp_Pnt const &P,Standard_Real const Weight){
    (*self)->InsertPoleBefore(Index, P, Weight);
  }
EXPORT void _wrap_Geom_BezierCurve_InsertPoleBefore__SWIG_1 (Handle_Geom_BezierCurve *larg1, Standard_Integer larg2, gp_Pnt *larg3, Standard_Real larg4) {
  Handle_Geom_BezierCurve *arg1 = (Handle_Geom_BezierCurve *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt *arg3 = 0 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BezierCurve_InsertPoleBefore__SWIG_1(arg1,arg2,(gp_Pnt const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierCurve_InsertPoleBefore\n  * wrapname: _wrap_Geom_BezierCurve_InsertPoleBefore__SWIG_1\n  * fulldecl: void Handle_Geom_BezierCurve::InsertPoleBefore(Standard_Integer const,gp_Pnt const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_BezierCurve_RemovePole(Handle_Geom_BezierCurve *self,Standard_Integer const Index){
    (*self)->RemovePole(Index);
  }
EXPORT void _wrap_Geom_BezierCurve_RemovePole (Handle_Geom_BezierCurve *larg1, Standard_Integer larg2) {
  Handle_Geom_BezierCurve *arg1 = (Handle_Geom_BezierCurve *) 0 ;
  Standard_Integer arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BezierCurve_RemovePole(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierCurve_RemovePole\n  * wrapname: _wrap_Geom_BezierCurve_RemovePole\n  * fulldecl: void Handle_Geom_BezierCurve::RemovePole(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_BezierCurve_Segment(Handle_Geom_BezierCurve *self,Standard_Real const U1,Standard_Real const U2){
    (*self)->Segment(U1, U2);
  }
EXPORT void _wrap_Geom_BezierCurve_Segment (Handle_Geom_BezierCurve *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom_BezierCurve *arg1 = (Handle_Geom_BezierCurve *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BezierCurve_Segment(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierCurve_Segment\n  * wrapname: _wrap_Geom_BezierCurve_Segment\n  * fulldecl: void Handle_Geom_BezierCurve::Segment(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_BezierCurve_SetPole__SWIG_0(Handle_Geom_BezierCurve *self,Standard_Integer const Index,gp_Pnt const &P){
    (*self)->SetPole(Index, P);
  }
EXPORT void _wrap_Geom_BezierCurve_SetPole__SWIG_0 (Handle_Geom_BezierCurve *larg1, Standard_Integer larg2, gp_Pnt *larg3) {
  Handle_Geom_BezierCurve *arg1 = (Handle_Geom_BezierCurve *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BezierCurve_SetPole__SWIG_0(arg1,arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierCurve_SetPole\n  * wrapname: _wrap_Geom_BezierCurve_SetPole__SWIG_0\n  * fulldecl: void Handle_Geom_BezierCurve::SetPole(Standard_Integer const,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_BezierCurve_SetPole__SWIG_1(Handle_Geom_BezierCurve *self,Standard_Integer const Index,gp_Pnt const &P,Standard_Real const Weight){
    (*self)->SetPole(Index, P, Weight);
  }
EXPORT void _wrap_Geom_BezierCurve_SetPole__SWIG_1 (Handle_Geom_BezierCurve *larg1, Standard_Integer larg2, gp_Pnt *larg3, Standard_Real larg4) {
  Handle_Geom_BezierCurve *arg1 = (Handle_Geom_BezierCurve *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt *arg3 = 0 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BezierCurve_SetPole__SWIG_1(arg1,arg2,(gp_Pnt const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierCurve_SetPole\n  * wrapname: _wrap_Geom_BezierCurve_SetPole__SWIG_1\n  * fulldecl: void Handle_Geom_BezierCurve::SetPole(Standard_Integer const,gp_Pnt const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_BezierCurve_SetWeight(Handle_Geom_BezierCurve *self,Standard_Integer const Index,Standard_Real const Weight){
    (*self)->SetWeight(Index, Weight);
  }
EXPORT void _wrap_Geom_BezierCurve_SetWeight (Handle_Geom_BezierCurve *larg1, Standard_Integer larg2, Standard_Real larg3) {
  Handle_Geom_BezierCurve *arg1 = (Handle_Geom_BezierCurve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BezierCurve_SetWeight(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierCurve_SetWeight\n  * wrapname: _wrap_Geom_BezierCurve_SetWeight\n  * fulldecl: void Handle_Geom_BezierCurve::SetWeight(Standard_Integer const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Boolean Handle_Geom_BezierCurve_IsRational(Handle_Geom_BezierCurve *self){
    return (*self)->IsRational();
  }
EXPORT bool _wrap_Geom_BezierCurve_IsRational (Handle_Geom_BezierCurve *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom_BezierCurve *arg1 = (Handle_Geom_BezierCurve *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom_BezierCurve_IsRational(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierCurve_IsRational\n  * wrapname: _wrap_Geom_BezierCurve_IsRational\n  * fulldecl: Standard_Boolean Handle_Geom_BezierCurve::IsRational()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BezierCurve_Degree(Handle_Geom_BezierCurve *self){
    return (*self)->Degree();
  }
EXPORT Standard_Integer _wrap_Geom_BezierCurve_Degree (Handle_Geom_BezierCurve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BezierCurve *arg1 = (Handle_Geom_BezierCurve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BezierCurve_Degree(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierCurve_Degree\n  * wrapname: _wrap_Geom_BezierCurve_Degree\n  * fulldecl: Standard_Integer Handle_Geom_BezierCurve::Degree()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BezierCurve_NbPoles(Handle_Geom_BezierCurve *self){
    return (*self)->NbPoles();
  }
EXPORT Standard_Integer _wrap_Geom_BezierCurve_NbPoles (Handle_Geom_BezierCurve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BezierCurve *arg1 = (Handle_Geom_BezierCurve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BezierCurve_NbPoles(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierCurve_NbPoles\n  * wrapname: _wrap_Geom_BezierCurve_NbPoles\n  * fulldecl: Standard_Integer Handle_Geom_BezierCurve::NbPoles()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_BezierCurve_Pole(Handle_Geom_BezierCurve *self,Standard_Integer const Index){
    return (*self)->Pole(Index);
  }
EXPORT gp_Pnt *_wrap_Geom_BezierCurve_Pole (Handle_Geom_BezierCurve *larg1, Standard_Integer larg2) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_BezierCurve *arg1 = (Handle_Geom_BezierCurve *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_BezierCurve_Pole(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierCurve_Pole\n  * wrapname: _wrap_Geom_BezierCurve_Pole\n  * fulldecl: gp_Pnt Handle_Geom_BezierCurve::Pole(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN TColgp_Array1OfPnt const &Handle_Geom_BezierCurve_Poles(Handle_Geom_BezierCurve *self){
    return (*self)->Poles();
  }
EXPORT TColgp_Array1OfPnt *_wrap_Geom_BezierCurve_Poles (Handle_Geom_BezierCurve *larg1) {
  TColgp_Array1OfPnt * lresult = (TColgp_Array1OfPnt *)0 ;
  Handle_Geom_BezierCurve *arg1 = (Handle_Geom_BezierCurve *) 0 ;
  TColgp_Array1OfPnt *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColgp_Array1OfPnt *) &Handle_Geom_BezierCurve_Poles(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierCurve_Poles\n  * wrapname: _wrap_Geom_BezierCurve_Poles\n  * fulldecl: TColgp_Array1OfPnt const & Handle_Geom_BezierCurve::Poles()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColgp_Array1OfPnt *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_BezierCurve_Weight(Handle_Geom_BezierCurve *self,Standard_Integer const Index){
    return (*self)->Weight(Index);
  }
EXPORT Standard_Real _wrap_Geom_BezierCurve_Weight (Handle_Geom_BezierCurve *larg1, Standard_Integer larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_BezierCurve *arg1 = (Handle_Geom_BezierCurve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_BezierCurve_Weight(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierCurve_Weight\n  * wrapname: _wrap_Geom_BezierCurve_Weight\n  * fulldecl: Standard_Real Handle_Geom_BezierCurve::Weight(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN TColStd_Array1OfReal const *Handle_Geom_BezierCurve_Weights(Handle_Geom_BezierCurve *self){
    return (*self)->Weights();
  }
EXPORT TColStd_Array1OfReal *_wrap_Geom_BezierCurve_Weights (Handle_Geom_BezierCurve *larg1) {
  TColStd_Array1OfReal * lresult = (TColStd_Array1OfReal *)0 ;
  Handle_Geom_BezierCurve *arg1 = (Handle_Geom_BezierCurve *) 0 ;
  TColStd_Array1OfReal *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColStd_Array1OfReal *)Handle_Geom_BezierCurve_Weights(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierCurve_Weights\n  * wrapname: _wrap_Geom_BezierCurve_Weights\n  * fulldecl: TColStd_Array1OfReal const * Handle_Geom_BezierCurve::Weights()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColStd_Array1OfReal *)0;
  }
}


SWIGINTERN void Handle_Geom_BezierCurve_Resolution(Handle_Geom_BezierCurve *self,Standard_Real Tolerance3d,Standard_Real &UTolerance){
    return (*self)->Resolution(Tolerance3d, UTolerance);
  }
EXPORT void _wrap_Geom_BezierCurve_Resolution (Handle_Geom_BezierCurve *larg1, Standard_Real larg2, Standard_Real *larg3) {
  Handle_Geom_BezierCurve *arg1 = (Handle_Geom_BezierCurve *) 0 ;
  Standard_Real arg2 ;
  Standard_Real *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BezierCurve_Resolution(arg1,arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierCurve_Resolution\n  * wrapname: _wrap_Geom_BezierCurve_Resolution\n  * fulldecl: void Handle_Geom_BezierCurve::Resolution(Standard_Real,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BezierCurve_MaxDegree(){
    return Geom_BezierCurve::MaxDegree();
  }
EXPORT Standard_Integer _wrap_Geom_BezierCurve_MaxDegree () {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Standard_Integer result;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BezierCurve_MaxDegree();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierCurve_MaxDegree\n  * wrapname: _wrap_Geom_BezierCurve_MaxDegree\n  * fulldecl: Standard_Integer Handle_Geom_BezierCurve::Handle_Geom_BezierCurve_MaxDegree()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Handle_Geom_BSplineCurve *new_Handle_Geom_BSplineCurve__SWIG_0(TColgp_Array1OfPnt const &Poles,TColStd_Array1OfReal const &Weights,TColStd_Array1OfReal const &Knots,TColStd_Array1OfInteger const &Multiplicities,Standard_Integer const Degree,Standard_Boolean const Periodic=Standard_False,Standard_Boolean const CheckRational=Standard_True){
		return new Handle_Geom_BSplineCurve(new Geom_BSplineCurve(
			Poles, Weights, Knots, Multiplicities, Degree, Periodic, CheckRational));
	}
EXPORT Handle_Geom_BSplineCurve *_wrap_new_Geom_BSplineCurve__SWIG_0 (TColgp_Array1OfPnt *larg1, TColStd_Array1OfReal *larg2, TColStd_Array1OfReal *larg3, TColStd_Array1OfInteger *larg4, Standard_Integer larg5, bool larg6, bool larg7) {
  Handle_Geom_BSplineCurve * lresult = (Handle_Geom_BSplineCurve *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  TColStd_Array1OfReal *arg3 = 0 ;
  TColStd_Array1OfInteger *arg4 = 0 ;
  Standard_Integer arg5 ;
  Standard_Boolean arg6 ;
  Standard_Boolean arg7 ;
  Handle_Geom_BSplineCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = (bool)larg6;
  arg7 = (bool)larg7;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_BSplineCurve *)new_Handle_Geom_BSplineCurve__SWIG_0((TColgp_Array1OfPnt const &)*arg1,(TColStd_Array1OfReal const &)*arg2,(TColStd_Array1OfReal const &)*arg3,(TColStd_Array1OfInteger const &)*arg4,arg5,arg6,arg7);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_BSplineCurve\n  * wrapname: _wrap_new_Geom_BSplineCurve__SWIG_0\n  * fulldecl: Handle_Geom_BSplineCurve::Handle_Geom_BSplineCurve(TColgp_Array1OfPnt const &,TColStd_Array1OfReal const &,TColStd_Array1OfReal const &,TColStd_Array1OfInteger const &,Standard_Integer const,Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_BSplineCurve *)0;
  }
}


EXPORT Handle_Geom_BSplineCurve *_wrap_new_Geom_BSplineCurve__SWIG_1 (TColgp_Array1OfPnt *larg1, TColStd_Array1OfReal *larg2, TColStd_Array1OfReal *larg3, TColStd_Array1OfInteger *larg4, Standard_Integer larg5, bool larg6) {
  Handle_Geom_BSplineCurve * lresult = (Handle_Geom_BSplineCurve *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  TColStd_Array1OfReal *arg3 = 0 ;
  TColStd_Array1OfInteger *arg4 = 0 ;
  Standard_Integer arg5 ;
  Standard_Boolean arg6 ;
  Handle_Geom_BSplineCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = (bool)larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_BSplineCurve *)new_Handle_Geom_BSplineCurve__SWIG_0((TColgp_Array1OfPnt const &)*arg1,(TColStd_Array1OfReal const &)*arg2,(TColStd_Array1OfReal const &)*arg3,(TColStd_Array1OfInteger const &)*arg4,arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_BSplineCurve\n  * wrapname: _wrap_new_Geom_BSplineCurve__SWIG_1\n  * fulldecl: Handle_Geom_BSplineCurve::Handle_Geom_BSplineCurve(TColgp_Array1OfPnt const &,TColStd_Array1OfReal const &,TColStd_Array1OfReal const &,TColStd_Array1OfInteger const &,Standard_Integer const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_BSplineCurve *)0;
  }
}


EXPORT Handle_Geom_BSplineCurve *_wrap_new_Geom_BSplineCurve__SWIG_2 (TColgp_Array1OfPnt *larg1, TColStd_Array1OfReal *larg2, TColStd_Array1OfReal *larg3, TColStd_Array1OfInteger *larg4, Standard_Integer larg5) {
  Handle_Geom_BSplineCurve * lresult = (Handle_Geom_BSplineCurve *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  TColStd_Array1OfReal *arg3 = 0 ;
  TColStd_Array1OfInteger *arg4 = 0 ;
  Standard_Integer arg5 ;
  Handle_Geom_BSplineCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_BSplineCurve *)new_Handle_Geom_BSplineCurve__SWIG_0((TColgp_Array1OfPnt const &)*arg1,(TColStd_Array1OfReal const &)*arg2,(TColStd_Array1OfReal const &)*arg3,(TColStd_Array1OfInteger const &)*arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_BSplineCurve\n  * wrapname: _wrap_new_Geom_BSplineCurve__SWIG_2\n  * fulldecl: Handle_Geom_BSplineCurve::Handle_Geom_BSplineCurve(TColgp_Array1OfPnt const &,TColStd_Array1OfReal const &,TColStd_Array1OfReal const &,TColStd_Array1OfInteger const &,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_BSplineCurve *)0;
  }
}


SWIGINTERN Handle_Geom_BSplineCurve *new_Handle_Geom_BSplineCurve__SWIG_3(TColgp_Array1OfPnt const &Poles,TColStd_Array1OfReal const &Knots,TColStd_Array1OfInteger const &Multiplicities,Standard_Integer const Degree,Standard_Boolean const Periodic=Standard_False){
        return new Handle_Geom_BSplineCurve(new Geom_BSplineCurve(Poles, Knots, Multiplicities, 
            Degree, Periodic));
    }
EXPORT Handle_Geom_BSplineCurve *_wrap_new_Geom_BSplineCurve__SWIG_3 (TColgp_Array1OfPnt *larg1, TColStd_Array1OfReal *larg2, TColStd_Array1OfInteger *larg3, Standard_Integer larg4, bool larg5) {
  Handle_Geom_BSplineCurve * lresult = (Handle_Geom_BSplineCurve *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  TColStd_Array1OfInteger *arg3 = 0 ;
  Standard_Integer arg4 ;
  Standard_Boolean arg5 ;
  Handle_Geom_BSplineCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = (bool)larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_BSplineCurve *)new_Handle_Geom_BSplineCurve__SWIG_3((TColgp_Array1OfPnt const &)*arg1,(TColStd_Array1OfReal const &)*arg2,(TColStd_Array1OfInteger const &)*arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_BSplineCurve\n  * wrapname: _wrap_new_Geom_BSplineCurve__SWIG_3\n  * fulldecl: Handle_Geom_BSplineCurve::Handle_Geom_BSplineCurve(TColgp_Array1OfPnt const &,TColStd_Array1OfReal const &,TColStd_Array1OfInteger const &,Standard_Integer const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_BSplineCurve *)0;
  }
}


EXPORT Handle_Geom_BSplineCurve *_wrap_new_Geom_BSplineCurve__SWIG_4 (TColgp_Array1OfPnt *larg1, TColStd_Array1OfReal *larg2, TColStd_Array1OfInteger *larg3, Standard_Integer larg4) {
  Handle_Geom_BSplineCurve * lresult = (Handle_Geom_BSplineCurve *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  TColStd_Array1OfInteger *arg3 = 0 ;
  Standard_Integer arg4 ;
  Handle_Geom_BSplineCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_BSplineCurve *)new_Handle_Geom_BSplineCurve__SWIG_3((TColgp_Array1OfPnt const &)*arg1,(TColStd_Array1OfReal const &)*arg2,(TColStd_Array1OfInteger const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_BSplineCurve\n  * wrapname: _wrap_new_Geom_BSplineCurve__SWIG_4\n  * fulldecl: Handle_Geom_BSplineCurve::Handle_Geom_BSplineCurve(TColgp_Array1OfPnt const &,TColStd_Array1OfReal const &,TColStd_Array1OfInteger const &,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_BSplineCurve *)0;
  }
}


SWIGINTERN void Handle_Geom_BSplineCurve_Delete(Handle_Geom_BSplineCurve *self){
    self->~Handle_Geom_BSplineCurve();
  }
EXPORT void _wrap_Geom_BSplineCurve_Delete (Handle_Geom_BSplineCurve *larg1) {
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BSplineCurve_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_Delete\n  * wrapname: _wrap_Geom_BSplineCurve_Delete\n  * fulldecl: void Handle_Geom_BSplineCurve::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_BSplineCurve_SetKnot__SWIG_0(Handle_Geom_BSplineCurve *self,Standard_Integer const Index,Standard_Real const K){
    (*self)->SetKnot(Index,K);
  }
EXPORT void _wrap_Geom_BSplineCurve_SetKnot__SWIG_0 (Handle_Geom_BSplineCurve *larg1, Standard_Integer larg2, Standard_Real larg3) {
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BSplineCurve_SetKnot__SWIG_0(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_SetKnot\n  * wrapname: _wrap_Geom_BSplineCurve_SetKnot__SWIG_0\n  * fulldecl: void Handle_Geom_BSplineCurve::SetKnot(Standard_Integer const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_BSplineCurve_SetKnot__SWIG_1(Handle_Geom_BSplineCurve *self,Standard_Integer const Index,Standard_Real const K,Standard_Integer const M){
    (*self)->SetKnot(Index,K,M);
  }
EXPORT void _wrap_Geom_BSplineCurve_SetKnot__SWIG_1 (Handle_Geom_BSplineCurve *larg1, Standard_Integer larg2, Standard_Real larg3, Standard_Integer larg4) {
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real arg3 ;
  Standard_Integer arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BSplineCurve_SetKnot__SWIG_1(arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_SetKnot\n  * wrapname: _wrap_Geom_BSplineCurve_SetKnot__SWIG_1\n  * fulldecl: void Handle_Geom_BSplineCurve::SetKnot(Standard_Integer const,Standard_Real const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_BSplineCurve_SetPeriodic(Handle_Geom_BSplineCurve *self){
    (*self)->SetPeriodic();
  }
EXPORT void _wrap_Geom_BSplineCurve_SetPeriodic (Handle_Geom_BSplineCurve *larg1) {
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BSplineCurve_SetPeriodic(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_SetPeriodic\n  * wrapname: _wrap_Geom_BSplineCurve_SetPeriodic\n  * fulldecl: void Handle_Geom_BSplineCurve::SetPeriodic()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_BSplineCurve_SetNotPeriodic(Handle_Geom_BSplineCurve *self){
    (*self)->SetNotPeriodic();
  }
EXPORT void _wrap_Geom_BSplineCurve_SetNotPeriodic (Handle_Geom_BSplineCurve *larg1) {
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BSplineCurve_SetNotPeriodic(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_SetNotPeriodic\n  * wrapname: _wrap_Geom_BSplineCurve_SetNotPeriodic\n  * fulldecl: void Handle_Geom_BSplineCurve::SetNotPeriodic()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_BSplineCurve_SetOrigin__SWIG_0(Handle_Geom_BSplineCurve *self,Standard_Integer const Index){
     (*self)->SetOrigin(Index);
  }
EXPORT void _wrap_Geom_BSplineCurve_SetOrigin__SWIG_0 (Handle_Geom_BSplineCurve *larg1, Standard_Integer larg2) {
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BSplineCurve_SetOrigin__SWIG_0(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_SetOrigin\n  * wrapname: _wrap_Geom_BSplineCurve_SetOrigin__SWIG_0\n  * fulldecl: void Handle_Geom_BSplineCurve::SetOrigin(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_BSplineCurve_SetOrigin__SWIG_1(Handle_Geom_BSplineCurve *self,Standard_Real const U,Standard_Real const Tol){
     (*self)->SetOrigin(U,Tol);
  }
EXPORT void _wrap_Geom_BSplineCurve_SetOrigin__SWIG_1 (Handle_Geom_BSplineCurve *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BSplineCurve_SetOrigin__SWIG_1(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_SetOrigin\n  * wrapname: _wrap_Geom_BSplineCurve_SetOrigin__SWIG_1\n  * fulldecl: void Handle_Geom_BSplineCurve::SetOrigin(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_BSplineCurve_SetPole__SWIG_0(Handle_Geom_BSplineCurve *self,Standard_Integer const Index,gp_Pnt const &P){
    (*self)->SetPole(Index,P);
  }
EXPORT void _wrap_Geom_BSplineCurve_SetPole__SWIG_0 (Handle_Geom_BSplineCurve *larg1, Standard_Integer larg2, gp_Pnt *larg3) {
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BSplineCurve_SetPole__SWIG_0(arg1,arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_SetPole\n  * wrapname: _wrap_Geom_BSplineCurve_SetPole__SWIG_0\n  * fulldecl: void Handle_Geom_BSplineCurve::SetPole(Standard_Integer const,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_BSplineCurve_SetPole__SWIG_1(Handle_Geom_BSplineCurve *self,Standard_Integer const Index,gp_Pnt const &P,Standard_Real const Weight){
    (*self)->SetPole(Index,P,Weight);
  }
EXPORT void _wrap_Geom_BSplineCurve_SetPole__SWIG_1 (Handle_Geom_BSplineCurve *larg1, Standard_Integer larg2, gp_Pnt *larg3, Standard_Real larg4) {
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt *arg3 = 0 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BSplineCurve_SetPole__SWIG_1(arg1,arg2,(gp_Pnt const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_SetPole\n  * wrapname: _wrap_Geom_BSplineCurve_SetPole__SWIG_1\n  * fulldecl: void Handle_Geom_BSplineCurve::SetPole(Standard_Integer const,gp_Pnt const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_BSplineCurve_MovePoint(Handle_Geom_BSplineCurve *self,Standard_Real const U,gp_Pnt const &P,Standard_Integer const Index1,Standard_Integer const Index2,Standard_Integer &FirstModifiedPole,Standard_Integer &LastModifiedPole){
    (*self)->MovePoint(U,P,Index1,Index2,FirstModifiedPole,LastModifiedPole);
  }
EXPORT void _wrap_Geom_BSplineCurve_MovePoint (Handle_Geom_BSplineCurve *larg1, Standard_Real larg2, gp_Pnt *larg3, Standard_Integer larg4, Standard_Integer larg5, Standard_Integer *larg6, Standard_Integer *larg7) {
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt *arg3 = 0 ;
  Standard_Integer arg4 ;
  Standard_Integer arg5 ;
  Standard_Integer *arg6 = 0 ;
  Standard_Integer *arg7 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BSplineCurve_MovePoint(arg1,arg2,(gp_Pnt const &)*arg3,arg4,arg5,*arg6,*arg7);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_MovePoint\n  * wrapname: _wrap_Geom_BSplineCurve_MovePoint\n  * fulldecl: void Handle_Geom_BSplineCurve::MovePoint(Standard_Real const,gp_Pnt const &,Standard_Integer const,Standard_Integer const,Standard_Integer &,Standard_Integer &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_BSplineCurve_MovePointAndTangent(Handle_Geom_BSplineCurve *self,Standard_Real const U,gp_Pnt const &P,gp_Vec const &Tangent,Standard_Real const Tolerance,Standard_Integer const StartingCondition,Standard_Integer const EndingCondition){
    Standard_Integer ErrorStatus =0;
	(*self)->MovePointAndTangent(U,P,Tangent,Tolerance,StartingCondition,EndingCondition,ErrorStatus);
  }
EXPORT void _wrap_Geom_BSplineCurve_MovePointAndTangent (Handle_Geom_BSplineCurve *larg1, Standard_Real larg2, gp_Pnt *larg3, gp_Vec *larg4, Standard_Real larg5, Standard_Integer larg6, Standard_Integer larg7) {
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt *arg3 = 0 ;
  gp_Vec *arg4 = 0 ;
  Standard_Real arg5 ;
  Standard_Integer arg6 ;
  Standard_Integer arg7 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BSplineCurve_MovePointAndTangent(arg1,arg2,(gp_Pnt const &)*arg3,(gp_Vec const &)*arg4,arg5,arg6,arg7);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_MovePointAndTangent\n  * wrapname: _wrap_Geom_BSplineCurve_MovePointAndTangent\n  * fulldecl: void Handle_Geom_BSplineCurve::MovePointAndTangent(Standard_Real const,gp_Pnt const &,gp_Vec const &,Standard_Real const,Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Boolean Handle_Geom_BSplineCurve_IsRational(Handle_Geom_BSplineCurve const *self){
    return (*self)->IsRational();
  }
EXPORT bool _wrap_Geom_BSplineCurve_IsRational (Handle_Geom_BSplineCurve *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom_BSplineCurve_IsRational((Handle_Geom_BSplineCurve const *)arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_IsRational\n  * wrapname: _wrap_Geom_BSplineCurve_IsRational\n  * fulldecl: Standard_Boolean Handle_Geom_BSplineCurve::IsRational() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN GeomAbs_Shape Handle_Geom_BSplineCurve_Continuity(Handle_Geom_BSplineCurve const *self){
    return (*self)->Continuity();
  }
EXPORT GeomAbs_Shape _wrap_Geom_BSplineCurve_Continuity (Handle_Geom_BSplineCurve *larg1) {
  GeomAbs_Shape lresult = (GeomAbs_Shape)0 ;
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  GeomAbs_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAbs_Shape)Handle_Geom_BSplineCurve_Continuity((Handle_Geom_BSplineCurve const *)arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_Continuity\n  * wrapname: _wrap_Geom_BSplineCurve_Continuity\n  * fulldecl: GeomAbs_Shape Handle_Geom_BSplineCurve::Continuity() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAbs_Shape)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineCurve_Degree(Handle_Geom_BSplineCurve const *self){
    return (*self)->Degree();
  }
EXPORT Standard_Integer _wrap_Geom_BSplineCurve_Degree (Handle_Geom_BSplineCurve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineCurve_Degree((Handle_Geom_BSplineCurve const *)arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_Degree\n  * wrapname: _wrap_Geom_BSplineCurve_Degree\n  * fulldecl: Standard_Integer Handle_Geom_BSplineCurve::Degree() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_BSplineCurve_LocalValue(Handle_Geom_BSplineCurve const *self,Standard_Real const U,Standard_Integer const FromK1,Standard_Integer const ToK2){
    return (*self)->LocalValue(U,FromK1,ToK2);
  }
EXPORT gp_Pnt *_wrap_Geom_BSplineCurve_LocalValue (Handle_Geom_BSplineCurve *larg1, Standard_Real larg2, Standard_Integer larg3, Standard_Integer larg4) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Real arg2 ;
  Standard_Integer arg3 ;
  Standard_Integer arg4 ;
  gp_Pnt result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_BSplineCurve_LocalValue((Handle_Geom_BSplineCurve const *)arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_LocalValue\n  * wrapname: _wrap_Geom_BSplineCurve_LocalValue\n  * fulldecl: gp_Pnt Handle_Geom_BSplineCurve::LocalValue(Standard_Real const,Standard_Integer const,Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_BSplineCurve_EndPoint(Handle_Geom_BSplineCurve const *self){
    return (*self)->EndPoint();
  }
EXPORT gp_Pnt *_wrap_Geom_BSplineCurve_EndPoint (Handle_Geom_BSplineCurve *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_BSplineCurve_EndPoint((Handle_Geom_BSplineCurve const *)arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_EndPoint\n  * wrapname: _wrap_Geom_BSplineCurve_EndPoint\n  * fulldecl: gp_Pnt Handle_Geom_BSplineCurve::EndPoint() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_BSplineCurve_StartPoint(Handle_Geom_BSplineCurve const *self){
    return (*self)->StartPoint();
  }
EXPORT gp_Pnt *_wrap_Geom_BSplineCurve_StartPoint (Handle_Geom_BSplineCurve *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_BSplineCurve_StartPoint((Handle_Geom_BSplineCurve const *)arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_StartPoint\n  * wrapname: _wrap_Geom_BSplineCurve_StartPoint\n  * fulldecl: gp_Pnt Handle_Geom_BSplineCurve::StartPoint() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineCurve_NbKnots(Handle_Geom_BSplineCurve const *self){
    return (*self)->NbKnots();
  }
EXPORT Standard_Integer _wrap_Geom_BSplineCurve_NbKnots (Handle_Geom_BSplineCurve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineCurve_NbKnots((Handle_Geom_BSplineCurve const *)arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_NbKnots\n  * wrapname: _wrap_Geom_BSplineCurve_NbKnots\n  * fulldecl: Standard_Integer Handle_Geom_BSplineCurve::NbKnots() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineCurve_NbPoles(Handle_Geom_BSplineCurve const *self){
    return (*self)->NbPoles();
  }
EXPORT Standard_Integer _wrap_Geom_BSplineCurve_NbPoles (Handle_Geom_BSplineCurve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineCurve_NbPoles((Handle_Geom_BSplineCurve const *)arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_NbPoles\n  * wrapname: _wrap_Geom_BSplineCurve_NbPoles\n  * fulldecl: Standard_Integer Handle_Geom_BSplineCurve::NbPoles() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_BSplineCurve_Pole(Handle_Geom_BSplineCurve const *self,Standard_Integer const Index){
    return (*self)->Pole(Index);
  }
EXPORT gp_Pnt *_wrap_Geom_BSplineCurve_Pole (Handle_Geom_BSplineCurve *larg1, Standard_Integer larg2) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_BSplineCurve_Pole((Handle_Geom_BSplineCurve const *)arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_Pole\n  * wrapname: _wrap_Geom_BSplineCurve_Pole\n  * fulldecl: gp_Pnt Handle_Geom_BSplineCurve::Pole(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN void Handle_Geom_BSplineCurve_Poles(Handle_Geom_BSplineCurve *self,TColgp_Array1OfPnt &P){
    (*self)->Poles(P);
  }
EXPORT void _wrap_Geom_BSplineCurve_Poles (Handle_Geom_BSplineCurve *larg1, TColgp_Array1OfPnt *larg2) {
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  TColgp_Array1OfPnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BSplineCurve_Poles(arg1,*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_Poles\n  * wrapname: _wrap_Geom_BSplineCurve_Poles\n  * fulldecl: void Handle_Geom_BSplineCurve::Poles(TColgp_Array1OfPnt &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Geom_BSplineCurve_Weight(Handle_Geom_BSplineCurve const *self,Standard_Integer const Index){
    return (*self)->Weight(Index);
  }
EXPORT Standard_Real _wrap_Geom_BSplineCurve_Weight (Handle_Geom_BSplineCurve *larg1, Standard_Integer larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_BSplineCurve_Weight((Handle_Geom_BSplineCurve const *)arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_Weight\n  * wrapname: _wrap_Geom_BSplineCurve_Weight\n  * fulldecl: Standard_Real Handle_Geom_BSplineCurve::Weight(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_BSplineCurve_Knot(Handle_Geom_BSplineCurve const *self,Standard_Integer const Index){
    return (*self)->Knot(Index);
  }
EXPORT Standard_Real _wrap_Geom_BSplineCurve_Knot (Handle_Geom_BSplineCurve *larg1, Standard_Integer larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_BSplineCurve_Knot((Handle_Geom_BSplineCurve const *)arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_Knot\n  * wrapname: _wrap_Geom_BSplineCurve_Knot\n  * fulldecl: Standard_Real Handle_Geom_BSplineCurve::Knot(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN void Handle_Geom_BSplineCurve_Knots(Handle_Geom_BSplineCurve *self,TColStd_Array1OfReal &K){
    (*self)->Knots(K);
  }
EXPORT void _wrap_Geom_BSplineCurve_Knots (Handle_Geom_BSplineCurve *larg1, TColStd_Array1OfReal *larg2) {
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BSplineCurve_Knots(arg1,*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_Knots\n  * wrapname: _wrap_Geom_BSplineCurve_Knots\n  * fulldecl: void Handle_Geom_BSplineCurve::Knots(TColStd_Array1OfReal &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineCurve_Multiplicity(Handle_Geom_BSplineCurve const *self,Standard_Integer const Index){
    return (*self)->Multiplicity(Index);
  }
EXPORT Standard_Integer _wrap_Geom_BSplineCurve_Multiplicity (Handle_Geom_BSplineCurve *larg1, Standard_Integer larg2) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineCurve_Multiplicity((Handle_Geom_BSplineCurve const *)arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_Multiplicity\n  * wrapname: _wrap_Geom_BSplineCurve_Multiplicity\n  * fulldecl: Standard_Integer Handle_Geom_BSplineCurve::Multiplicity(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Handle_Geom_Circle *new_Handle_Geom_Circle(gp_Ax2 const &A2,Standard_Real const R){
    return new Handle_Geom_Circle(new Geom_Circle(A2, R));
  }
EXPORT Handle_Geom_Circle *_wrap_new_Geom_Circle (gp_Ax2 *larg1, Standard_Real larg2) {
  Handle_Geom_Circle * lresult = (Handle_Geom_Circle *)0 ;
  gp_Ax2 *arg1 = 0 ;
  Standard_Real arg2 ;
  Handle_Geom_Circle *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_Circle *)new_Handle_Geom_Circle((gp_Ax2 const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_Circle\n  * wrapname: _wrap_new_Geom_Circle\n  * fulldecl: Handle_Geom_Circle::Handle_Geom_Circle(gp_Ax2 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_Circle *)0;
  }
}


SWIGINTERN void Handle_Geom_Circle_Delete(Handle_Geom_Circle *self){
    self->~Handle_Geom_Circle();
  }
EXPORT void _wrap_Geom_Circle_Delete (Handle_Geom_Circle *larg1) {
  Handle_Geom_Circle *arg1 = (Handle_Geom_Circle *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Circle_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Circle_Delete\n  * wrapname: _wrap_Geom_Circle_Delete\n  * fulldecl: void Handle_Geom_Circle::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Geom_Circle_Radius(Handle_Geom_Circle *self){
    return (*self)->Radius();
  }
EXPORT Standard_Real _wrap_Geom_Circle_Radius (Handle_Geom_Circle *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Circle *arg1 = (Handle_Geom_Circle *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Circle_Radius(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Circle_Radius\n  * wrapname: _wrap_Geom_Circle_Radius\n  * fulldecl: Standard_Real Handle_Geom_Circle::Radius()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Handle_Geom_Ellipse *new_Handle_Geom_Ellipse(gp_Ax2 const &A2,Standard_Real const majorRadius,Standard_Real const minorRadius){
    return new Handle_Geom_Ellipse(new Geom_Ellipse(A2, majorRadius, minorRadius));
  }
EXPORT Handle_Geom_Ellipse *_wrap_new_Geom_Ellipse (gp_Ax2 *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom_Ellipse * lresult = (Handle_Geom_Ellipse *)0 ;
  gp_Ax2 *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Handle_Geom_Ellipse *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_Ellipse *)new_Handle_Geom_Ellipse((gp_Ax2 const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_Ellipse\n  * wrapname: _wrap_new_Geom_Ellipse\n  * fulldecl: Handle_Geom_Ellipse::Handle_Geom_Ellipse(gp_Ax2 const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_Ellipse *)0;
  }
}


SWIGINTERN void Handle_Geom_Ellipse_Delete(Handle_Geom_Ellipse *self){
    self->~Handle_Geom_Ellipse();
  }
EXPORT void _wrap_Geom_Ellipse_Delete (Handle_Geom_Ellipse *larg1) {
  Handle_Geom_Ellipse *arg1 = (Handle_Geom_Ellipse *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Ellipse_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Ellipse_Delete\n  * wrapname: _wrap_Geom_Ellipse_Delete\n  * fulldecl: void Handle_Geom_Ellipse::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Ax1 Handle_Geom_Ellipse_Directrix1(Handle_Geom_Ellipse *self){
		return (*self)->Directrix1();
	}
EXPORT gp_Ax1 *_wrap_Geom_Ellipse_Directrix1 (Handle_Geom_Ellipse *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  Handle_Geom_Ellipse *arg1 = (Handle_Geom_Ellipse *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Ellipse_Directrix1(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Ellipse_Directrix1\n  * wrapname: _wrap_Geom_Ellipse_Directrix1\n  * fulldecl: gp_Ax1 Handle_Geom_Ellipse::Directrix1()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


SWIGINTERN gp_Ax1 Handle_Geom_Ellipse_Directrix2(Handle_Geom_Ellipse *self){
		return (*self)->Directrix2();
	}
EXPORT gp_Ax1 *_wrap_Geom_Ellipse_Directrix2 (Handle_Geom_Ellipse *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  Handle_Geom_Ellipse *arg1 = (Handle_Geom_Ellipse *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Ellipse_Directrix2(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Ellipse_Directrix2\n  * wrapname: _wrap_Geom_Ellipse_Directrix2\n  * fulldecl: gp_Ax1 Handle_Geom_Ellipse::Directrix2()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Ellipse_FocalDistance(Handle_Geom_Ellipse *self){
		return (*self)->Focal();
	}
EXPORT Standard_Real _wrap_Geom_Ellipse_FocalDistance (Handle_Geom_Ellipse *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Ellipse *arg1 = (Handle_Geom_Ellipse *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Ellipse_FocalDistance(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Ellipse_FocalDistance\n  * wrapname: _wrap_Geom_Ellipse_FocalDistance\n  * fulldecl: Standard_Real Handle_Geom_Ellipse::FocalDistance()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_Ellipse_Focus1(Handle_Geom_Ellipse *self){
		return (*self)->Focus1();
	}
EXPORT gp_Pnt *_wrap_Geom_Ellipse_Focus1 (Handle_Geom_Ellipse *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_Ellipse *arg1 = (Handle_Geom_Ellipse *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Ellipse_Focus1(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Ellipse_Focus1\n  * wrapname: _wrap_Geom_Ellipse_Focus1\n  * fulldecl: gp_Pnt Handle_Geom_Ellipse::Focus1()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_Ellipse_Focus2(Handle_Geom_Ellipse *self){
    	return (*self)->Focus2();
	}
EXPORT gp_Pnt *_wrap_Geom_Ellipse_Focus2 (Handle_Geom_Ellipse *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_Ellipse *arg1 = (Handle_Geom_Ellipse *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Ellipse_Focus2(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Ellipse_Focus2\n  * wrapname: _wrap_Geom_Ellipse_Focus2\n  * fulldecl: gp_Pnt Handle_Geom_Ellipse::Focus2()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Ellipse_MajorRadius(Handle_Geom_Ellipse *self){
		return (*self)->MajorRadius();
	}
EXPORT Standard_Real _wrap_Geom_Ellipse_MajorRadius (Handle_Geom_Ellipse *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Ellipse *arg1 = (Handle_Geom_Ellipse *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Ellipse_MajorRadius(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Ellipse_MajorRadius\n  * wrapname: _wrap_Geom_Ellipse_MajorRadius\n  * fulldecl: Standard_Real Handle_Geom_Ellipse::MajorRadius()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Ellipse_MinorRadius(Handle_Geom_Ellipse *self){
		return (*self)->MinorRadius();
	}
EXPORT Standard_Real _wrap_Geom_Ellipse_MinorRadius (Handle_Geom_Ellipse *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Ellipse *arg1 = (Handle_Geom_Ellipse *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Ellipse_MinorRadius(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Ellipse_MinorRadius\n  * wrapname: _wrap_Geom_Ellipse_MinorRadius\n  * fulldecl: Standard_Real Handle_Geom_Ellipse::MinorRadius()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Ellipse_Parameter(Handle_Geom_Ellipse *self){
		return (*self)->Parameter();
	}
EXPORT Standard_Real _wrap_Geom_Ellipse_Parameter (Handle_Geom_Ellipse *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Ellipse *arg1 = (Handle_Geom_Ellipse *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Ellipse_Parameter(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Ellipse_Parameter\n  * wrapname: _wrap_Geom_Ellipse_Parameter\n  * fulldecl: Standard_Real Handle_Geom_Ellipse::Parameter()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Handle_Geom_TrimmedCurve *new_Handle_Geom_TrimmedCurve__SWIG_0(Handle_Geom_Curve const &C,Standard_Real const U1,Standard_Real const U2,Standard_Boolean const Sense=Standard_True){
          return new Handle_Geom_TrimmedCurve(new Geom_TrimmedCurve(C, U1, U2, Sense));
    }
EXPORT Handle_Geom_TrimmedCurve *_wrap_new_Geom_TrimmedCurve__SWIG_0 (Handle_Geom_Curve *larg1, Standard_Real larg2, Standard_Real larg3, bool larg4) {
  Handle_Geom_TrimmedCurve * lresult = (Handle_Geom_TrimmedCurve *)0 ;
  Handle_Geom_Curve *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Boolean arg4 ;
  Handle_Geom_TrimmedCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_TrimmedCurve *)new_Handle_Geom_TrimmedCurve__SWIG_0((Handle_Geom_Curve const &)*arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_TrimmedCurve\n  * wrapname: _wrap_new_Geom_TrimmedCurve__SWIG_0\n  * fulldecl: Handle_Geom_TrimmedCurve::Handle_Geom_TrimmedCurve(Handle_Geom_Curve const &,Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_TrimmedCurve *)0;
  }
}


EXPORT Handle_Geom_TrimmedCurve *_wrap_new_Geom_TrimmedCurve__SWIG_1 (Handle_Geom_Curve *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom_TrimmedCurve * lresult = (Handle_Geom_TrimmedCurve *)0 ;
  Handle_Geom_Curve *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Handle_Geom_TrimmedCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_TrimmedCurve *)new_Handle_Geom_TrimmedCurve__SWIG_0((Handle_Geom_Curve const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_TrimmedCurve\n  * wrapname: _wrap_new_Geom_TrimmedCurve__SWIG_1\n  * fulldecl: Handle_Geom_TrimmedCurve::Handle_Geom_TrimmedCurve(Handle_Geom_Curve const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_TrimmedCurve *)0;
  }
}


SWIGINTERN void Handle_Geom_TrimmedCurve_Delete(Handle_Geom_TrimmedCurve *self){
    self->~Handle_Geom_TrimmedCurve();
  }
EXPORT void _wrap_Geom_TrimmedCurve_Delete (Handle_Geom_TrimmedCurve *larg1) {
  Handle_Geom_TrimmedCurve *arg1 = (Handle_Geom_TrimmedCurve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_TrimmedCurve_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_TrimmedCurve_Delete\n  * wrapname: _wrap_Geom_TrimmedCurve_Delete\n  * fulldecl: void Handle_Geom_TrimmedCurve::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom_Curve Handle_Geom_TrimmedCurve_BasisCurve(Handle_Geom_TrimmedCurve *self){
		return (*self)->BasisCurve();
	}
EXPORT Handle_Geom_Curve *_wrap_Geom_TrimmedCurve_BasisCurve (Handle_Geom_TrimmedCurve *larg1) {
  Handle_Geom_Curve * lresult = (Handle_Geom_Curve *)0 ;
  Handle_Geom_TrimmedCurve *arg1 = (Handle_Geom_TrimmedCurve *) 0 ;
  SwigValueWrapper< Handle_Geom_Curve > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_TrimmedCurve_BasisCurve(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_TrimmedCurve_BasisCurve\n  * wrapname: _wrap_Geom_TrimmedCurve_BasisCurve\n  * fulldecl: Handle_Geom_Curve Handle_Geom_TrimmedCurve::BasisCurve()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Curve(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Curve *)0;
  }
}


SWIGINTERN Handle_Geom_OffsetCurve *new_Handle_Geom_OffsetCurve(Handle_Geom_Curve const &C,Standard_Real const Offset,gp_Dir const &V){
          return new Handle_Geom_OffsetCurve(new Geom_OffsetCurve(C, Offset, V));
    }
EXPORT Handle_Geom_OffsetCurve *_wrap_new_Geom_OffsetCurve (Handle_Geom_Curve *larg1, Standard_Real larg2, gp_Dir *larg3) {
  Handle_Geom_OffsetCurve * lresult = (Handle_Geom_OffsetCurve *)0 ;
  Handle_Geom_Curve *arg1 = 0 ;
  Standard_Real arg2 ;
  gp_Dir *arg3 = 0 ;
  Handle_Geom_OffsetCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_OffsetCurve *)new_Handle_Geom_OffsetCurve((Handle_Geom_Curve const &)*arg1,arg2,(gp_Dir const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_OffsetCurve\n  * wrapname: _wrap_new_Geom_OffsetCurve\n  * fulldecl: Handle_Geom_OffsetCurve::Handle_Geom_OffsetCurve(Handle_Geom_Curve const &,Standard_Real const,gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_OffsetCurve *)0;
  }
}


SWIGINTERN void Handle_Geom_OffsetCurve_Delete(Handle_Geom_OffsetCurve *self){
      self->~Handle_Geom_OffsetCurve();
    }
EXPORT void _wrap_Geom_OffsetCurve_Delete (Handle_Geom_OffsetCurve *larg1) {
  Handle_Geom_OffsetCurve *arg1 = (Handle_Geom_OffsetCurve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_OffsetCurve_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_OffsetCurve_Delete\n  * wrapname: _wrap_Geom_OffsetCurve_Delete\n  * fulldecl: void Handle_Geom_OffsetCurve::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Dir Handle_Geom_OffsetCurve_Direction(Handle_Geom_OffsetCurve *self){
    	return (*self)->Direction();
    }
EXPORT gp_Dir *_wrap_Geom_OffsetCurve_Direction (Handle_Geom_OffsetCurve *larg1) {
  gp_Dir * lresult = (gp_Dir *)0 ;
  Handle_Geom_OffsetCurve *arg1 = (Handle_Geom_OffsetCurve *) 0 ;
  gp_Dir result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_OffsetCurve_Direction(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_OffsetCurve_Direction\n  * wrapname: _wrap_Geom_OffsetCurve_Direction\n  * fulldecl: gp_Dir Handle_Geom_OffsetCurve::Direction()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Dir(result);
    return lresult;
  } catch (...) {
    return (gp_Dir *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_OffsetCurve_Offset(Handle_Geom_OffsetCurve *self){
    	return (*self)->Offset();
    }
EXPORT Standard_Real _wrap_Geom_OffsetCurve_Offset (Handle_Geom_OffsetCurve *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_OffsetCurve *arg1 = (Handle_Geom_OffsetCurve *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_OffsetCurve_Offset(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_OffsetCurve_Offset\n  * wrapname: _wrap_Geom_OffsetCurve_Offset\n  * fulldecl: Standard_Real Handle_Geom_OffsetCurve::Offset()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Handle_Geom_Curve Handle_Geom_OffsetCurve_BasisCurve(Handle_Geom_OffsetCurve *self){
    	return (*self)->BasisCurve();
    }
EXPORT Handle_Geom_Curve *_wrap_Geom_OffsetCurve_BasisCurve (Handle_Geom_OffsetCurve *larg1) {
  Handle_Geom_Curve * lresult = (Handle_Geom_Curve *)0 ;
  Handle_Geom_OffsetCurve *arg1 = (Handle_Geom_OffsetCurve *) 0 ;
  SwigValueWrapper< Handle_Geom_Curve > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_OffsetCurve_BasisCurve(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_OffsetCurve_BasisCurve\n  * wrapname: _wrap_Geom_OffsetCurve_BasisCurve\n  * fulldecl: Handle_Geom_Curve Handle_Geom_OffsetCurve::BasisCurve()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Curve(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Curve *)0;
  }
}


SWIGINTERN Handle_Geom_Hyperbola *new_Handle_Geom_Hyperbola(gp_Ax2 const &A2,Standard_Real const majorRadius,Standard_Real const minorRadius){
		return new Handle_Geom_Hyperbola(new Geom_Hyperbola(A2, majorRadius, minorRadius));
	}
EXPORT Handle_Geom_Hyperbola *_wrap_new_Geom_Hyperbola (gp_Ax2 *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom_Hyperbola * lresult = (Handle_Geom_Hyperbola *)0 ;
  gp_Ax2 *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Handle_Geom_Hyperbola *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_Hyperbola *)new_Handle_Geom_Hyperbola((gp_Ax2 const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_Hyperbola\n  * wrapname: _wrap_new_Geom_Hyperbola\n  * fulldecl: Handle_Geom_Hyperbola::Handle_Geom_Hyperbola(gp_Ax2 const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_Hyperbola *)0;
  }
}


SWIGINTERN void Handle_Geom_Hyperbola_Delete(Handle_Geom_Hyperbola *self){
	  self->~Handle_Geom_Hyperbola();
	}
EXPORT void _wrap_Geom_Hyperbola_Delete (Handle_Geom_Hyperbola *larg1) {
  Handle_Geom_Hyperbola *arg1 = (Handle_Geom_Hyperbola *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Hyperbola_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Hyperbola_Delete\n  * wrapname: _wrap_Geom_Hyperbola_Delete\n  * fulldecl: void Handle_Geom_Hyperbola::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Ax1 Handle_Geom_Hyperbola_Asymptote1(Handle_Geom_Hyperbola *self){
		return (*self)->Asymptote1();
	}
EXPORT gp_Ax1 *_wrap_Geom_Hyperbola_Asymptote1 (Handle_Geom_Hyperbola *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  Handle_Geom_Hyperbola *arg1 = (Handle_Geom_Hyperbola *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Hyperbola_Asymptote1(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Hyperbola_Asymptote1\n  * wrapname: _wrap_Geom_Hyperbola_Asymptote1\n  * fulldecl: gp_Ax1 Handle_Geom_Hyperbola::Asymptote1()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


SWIGINTERN gp_Ax1 Handle_Geom_Hyperbola_Asymptote2(Handle_Geom_Hyperbola *self){
		return (*self)->Asymptote2();
	}
EXPORT gp_Ax1 *_wrap_Geom_Hyperbola_Asymptote2 (Handle_Geom_Hyperbola *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  Handle_Geom_Hyperbola *arg1 = (Handle_Geom_Hyperbola *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Hyperbola_Asymptote2(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Hyperbola_Asymptote2\n  * wrapname: _wrap_Geom_Hyperbola_Asymptote2\n  * fulldecl: gp_Ax1 Handle_Geom_Hyperbola::Asymptote2()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


SWIGINTERN gp_Hypr Handle_Geom_Hyperbola_ConjugateBranch1(Handle_Geom_Hyperbola *self){
		return (*self)->ConjugateBranch1();
	}
EXPORT gp_Hypr *_wrap_Geom_Hyperbola_ConjugateBranch1 (Handle_Geom_Hyperbola *larg1) {
  gp_Hypr * lresult = (gp_Hypr *)0 ;
  Handle_Geom_Hyperbola *arg1 = (Handle_Geom_Hyperbola *) 0 ;
  gp_Hypr result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Hyperbola_ConjugateBranch1(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Hyperbola_ConjugateBranch1\n  * wrapname: _wrap_Geom_Hyperbola_ConjugateBranch1\n  * fulldecl: gp_Hypr Handle_Geom_Hyperbola::ConjugateBranch1()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr *)0;
  }
}


SWIGINTERN gp_Hypr Handle_Geom_Hyperbola_ConjugateBranch2(Handle_Geom_Hyperbola *self){
		return (*self)->ConjugateBranch2();
	}
EXPORT gp_Hypr *_wrap_Geom_Hyperbola_ConjugateBranch2 (Handle_Geom_Hyperbola *larg1) {
  gp_Hypr * lresult = (gp_Hypr *)0 ;
  Handle_Geom_Hyperbola *arg1 = (Handle_Geom_Hyperbola *) 0 ;
  gp_Hypr result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Hyperbola_ConjugateBranch2(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Hyperbola_ConjugateBranch2\n  * wrapname: _wrap_Geom_Hyperbola_ConjugateBranch2\n  * fulldecl: gp_Hypr Handle_Geom_Hyperbola::ConjugateBranch2()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr *)0;
  }
}


SWIGINTERN gp_Hypr Handle_Geom_Hyperbola_OtherBranch(Handle_Geom_Hyperbola *self){
		return (*self)->OtherBranch();
	}
EXPORT gp_Hypr *_wrap_Geom_Hyperbola_OtherBranch (Handle_Geom_Hyperbola *larg1) {
  gp_Hypr * lresult = (gp_Hypr *)0 ;
  Handle_Geom_Hyperbola *arg1 = (Handle_Geom_Hyperbola *) 0 ;
  gp_Hypr result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Hyperbola_OtherBranch(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Hyperbola_OtherBranch\n  * wrapname: _wrap_Geom_Hyperbola_OtherBranch\n  * fulldecl: gp_Hypr Handle_Geom_Hyperbola::OtherBranch()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr *)0;
  }
}


SWIGINTERN gp_Ax1 Handle_Geom_Hyperbola_Directrix1(Handle_Geom_Hyperbola *self){
		return (*self)->Directrix1();
	}
EXPORT gp_Ax1 *_wrap_Geom_Hyperbola_Directrix1 (Handle_Geom_Hyperbola *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  Handle_Geom_Hyperbola *arg1 = (Handle_Geom_Hyperbola *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Hyperbola_Directrix1(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Hyperbola_Directrix1\n  * wrapname: _wrap_Geom_Hyperbola_Directrix1\n  * fulldecl: gp_Ax1 Handle_Geom_Hyperbola::Directrix1()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


SWIGINTERN gp_Ax1 Handle_Geom_Hyperbola_Directrix2(Handle_Geom_Hyperbola *self){
		return (*self)->Directrix2();
	}
EXPORT gp_Ax1 *_wrap_Geom_Hyperbola_Directrix2 (Handle_Geom_Hyperbola *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  Handle_Geom_Hyperbola *arg1 = (Handle_Geom_Hyperbola *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Hyperbola_Directrix2(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Hyperbola_Directrix2\n  * wrapname: _wrap_Geom_Hyperbola_Directrix2\n  * fulldecl: gp_Ax1 Handle_Geom_Hyperbola::Directrix2()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Hyperbola_FocalDistance(Handle_Geom_Hyperbola *self){
		return (*self)->Focal();
	}
EXPORT Standard_Real _wrap_Geom_Hyperbola_FocalDistance (Handle_Geom_Hyperbola *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Hyperbola *arg1 = (Handle_Geom_Hyperbola *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Hyperbola_FocalDistance(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Hyperbola_FocalDistance\n  * wrapname: _wrap_Geom_Hyperbola_FocalDistance\n  * fulldecl: Standard_Real Handle_Geom_Hyperbola::FocalDistance()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_Hyperbola_Focus1(Handle_Geom_Hyperbola *self){
		return (*self)->Focus1();
	}
EXPORT gp_Pnt *_wrap_Geom_Hyperbola_Focus1 (Handle_Geom_Hyperbola *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_Hyperbola *arg1 = (Handle_Geom_Hyperbola *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Hyperbola_Focus1(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Hyperbola_Focus1\n  * wrapname: _wrap_Geom_Hyperbola_Focus1\n  * fulldecl: gp_Pnt Handle_Geom_Hyperbola::Focus1()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_Hyperbola_Focus2(Handle_Geom_Hyperbola *self){
		return (*self)->Focus2();
	}
EXPORT gp_Pnt *_wrap_Geom_Hyperbola_Focus2 (Handle_Geom_Hyperbola *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_Hyperbola *arg1 = (Handle_Geom_Hyperbola *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Hyperbola_Focus2(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Hyperbola_Focus2\n  * wrapname: _wrap_Geom_Hyperbola_Focus2\n  * fulldecl: gp_Pnt Handle_Geom_Hyperbola::Focus2()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Hyperbola_MajorRadius(Handle_Geom_Hyperbola *self){
		return (*self)->MajorRadius();
	}
EXPORT Standard_Real _wrap_Geom_Hyperbola_MajorRadius (Handle_Geom_Hyperbola *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Hyperbola *arg1 = (Handle_Geom_Hyperbola *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Hyperbola_MajorRadius(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Hyperbola_MajorRadius\n  * wrapname: _wrap_Geom_Hyperbola_MajorRadius\n  * fulldecl: Standard_Real Handle_Geom_Hyperbola::MajorRadius()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Hyperbola_MinorRadius(Handle_Geom_Hyperbola *self){
		return (*self)->MinorRadius();
	}
EXPORT Standard_Real _wrap_Geom_Hyperbola_MinorRadius (Handle_Geom_Hyperbola *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Hyperbola *arg1 = (Handle_Geom_Hyperbola *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Hyperbola_MinorRadius(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Hyperbola_MinorRadius\n  * wrapname: _wrap_Geom_Hyperbola_MinorRadius\n  * fulldecl: Standard_Real Handle_Geom_Hyperbola::MinorRadius()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Hyperbola_Parameter(Handle_Geom_Hyperbola *self){
		return (*self)->Parameter();
	}
EXPORT Standard_Real _wrap_Geom_Hyperbola_Parameter (Handle_Geom_Hyperbola *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Hyperbola *arg1 = (Handle_Geom_Hyperbola *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Hyperbola_Parameter(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Hyperbola_Parameter\n  * wrapname: _wrap_Geom_Hyperbola_Parameter\n  * fulldecl: Standard_Real Handle_Geom_Hyperbola::Parameter()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Handle_Geom_Line *new_Handle_Geom_Line__SWIG_0(gp_Ax1 const &A1){
		return new Handle_Geom_Line(new Geom_Line(A1));
	}
EXPORT Handle_Geom_Line *_wrap_new_Geom_Line__SWIG_0 (gp_Ax1 *larg1) {
  Handle_Geom_Line * lresult = (Handle_Geom_Line *)0 ;
  gp_Ax1 *arg1 = 0 ;
  Handle_Geom_Line *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_Line *)new_Handle_Geom_Line__SWIG_0((gp_Ax1 const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_Line\n  * wrapname: _wrap_new_Geom_Line__SWIG_0\n  * fulldecl: Handle_Geom_Line::Handle_Geom_Line(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_Line *)0;
  }
}


SWIGINTERN Handle_Geom_Line *new_Handle_Geom_Line__SWIG_1(gp_Pnt const &P,gp_Dir const &V){
		return new Handle_Geom_Line(new Geom_Line(P, V));
	}
EXPORT Handle_Geom_Line *_wrap_new_Geom_Line__SWIG_1 (gp_Pnt *larg1, gp_Dir *larg2) {
  Handle_Geom_Line * lresult = (Handle_Geom_Line *)0 ;
  gp_Pnt *arg1 = 0 ;
  gp_Dir *arg2 = 0 ;
  Handle_Geom_Line *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_Line *)new_Handle_Geom_Line__SWIG_1((gp_Pnt const &)*arg1,(gp_Dir const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_Line\n  * wrapname: _wrap_new_Geom_Line__SWIG_1\n  * fulldecl: Handle_Geom_Line::Handle_Geom_Line(gp_Pnt const &,gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_Line *)0;
  }
}


SWIGINTERN void Handle_Geom_Line_Delete(Handle_Geom_Line *self){
	  self->~Handle_Geom_Line();
	}
EXPORT void _wrap_Geom_Line_Delete (Handle_Geom_Line *larg1) {
  Handle_Geom_Line *arg1 = (Handle_Geom_Line *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Line_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Line_Delete\n  * wrapname: _wrap_Geom_Line_Delete\n  * fulldecl: void Handle_Geom_Line::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Ax1 Handle_Geom_Line_Position(Handle_Geom_Line *self){
		return (*self)->Position();
	}
EXPORT gp_Ax1 *_wrap_Geom_Line_Position (Handle_Geom_Line *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  Handle_Geom_Line *arg1 = (Handle_Geom_Line *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Line_Position(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Line_Position\n  * wrapname: _wrap_Geom_Line_Position\n  * fulldecl: gp_Ax1 Handle_Geom_Line::Position()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


SWIGINTERN gp_Lin Handle_Geom_Line_Lin(Handle_Geom_Line *self){
		return (*self)->Lin();
	}
EXPORT gp_Lin *_wrap_Geom_Line_Lin (Handle_Geom_Line *larg1) {
  gp_Lin * lresult = (gp_Lin *)0 ;
  Handle_Geom_Line *arg1 = (Handle_Geom_Line *) 0 ;
  gp_Lin result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Line_Lin(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Line_Lin\n  * wrapname: _wrap_Geom_Line_Lin\n  * fulldecl: gp_Lin Handle_Geom_Line::Lin()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Lin(result);
    return lresult;
  } catch (...) {
    return (gp_Lin *)0;
  }
}


SWIGINTERN Handle_Geom_Parabola *new_Handle_Geom_Parabola(gp_Ax2 const &A2,Standard_Real const Focal){
		return new Handle_Geom_Parabola(new Geom_Parabola(A2, Focal));
	}
EXPORT Handle_Geom_Parabola *_wrap_new_Geom_Parabola (gp_Ax2 *larg1, Standard_Real larg2) {
  Handle_Geom_Parabola * lresult = (Handle_Geom_Parabola *)0 ;
  gp_Ax2 *arg1 = 0 ;
  Standard_Real arg2 ;
  Handle_Geom_Parabola *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_Parabola *)new_Handle_Geom_Parabola((gp_Ax2 const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_Parabola\n  * wrapname: _wrap_new_Geom_Parabola\n  * fulldecl: Handle_Geom_Parabola::Handle_Geom_Parabola(gp_Ax2 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_Parabola *)0;
  }
}


SWIGINTERN void Handle_Geom_Parabola_Delete(Handle_Geom_Parabola *self){
	  self->~Handle_Geom_Parabola();
	}
EXPORT void _wrap_Geom_Parabola_Delete (Handle_Geom_Parabola *larg1) {
  Handle_Geom_Parabola *arg1 = (Handle_Geom_Parabola *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Parabola_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Parabola_Delete\n  * wrapname: _wrap_Geom_Parabola_Delete\n  * fulldecl: void Handle_Geom_Parabola::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Ax1 Handle_Geom_Parabola_Directrix(Handle_Geom_Parabola *self){
		return (*self)->Directrix();
	}
EXPORT gp_Ax1 *_wrap_Geom_Parabola_Directrix (Handle_Geom_Parabola *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  Handle_Geom_Parabola *arg1 = (Handle_Geom_Parabola *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Parabola_Directrix(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Parabola_Directrix\n  * wrapname: _wrap_Geom_Parabola_Directrix\n  * fulldecl: gp_Ax1 Handle_Geom_Parabola::Directrix()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Parabola_FocalDistance(Handle_Geom_Parabola *self){
		return (*self)->Focal();
	}
EXPORT Standard_Real _wrap_Geom_Parabola_FocalDistance (Handle_Geom_Parabola *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Parabola *arg1 = (Handle_Geom_Parabola *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Parabola_FocalDistance(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Parabola_FocalDistance\n  * wrapname: _wrap_Geom_Parabola_FocalDistance\n  * fulldecl: Standard_Real Handle_Geom_Parabola::FocalDistance()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_Parabola_Focus(Handle_Geom_Parabola *self){
		return (*self)->Focus();
	}
EXPORT gp_Pnt *_wrap_Geom_Parabola_Focus (Handle_Geom_Parabola *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_Parabola *arg1 = (Handle_Geom_Parabola *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Parabola_Focus(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Parabola_Focus\n  * wrapname: _wrap_Geom_Parabola_Focus\n  * fulldecl: gp_Pnt Handle_Geom_Parabola::Focus()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Parabola_Parameter(Handle_Geom_Parabola *self){
		return (*self)->Parameter();
	}
EXPORT Standard_Real _wrap_Geom_Parabola_Parameter (Handle_Geom_Parabola *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Parabola *arg1 = (Handle_Geom_Parabola *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Parabola_Parameter(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Parabola_Parameter\n  * wrapname: _wrap_Geom_Parabola_Parameter\n  * fulldecl: Standard_Real Handle_Geom_Parabola::Parameter()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Handle_Geom_BezierSurface *new_Handle_Geom_BezierSurface(TColgp_Array2OfPnt const &SurfacePoles,TColStd_Array2OfReal const &PoleWeights){
		return new Handle_Geom_BezierSurface(new Geom_BezierSurface(SurfacePoles, PoleWeights));
	}
EXPORT Handle_Geom_BezierSurface *_wrap_new_Geom_BezierSurface (TColgp_Array2OfPnt *larg1, TColStd_Array2OfReal *larg2) {
  Handle_Geom_BezierSurface * lresult = (Handle_Geom_BezierSurface *)0 ;
  TColgp_Array2OfPnt *arg1 = 0 ;
  TColStd_Array2OfReal *arg2 = 0 ;
  Handle_Geom_BezierSurface *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_BezierSurface *)new_Handle_Geom_BezierSurface((TColgp_Array2OfPnt const &)*arg1,(TColStd_Array2OfReal const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_BezierSurface\n  * wrapname: _wrap_new_Geom_BezierSurface\n  * fulldecl: Handle_Geom_BezierSurface::Handle_Geom_BezierSurface(TColgp_Array2OfPnt const &,TColStd_Array2OfReal const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_BezierSurface *)0;
  }
}


SWIGINTERN void Handle_Geom_BezierSurface_Delete(Handle_Geom_BezierSurface *self){
	  self->~Handle_Geom_BezierSurface();
	}
EXPORT void _wrap_Geom_BezierSurface_Delete (Handle_Geom_BezierSurface *larg1) {
  Handle_Geom_BezierSurface *arg1 = (Handle_Geom_BezierSurface *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BezierSurface_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierSurface_Delete\n  * wrapname: _wrap_Geom_BezierSurface_Delete\n  * fulldecl: void Handle_Geom_BezierSurface::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BezierSurface_NbUPoles(Handle_Geom_BezierSurface *self){
        return (*self)->NbUPoles();
    }
EXPORT Standard_Integer _wrap_Geom_BezierSurface_NbUPoles (Handle_Geom_BezierSurface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BezierSurface *arg1 = (Handle_Geom_BezierSurface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BezierSurface_NbUPoles(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierSurface_NbUPoles\n  * wrapname: _wrap_Geom_BezierSurface_NbUPoles\n  * fulldecl: Standard_Integer Handle_Geom_BezierSurface::NbUPoles()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BezierSurface_NbVPoles(Handle_Geom_BezierSurface *self){
        return (*self)->NbVPoles();
    }
EXPORT Standard_Integer _wrap_Geom_BezierSurface_NbVPoles (Handle_Geom_BezierSurface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BezierSurface *arg1 = (Handle_Geom_BezierSurface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BezierSurface_NbVPoles(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierSurface_NbVPoles\n  * wrapname: _wrap_Geom_BezierSurface_NbVPoles\n  * fulldecl: Standard_Integer Handle_Geom_BezierSurface::NbVPoles()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BezierSurface_UDegree(Handle_Geom_BezierSurface *self){
        return (*self)->UDegree();
    }
EXPORT Standard_Integer _wrap_Geom_BezierSurface_UDegree (Handle_Geom_BezierSurface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BezierSurface *arg1 = (Handle_Geom_BezierSurface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BezierSurface_UDegree(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierSurface_UDegree\n  * wrapname: _wrap_Geom_BezierSurface_UDegree\n  * fulldecl: Standard_Integer Handle_Geom_BezierSurface::UDegree()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BezierSurface_VDegree(Handle_Geom_BezierSurface *self){
        return (*self)->VDegree();
    }
EXPORT Standard_Integer _wrap_Geom_BezierSurface_VDegree (Handle_Geom_BezierSurface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BezierSurface *arg1 = (Handle_Geom_BezierSurface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BezierSurface_VDegree(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierSurface_VDegree\n  * wrapname: _wrap_Geom_BezierSurface_VDegree\n  * fulldecl: Standard_Integer Handle_Geom_BezierSurface::VDegree()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_BezierSurface_Pole(Handle_Geom_BezierSurface *self,Standard_Integer const indexU,Standard_Integer const indexV){
        return (*self)->Pole(indexU, indexV);
    }
EXPORT gp_Pnt *_wrap_Geom_BezierSurface_Pole (Handle_Geom_BezierSurface *larg1, Standard_Integer larg2, Standard_Integer larg3) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_BezierSurface *arg1 = (Handle_Geom_BezierSurface *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  gp_Pnt result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_BezierSurface_Pole(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierSurface_Pole\n  * wrapname: _wrap_Geom_BezierSurface_Pole\n  * fulldecl: gp_Pnt Handle_Geom_BezierSurface::Pole(Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_BezierSurface_Weight(Handle_Geom_BezierSurface *self,Standard_Integer const indexU,Standard_Integer const indexV){
        return (*self)->Weight(indexU, indexV);
    }
EXPORT Standard_Real _wrap_Geom_BezierSurface_Weight (Handle_Geom_BezierSurface *larg1, Standard_Integer larg2, Standard_Integer larg3) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_BezierSurface *arg1 = (Handle_Geom_BezierSurface *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_BezierSurface_Weight(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierSurface_Weight\n  * wrapname: _wrap_Geom_BezierSurface_Weight\n  * fulldecl: Standard_Real Handle_Geom_BezierSurface::Weight(Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom_BezierSurface_IsURational(Handle_Geom_BezierSurface *self){
        return (*self)->IsURational();
    }
EXPORT bool _wrap_Geom_BezierSurface_IsURational (Handle_Geom_BezierSurface *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom_BezierSurface *arg1 = (Handle_Geom_BezierSurface *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom_BezierSurface_IsURational(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierSurface_IsURational\n  * wrapname: _wrap_Geom_BezierSurface_IsURational\n  * fulldecl: Standard_Boolean Handle_Geom_BezierSurface::IsURational()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom_BezierSurface_IsVRational(Handle_Geom_BezierSurface *self){
        return (*self)->IsVRational();
    }
EXPORT bool _wrap_Geom_BezierSurface_IsVRational (Handle_Geom_BezierSurface *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom_BezierSurface *arg1 = (Handle_Geom_BezierSurface *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom_BezierSurface_IsVRational(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierSurface_IsVRational\n  * wrapname: _wrap_Geom_BezierSurface_IsVRational\n  * fulldecl: Standard_Boolean Handle_Geom_BezierSurface::IsVRational()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BezierSurface_MaxDegree(){
      return Geom_BezierSurface::MaxDegree();
    }
EXPORT Standard_Integer _wrap_Geom_BezierSurface_MaxDegree () {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Standard_Integer result;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BezierSurface_MaxDegree();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierSurface_MaxDegree\n  * wrapname: _wrap_Geom_BezierSurface_MaxDegree\n  * fulldecl: Standard_Integer Handle_Geom_BezierSurface::Handle_Geom_BezierSurface_MaxDegree()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN void Handle_Geom_BezierSurface_Resolution(Handle_Geom_BezierSurface *self,Standard_Real tolerance3d,Standard_Real &toleranceU,Standard_Real &toleranceV){
        return (*self)->Resolution(tolerance3d, toleranceU, toleranceV);
    }
EXPORT void _wrap_Geom_BezierSurface_Resolution (Handle_Geom_BezierSurface *larg1, Standard_Real larg2, Standard_Real *larg3, Standard_Real *larg4) {
  Handle_Geom_BezierSurface *arg1 = (Handle_Geom_BezierSurface *) 0 ;
  Standard_Real arg2 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BezierSurface_Resolution(arg1,arg2,*arg3,*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierSurface_Resolution\n  * wrapname: _wrap_Geom_BezierSurface_Resolution\n  * fulldecl: void Handle_Geom_BezierSurface::Resolution(Standard_Real,Standard_Real &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom_BSplineSurface *new_Handle_Geom_BSplineSurface__SWIG_0(TColgp_Array2OfPnt const &Poles,TColStd_Array2OfReal const &Weights,TColStd_Array1OfReal const &UKnots,TColStd_Array1OfReal const &VKnots,TColStd_Array1OfInteger const &UMults,TColStd_Array1OfInteger const &VMults,Standard_Integer const UDegree,Standard_Integer const VDegree,Standard_Boolean const UPeriodic=Standard_False,Standard_Boolean const VPeriodic=Standard_False){
        return new Handle_Geom_BSplineSurface(new Geom_BSplineSurface(Poles, Weights, UKnots, VKnots, UMults, VMults,
            UDegree, VDegree, UPeriodic, VPeriodic));
    }
EXPORT Handle_Geom_BSplineSurface *_wrap_new_Geom_BSplineSurface__SWIG_0 (TColgp_Array2OfPnt *larg1, TColStd_Array2OfReal *larg2, TColStd_Array1OfReal *larg3, TColStd_Array1OfReal *larg4, TColStd_Array1OfInteger *larg5, TColStd_Array1OfInteger *larg6, Standard_Integer larg7, Standard_Integer larg8, bool larg9, bool larg10) {
  Handle_Geom_BSplineSurface * lresult = (Handle_Geom_BSplineSurface *)0 ;
  TColgp_Array2OfPnt *arg1 = 0 ;
  TColStd_Array2OfReal *arg2 = 0 ;
  TColStd_Array1OfReal *arg3 = 0 ;
  TColStd_Array1OfReal *arg4 = 0 ;
  TColStd_Array1OfInteger *arg5 = 0 ;
  TColStd_Array1OfInteger *arg6 = 0 ;
  Standard_Integer arg7 ;
  Standard_Integer arg8 ;
  Standard_Boolean arg9 ;
  Standard_Boolean arg10 ;
  Handle_Geom_BSplineSurface *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = (bool)larg9;
  arg10 = (bool)larg10;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_BSplineSurface *)new_Handle_Geom_BSplineSurface__SWIG_0((TColgp_Array2OfPnt const &)*arg1,(TColStd_Array2OfReal const &)*arg2,(TColStd_Array1OfReal const &)*arg3,(TColStd_Array1OfReal const &)*arg4,(TColStd_Array1OfInteger const &)*arg5,(TColStd_Array1OfInteger const &)*arg6,arg7,arg8,arg9,arg10);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_BSplineSurface\n  * wrapname: _wrap_new_Geom_BSplineSurface__SWIG_0\n  * fulldecl: Handle_Geom_BSplineSurface::Handle_Geom_BSplineSurface(TColgp_Array2OfPnt const &,TColStd_Array2OfReal const &,TColStd_Array1OfReal const &,TColStd_Array1OfReal const &,TColStd_Array1OfInteger const &,TColStd_Array1OfInteger const &,Standard_Integer const,Standard_Integer const,Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_BSplineSurface *)0;
  }
}


EXPORT Handle_Geom_BSplineSurface *_wrap_new_Geom_BSplineSurface__SWIG_1 (TColgp_Array2OfPnt *larg1, TColStd_Array2OfReal *larg2, TColStd_Array1OfReal *larg3, TColStd_Array1OfReal *larg4, TColStd_Array1OfInteger *larg5, TColStd_Array1OfInteger *larg6, Standard_Integer larg7, Standard_Integer larg8, bool larg9) {
  Handle_Geom_BSplineSurface * lresult = (Handle_Geom_BSplineSurface *)0 ;
  TColgp_Array2OfPnt *arg1 = 0 ;
  TColStd_Array2OfReal *arg2 = 0 ;
  TColStd_Array1OfReal *arg3 = 0 ;
  TColStd_Array1OfReal *arg4 = 0 ;
  TColStd_Array1OfInteger *arg5 = 0 ;
  TColStd_Array1OfInteger *arg6 = 0 ;
  Standard_Integer arg7 ;
  Standard_Integer arg8 ;
  Standard_Boolean arg9 ;
  Handle_Geom_BSplineSurface *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = (bool)larg9;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_BSplineSurface *)new_Handle_Geom_BSplineSurface__SWIG_0((TColgp_Array2OfPnt const &)*arg1,(TColStd_Array2OfReal const &)*arg2,(TColStd_Array1OfReal const &)*arg3,(TColStd_Array1OfReal const &)*arg4,(TColStd_Array1OfInteger const &)*arg5,(TColStd_Array1OfInteger const &)*arg6,arg7,arg8,arg9);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_BSplineSurface\n  * wrapname: _wrap_new_Geom_BSplineSurface__SWIG_1\n  * fulldecl: Handle_Geom_BSplineSurface::Handle_Geom_BSplineSurface(TColgp_Array2OfPnt const &,TColStd_Array2OfReal const &,TColStd_Array1OfReal const &,TColStd_Array1OfReal const &,TColStd_Array1OfInteger const &,TColStd_Array1OfInteger const &,Standard_Integer const,Standard_Integer const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_BSplineSurface *)0;
  }
}


EXPORT Handle_Geom_BSplineSurface *_wrap_new_Geom_BSplineSurface__SWIG_2 (TColgp_Array2OfPnt *larg1, TColStd_Array2OfReal *larg2, TColStd_Array1OfReal *larg3, TColStd_Array1OfReal *larg4, TColStd_Array1OfInteger *larg5, TColStd_Array1OfInteger *larg6, Standard_Integer larg7, Standard_Integer larg8) {
  Handle_Geom_BSplineSurface * lresult = (Handle_Geom_BSplineSurface *)0 ;
  TColgp_Array2OfPnt *arg1 = 0 ;
  TColStd_Array2OfReal *arg2 = 0 ;
  TColStd_Array1OfReal *arg3 = 0 ;
  TColStd_Array1OfReal *arg4 = 0 ;
  TColStd_Array1OfInteger *arg5 = 0 ;
  TColStd_Array1OfInteger *arg6 = 0 ;
  Standard_Integer arg7 ;
  Standard_Integer arg8 ;
  Handle_Geom_BSplineSurface *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_BSplineSurface *)new_Handle_Geom_BSplineSurface__SWIG_0((TColgp_Array2OfPnt const &)*arg1,(TColStd_Array2OfReal const &)*arg2,(TColStd_Array1OfReal const &)*arg3,(TColStd_Array1OfReal const &)*arg4,(TColStd_Array1OfInteger const &)*arg5,(TColStd_Array1OfInteger const &)*arg6,arg7,arg8);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_BSplineSurface\n  * wrapname: _wrap_new_Geom_BSplineSurface__SWIG_2\n  * fulldecl: Handle_Geom_BSplineSurface::Handle_Geom_BSplineSurface(TColgp_Array2OfPnt const &,TColStd_Array2OfReal const &,TColStd_Array1OfReal const &,TColStd_Array1OfReal const &,TColStd_Array1OfInteger const &,TColStd_Array1OfInteger const &,Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_BSplineSurface *)0;
  }
}


SWIGINTERN void Handle_Geom_BSplineSurface_Delete(Handle_Geom_BSplineSurface *self){
	  self->~Handle_Geom_BSplineSurface();
	}
EXPORT void _wrap_Geom_BSplineSurface_Delete (Handle_Geom_BSplineSurface *larg1) {
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BSplineSurface_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_Delete\n  * wrapname: _wrap_Geom_BSplineSurface_Delete\n  * fulldecl: void Handle_Geom_BSplineSurface::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Boolean Handle_Geom_BSplineSurface_IsURational(Handle_Geom_BSplineSurface *self){
        return (*self)->IsURational();
    }
EXPORT bool _wrap_Geom_BSplineSurface_IsURational (Handle_Geom_BSplineSurface *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom_BSplineSurface_IsURational(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_IsURational\n  * wrapname: _wrap_Geom_BSplineSurface_IsURational\n  * fulldecl: Standard_Boolean Handle_Geom_BSplineSurface::IsURational()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom_BSplineSurface_IsVRational(Handle_Geom_BSplineSurface *self){
        return (*self)->IsVRational();
    }
EXPORT bool _wrap_Geom_BSplineSurface_IsVRational (Handle_Geom_BSplineSurface *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom_BSplineSurface_IsVRational(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_IsVRational\n  * wrapname: _wrap_Geom_BSplineSurface_IsVRational\n  * fulldecl: Standard_Boolean Handle_Geom_BSplineSurface::IsVRational()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineSurface_FirstUKnotIndex(Handle_Geom_BSplineSurface *self){
        return (*self)->FirstUKnotIndex();
    }
EXPORT Standard_Integer _wrap_Geom_BSplineSurface_FirstUKnotIndex (Handle_Geom_BSplineSurface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineSurface_FirstUKnotIndex(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_FirstUKnotIndex\n  * wrapname: _wrap_Geom_BSplineSurface_FirstUKnotIndex\n  * fulldecl: Standard_Integer Handle_Geom_BSplineSurface::FirstUKnotIndex()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineSurface_FirstVKnotIndex(Handle_Geom_BSplineSurface *self){
        return (*self)->FirstVKnotIndex();
    }
EXPORT Standard_Integer _wrap_Geom_BSplineSurface_FirstVKnotIndex (Handle_Geom_BSplineSurface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineSurface_FirstVKnotIndex(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_FirstVKnotIndex\n  * wrapname: _wrap_Geom_BSplineSurface_FirstVKnotIndex\n  * fulldecl: Standard_Integer Handle_Geom_BSplineSurface::FirstVKnotIndex()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineSurface_LastUKnotIndex(Handle_Geom_BSplineSurface *self){
        return (*self)->LastUKnotIndex();
    }
EXPORT Standard_Integer _wrap_Geom_BSplineSurface_LastUKnotIndex (Handle_Geom_BSplineSurface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineSurface_LastUKnotIndex(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_LastUKnotIndex\n  * wrapname: _wrap_Geom_BSplineSurface_LastUKnotIndex\n  * fulldecl: Standard_Integer Handle_Geom_BSplineSurface::LastUKnotIndex()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineSurface_LastVKnotIndex(Handle_Geom_BSplineSurface *self){
        return (*self)->LastVKnotIndex();
    }
EXPORT Standard_Integer _wrap_Geom_BSplineSurface_LastVKnotIndex (Handle_Geom_BSplineSurface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineSurface_LastVKnotIndex(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_LastVKnotIndex\n  * wrapname: _wrap_Geom_BSplineSurface_LastVKnotIndex\n  * fulldecl: Standard_Integer Handle_Geom_BSplineSurface::LastVKnotIndex()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineSurface_NbUPoles(Handle_Geom_BSplineSurface *self){
        return (*self)->NbUPoles();
    }
EXPORT Standard_Integer _wrap_Geom_BSplineSurface_NbUPoles (Handle_Geom_BSplineSurface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineSurface_NbUPoles(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_NbUPoles\n  * wrapname: _wrap_Geom_BSplineSurface_NbUPoles\n  * fulldecl: Standard_Integer Handle_Geom_BSplineSurface::NbUPoles()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineSurface_NbVPoles(Handle_Geom_BSplineSurface *self){
        return (*self)->NbVPoles();
    }
EXPORT Standard_Integer _wrap_Geom_BSplineSurface_NbVPoles (Handle_Geom_BSplineSurface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineSurface_NbVPoles(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_NbVPoles\n  * wrapname: _wrap_Geom_BSplineSurface_NbVPoles\n  * fulldecl: Standard_Integer Handle_Geom_BSplineSurface::NbVPoles()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineSurface_NbUKnots(Handle_Geom_BSplineSurface *self){
        return (*self)->NbUKnots();
    }
EXPORT Standard_Integer _wrap_Geom_BSplineSurface_NbUKnots (Handle_Geom_BSplineSurface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineSurface_NbUKnots(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_NbUKnots\n  * wrapname: _wrap_Geom_BSplineSurface_NbUKnots\n  * fulldecl: Standard_Integer Handle_Geom_BSplineSurface::NbUKnots()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineSurface_NbVKnots(Handle_Geom_BSplineSurface *self){
        return (*self)->NbVKnots();
    }
EXPORT Standard_Integer _wrap_Geom_BSplineSurface_NbVKnots (Handle_Geom_BSplineSurface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineSurface_NbVKnots(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_NbVKnots\n  * wrapname: _wrap_Geom_BSplineSurface_NbVKnots\n  * fulldecl: Standard_Integer Handle_Geom_BSplineSurface::NbVKnots()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_BSplineSurface_Pole(Handle_Geom_BSplineSurface *self,Standard_Integer const indexU,Standard_Integer const indexV){
        return (*self)->Pole(indexU, indexV);
    }
EXPORT gp_Pnt *_wrap_Geom_BSplineSurface_Pole (Handle_Geom_BSplineSurface *larg1, Standard_Integer larg2, Standard_Integer larg3) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  gp_Pnt result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_BSplineSurface_Pole(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_Pole\n  * wrapname: _wrap_Geom_BSplineSurface_Pole\n  * fulldecl: gp_Pnt Handle_Geom_BSplineSurface::Pole(Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineSurface_UDegree(Handle_Geom_BSplineSurface *self){
        return (*self)->UDegree();
    }
EXPORT Standard_Integer _wrap_Geom_BSplineSurface_UDegree (Handle_Geom_BSplineSurface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineSurface_UDegree(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_UDegree\n  * wrapname: _wrap_Geom_BSplineSurface_UDegree\n  * fulldecl: Standard_Integer Handle_Geom_BSplineSurface::UDegree()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineSurface_VDegree(Handle_Geom_BSplineSurface *self){
        return (*self)->VDegree();
    }
EXPORT Standard_Integer _wrap_Geom_BSplineSurface_VDegree (Handle_Geom_BSplineSurface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineSurface_VDegree(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_VDegree\n  * wrapname: _wrap_Geom_BSplineSurface_VDegree\n  * fulldecl: Standard_Integer Handle_Geom_BSplineSurface::VDegree()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_BSplineSurface_UKnot(Handle_Geom_BSplineSurface *self,Standard_Integer const indexUKnot){
        return (*self)->UKnot(indexUKnot);
    }
EXPORT Standard_Real _wrap_Geom_BSplineSurface_UKnot (Handle_Geom_BSplineSurface *larg1, Standard_Integer larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_BSplineSurface_UKnot(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_UKnot\n  * wrapname: _wrap_Geom_BSplineSurface_UKnot\n  * fulldecl: Standard_Real Handle_Geom_BSplineSurface::UKnot(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_BSplineSurface_VKnot(Handle_Geom_BSplineSurface *self,Standard_Integer const indexVKnot){
        return (*self)->VKnot(indexVKnot);
    }
EXPORT Standard_Real _wrap_Geom_BSplineSurface_VKnot (Handle_Geom_BSplineSurface *larg1, Standard_Integer larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_BSplineSurface_VKnot(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_VKnot\n  * wrapname: _wrap_Geom_BSplineSurface_VKnot\n  * fulldecl: Standard_Real Handle_Geom_BSplineSurface::VKnot(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineSurface_UMultiplicity(Handle_Geom_BSplineSurface *self,Standard_Integer const indexUKnot){
		return (*self)->UMultiplicity(indexUKnot);
    }
EXPORT Standard_Integer _wrap_Geom_BSplineSurface_UMultiplicity (Handle_Geom_BSplineSurface *larg1, Standard_Integer larg2) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineSurface_UMultiplicity(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_UMultiplicity\n  * wrapname: _wrap_Geom_BSplineSurface_UMultiplicity\n  * fulldecl: Standard_Integer Handle_Geom_BSplineSurface::UMultiplicity(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineSurface_VMultiplicity(Handle_Geom_BSplineSurface *self,Standard_Integer const indexVKnot){
		return (*self)->VMultiplicity(indexVKnot);
    }
EXPORT Standard_Integer _wrap_Geom_BSplineSurface_VMultiplicity (Handle_Geom_BSplineSurface *larg1, Standard_Integer larg2) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineSurface_VMultiplicity(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_VMultiplicity\n  * wrapname: _wrap_Geom_BSplineSurface_VMultiplicity\n  * fulldecl: Standard_Integer Handle_Geom_BSplineSurface::VMultiplicity(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_BSplineSurface_Weight(Handle_Geom_BSplineSurface *self,Standard_Integer const indexU,Standard_Integer const indexV){
        return (*self)->Weight(indexU, indexV);
    }
EXPORT Standard_Real _wrap_Geom_BSplineSurface_Weight (Handle_Geom_BSplineSurface *larg1, Standard_Integer larg2, Standard_Integer larg3) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_BSplineSurface_Weight(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_Weight\n  * wrapname: _wrap_Geom_BSplineSurface_Weight\n  * fulldecl: Standard_Real Handle_Geom_BSplineSurface::Weight(Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineSurface_MaxDegree(){
      return Geom_BSplineSurface::MaxDegree();
    }
EXPORT Standard_Integer _wrap_Geom_BSplineSurface_MaxDegree () {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Standard_Integer result;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineSurface_MaxDegree();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_MaxDegree\n  * wrapname: _wrap_Geom_BSplineSurface_MaxDegree\n  * fulldecl: Standard_Integer Handle_Geom_BSplineSurface::Handle_Geom_BSplineSurface_MaxDegree()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN void Handle_Geom_BSplineSurface_Resolution(Handle_Geom_BSplineSurface *self,Standard_Real tolerance3d,Standard_Real &toleranceU,Standard_Real &toleranceV){
      (*self)->Resolution(tolerance3d, toleranceU, toleranceV);
    }
EXPORT void _wrap_Geom_BSplineSurface_Resolution (Handle_Geom_BSplineSurface *larg1, Standard_Real larg2, Standard_Real *larg3, Standard_Real *larg4) {
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Real arg2 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BSplineSurface_Resolution(arg1,arg2,*arg3,*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_Resolution\n  * wrapname: _wrap_Geom_BSplineSurface_Resolution\n  * fulldecl: void Handle_Geom_BSplineSurface::Resolution(Standard_Real,Standard_Real &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom_RectangularTrimmedSurface *new_Handle_Geom_RectangularTrimmedSurface__SWIG_0(Handle_Geom_Surface const &S,Standard_Real const U1,Standard_Real const U2,Standard_Real const V1,Standard_Real const V2,Standard_Boolean const USense=Standard_True,Standard_Boolean const VSense=Standard_True){
        return new Handle_Geom_RectangularTrimmedSurface(new Geom_RectangularTrimmedSurface(S, U1, U2, V1, V2, USense, VSense));
     }
EXPORT Handle_Geom_RectangularTrimmedSurface *_wrap_new_Geom_RectangularTrimmedSurface__SWIG_0 (Handle_Geom_Surface *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5, bool larg6, bool larg7) {
  Handle_Geom_RectangularTrimmedSurface * lresult = (Handle_Geom_RectangularTrimmedSurface *)0 ;
  Handle_Geom_Surface *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  Standard_Boolean arg6 ;
  Standard_Boolean arg7 ;
  Handle_Geom_RectangularTrimmedSurface *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = (bool)larg6;
  arg7 = (bool)larg7;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_RectangularTrimmedSurface *)new_Handle_Geom_RectangularTrimmedSurface__SWIG_0((Handle_Geom_Surface const &)*arg1,arg2,arg3,arg4,arg5,arg6,arg7);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_RectangularTrimmedSurface\n  * wrapname: _wrap_new_Geom_RectangularTrimmedSurface__SWIG_0\n  * fulldecl: Handle_Geom_RectangularTrimmedSurface::Handle_Geom_RectangularTrimmedSurface(Handle_Geom_Surface const &,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_RectangularTrimmedSurface *)0;
  }
}


EXPORT Handle_Geom_RectangularTrimmedSurface *_wrap_new_Geom_RectangularTrimmedSurface__SWIG_1 (Handle_Geom_Surface *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5, bool larg6) {
  Handle_Geom_RectangularTrimmedSurface * lresult = (Handle_Geom_RectangularTrimmedSurface *)0 ;
  Handle_Geom_Surface *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  Standard_Boolean arg6 ;
  Handle_Geom_RectangularTrimmedSurface *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = (bool)larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_RectangularTrimmedSurface *)new_Handle_Geom_RectangularTrimmedSurface__SWIG_0((Handle_Geom_Surface const &)*arg1,arg2,arg3,arg4,arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_RectangularTrimmedSurface\n  * wrapname: _wrap_new_Geom_RectangularTrimmedSurface__SWIG_1\n  * fulldecl: Handle_Geom_RectangularTrimmedSurface::Handle_Geom_RectangularTrimmedSurface(Handle_Geom_Surface const &,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_RectangularTrimmedSurface *)0;
  }
}


EXPORT Handle_Geom_RectangularTrimmedSurface *_wrap_new_Geom_RectangularTrimmedSurface__SWIG_2 (Handle_Geom_Surface *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5) {
  Handle_Geom_RectangularTrimmedSurface * lresult = (Handle_Geom_RectangularTrimmedSurface *)0 ;
  Handle_Geom_Surface *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  Handle_Geom_RectangularTrimmedSurface *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_RectangularTrimmedSurface *)new_Handle_Geom_RectangularTrimmedSurface__SWIG_0((Handle_Geom_Surface const &)*arg1,arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_RectangularTrimmedSurface\n  * wrapname: _wrap_new_Geom_RectangularTrimmedSurface__SWIG_2\n  * fulldecl: Handle_Geom_RectangularTrimmedSurface::Handle_Geom_RectangularTrimmedSurface(Handle_Geom_Surface const &,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_RectangularTrimmedSurface *)0;
  }
}


SWIGINTERN void Handle_Geom_RectangularTrimmedSurface_Delete(Handle_Geom_RectangularTrimmedSurface *self){
	  self->~Handle_Geom_RectangularTrimmedSurface();
	}
EXPORT void _wrap_Geom_RectangularTrimmedSurface_Delete (Handle_Geom_RectangularTrimmedSurface *larg1) {
  Handle_Geom_RectangularTrimmedSurface *arg1 = (Handle_Geom_RectangularTrimmedSurface *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_RectangularTrimmedSurface_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_RectangularTrimmedSurface_Delete\n  * wrapname: _wrap_Geom_RectangularTrimmedSurface_Delete\n  * fulldecl: void Handle_Geom_RectangularTrimmedSurface::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom_Surface Handle_Geom_RectangularTrimmedSurface_BasisSurface(Handle_Geom_RectangularTrimmedSurface *self){
        return (*self)->BasisSurface();	
	}
EXPORT Handle_Geom_Surface *_wrap_Geom_RectangularTrimmedSurface_BasisSurface (Handle_Geom_RectangularTrimmedSurface *larg1) {
  Handle_Geom_Surface * lresult = (Handle_Geom_Surface *)0 ;
  Handle_Geom_RectangularTrimmedSurface *arg1 = (Handle_Geom_RectangularTrimmedSurface *) 0 ;
  SwigValueWrapper< Handle_Geom_Surface > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_RectangularTrimmedSurface_BasisSurface(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_RectangularTrimmedSurface_BasisSurface\n  * wrapname: _wrap_Geom_RectangularTrimmedSurface_BasisSurface\n  * fulldecl: Handle_Geom_Surface Handle_Geom_RectangularTrimmedSurface::BasisSurface()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Surface(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Surface *)0;
  }
}


SWIGINTERN void Handle_Geom_RectangularTrimmedSurface_Bounds(Handle_Geom_RectangularTrimmedSurface *self,Standard_Real &u1,Standard_Real &u2,Standard_Real &v1,Standard_Real &v2){
        (*self)->Bounds(u1, u2, v1, v2);
    }
EXPORT void _wrap_Geom_RectangularTrimmedSurface_Bounds (Handle_Geom_RectangularTrimmedSurface *larg1, Standard_Real *larg2, Standard_Real *larg3, Standard_Real *larg4, Standard_Real *larg5) {
  Handle_Geom_RectangularTrimmedSurface *arg1 = (Handle_Geom_RectangularTrimmedSurface *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  Standard_Real *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_RectangularTrimmedSurface_Bounds(arg1,*arg2,*arg3,*arg4,*arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_RectangularTrimmedSurface_Bounds\n  * wrapname: _wrap_Geom_RectangularTrimmedSurface_Bounds\n  * fulldecl: void Handle_Geom_RectangularTrimmedSurface::Bounds(Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom_SphericalSurface *new_Handle_Geom_SphericalSurface(gp_Ax3 const &A3,Standard_Real const Radius){
        return new Handle_Geom_SphericalSurface(new Geom_SphericalSurface(A3, Radius));
    }
EXPORT Handle_Geom_SphericalSurface *_wrap_new_Geom_SphericalSurface (gp_Ax3 *larg1, Standard_Real larg2) {
  Handle_Geom_SphericalSurface * lresult = (Handle_Geom_SphericalSurface *)0 ;
  gp_Ax3 *arg1 = 0 ;
  Standard_Real arg2 ;
  Handle_Geom_SphericalSurface *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_SphericalSurface *)new_Handle_Geom_SphericalSurface((gp_Ax3 const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_SphericalSurface\n  * wrapname: _wrap_new_Geom_SphericalSurface\n  * fulldecl: Handle_Geom_SphericalSurface::Handle_Geom_SphericalSurface(gp_Ax3 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_SphericalSurface *)0;
  }
}


SWIGINTERN void Handle_Geom_SphericalSurface_Delete(Handle_Geom_SphericalSurface *self){
      self->~Handle_Geom_SphericalSurface();
    }
EXPORT void _wrap_Geom_SphericalSurface_Delete (Handle_Geom_SphericalSurface *larg1) {
  Handle_Geom_SphericalSurface *arg1 = (Handle_Geom_SphericalSurface *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_SphericalSurface_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_SphericalSurface_Delete\n  * wrapname: _wrap_Geom_SphericalSurface_Delete\n  * fulldecl: void Handle_Geom_SphericalSurface::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Sphere Handle_Geom_SphericalSurface_Sphere(Handle_Geom_SphericalSurface *self){
	    return (*self)->Sphere();	
	}
EXPORT gp_Sphere *_wrap_Geom_SphericalSurface_Sphere (Handle_Geom_SphericalSurface *larg1) {
  gp_Sphere * lresult = (gp_Sphere *)0 ;
  Handle_Geom_SphericalSurface *arg1 = (Handle_Geom_SphericalSurface *) 0 ;
  gp_Sphere result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_SphericalSurface_Sphere(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_SphericalSurface_Sphere\n  * wrapname: _wrap_Geom_SphericalSurface_Sphere\n  * fulldecl: gp_Sphere Handle_Geom_SphericalSurface::Sphere()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Sphere(result);
    return lresult;
  } catch (...) {
    return (gp_Sphere *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_SphericalSurface_Area(Handle_Geom_SphericalSurface *self){
	    return (*self)->Area();	
	}
EXPORT Standard_Real _wrap_Geom_SphericalSurface_Area (Handle_Geom_SphericalSurface *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_SphericalSurface *arg1 = (Handle_Geom_SphericalSurface *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_SphericalSurface_Area(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_SphericalSurface_Area\n  * wrapname: _wrap_Geom_SphericalSurface_Area\n  * fulldecl: Standard_Real Handle_Geom_SphericalSurface::Area()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN void Handle_Geom_SphericalSurface_Coefficients(Handle_Geom_SphericalSurface *self,Standard_Real &outA1,Standard_Real &outA2,Standard_Real &outA3,Standard_Real &outB1,Standard_Real &outB2,Standard_Real &outB3,Standard_Real &outC1,Standard_Real &outC2,Standard_Real &outC3,Standard_Real &outD){
		return (*self)->Coefficients(outA1, outA2, outA3, outB1, outB2, outB3, outC1, outC2, outC3, outD);
	}
EXPORT void _wrap_Geom_SphericalSurface_Coefficients (Handle_Geom_SphericalSurface *larg1, Standard_Real *larg2, Standard_Real *larg3, Standard_Real *larg4, Standard_Real *larg5, Standard_Real *larg6, Standard_Real *larg7, Standard_Real *larg8, Standard_Real *larg9, Standard_Real *larg10, Standard_Real *larg11) {
  Handle_Geom_SphericalSurface *arg1 = (Handle_Geom_SphericalSurface *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  Standard_Real *arg5 = 0 ;
  Standard_Real *arg6 = 0 ;
  Standard_Real *arg7 = 0 ;
  Standard_Real *arg8 = 0 ;
  Standard_Real *arg9 = 0 ;
  Standard_Real *arg10 = 0 ;
  Standard_Real *arg11 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  arg11 = larg11;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_SphericalSurface_Coefficients(arg1,*arg2,*arg3,*arg4,*arg5,*arg6,*arg7,*arg8,*arg9,*arg10,*arg11);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_SphericalSurface_Coefficients\n  * wrapname: _wrap_Geom_SphericalSurface_Coefficients\n  * fulldecl: void Handle_Geom_SphericalSurface::Coefficients(Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Geom_SphericalSurface_Radius(Handle_Geom_SphericalSurface *self){   
		return (*self)->Radius();	
	}
EXPORT Standard_Real _wrap_Geom_SphericalSurface_Radius (Handle_Geom_SphericalSurface *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_SphericalSurface *arg1 = (Handle_Geom_SphericalSurface *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_SphericalSurface_Radius(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_SphericalSurface_Radius\n  * wrapname: _wrap_Geom_SphericalSurface_Radius\n  * fulldecl: Standard_Real Handle_Geom_SphericalSurface::Radius()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_SphericalSurface_Volume(Handle_Geom_SphericalSurface *self){   
		return (*self)->Volume();	
	}
EXPORT Standard_Real _wrap_Geom_SphericalSurface_Volume (Handle_Geom_SphericalSurface *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_SphericalSurface *arg1 = (Handle_Geom_SphericalSurface *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_SphericalSurface_Volume(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_SphericalSurface_Volume\n  * wrapname: _wrap_Geom_SphericalSurface_Volume\n  * fulldecl: Standard_Real Handle_Geom_SphericalSurface::Volume()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Handle_Geom_ToroidalSurface *new_Handle_Geom_ToroidalSurface(gp_Ax3 const &A3,Standard_Real const MajorRadius,Standard_Real const MinorRadius){
        return new Handle_Geom_ToroidalSurface(new Geom_ToroidalSurface(A3, MajorRadius, MinorRadius));
    }
EXPORT Handle_Geom_ToroidalSurface *_wrap_new_Geom_ToroidalSurface (gp_Ax3 *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom_ToroidalSurface * lresult = (Handle_Geom_ToroidalSurface *)0 ;
  gp_Ax3 *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Handle_Geom_ToroidalSurface *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_ToroidalSurface *)new_Handle_Geom_ToroidalSurface((gp_Ax3 const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_ToroidalSurface\n  * wrapname: _wrap_new_Geom_ToroidalSurface\n  * fulldecl: Handle_Geom_ToroidalSurface::Handle_Geom_ToroidalSurface(gp_Ax3 const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_ToroidalSurface *)0;
  }
}


SWIGINTERN void Handle_Geom_ToroidalSurface_Delete(Handle_Geom_ToroidalSurface *self){
      self->~Handle_Geom_ToroidalSurface();
    }
EXPORT void _wrap_Geom_ToroidalSurface_Delete (Handle_Geom_ToroidalSurface *larg1) {
  Handle_Geom_ToroidalSurface *arg1 = (Handle_Geom_ToroidalSurface *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_ToroidalSurface_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_ToroidalSurface_Delete\n  * wrapname: _wrap_Geom_ToroidalSurface_Delete\n  * fulldecl: void Handle_Geom_ToroidalSurface::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Torus Handle_Geom_ToroidalSurface_Torus(Handle_Geom_ToroidalSurface *self){
	    return (*self)->Torus();	
	}
EXPORT gp_Torus *_wrap_Geom_ToroidalSurface_Torus (Handle_Geom_ToroidalSurface *larg1) {
  gp_Torus * lresult = (gp_Torus *)0 ;
  Handle_Geom_ToroidalSurface *arg1 = (Handle_Geom_ToroidalSurface *) 0 ;
  gp_Torus result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_ToroidalSurface_Torus(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_ToroidalSurface_Torus\n  * wrapname: _wrap_Geom_ToroidalSurface_Torus\n  * fulldecl: gp_Torus Handle_Geom_ToroidalSurface::Torus()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Torus(result);
    return lresult;
  } catch (...) {
    return (gp_Torus *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_ToroidalSurface_Area(Handle_Geom_ToroidalSurface *self){
	    return (*self)->Area();	
	}
EXPORT Standard_Real _wrap_Geom_ToroidalSurface_Area (Handle_Geom_ToroidalSurface *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_ToroidalSurface *arg1 = (Handle_Geom_ToroidalSurface *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_ToroidalSurface_Area(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_ToroidalSurface_Area\n  * wrapname: _wrap_Geom_ToroidalSurface_Area\n  * fulldecl: Standard_Real Handle_Geom_ToroidalSurface::Area()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_ToroidalSurface_MajorRadius(Handle_Geom_ToroidalSurface *self){
		return (*self)->MajorRadius();
	}
EXPORT Standard_Real _wrap_Geom_ToroidalSurface_MajorRadius (Handle_Geom_ToroidalSurface *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_ToroidalSurface *arg1 = (Handle_Geom_ToroidalSurface *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_ToroidalSurface_MajorRadius(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_ToroidalSurface_MajorRadius\n  * wrapname: _wrap_Geom_ToroidalSurface_MajorRadius\n  * fulldecl: Standard_Real Handle_Geom_ToroidalSurface::MajorRadius()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_ToroidalSurface_MinorRadius(Handle_Geom_ToroidalSurface *self){
		return (*self)->MinorRadius();
	}
EXPORT Standard_Real _wrap_Geom_ToroidalSurface_MinorRadius (Handle_Geom_ToroidalSurface *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_ToroidalSurface *arg1 = (Handle_Geom_ToroidalSurface *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_ToroidalSurface_MinorRadius(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_ToroidalSurface_MinorRadius\n  * wrapname: _wrap_Geom_ToroidalSurface_MinorRadius\n  * fulldecl: Standard_Real Handle_Geom_ToroidalSurface::MinorRadius()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_ToroidalSurface_Volume(Handle_Geom_ToroidalSurface *self){   
		return (*self)->Volume();	
	}
EXPORT Standard_Real _wrap_Geom_ToroidalSurface_Volume (Handle_Geom_ToroidalSurface *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_ToroidalSurface *arg1 = (Handle_Geom_ToroidalSurface *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_ToroidalSurface_Volume(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_ToroidalSurface_Volume\n  * wrapname: _wrap_Geom_ToroidalSurface_Volume\n  * fulldecl: Standard_Real Handle_Geom_ToroidalSurface::Volume()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Handle_Geom_OffsetSurface *new_Handle_Geom_OffsetSurface(Handle_Geom_Surface const &S,Standard_Real const Offset){
        return new Handle_Geom_OffsetSurface(new Geom_OffsetSurface(S, Offset)); 
    }
EXPORT Handle_Geom_OffsetSurface *_wrap_new_Geom_OffsetSurface (Handle_Geom_Surface *larg1, Standard_Real larg2) {
  Handle_Geom_OffsetSurface * lresult = (Handle_Geom_OffsetSurface *)0 ;
  Handle_Geom_Surface *arg1 = 0 ;
  Standard_Real arg2 ;
  Handle_Geom_OffsetSurface *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_OffsetSurface *)new_Handle_Geom_OffsetSurface((Handle_Geom_Surface const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_OffsetSurface\n  * wrapname: _wrap_new_Geom_OffsetSurface\n  * fulldecl: Handle_Geom_OffsetSurface::Handle_Geom_OffsetSurface(Handle_Geom_Surface const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_OffsetSurface *)0;
  }
}


SWIGINTERN void Handle_Geom_OffsetSurface_Delete(Handle_Geom_OffsetSurface *self){
      self->~Handle_Geom_OffsetSurface();
    }
EXPORT void _wrap_Geom_OffsetSurface_Delete (Handle_Geom_OffsetSurface *larg1) {
  Handle_Geom_OffsetSurface *arg1 = (Handle_Geom_OffsetSurface *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_OffsetSurface_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_OffsetSurface_Delete\n  * wrapname: _wrap_Geom_OffsetSurface_Delete\n  * fulldecl: void Handle_Geom_OffsetSurface::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Geom_OffsetSurface_Offset(Handle_Geom_OffsetSurface *self){
		return (*self)->Offset();	
	}
EXPORT Standard_Real _wrap_Geom_OffsetSurface_Offset (Handle_Geom_OffsetSurface *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_OffsetSurface *arg1 = (Handle_Geom_OffsetSurface *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_OffsetSurface_Offset(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_OffsetSurface_Offset\n  * wrapname: _wrap_Geom_OffsetSurface_Offset\n  * fulldecl: Standard_Real Handle_Geom_OffsetSurface::Offset()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Handle_Geom_Surface Handle_Geom_OffsetSurface_BasisSurface(Handle_Geom_OffsetSurface *self){
        return (*self)->BasisSurface();	
	}
EXPORT Handle_Geom_Surface *_wrap_Geom_OffsetSurface_BasisSurface (Handle_Geom_OffsetSurface *larg1) {
  Handle_Geom_Surface * lresult = (Handle_Geom_Surface *)0 ;
  Handle_Geom_OffsetSurface *arg1 = (Handle_Geom_OffsetSurface *) 0 ;
  SwigValueWrapper< Handle_Geom_Surface > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_OffsetSurface_BasisSurface(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_OffsetSurface_BasisSurface\n  * wrapname: _wrap_Geom_OffsetSurface_BasisSurface\n  * fulldecl: Handle_Geom_Surface Handle_Geom_OffsetSurface::BasisSurface()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Surface(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Surface *)0;
  }
}


SWIGINTERN Handle_Geom_SurfaceOfRevolution *new_Handle_Geom_SurfaceOfRevolution(Handle_Geom_Curve const &C,gp_Ax1 const &A1){
        return new Handle_Geom_SurfaceOfRevolution(new Geom_SurfaceOfRevolution(C, A1));
    }
EXPORT Handle_Geom_SurfaceOfRevolution *_wrap_new_Geom_SurfaceOfRevolution (Handle_Geom_Curve *larg1, gp_Ax1 *larg2) {
  Handle_Geom_SurfaceOfRevolution * lresult = (Handle_Geom_SurfaceOfRevolution *)0 ;
  Handle_Geom_Curve *arg1 = 0 ;
  gp_Ax1 *arg2 = 0 ;
  Handle_Geom_SurfaceOfRevolution *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_SurfaceOfRevolution *)new_Handle_Geom_SurfaceOfRevolution((Handle_Geom_Curve const &)*arg1,(gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_SurfaceOfRevolution\n  * wrapname: _wrap_new_Geom_SurfaceOfRevolution\n  * fulldecl: Handle_Geom_SurfaceOfRevolution::Handle_Geom_SurfaceOfRevolution(Handle_Geom_Curve const &,gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_SurfaceOfRevolution *)0;
  }
}


SWIGINTERN void Handle_Geom_SurfaceOfRevolution_Delete(Handle_Geom_SurfaceOfRevolution *self){
      self->~Handle_Geom_SurfaceOfRevolution();
    }
EXPORT void _wrap_Geom_SurfaceOfRevolution_Delete (Handle_Geom_SurfaceOfRevolution *larg1) {
  Handle_Geom_SurfaceOfRevolution *arg1 = (Handle_Geom_SurfaceOfRevolution *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_SurfaceOfRevolution_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_SurfaceOfRevolution_Delete\n  * wrapname: _wrap_Geom_SurfaceOfRevolution_Delete\n  * fulldecl: void Handle_Geom_SurfaceOfRevolution::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Ax1 Handle_Geom_SurfaceOfRevolution_Axis(Handle_Geom_SurfaceOfRevolution *self){
		return (*self)->Axis();	
	}
EXPORT gp_Ax1 *_wrap_Geom_SurfaceOfRevolution_Axis (Handle_Geom_SurfaceOfRevolution *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  Handle_Geom_SurfaceOfRevolution *arg1 = (Handle_Geom_SurfaceOfRevolution *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_SurfaceOfRevolution_Axis(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_SurfaceOfRevolution_Axis\n  * wrapname: _wrap_Geom_SurfaceOfRevolution_Axis\n  * fulldecl: gp_Ax1 Handle_Geom_SurfaceOfRevolution::Axis()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_SurfaceOfRevolution_Location(Handle_Geom_SurfaceOfRevolution *self){
		return (*self)->Location();	
	}
EXPORT gp_Pnt *_wrap_Geom_SurfaceOfRevolution_Location (Handle_Geom_SurfaceOfRevolution *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_SurfaceOfRevolution *arg1 = (Handle_Geom_SurfaceOfRevolution *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_SurfaceOfRevolution_Location(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_SurfaceOfRevolution_Location\n  * wrapname: _wrap_Geom_SurfaceOfRevolution_Location\n  * fulldecl: gp_Pnt Handle_Geom_SurfaceOfRevolution::Location()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN gp_Ax2 Handle_Geom_SurfaceOfRevolution_ReferencePlane(Handle_Geom_SurfaceOfRevolution *self){
		return (*self)->ReferencePlane();	
	}
EXPORT gp_Ax2 *_wrap_Geom_SurfaceOfRevolution_ReferencePlane (Handle_Geom_SurfaceOfRevolution *larg1) {
  gp_Ax2 * lresult = (gp_Ax2 *)0 ;
  Handle_Geom_SurfaceOfRevolution *arg1 = (Handle_Geom_SurfaceOfRevolution *) 0 ;
  gp_Ax2 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_SurfaceOfRevolution_ReferencePlane(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_SurfaceOfRevolution_ReferencePlane\n  * wrapname: _wrap_Geom_SurfaceOfRevolution_ReferencePlane\n  * fulldecl: gp_Ax2 Handle_Geom_SurfaceOfRevolution::ReferencePlane()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2 *)0;
  }
}


SWIGINTERN Handle_Geom_ConicalSurface *new_Handle_Geom_ConicalSurface(gp_Ax3 const &A3,Standard_Real const Ang,Standard_Real const Radius){
		return new Handle_Geom_ConicalSurface(new Geom_ConicalSurface(A3, Ang, Radius));
	}
EXPORT Handle_Geom_ConicalSurface *_wrap_new_Geom_ConicalSurface (gp_Ax3 *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom_ConicalSurface * lresult = (Handle_Geom_ConicalSurface *)0 ;
  gp_Ax3 *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Handle_Geom_ConicalSurface *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_ConicalSurface *)new_Handle_Geom_ConicalSurface((gp_Ax3 const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_ConicalSurface\n  * wrapname: _wrap_new_Geom_ConicalSurface\n  * fulldecl: Handle_Geom_ConicalSurface::Handle_Geom_ConicalSurface(gp_Ax3 const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_ConicalSurface *)0;
  }
}


SWIGINTERN void Handle_Geom_ConicalSurface_Delete(Handle_Geom_ConicalSurface *self){
      self->~Handle_Geom_ConicalSurface();
    }
EXPORT void _wrap_Geom_ConicalSurface_Delete (Handle_Geom_ConicalSurface *larg1) {
  Handle_Geom_ConicalSurface *arg1 = (Handle_Geom_ConicalSurface *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_ConicalSurface_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_ConicalSurface_Delete\n  * wrapname: _wrap_Geom_ConicalSurface_Delete\n  * fulldecl: void Handle_Geom_ConicalSurface::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Cone Handle_Geom_ConicalSurface_Cone(Handle_Geom_ConicalSurface *self){
		return (*self)->Cone();	
	}
EXPORT gp_Cone *_wrap_Geom_ConicalSurface_Cone (Handle_Geom_ConicalSurface *larg1) {
  gp_Cone * lresult = (gp_Cone *)0 ;
  Handle_Geom_ConicalSurface *arg1 = (Handle_Geom_ConicalSurface *) 0 ;
  gp_Cone result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_ConicalSurface_Cone(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_ConicalSurface_Cone\n  * wrapname: _wrap_Geom_ConicalSurface_Cone\n  * fulldecl: gp_Cone Handle_Geom_ConicalSurface::Cone()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Cone(result);
    return lresult;
  } catch (...) {
    return (gp_Cone *)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_ConicalSurface_Apex(Handle_Geom_ConicalSurface *self){
		return (*self)->Apex();	
	}
EXPORT gp_Pnt *_wrap_Geom_ConicalSurface_Apex (Handle_Geom_ConicalSurface *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_ConicalSurface *arg1 = (Handle_Geom_ConicalSurface *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_ConicalSurface_Apex(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_ConicalSurface_Apex\n  * wrapname: _wrap_Geom_ConicalSurface_Apex\n  * fulldecl: gp_Pnt Handle_Geom_ConicalSurface::Apex()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN void Handle_Geom_ConicalSurface_Coefficients(Handle_Geom_ConicalSurface *self,Standard_Real &outA1,Standard_Real &outA2,Standard_Real &outA3,Standard_Real &outB1,Standard_Real &outB2,Standard_Real &outB3,Standard_Real &outC1,Standard_Real &outC2,Standard_Real &outC3,Standard_Real &outD){
    	(*self)->Coefficients(outA1, outA2, outA3, outB1, outB2, outB3, outC1, outC2, outC3, outD);
    }
EXPORT void _wrap_Geom_ConicalSurface_Coefficients (Handle_Geom_ConicalSurface *larg1, Standard_Real *larg2, Standard_Real *larg3, Standard_Real *larg4, Standard_Real *larg5, Standard_Real *larg6, Standard_Real *larg7, Standard_Real *larg8, Standard_Real *larg9, Standard_Real *larg10, Standard_Real *larg11) {
  Handle_Geom_ConicalSurface *arg1 = (Handle_Geom_ConicalSurface *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  Standard_Real *arg5 = 0 ;
  Standard_Real *arg6 = 0 ;
  Standard_Real *arg7 = 0 ;
  Standard_Real *arg8 = 0 ;
  Standard_Real *arg9 = 0 ;
  Standard_Real *arg10 = 0 ;
  Standard_Real *arg11 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  arg11 = larg11;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_ConicalSurface_Coefficients(arg1,*arg2,*arg3,*arg4,*arg5,*arg6,*arg7,*arg8,*arg9,*arg10,*arg11);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_ConicalSurface_Coefficients\n  * wrapname: _wrap_Geom_ConicalSurface_Coefficients\n  * fulldecl: void Handle_Geom_ConicalSurface::Coefficients(Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Geom_ConicalSurface_ReferenceRadius(Handle_Geom_ConicalSurface *self){   
		return (*self)->RefRadius();	
	}
EXPORT Standard_Real _wrap_Geom_ConicalSurface_ReferenceRadius (Handle_Geom_ConicalSurface *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_ConicalSurface *arg1 = (Handle_Geom_ConicalSurface *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_ConicalSurface_ReferenceRadius(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_ConicalSurface_ReferenceRadius\n  * wrapname: _wrap_Geom_ConicalSurface_ReferenceRadius\n  * fulldecl: Standard_Real Handle_Geom_ConicalSurface::ReferenceRadius()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_ConicalSurface_SemiAngle(Handle_Geom_ConicalSurface *self){   
		return (*self)->SemiAngle();	
	}
EXPORT Standard_Real _wrap_Geom_ConicalSurface_SemiAngle (Handle_Geom_ConicalSurface *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_ConicalSurface *arg1 = (Handle_Geom_ConicalSurface *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_ConicalSurface_SemiAngle(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_ConicalSurface_SemiAngle\n  * wrapname: _wrap_Geom_ConicalSurface_SemiAngle\n  * fulldecl: Standard_Real Handle_Geom_ConicalSurface::SemiAngle()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Handle_Geom_CylindricalSurface *new_Handle_Geom_CylindricalSurface__SWIG_0(gp_Ax3 const &A3,Standard_Real const Radius){
		return new Handle_Geom_CylindricalSurface(new Geom_CylindricalSurface(A3, Radius));
	}
EXPORT Handle_Geom_CylindricalSurface *_wrap_new_Geom_CylindricalSurface__SWIG_0 (gp_Ax3 *larg1, Standard_Real larg2) {
  Handle_Geom_CylindricalSurface * lresult = (Handle_Geom_CylindricalSurface *)0 ;
  gp_Ax3 *arg1 = 0 ;
  Standard_Real arg2 ;
  Handle_Geom_CylindricalSurface *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_CylindricalSurface *)new_Handle_Geom_CylindricalSurface__SWIG_0((gp_Ax3 const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_CylindricalSurface\n  * wrapname: _wrap_new_Geom_CylindricalSurface__SWIG_0\n  * fulldecl: Handle_Geom_CylindricalSurface::Handle_Geom_CylindricalSurface(gp_Ax3 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_CylindricalSurface *)0;
  }
}


SWIGINTERN Handle_Geom_CylindricalSurface *new_Handle_Geom_CylindricalSurface__SWIG_1(gp_Ax2 const &A2,Standard_Real const Radius){
		return new Handle_Geom_CylindricalSurface(new Geom_CylindricalSurface(A2, Radius));
	}
EXPORT Handle_Geom_CylindricalSurface *_wrap_new_Geom_CylindricalSurface__SWIG_1 (gp_Ax2 *larg1, Standard_Real larg2) {
  Handle_Geom_CylindricalSurface * lresult = (Handle_Geom_CylindricalSurface *)0 ;
  gp_Ax2 *arg1 = 0 ;
  Standard_Real arg2 ;
  Handle_Geom_CylindricalSurface *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_CylindricalSurface *)new_Handle_Geom_CylindricalSurface__SWIG_1((gp_Ax2 const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_CylindricalSurface\n  * wrapname: _wrap_new_Geom_CylindricalSurface__SWIG_1\n  * fulldecl: Handle_Geom_CylindricalSurface::Handle_Geom_CylindricalSurface(gp_Ax2 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_CylindricalSurface *)0;
  }
}


SWIGINTERN void Handle_Geom_CylindricalSurface_Delete(Handle_Geom_CylindricalSurface *self){
      self->~Handle_Geom_CylindricalSurface();
    }
EXPORT void _wrap_Geom_CylindricalSurface_Delete (Handle_Geom_CylindricalSurface *larg1) {
  Handle_Geom_CylindricalSurface *arg1 = (Handle_Geom_CylindricalSurface *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_CylindricalSurface_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_CylindricalSurface_Delete\n  * wrapname: _wrap_Geom_CylindricalSurface_Delete\n  * fulldecl: void Handle_Geom_CylindricalSurface::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Cylinder Handle_Geom_CylindricalSurface_Cylinder(Handle_Geom_CylindricalSurface *self){
		return (*self)->Cylinder();	
	}
EXPORT gp_Cylinder *_wrap_Geom_CylindricalSurface_Cylinder (Handle_Geom_CylindricalSurface *larg1) {
  gp_Cylinder * lresult = (gp_Cylinder *)0 ;
  Handle_Geom_CylindricalSurface *arg1 = (Handle_Geom_CylindricalSurface *) 0 ;
  gp_Cylinder result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_CylindricalSurface_Cylinder(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_CylindricalSurface_Cylinder\n  * wrapname: _wrap_Geom_CylindricalSurface_Cylinder\n  * fulldecl: gp_Cylinder Handle_Geom_CylindricalSurface::Cylinder()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Cylinder(result);
    return lresult;
  } catch (...) {
    return (gp_Cylinder *)0;
  }
}


SWIGINTERN void Handle_Geom_CylindricalSurface_Coefficients(Handle_Geom_CylindricalSurface *self,Standard_Real &outA1,Standard_Real &outA2,Standard_Real &outA3,Standard_Real &outB1,Standard_Real &outB2,Standard_Real &outB3,Standard_Real &outC1,Standard_Real &outC2,Standard_Real &outC3,Standard_Real &outD){
		return (*self)->Coefficients(outA1, outA2, outA3, outB1, outB2, outB3, outC1, outC2, outC3, outD);
	}
EXPORT void _wrap_Geom_CylindricalSurface_Coefficients (Handle_Geom_CylindricalSurface *larg1, Standard_Real *larg2, Standard_Real *larg3, Standard_Real *larg4, Standard_Real *larg5, Standard_Real *larg6, Standard_Real *larg7, Standard_Real *larg8, Standard_Real *larg9, Standard_Real *larg10, Standard_Real *larg11) {
  Handle_Geom_CylindricalSurface *arg1 = (Handle_Geom_CylindricalSurface *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  Standard_Real *arg5 = 0 ;
  Standard_Real *arg6 = 0 ;
  Standard_Real *arg7 = 0 ;
  Standard_Real *arg8 = 0 ;
  Standard_Real *arg9 = 0 ;
  Standard_Real *arg10 = 0 ;
  Standard_Real *arg11 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  arg11 = larg11;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_CylindricalSurface_Coefficients(arg1,*arg2,*arg3,*arg4,*arg5,*arg6,*arg7,*arg8,*arg9,*arg10,*arg11);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_CylindricalSurface_Coefficients\n  * wrapname: _wrap_Geom_CylindricalSurface_Coefficients\n  * fulldecl: void Handle_Geom_CylindricalSurface::Coefficients(Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Geom_CylindricalSurface_Radius(Handle_Geom_CylindricalSurface *self){   
		return (*self)->Radius();	
	}
EXPORT Standard_Real _wrap_Geom_CylindricalSurface_Radius (Handle_Geom_CylindricalSurface *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_CylindricalSurface *arg1 = (Handle_Geom_CylindricalSurface *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_CylindricalSurface_Radius(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_CylindricalSurface_Radius\n  * wrapname: _wrap_Geom_CylindricalSurface_Radius\n  * fulldecl: Standard_Real Handle_Geom_CylindricalSurface::Radius()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Handle_Geom_SurfaceOfLinearExtrusion *new_Handle_Geom_SurfaceOfLinearExtrusion(Handle_Geom_Curve const &C,gp_Dir const &V){
        return new Handle_Geom_SurfaceOfLinearExtrusion(new Geom_SurfaceOfLinearExtrusion(C, V));
    }
EXPORT Handle_Geom_SurfaceOfLinearExtrusion *_wrap_new_Geom_SurfaceOfLinearExtrusion (Handle_Geom_Curve *larg1, gp_Dir *larg2) {
  Handle_Geom_SurfaceOfLinearExtrusion * lresult = (Handle_Geom_SurfaceOfLinearExtrusion *)0 ;
  Handle_Geom_Curve *arg1 = 0 ;
  gp_Dir *arg2 = 0 ;
  Handle_Geom_SurfaceOfLinearExtrusion *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_SurfaceOfLinearExtrusion *)new_Handle_Geom_SurfaceOfLinearExtrusion((Handle_Geom_Curve const &)*arg1,(gp_Dir const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_SurfaceOfLinearExtrusion\n  * wrapname: _wrap_new_Geom_SurfaceOfLinearExtrusion\n  * fulldecl: Handle_Geom_SurfaceOfLinearExtrusion::Handle_Geom_SurfaceOfLinearExtrusion(Handle_Geom_Curve const &,gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_SurfaceOfLinearExtrusion *)0;
  }
}


SWIGINTERN void Handle_Geom_SurfaceOfLinearExtrusion_Delete(Handle_Geom_SurfaceOfLinearExtrusion *self){
      self->~Handle_Geom_SurfaceOfLinearExtrusion();
    }
EXPORT void _wrap_Geom_SurfaceOfLinearExtrusion_Delete (Handle_Geom_SurfaceOfLinearExtrusion *larg1) {
  Handle_Geom_SurfaceOfLinearExtrusion *arg1 = (Handle_Geom_SurfaceOfLinearExtrusion *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_SurfaceOfLinearExtrusion_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_SurfaceOfLinearExtrusion_Delete\n  * wrapname: _wrap_Geom_SurfaceOfLinearExtrusion_Delete\n  * fulldecl: void Handle_Geom_SurfaceOfLinearExtrusion::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom_Plane *new_Handle_Geom_Plane(gp_Ax3 const &A3){
		return new Handle_Geom_Plane(new Geom_Plane(A3));
	}
EXPORT Handle_Geom_Plane *_wrap_new_Geom_Plane (gp_Ax3 *larg1) {
  Handle_Geom_Plane * lresult = (Handle_Geom_Plane *)0 ;
  gp_Ax3 *arg1 = 0 ;
  Handle_Geom_Plane *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_Plane *)new_Handle_Geom_Plane((gp_Ax3 const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_Plane\n  * wrapname: _wrap_new_Geom_Plane\n  * fulldecl: Handle_Geom_Plane::Handle_Geom_Plane(gp_Ax3 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_Plane *)0;
  }
}


SWIGINTERN void Handle_Geom_Plane_Delete(Handle_Geom_Plane *self){
      self->~Handle_Geom_Plane();
    }
EXPORT void _wrap_Geom_Plane_Delete (Handle_Geom_Plane *larg1) {
  Handle_Geom_Plane *arg1 = (Handle_Geom_Plane *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Plane_Delete(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Plane_Delete\n  * wrapname: _wrap_Geom_Plane_Delete\n  * fulldecl: void Handle_Geom_Plane::Delete()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Pln Handle_Geom_Plane_Plane(Handle_Geom_Plane *self){
		return (*self)->Pln();	
	}
EXPORT gp_Pln *_wrap_Geom_Plane_Plane (Handle_Geom_Plane *larg1) {
  gp_Pln * lresult = (gp_Pln *)0 ;
  Handle_Geom_Plane *arg1 = (Handle_Geom_Plane *) 0 ;
  SwigValueWrapper< gp_Pln > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Plane_Plane(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Plane_Plane\n  * wrapname: _wrap_Geom_Plane_Plane\n  * fulldecl: gp_Pln Handle_Geom_Plane::Plane()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pln(result);
    return lresult;
  } catch (...) {
    return (gp_Pln *)0;
  }
}


SWIGINTERN void Handle_Geom_Plane_Coefficients(Handle_Geom_Plane *self,Standard_Real &outA,Standard_Real &outB,Standard_Real &outC,Standard_Real &outD){
		return (*self)->Coefficients(outA, outB, outC, outD);
	}
EXPORT void _wrap_Geom_Plane_Coefficients (Handle_Geom_Plane *larg1, Standard_Real *larg2, Standard_Real *larg3, Standard_Real *larg4, Standard_Real *larg5) {
  Handle_Geom_Plane *arg1 = (Handle_Geom_Plane *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  Standard_Real *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Plane_Coefficients(arg1,*arg2,*arg3,*arg4,*arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Plane_Coefficients\n  * wrapname: _wrap_Geom_Plane_Coefficients\n  * fulldecl: void Handle_Geom_Plane::Coefficients(Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <BRepLib.hxx>

EXPORT void _wrap_BRepLib_Precision__SWIG_0 (Standard_Real larg1) {
  Standard_Real arg1 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::Precision(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_Precision\n  * wrapname: _wrap_BRepLib_Precision__SWIG_0\n  * fulldecl: void BRepLib::Precision(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Real _wrap_BRepLib_Precision__SWIG_1 () {
  Standard_Real lresult = (Standard_Real)0 ;
  Standard_Real result;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)BRepLib::Precision();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_Precision\n  * wrapname: _wrap_BRepLib_Precision__SWIG_1\n  * fulldecl: Standard_Real BRepLib::Precision()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_BRepLib_Plane__SWIG_0 (Handle_Geom_Plane *larg1) {
  Handle_Geom_Plane *arg1 = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::Plane((Handle_Geom_Plane const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_Plane\n  * wrapname: _wrap_BRepLib_Plane__SWIG_0\n  * fulldecl: void BRepLib::Plane(Handle_Geom_Plane const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Handle_Geom_Plane *_wrap_BRepLib_Plane__SWIG_1 () {
  Handle_Geom_Plane * lresult = (Handle_Geom_Plane *)0 ;
  Handle_Geom_Plane *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_Plane *) &BRepLib::Plane();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_Plane\n  * wrapname: _wrap_BRepLib_Plane__SWIG_1\n  * fulldecl: Handle_Geom_Plane const & BRepLib::Plane()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_Plane *)0;
  }
}


EXPORT bool _wrap_BRepLib_CheckSameRange__SWIG_0 (TopoDS_Edge *larg1, Standard_Real larg2) {
  bool lresult = (bool)0 ;
  TopoDS_Edge *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::CheckSameRange((TopoDS_Edge const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_CheckSameRange\n  * wrapname: _wrap_BRepLib_CheckSameRange__SWIG_0\n  * fulldecl: Standard_Boolean BRepLib::CheckSameRange(TopoDS_Edge const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepLib_CheckSameRange__SWIG_1 (TopoDS_Edge *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Edge *arg1 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::CheckSameRange((TopoDS_Edge const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_CheckSameRange\n  * wrapname: _wrap_BRepLib_CheckSameRange__SWIG_1\n  * fulldecl: Standard_Boolean BRepLib::CheckSameRange(TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_BRepLib_SameRange__SWIG_0 (TopoDS_Edge *larg1, Standard_Real larg2) {
  TopoDS_Edge *arg1 = 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::SameRange((TopoDS_Edge const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_SameRange\n  * wrapname: _wrap_BRepLib_SameRange__SWIG_0\n  * fulldecl: void BRepLib::SameRange(TopoDS_Edge const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepLib_SameRange__SWIG_1 (TopoDS_Edge *larg1) {
  TopoDS_Edge *arg1 = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::SameRange((TopoDS_Edge const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_SameRange\n  * wrapname: _wrap_BRepLib_SameRange__SWIG_1\n  * fulldecl: void BRepLib::SameRange(TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_BRepLib_BuildCurve3d__SWIG_0 (TopoDS_Edge *larg1, Standard_Real larg2, GeomAbs_Shape larg3, Standard_Integer larg4, Standard_Integer larg5) {
  bool lresult = (bool)0 ;
  TopoDS_Edge *arg1 = 0 ;
  Standard_Real arg2 ;
  GeomAbs_Shape arg3 ;
  Standard_Integer arg4 ;
  Standard_Integer arg5 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::BuildCurve3d((TopoDS_Edge const &)*arg1,arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_BuildCurve3d\n  * wrapname: _wrap_BRepLib_BuildCurve3d__SWIG_0\n  * fulldecl: Standard_Boolean BRepLib::BuildCurve3d(TopoDS_Edge const &,Standard_Real const,GeomAbs_Shape const,Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepLib_BuildCurve3d__SWIG_1 (TopoDS_Edge *larg1, Standard_Real larg2, GeomAbs_Shape larg3, Standard_Integer larg4) {
  bool lresult = (bool)0 ;
  TopoDS_Edge *arg1 = 0 ;
  Standard_Real arg2 ;
  GeomAbs_Shape arg3 ;
  Standard_Integer arg4 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::BuildCurve3d((TopoDS_Edge const &)*arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_BuildCurve3d\n  * wrapname: _wrap_BRepLib_BuildCurve3d__SWIG_1\n  * fulldecl: Standard_Boolean BRepLib::BuildCurve3d(TopoDS_Edge const &,Standard_Real const,GeomAbs_Shape const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepLib_BuildCurve3d__SWIG_2 (TopoDS_Edge *larg1, Standard_Real larg2, GeomAbs_Shape larg3) {
  bool lresult = (bool)0 ;
  TopoDS_Edge *arg1 = 0 ;
  Standard_Real arg2 ;
  GeomAbs_Shape arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::BuildCurve3d((TopoDS_Edge const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_BuildCurve3d\n  * wrapname: _wrap_BRepLib_BuildCurve3d__SWIG_2\n  * fulldecl: Standard_Boolean BRepLib::BuildCurve3d(TopoDS_Edge const &,Standard_Real const,GeomAbs_Shape const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepLib_BuildCurve3d__SWIG_3 (TopoDS_Edge *larg1, Standard_Real larg2) {
  bool lresult = (bool)0 ;
  TopoDS_Edge *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::BuildCurve3d((TopoDS_Edge const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_BuildCurve3d\n  * wrapname: _wrap_BRepLib_BuildCurve3d__SWIG_3\n  * fulldecl: Standard_Boolean BRepLib::BuildCurve3d(TopoDS_Edge const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepLib_BuildCurve3d__SWIG_4 (TopoDS_Edge *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Edge *arg1 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::BuildCurve3d((TopoDS_Edge const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_BuildCurve3d\n  * wrapname: _wrap_BRepLib_BuildCurve3d__SWIG_4\n  * fulldecl: Standard_Boolean BRepLib::BuildCurve3d(TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepLib_BuildCurves3d__SWIG_0 (TopoDS_Shape *larg1, Standard_Real larg2, GeomAbs_Shape larg3, Standard_Integer larg4, Standard_Integer larg5) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  GeomAbs_Shape arg3 ;
  Standard_Integer arg4 ;
  Standard_Integer arg5 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::BuildCurves3d((TopoDS_Shape const &)*arg1,arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_BuildCurves3d\n  * wrapname: _wrap_BRepLib_BuildCurves3d__SWIG_0\n  * fulldecl: Standard_Boolean BRepLib::BuildCurves3d(TopoDS_Shape const &,Standard_Real const,GeomAbs_Shape const,Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepLib_BuildCurves3d__SWIG_1 (TopoDS_Shape *larg1, Standard_Real larg2, GeomAbs_Shape larg3, Standard_Integer larg4) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  GeomAbs_Shape arg3 ;
  Standard_Integer arg4 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::BuildCurves3d((TopoDS_Shape const &)*arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_BuildCurves3d\n  * wrapname: _wrap_BRepLib_BuildCurves3d__SWIG_1\n  * fulldecl: Standard_Boolean BRepLib::BuildCurves3d(TopoDS_Shape const &,Standard_Real const,GeomAbs_Shape const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepLib_BuildCurves3d__SWIG_2 (TopoDS_Shape *larg1, Standard_Real larg2, GeomAbs_Shape larg3) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  GeomAbs_Shape arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::BuildCurves3d((TopoDS_Shape const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_BuildCurves3d\n  * wrapname: _wrap_BRepLib_BuildCurves3d__SWIG_2\n  * fulldecl: Standard_Boolean BRepLib::BuildCurves3d(TopoDS_Shape const &,Standard_Real const,GeomAbs_Shape const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepLib_BuildCurves3d__SWIG_3 (TopoDS_Shape *larg1, Standard_Real larg2) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::BuildCurves3d((TopoDS_Shape const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_BuildCurves3d\n  * wrapname: _wrap_BRepLib_BuildCurves3d__SWIG_3\n  * fulldecl: Standard_Boolean BRepLib::BuildCurves3d(TopoDS_Shape const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepLib_BuildCurves3d__SWIG_4 (TopoDS_Shape *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::BuildCurves3d((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_BuildCurves3d\n  * wrapname: _wrap_BRepLib_BuildCurves3d__SWIG_4\n  * fulldecl: Standard_Boolean BRepLib::BuildCurves3d(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepLib_UpdateEdgeTol (TopoDS_Edge *larg1, Standard_Real larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  TopoDS_Edge *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::UpdateEdgeTol((TopoDS_Edge const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_UpdateEdgeTol\n  * wrapname: _wrap_BRepLib_UpdateEdgeTol\n  * fulldecl: Standard_Boolean BRepLib::UpdateEdgeTol(TopoDS_Edge const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepLib_UpdateEdgeTolerance (TopoDS_Shape *larg1, Standard_Real larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::UpdateEdgeTolerance((TopoDS_Shape const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_UpdateEdgeTolerance\n  * wrapname: _wrap_BRepLib_UpdateEdgeTolerance\n  * fulldecl: Standard_Boolean BRepLib::UpdateEdgeTolerance(TopoDS_Shape const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_BRepLib_SameParameter__SWIG_0 (TopoDS_Edge *larg1, Standard_Real larg2) {
  TopoDS_Edge *arg1 = 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::SameParameter((TopoDS_Edge const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_SameParameter\n  * wrapname: _wrap_BRepLib_SameParameter__SWIG_0\n  * fulldecl: void BRepLib::SameParameter(TopoDS_Edge const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepLib_SameParameter__SWIG_1 (TopoDS_Edge *larg1) {
  TopoDS_Edge *arg1 = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::SameParameter((TopoDS_Edge const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_SameParameter\n  * wrapname: _wrap_BRepLib_SameParameter__SWIG_1\n  * fulldecl: void BRepLib::SameParameter(TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepLib_SameParameter__SWIG_2 (TopoDS_Shape *larg1, Standard_Real larg2, bool larg3) {
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Boolean arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::SameParameter((TopoDS_Shape const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_SameParameter\n  * wrapname: _wrap_BRepLib_SameParameter__SWIG_2\n  * fulldecl: void BRepLib::SameParameter(TopoDS_Shape const &,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepLib_SameParameter__SWIG_3 (TopoDS_Shape *larg1, Standard_Real larg2) {
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::SameParameter((TopoDS_Shape const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_SameParameter\n  * wrapname: _wrap_BRepLib_SameParameter__SWIG_3\n  * fulldecl: void BRepLib::SameParameter(TopoDS_Shape const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepLib_SameParameter__SWIG_4 (TopoDS_Shape *larg1) {
  TopoDS_Shape *arg1 = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::SameParameter((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_SameParameter\n  * wrapname: _wrap_BRepLib_SameParameter__SWIG_4\n  * fulldecl: void BRepLib::SameParameter(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepLib_UpdateTolerances__SWIG_0 (TopoDS_Shape *larg1, bool larg2) {
  TopoDS_Shape *arg1 = 0 ;
  Standard_Boolean arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::UpdateTolerances((TopoDS_Shape const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_UpdateTolerances\n  * wrapname: _wrap_BRepLib_UpdateTolerances__SWIG_0\n  * fulldecl: void BRepLib::UpdateTolerances(TopoDS_Shape const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepLib_UpdateTolerances__SWIG_1 (TopoDS_Shape *larg1) {
  TopoDS_Shape *arg1 = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::UpdateTolerances((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_UpdateTolerances\n  * wrapname: _wrap_BRepLib_UpdateTolerances__SWIG_1\n  * fulldecl: void BRepLib::UpdateTolerances(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepLib_UpdateInnerTolerances (TopoDS_Shape *larg1) {
  TopoDS_Shape *arg1 = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::UpdateInnerTolerances((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_UpdateInnerTolerances\n  * wrapname: _wrap_BRepLib_UpdateInnerTolerances\n  * fulldecl: void BRepLib::UpdateInnerTolerances(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_BRepLib_OrientClosedSolid (TopoDS_Solid *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Solid *arg1 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::OrientClosedSolid(*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_OrientClosedSolid\n  * wrapname: _wrap_BRepLib_OrientClosedSolid\n  * fulldecl: Standard_Boolean BRepLib::OrientClosedSolid(TopoDS_Solid &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_BRepLib_EncodeRegularity__SWIG_0 (TopoDS_Shape *larg1, Standard_Real larg2) {
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::EncodeRegularity((TopoDS_Shape const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_EncodeRegularity\n  * wrapname: _wrap_BRepLib_EncodeRegularity__SWIG_0\n  * fulldecl: void BRepLib::EncodeRegularity(TopoDS_Shape const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepLib_EncodeRegularity__SWIG_1 (TopoDS_Shape *larg1) {
  TopoDS_Shape *arg1 = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::EncodeRegularity((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_EncodeRegularity\n  * wrapname: _wrap_BRepLib_EncodeRegularity__SWIG_1\n  * fulldecl: void BRepLib::EncodeRegularity(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepLib_EncodeRegularity__SWIG_2 (TopoDS_Edge *larg1, TopoDS_Face *larg2, TopoDS_Face *larg3, Standard_Real larg4) {
  TopoDS_Edge *arg1 = 0 ;
  TopoDS_Face *arg2 = 0 ;
  TopoDS_Face *arg3 = 0 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::EncodeRegularity(*arg1,(TopoDS_Face const &)*arg2,(TopoDS_Face const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_EncodeRegularity\n  * wrapname: _wrap_BRepLib_EncodeRegularity__SWIG_2\n  * fulldecl: void BRepLib::EncodeRegularity(TopoDS_Edge &,TopoDS_Face const &,TopoDS_Face const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepLib_EncodeRegularity__SWIG_3 (TopoDS_Edge *larg1, TopoDS_Face *larg2, TopoDS_Face *larg3) {
  TopoDS_Edge *arg1 = 0 ;
  TopoDS_Face *arg2 = 0 ;
  TopoDS_Face *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::EncodeRegularity(*arg1,(TopoDS_Face const &)*arg2,(TopoDS_Face const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_EncodeRegularity\n  * wrapname: _wrap_BRepLib_EncodeRegularity__SWIG_3\n  * fulldecl: void BRepLib::EncodeRegularity(TopoDS_Edge &,TopoDS_Face const &,TopoDS_Face const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepLib_SortFaces (TopoDS_Shape *larg1, TopTools_ListOfShape *larg2) {
  TopoDS_Shape *arg1 = 0 ;
  TopTools_ListOfShape *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::SortFaces((TopoDS_Shape const &)*arg1,*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_SortFaces\n  * wrapname: _wrap_BRepLib_SortFaces\n  * fulldecl: void BRepLib::SortFaces(TopoDS_Shape const &,TopTools_ListOfShape &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepLib_ReverseSortFaces (TopoDS_Shape *larg1, TopTools_ListOfShape *larg2) {
  TopoDS_Shape *arg1 = 0 ;
  TopTools_ListOfShape *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::ReverseSortFaces((TopoDS_Shape const &)*arg1,*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_ReverseSortFaces\n  * wrapname: _wrap_BRepLib_ReverseSortFaces\n  * fulldecl: void BRepLib::ReverseSortFaces(TopoDS_Shape const &,TopTools_ListOfShape &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_BRepLib_EnsureNormalConsistency__SWIG_0 (TopoDS_Shape *larg1, Standard_Real larg2, bool larg3) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Boolean arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::EnsureNormalConsistency((TopoDS_Shape const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_EnsureNormalConsistency\n  * wrapname: _wrap_BRepLib_EnsureNormalConsistency__SWIG_0\n  * fulldecl: Standard_Boolean BRepLib::EnsureNormalConsistency(TopoDS_Shape const &,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepLib_EnsureNormalConsistency__SWIG_1 (TopoDS_Shape *larg1, Standard_Real larg2) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::EnsureNormalConsistency((TopoDS_Shape const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_EnsureNormalConsistency\n  * wrapname: _wrap_BRepLib_EnsureNormalConsistency__SWIG_1\n  * fulldecl: Standard_Boolean BRepLib::EnsureNormalConsistency(TopoDS_Shape const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepLib_EnsureNormalConsistency__SWIG_2 (TopoDS_Shape *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::EnsureNormalConsistency((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_EnsureNormalConsistency\n  * wrapname: _wrap_BRepLib_EnsureNormalConsistency__SWIG_2\n  * fulldecl: Standard_Boolean BRepLib::EnsureNormalConsistency(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_BRepLib_BoundingVertex (NCollection_List< TopoDS_Shape > *larg1, gp_Pnt *larg2, Standard_Real *larg3) {
  NCollection_List< TopoDS_Shape > *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::BoundingVertex((NCollection_List< TopoDS_Shape > const &)*arg1,*arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_BoundingVertex\n  * wrapname: _wrap_BRepLib_BoundingVertex\n  * fulldecl: void BRepLib::BoundingVertex(NCollection_List< TopoDS_Shape > const &,gp_Pnt &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <BRepFilletAPI_MakeFillet.hxx>
#include <BRepFilletAPI_MakeChamfer.hxx>
  
EXPORT void _wrap_delete_BRepFilletAPI_LocalOperation (BRepFilletAPI_LocalOperation *larg1) {
  BRepFilletAPI_LocalOperation *arg1 = (BRepFilletAPI_LocalOperation *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepFilletAPI_LocalOperation\n  * wrapname: _wrap_delete_BRepFilletAPI_LocalOperation\n  * fulldecl: BRepFilletAPI_LocalOperation::~BRepFilletAPI_LocalOperation()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepFilletAPI_MakeFillet *_wrap_new_BRepFilletAPI_MakeFillet__SWIG_0 (TopoDS_Shape *larg1, ChFi3d_FilletShape larg2) {
  BRepFilletAPI_MakeFillet * lresult = (BRepFilletAPI_MakeFillet *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  ChFi3d_FilletShape arg2 ;
  BRepFilletAPI_MakeFillet *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepFilletAPI_MakeFillet *)new BRepFilletAPI_MakeFillet((TopoDS_Shape const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepFilletAPI_MakeFillet\n  * wrapname: _wrap_new_BRepFilletAPI_MakeFillet__SWIG_0\n  * fulldecl: BRepFilletAPI_MakeFillet::BRepFilletAPI_MakeFillet(TopoDS_Shape const &,ChFi3d_FilletShape const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepFilletAPI_MakeFillet *)0;
  }
}


EXPORT BRepFilletAPI_MakeFillet *_wrap_new_BRepFilletAPI_MakeFillet__SWIG_1 (TopoDS_Shape *larg1) {
  BRepFilletAPI_MakeFillet * lresult = (BRepFilletAPI_MakeFillet *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  BRepFilletAPI_MakeFillet *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepFilletAPI_MakeFillet *)new BRepFilletAPI_MakeFillet((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepFilletAPI_MakeFillet\n  * wrapname: _wrap_new_BRepFilletAPI_MakeFillet__SWIG_1\n  * fulldecl: BRepFilletAPI_MakeFillet::BRepFilletAPI_MakeFillet(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepFilletAPI_MakeFillet *)0;
  }
}


EXPORT void _wrap_BRepFilletAPI_MakeFillet_Add (BRepFilletAPI_MakeFillet *larg1, Standard_Real larg2, TopoDS_Edge *larg3) {
  BRepFilletAPI_MakeFillet *arg1 = (BRepFilletAPI_MakeFillet *) 0 ;
  Standard_Real arg2 ;
  TopoDS_Edge *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Add(arg2,(TopoDS_Edge const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepFilletAPI_MakeFillet_Add\n  * wrapname: _wrap_BRepFilletAPI_MakeFillet_Add\n  * fulldecl: void BRepFilletAPI_MakeFillet::Add(Standard_Real const,TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_BRepFilletAPI_MakeFillet (BRepFilletAPI_MakeFillet *larg1) {
  BRepFilletAPI_MakeFillet *arg1 = (BRepFilletAPI_MakeFillet *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepFilletAPI_MakeFillet\n  * wrapname: _wrap_delete_BRepFilletAPI_MakeFillet\n  * fulldecl: BRepFilletAPI_MakeFillet::~BRepFilletAPI_MakeFillet()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepFilletAPI_MakeChamfer *_wrap_new_BRepFilletAPI_MakeChamfer (TopoDS_Shape *larg1) {
  BRepFilletAPI_MakeChamfer * lresult = (BRepFilletAPI_MakeChamfer *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  BRepFilletAPI_MakeChamfer *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepFilletAPI_MakeChamfer *)new BRepFilletAPI_MakeChamfer((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepFilletAPI_MakeChamfer\n  * wrapname: _wrap_new_BRepFilletAPI_MakeChamfer\n  * fulldecl: BRepFilletAPI_MakeChamfer::BRepFilletAPI_MakeChamfer(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepFilletAPI_MakeChamfer *)0;
  }
}


EXPORT void _wrap_BRepFilletAPI_MakeChamfer_Add (BRepFilletAPI_MakeChamfer *larg1, Standard_Real larg2, TopoDS_Edge *larg3, TopoDS_Face *larg4) {
  BRepFilletAPI_MakeChamfer *arg1 = (BRepFilletAPI_MakeChamfer *) 0 ;
  Standard_Real arg2 ;
  TopoDS_Edge *arg3 = 0 ;
  TopoDS_Face *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Add(arg2,(TopoDS_Edge const &)*arg3,(TopoDS_Face const &)*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepFilletAPI_MakeChamfer_Add\n  * wrapname: _wrap_BRepFilletAPI_MakeChamfer_Add\n  * fulldecl: void BRepFilletAPI_MakeChamfer::Add(Standard_Real const,TopoDS_Edge const &,TopoDS_Face const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_BRepFilletAPI_MakeChamfer (BRepFilletAPI_MakeChamfer *larg1) {
  BRepFilletAPI_MakeChamfer *arg1 = (BRepFilletAPI_MakeChamfer *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepFilletAPI_MakeChamfer\n  * wrapname: _wrap_delete_BRepFilletAPI_MakeChamfer\n  * fulldecl: BRepFilletAPI_MakeChamfer::~BRepFilletAPI_MakeChamfer()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include <BRepCheck_Analyzer.hxx>
EXPORT BRepCheck_Analyzer *_wrap_new_BRepCheck_Analyzer__SWIG_0 (TopoDS_Shape *larg1, bool larg2) {
  BRepCheck_Analyzer * lresult = (BRepCheck_Analyzer *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Boolean arg2 ;
  BRepCheck_Analyzer *result = 0 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepCheck_Analyzer *)new BRepCheck_Analyzer((TopoDS_Shape const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepCheck_Analyzer\n  * wrapname: _wrap_new_BRepCheck_Analyzer__SWIG_0\n  * fulldecl: BRepCheck_Analyzer::BRepCheck_Analyzer(TopoDS_Shape const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepCheck_Analyzer *)0;
  }
}


EXPORT BRepCheck_Analyzer *_wrap_new_BRepCheck_Analyzer__SWIG_1 (TopoDS_Shape *larg1) {
  BRepCheck_Analyzer * lresult = (BRepCheck_Analyzer *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  BRepCheck_Analyzer *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepCheck_Analyzer *)new BRepCheck_Analyzer((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepCheck_Analyzer\n  * wrapname: _wrap_new_BRepCheck_Analyzer__SWIG_1\n  * fulldecl: BRepCheck_Analyzer::BRepCheck_Analyzer(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepCheck_Analyzer *)0;
  }
}


EXPORT void _wrap_BRepCheck_Analyzer_Init__SWIG_0 (BRepCheck_Analyzer *larg1, TopoDS_Shape *larg2, bool larg3) {
  BRepCheck_Analyzer *arg1 = (BRepCheck_Analyzer *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init((TopoDS_Shape const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepCheck_Analyzer_Init\n  * wrapname: _wrap_BRepCheck_Analyzer_Init__SWIG_0\n  * fulldecl: void BRepCheck_Analyzer::Init(TopoDS_Shape const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepCheck_Analyzer_Init__SWIG_1 (BRepCheck_Analyzer *larg1, TopoDS_Shape *larg2) {
  BRepCheck_Analyzer *arg1 = (BRepCheck_Analyzer *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepCheck_Analyzer_Init\n  * wrapname: _wrap_BRepCheck_Analyzer_Init__SWIG_1\n  * fulldecl: void BRepCheck_Analyzer::Init(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_BRepCheck_Analyzer_IsValid (BRepCheck_Analyzer *larg1) {
  bool lresult = (bool)0 ;
  BRepCheck_Analyzer *arg1 = (BRepCheck_Analyzer *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepCheck_Analyzer const *)arg1)->IsValid();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepCheck_Analyzer_IsValid\n  * wrapname: _wrap_BRepCheck_Analyzer_IsValid\n  * fulldecl: Standard_Boolean BRepCheck_Analyzer::IsValid() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_delete_BRepCheck_Analyzer (BRepCheck_Analyzer *larg1) {
  BRepCheck_Analyzer *arg1 = (BRepCheck_Analyzer *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepCheck_Analyzer\n  * wrapname: _wrap_delete_BRepCheck_Analyzer\n  * fulldecl: BRepCheck_Analyzer::~BRepCheck_Analyzer()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include <ShapeBuild_ReShape.hxx>
EXPORT ShapeBuild_ReShape *_wrap_new_ShapeBuild_ReShape () {
  ShapeBuild_ReShape * lresult = (ShapeBuild_ReShape *)0 ;
  ShapeBuild_ReShape *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (ShapeBuild_ReShape *)new ShapeBuild_ReShape();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_ShapeBuild_ReShape\n  * wrapname: _wrap_new_ShapeBuild_ReShape\n  * fulldecl: ShapeBuild_ReShape::ShapeBuild_ReShape()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (ShapeBuild_ReShape *)0;
  }
}


EXPORT void _wrap_ShapeBuild_ReShape_Replace__SWIG_0 (ShapeBuild_ReShape *larg1, TopoDS_Shape *larg2, TopoDS_Shape *larg3, bool larg4) {
  ShapeBuild_ReShape *arg1 = (ShapeBuild_ReShape *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopoDS_Shape *arg3 = 0 ;
  Standard_Boolean arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Replace((TopoDS_Shape const &)*arg2,(TopoDS_Shape const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeBuild_ReShape_Replace\n  * wrapname: _wrap_ShapeBuild_ReShape_Replace__SWIG_0\n  * fulldecl: void ShapeBuild_ReShape::Replace(TopoDS_Shape const &,TopoDS_Shape const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_ShapeBuild_ReShape_Replace__SWIG_1 (ShapeBuild_ReShape *larg1, TopoDS_Shape *larg2, TopoDS_Shape *larg3) {
  ShapeBuild_ReShape *arg1 = (ShapeBuild_ReShape *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopoDS_Shape *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Replace((TopoDS_Shape const &)*arg2,(TopoDS_Shape const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeBuild_ReShape_Replace\n  * wrapname: _wrap_ShapeBuild_ReShape_Replace__SWIG_1\n  * fulldecl: void ShapeBuild_ReShape::Replace(TopoDS_Shape const &,TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopoDS_Shape *_wrap_ShapeBuild_ReShape_Apply__SWIG_0 (ShapeBuild_ReShape *larg1, TopoDS_Shape *larg2, TopAbs_ShapeEnum larg3) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  ShapeBuild_ReShape *arg1 = (ShapeBuild_ReShape *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopAbs_ShapeEnum arg3 ;
  TopoDS_Shape result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (arg1)->Apply((TopoDS_Shape const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeBuild_ReShape_Apply\n  * wrapname: _wrap_ShapeBuild_ReShape_Apply__SWIG_0\n  * fulldecl: TopoDS_Shape ShapeBuild_ReShape::Apply(TopoDS_Shape const &,TopAbs_ShapeEnum const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new TopoDS_Shape(result);
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT TopoDS_Shape *_wrap_ShapeBuild_ReShape_Apply__SWIG_1 (ShapeBuild_ReShape *larg1, TopoDS_Shape *larg2) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  ShapeBuild_ReShape *arg1 = (ShapeBuild_ReShape *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopoDS_Shape result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (arg1)->Apply((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeBuild_ReShape_Apply\n  * wrapname: _wrap_ShapeBuild_ReShape_Apply__SWIG_1\n  * fulldecl: TopoDS_Shape ShapeBuild_ReShape::Apply(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new TopoDS_Shape(result);
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT void _wrap_delete_ShapeBuild_ReShape (ShapeBuild_ReShape *larg1) {
  ShapeBuild_ReShape *arg1 = (ShapeBuild_ReShape *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_ShapeBuild_ReShape\n  * wrapname: _wrap_delete_ShapeBuild_ReShape\n  * fulldecl: ShapeBuild_ReShape::~ShapeBuild_ReShape()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <STEPControl_Reader.hxx>
#include <IGESControl_Reader.hxx>
#include <XSControl_WorkSession.hxx>
#include <XSControl_TransferReader.hxx>
#include <StepRepr_RepresentationItem.hxx>
#include <TCollection_HAsciiString.hxx>
#include <IGESData_IGESEntity.hxx>
#include <TransferBRep.hxx>
#include <Transfer_Binder.hxx>
#include <Transfer_TransientProcess.hxx>
#include <Interface_InterfaceModel.hxx>
#include <iostream>
 
EXPORT IFSelect_ReturnStatus _wrap_XSControl_Reader_ReadFile (XSControl_Reader *larg1, Standard_CString larg2) {
  IFSelect_ReturnStatus lresult = (IFSelect_ReturnStatus)0 ;
  XSControl_Reader *arg1 = (XSControl_Reader *) 0 ;
  Standard_CString arg2 = (Standard_CString) (Standard_CString)0 ;
  IFSelect_ReturnStatus result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (IFSelect_ReturnStatus)(arg1)->ReadFile(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: XSControl_Reader_ReadFile\n  * wrapname: _wrap_XSControl_Reader_ReadFile\n  * fulldecl: IFSelect_ReturnStatus XSControl_Reader::ReadFile(Standard_CString const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (IFSelect_ReturnStatus)0;
  }
}


EXPORT Standard_Integer _wrap_XSControl_Reader_TransferRoots (XSControl_Reader *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  XSControl_Reader *arg1 = (XSControl_Reader *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)(arg1)->TransferRoots();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: XSControl_Reader_TransferRoots\n  * wrapname: _wrap_XSControl_Reader_TransferRoots\n  * fulldecl: Standard_Integer XSControl_Reader::TransferRoots()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT void _wrap_XSControl_Reader_ClearShapes (XSControl_Reader *larg1) {
  XSControl_Reader *arg1 = (XSControl_Reader *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->ClearShapes();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: XSControl_Reader_ClearShapes\n  * wrapname: _wrap_XSControl_Reader_ClearShapes\n  * fulldecl: void XSControl_Reader::ClearShapes()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Integer _wrap_XSControl_Reader_NbRootsForTransfer (XSControl_Reader *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  XSControl_Reader *arg1 = (XSControl_Reader *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)(arg1)->NbRootsForTransfer();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: XSControl_Reader_NbRootsForTransfer\n  * wrapname: _wrap_XSControl_Reader_NbRootsForTransfer\n  * fulldecl: Standard_Integer XSControl_Reader::NbRootsForTransfer()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT TopoDS_Shape *_wrap_XSControl_Reader_OneShape (XSControl_Reader *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  XSControl_Reader *arg1 = (XSControl_Reader *) 0 ;
  TopoDS_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((XSControl_Reader const *)arg1)->OneShape();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: XSControl_Reader_OneShape\n  * wrapname: _wrap_XSControl_Reader_OneShape\n  * fulldecl: TopoDS_Shape XSControl_Reader::OneShape() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new TopoDS_Shape(result);
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT void _wrap_delete_XSControl_Reader (XSControl_Reader *larg1) {
  XSControl_Reader *arg1 = (XSControl_Reader *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_XSControl_Reader\n  * wrapname: _wrap_delete_XSControl_Reader\n  * fulldecl: XSControl_Reader::~XSControl_Reader()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT STEPControl_Reader *_wrap_new_STEPControl_Reader () {
  STEPControl_Reader * lresult = (STEPControl_Reader *)0 ;
  STEPControl_Reader *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (STEPControl_Reader *)new STEPControl_Reader();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_STEPControl_Reader\n  * wrapname: _wrap_new_STEPControl_Reader\n  * fulldecl: STEPControl_Reader::STEPControl_Reader()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (STEPControl_Reader *)0;
  }
}


SWIGINTERN char const *STEPControl_Reader_getLabel(STEPControl_Reader *self,TopoDS_Shape *theShape){
		const Handle(XSControl_WorkSession)& theSession = self->WS();
		const Handle(XSControl_TransferReader)& aReader = theSession->TransferReader();
		Handle(Standard_Transient) anEntity = aReader->EntityFromShapeResult(*theShape, 1);
		if (anEntity.IsNull()) {
			// as just mapped
			anEntity = aReader->EntityFromShapeResult (*theShape,-1);
		}

		if (anEntity.IsNull()) {
			// as anything
			anEntity = aReader->EntityFromShapeResult (*theShape,4);
		}

		if (anEntity.IsNull()) {
			cout<<"Warning: XSInterface_STEPReader::ReadAttributes() entity not found"<<endl;
			return NULL;
		}
		else 
		{
			Handle(StepRepr_RepresentationItem) aReprItem;
			aReprItem = Handle(StepRepr_RepresentationItem)::DownCast(anEntity);

			if (aReprItem.IsNull()) {
				cout<<"Error: STEPReader::ReadAttributes(): StepRepr_RepresentationItem Is NULL"<<endl;
				return NULL;
			}
			else 
				return aReprItem->Name()->ToCString();
		}
	}
EXPORT char *_wrap_STEPControl_Reader_getLabel (STEPControl_Reader *larg1, TopoDS_Shape *larg2) {
  char * lresult = (char *)0 ;
  STEPControl_Reader *arg1 = (STEPControl_Reader *) 0 ;
  TopoDS_Shape *arg2 = (TopoDS_Shape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (char *)STEPControl_Reader_getLabel(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: STEPControl_Reader_getLabel\n  * wrapname: _wrap_STEPControl_Reader_getLabel\n  * fulldecl: char const * STEPControl_Reader::getLabel(TopoDS_Shape *)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_STEPControl_Reader (STEPControl_Reader *larg1) {
  STEPControl_Reader *arg1 = (STEPControl_Reader *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_STEPControl_Reader\n  * wrapname: _wrap_delete_STEPControl_Reader\n  * fulldecl: STEPControl_Reader::~STEPControl_Reader()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT IGESControl_Reader *_wrap_new_IGESControl_Reader () {
  IGESControl_Reader * lresult = (IGESControl_Reader *)0 ;
  IGESControl_Reader *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (IGESControl_Reader *)new IGESControl_Reader();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_IGESControl_Reader\n  * wrapname: _wrap_new_IGESControl_Reader\n  * fulldecl: IGESControl_Reader::IGESControl_Reader()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (IGESControl_Reader *)0;
  }
}


SWIGINTERN char const *IGESControl_Reader_getLabel(IGESControl_Reader *self,TopoDS_Shape theShape){
		const Handle(XSControl_WorkSession)& theSession = self->WS();
		const Handle(Interface_InterfaceModel)& theModel = theSession->Model();
		const Handle(XSControl_TransferReader)& aReader = theSession->TransferReader();
		const Handle(Transfer_TransientProcess)& tp = aReader->TransientProcess();
		Standard_Integer nb = theModel->NbEntities(); 
		for(Standard_Integer i=1; i<=nb; i++) 
		{
			Handle(IGESData_IGESEntity) ent = Handle(IGESData_IGESEntity)::DownCast(theModel->Value(i));

			if (ent.IsNull())
				continue;

			Handle(Transfer_Binder) binder = tp->Find(ent); 

			if (binder.IsNull())
				continue;
			TopoDS_Shape oneShape = TransferBRep::ShapeResult(binder);
			if (oneShape.IsNull())
				continue;
			if (oneShape.IsEqual(theShape))
			{
				if (ent->HasName())
					return ent->NameValue()->String().ToCString();
				else
					return NULL; 
			}
		}
		return NULL; 
	}
EXPORT char *_wrap_IGESControl_Reader_getLabel (IGESControl_Reader *larg1, TopoDS_Shape *larg2) {
  char * lresult = (char *)0 ;
  IGESControl_Reader *arg1 = (IGESControl_Reader *) 0 ;
  TopoDS_Shape arg2 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = *larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (char *)IGESControl_Reader_getLabel(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: IGESControl_Reader_getLabel\n  * wrapname: _wrap_IGESControl_Reader_getLabel\n  * fulldecl: char const * IGESControl_Reader::getLabel(TopoDS_Shape)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


SWIGINTERN TopoDS_Shape IGESControl_Reader_getShape(IGESControl_Reader *self,char *shapeName){
		const TCollection_AsciiString ascShapeName(shapeName);
		const Handle(XSControl_WorkSession)& theSession = self->WS();
		const Handle(Interface_InterfaceModel)& theModel = theSession->Model();
		const Handle(XSControl_TransferReader)& aReader = theSession->TransferReader();
		const Handle(Transfer_TransientProcess)& tp = aReader->TransientProcess();
		Standard_Integer nb = theModel->NbEntities();
		TopoDS_Shape retShape; 
		for(Standard_Integer i=1; i<=nb; i++)
		{
			Handle(IGESData_IGESEntity) ent = Handle(IGESData_IGESEntity)::DownCast(theModel->Value(i));

			if (ent.IsNull())
				continue;
			Handle(Transfer_Binder) binder = tp->Find(ent);

			if (binder.IsNull())
				continue;
			TopoDS_Shape oneShape = TransferBRep::ShapeResult(binder);

			if (oneShape.IsNull())
				continue;

			if (ent->HasName() && ent->NameValue()->String().IsEqual(ascShapeName))
				retShape = oneShape;
		}
		return retShape; 
	}
EXPORT TopoDS_Shape *_wrap_IGESControl_Reader_getShape (IGESControl_Reader *larg1, char *larg2) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  IGESControl_Reader *arg1 = (IGESControl_Reader *) 0 ;
  char *arg2 = (char *) 0 ;
  TopoDS_Shape result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = IGESControl_Reader_getShape(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: IGESControl_Reader_getShape\n  * wrapname: _wrap_IGESControl_Reader_getShape\n  * fulldecl: TopoDS_Shape IGESControl_Reader::getShape(char *)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new TopoDS_Shape(result);
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


SWIGINTERN void IGESControl_Reader_dumpLabels(IGESControl_Reader *self){
		const Handle(XSControl_WorkSession)& theSession = self->WS();
		const Handle(Interface_InterfaceModel)& theModel = theSession->Model();
		Standard_Integer nb = theModel->NbEntities();
		for(Standard_Integer i=1; i<=nb; i++)
		{
			Handle(IGESData_IGESEntity) ent = Handle(IGESData_IGESEntity)::DownCast(theModel->Value(i));
			if (ent.IsNull()) continue;
			if (ent->HasName())
			{
				std::cout << ent->NameValue()->String().ToCString() << std::endl;
			}
		}
	}
EXPORT void _wrap_IGESControl_Reader_dumpLabels (IGESControl_Reader *larg1) {
  IGESControl_Reader *arg1 = (IGESControl_Reader *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        IGESControl_Reader_dumpLabels(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: IGESControl_Reader_dumpLabels\n  * wrapname: _wrap_IGESControl_Reader_dumpLabels\n  * fulldecl: void IGESControl_Reader::dumpLabels()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_IGESControl_Reader (IGESControl_Reader *larg1) {
  IGESControl_Reader *arg1 = (IGESControl_Reader *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_IGESControl_Reader\n  * wrapname: _wrap_delete_IGESControl_Reader\n  * fulldecl: IGESControl_Reader::~IGESControl_Reader()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <STEPControl_Writer.hxx>
 
EXPORT STEPControl_Writer *_wrap_new_STEPControl_Writer () {
  STEPControl_Writer * lresult = (STEPControl_Writer *)0 ;
  STEPControl_Writer *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (STEPControl_Writer *)new STEPControl_Writer();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_STEPControl_Writer\n  * wrapname: _wrap_new_STEPControl_Writer\n  * fulldecl: STEPControl_Writer::STEPControl_Writer()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (STEPControl_Writer *)0;
  }
}


EXPORT IFSelect_ReturnStatus _wrap_STEPControl_Writer_Write (STEPControl_Writer *larg1, Standard_CString larg2) {
  IFSelect_ReturnStatus lresult = (IFSelect_ReturnStatus)0 ;
  STEPControl_Writer *arg1 = (STEPControl_Writer *) 0 ;
  Standard_CString arg2 = (Standard_CString) (Standard_CString)0 ;
  IFSelect_ReturnStatus result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (IFSelect_ReturnStatus)(arg1)->Write(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: STEPControl_Writer_Write\n  * wrapname: _wrap_STEPControl_Writer_Write\n  * fulldecl: IFSelect_ReturnStatus STEPControl_Writer::Write(Standard_CString const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (IFSelect_ReturnStatus)0;
  }
}


EXPORT IFSelect_ReturnStatus _wrap_STEPControl_Writer_Transfer (STEPControl_Writer *larg1, TopoDS_Shape *larg2, STEPControl_StepModelType larg3) {
  IFSelect_ReturnStatus lresult = (IFSelect_ReturnStatus)0 ;
  STEPControl_Writer *arg1 = (STEPControl_Writer *) 0 ;
  TopoDS_Shape arg2 ;
  STEPControl_StepModelType arg3 ;
  IFSelect_ReturnStatus result;
  
  arg1 = larg1;
  arg2 = *larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (IFSelect_ReturnStatus)(arg1)->Transfer(arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: STEPControl_Writer_Transfer\n  * wrapname: _wrap_STEPControl_Writer_Transfer\n  * fulldecl: IFSelect_ReturnStatus STEPControl_Writer::Transfer(TopoDS_Shape,STEPControl_StepModelType)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (IFSelect_ReturnStatus)0;
  }
}


EXPORT void _wrap_delete_STEPControl_Writer (STEPControl_Writer *larg1) {
  STEPControl_Writer *arg1 = (STEPControl_Writer *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_STEPControl_Writer\n  * wrapname: _wrap_delete_STEPControl_Writer\n  * fulldecl: STEPControl_Writer::~STEPControl_Writer()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <IGESControl_Writer.hxx>
 
EXPORT IGESControl_Writer *_wrap_new_IGESControl_Writer__SWIG_0 () {
  IGESControl_Writer * lresult = (IGESControl_Writer *)0 ;
  IGESControl_Writer *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (IGESControl_Writer *)new IGESControl_Writer();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_IGESControl_Writer\n  * wrapname: _wrap_new_IGESControl_Writer__SWIG_0\n  * fulldecl: IGESControl_Writer::IGESControl_Writer()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (IGESControl_Writer *)0;
  }
}


EXPORT IGESControl_Writer *_wrap_new_IGESControl_Writer__SWIG_1 (Standard_CString larg1, Standard_Integer larg2) {
  IGESControl_Writer * lresult = (IGESControl_Writer *)0 ;
  Standard_CString arg1 = (Standard_CString) (Standard_CString)0 ;
  Standard_Integer arg2 ;
  IGESControl_Writer *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (IGESControl_Writer *)new IGESControl_Writer(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_IGESControl_Writer\n  * wrapname: _wrap_new_IGESControl_Writer__SWIG_1\n  * fulldecl: IGESControl_Writer::IGESControl_Writer(Standard_CString const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (IGESControl_Writer *)0;
  }
}


EXPORT IGESControl_Writer *_wrap_new_IGESControl_Writer__SWIG_2 (Standard_CString larg1) {
  IGESControl_Writer * lresult = (IGESControl_Writer *)0 ;
  Standard_CString arg1 = (Standard_CString) (Standard_CString)0 ;
  IGESControl_Writer *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (IGESControl_Writer *)new IGESControl_Writer(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_IGESControl_Writer\n  * wrapname: _wrap_new_IGESControl_Writer__SWIG_2\n  * fulldecl: IGESControl_Writer::IGESControl_Writer(Standard_CString const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (IGESControl_Writer *)0;
  }
}


EXPORT bool _wrap_IGESControl_Writer_Write (IGESControl_Writer *larg1, Standard_CString larg2) {
  bool lresult = (bool)0 ;
  IGESControl_Writer *arg1 = (IGESControl_Writer *) 0 ;
  Standard_CString arg2 = (Standard_CString) (Standard_CString)0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->Write(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: IGESControl_Writer_Write\n  * wrapname: _wrap_IGESControl_Writer_Write\n  * fulldecl: Standard_Boolean IGESControl_Writer::Write(Standard_CString const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_IGESControl_Writer_AddShape (IGESControl_Writer *larg1, TopoDS_Shape *larg2) {
  bool lresult = (bool)0 ;
  IGESControl_Writer *arg1 = (IGESControl_Writer *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->AddShape((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: IGESControl_Writer_AddShape\n  * wrapname: _wrap_IGESControl_Writer_AddShape\n  * fulldecl: Standard_Boolean IGESControl_Writer::AddShape(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_IGESControl_Writer_ComputeModel (IGESControl_Writer *larg1) {
  IGESControl_Writer *arg1 = (IGESControl_Writer *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->ComputeModel();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: IGESControl_Writer_ComputeModel\n  * wrapname: _wrap_IGESControl_Writer_ComputeModel\n  * fulldecl: void IGESControl_Writer::ComputeModel()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_IGESControl_Writer (IGESControl_Writer *larg1) {
  IGESControl_Writer *arg1 = (IGESControl_Writer *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_IGESControl_Writer\n  * wrapname: _wrap_delete_IGESControl_Writer\n  * fulldecl: IGESControl_Writer::~IGESControl_Writer()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <IGESControl_Controller.hxx>
 
EXPORT IGESControl_Controller *_wrap_new_IGESControl_Controller () {
  IGESControl_Controller * lresult = (IGESControl_Controller *)0 ;
  IGESControl_Controller *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (IGESControl_Controller *)new IGESControl_Controller();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_IGESControl_Controller\n  * wrapname: _wrap_new_IGESControl_Controller\n  * fulldecl: IGESControl_Controller::IGESControl_Controller()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (IGESControl_Controller *)0;
  }
}


EXPORT void _wrap_IGESControl_Controller_Init (IGESControl_Controller *larg1) {
  IGESControl_Controller *arg1 = (IGESControl_Controller *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: IGESControl_Controller_Init\n  * wrapname: _wrap_IGESControl_Controller_Init\n  * fulldecl: void IGESControl_Controller::Init()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_IGESControl_Controller (IGESControl_Controller *larg1) {
  IGESControl_Controller *arg1 = (IGESControl_Controller *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_IGESControl_Controller\n  * wrapname: _wrap_delete_IGESControl_Controller\n  * fulldecl: IGESControl_Controller::~IGESControl_Controller()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <ShapeFix_Wireframe.hxx>
#include <ShapeFix_Root.hxx>
#include <ShapeBuild_ReShape.hxx>
#include <Message_ProgressIndicator.hxx>
#include <ShapeFix_Shape.hxx>
#include <ShapeFix_Solid.hxx>
#include <ShapeFix_Shell.hxx>
#include <ShapeFix_Face.hxx>
#include <ShapeFix_Wire.hxx>
#include <ShapeFix_Edge.hxx>

EXPORT void _wrap_ShapeFix_Root_SetPrecision (ShapeFix_Root *larg1, Standard_Real larg2) {
  ShapeFix_Root *arg1 = (ShapeFix_Root *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetPrecision(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Root_SetPrecision\n  * wrapname: _wrap_ShapeFix_Root_SetPrecision\n  * fulldecl: void ShapeFix_Root::SetPrecision(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Real _wrap_ShapeFix_Root_Precision (ShapeFix_Root *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  ShapeFix_Root *arg1 = (ShapeFix_Root *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((ShapeFix_Root const *)arg1)->Precision();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Root_Precision\n  * wrapname: _wrap_ShapeFix_Root_Precision\n  * fulldecl: Standard_Real ShapeFix_Root::Precision() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_ShapeFix_Root_SetContext (ShapeFix_Root *larg1, ShapeBuild_ReShape *larg2) {
  ShapeFix_Root *arg1 = (ShapeFix_Root *) 0 ;
  ShapeBuild_ReShape *arg2 = (ShapeBuild_ReShape *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetContext((ShapeBuild_ReShape const *)arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Root_SetContext\n  * wrapname: _wrap_ShapeFix_Root_SetContext\n  * fulldecl: void ShapeFix_Root::SetContext(ShapeBuild_ReShape const *)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_ShapeBuild_ReShape ShapeFix_Root_getContext(ShapeFix_Root *self){
        Handle_ShapeBuild_ReShape p = self->Context();
        return p;
    }
EXPORT Handle_ShapeBuild_ReShape *_wrap_ShapeFix_Root_getContext (ShapeFix_Root *larg1) {
  Handle_ShapeBuild_ReShape * lresult = (Handle_ShapeBuild_ReShape *)0 ;
  ShapeFix_Root *arg1 = (ShapeFix_Root *) 0 ;
  Handle_ShapeBuild_ReShape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ShapeFix_Root_getContext(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Root_getContext\n  * wrapname: _wrap_ShapeFix_Root_getContext\n  * fulldecl: Handle_ShapeBuild_ReShape ShapeFix_Root::getContext()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_ShapeBuild_ReShape(result);
    return lresult;
  } catch (...) {
    return (Handle_ShapeBuild_ReShape *)0;
  }
}


EXPORT void _wrap_delete_ShapeFix_Root (ShapeFix_Root *larg1) {
  ShapeFix_Root *arg1 = (ShapeFix_Root *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_ShapeFix_Root\n  * wrapname: _wrap_delete_ShapeFix_Root\n  * fulldecl: ShapeFix_Root::~ShapeFix_Root()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT ShapeFix_Wireframe *_wrap_new_ShapeFix_Wireframe (TopoDS_Shape *larg1) {
  ShapeFix_Wireframe * lresult = (ShapeFix_Wireframe *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  ShapeFix_Wireframe *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (ShapeFix_Wireframe *)new ShapeFix_Wireframe((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_ShapeFix_Wireframe\n  * wrapname: _wrap_new_ShapeFix_Wireframe\n  * fulldecl: ShapeFix_Wireframe::ShapeFix_Wireframe(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (ShapeFix_Wireframe *)0;
  }
}


EXPORT bool _wrap_ShapeFix_Wireframe_FixWireGaps (ShapeFix_Wireframe *larg1) {
  bool lresult = (bool)0 ;
  ShapeFix_Wireframe *arg1 = (ShapeFix_Wireframe *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->FixWireGaps();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Wireframe_FixWireGaps\n  * wrapname: _wrap_ShapeFix_Wireframe_FixWireGaps\n  * fulldecl: Standard_Boolean ShapeFix_Wireframe::FixWireGaps()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_ShapeFix_Wireframe_FixSmallEdges (ShapeFix_Wireframe *larg1) {
  bool lresult = (bool)0 ;
  ShapeFix_Wireframe *arg1 = (ShapeFix_Wireframe *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->FixSmallEdges();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Wireframe_FixSmallEdges\n  * wrapname: _wrap_ShapeFix_Wireframe_FixSmallEdges\n  * fulldecl: Standard_Boolean ShapeFix_Wireframe::FixSmallEdges()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_ShapeFix_Wireframe_SetLimitAngle (ShapeFix_Wireframe *larg1, Standard_Real larg2) {
  ShapeFix_Wireframe *arg1 = (ShapeFix_Wireframe *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLimitAngle(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Wireframe_SetLimitAngle\n  * wrapname: _wrap_ShapeFix_Wireframe_SetLimitAngle\n  * fulldecl: void ShapeFix_Wireframe::SetLimitAngle(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Real _wrap_ShapeFix_Wireframe_LimitAngle (ShapeFix_Wireframe *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  ShapeFix_Wireframe *arg1 = (ShapeFix_Wireframe *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((ShapeFix_Wireframe const *)arg1)->LimitAngle();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Wireframe_LimitAngle\n  * wrapname: _wrap_ShapeFix_Wireframe_LimitAngle\n  * fulldecl: Standard_Real ShapeFix_Wireframe::LimitAngle() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT TopoDS_Shape *_wrap_ShapeFix_Wireframe_Shape (ShapeFix_Wireframe *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  ShapeFix_Wireframe *arg1 = (ShapeFix_Wireframe *) 0 ;
  TopoDS_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (arg1)->Shape();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Wireframe_Shape\n  * wrapname: _wrap_ShapeFix_Wireframe_Shape\n  * fulldecl: TopoDS_Shape ShapeFix_Wireframe::Shape()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new TopoDS_Shape(result);
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


SWIGINTERN void ShapeFix_Wireframe_setDropSmallEdges(ShapeFix_Wireframe *self,bool b){
		self->ModeDropSmallEdges()=b;
	}
EXPORT void _wrap_ShapeFix_Wireframe_setDropSmallEdges (ShapeFix_Wireframe *larg1, bool larg2) {
  ShapeFix_Wireframe *arg1 = (ShapeFix_Wireframe *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ShapeFix_Wireframe_setDropSmallEdges(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Wireframe_setDropSmallEdges\n  * wrapname: _wrap_ShapeFix_Wireframe_setDropSmallEdges\n  * fulldecl: void ShapeFix_Wireframe::setDropSmallEdges(bool)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN bool ShapeFix_Wireframe_getDropSmallEdges(ShapeFix_Wireframe *self){
        return self->ModeDropSmallEdges()!=0;
	}
EXPORT bool _wrap_ShapeFix_Wireframe_getDropSmallEdges (ShapeFix_Wireframe *larg1) {
  bool lresult = (bool)0 ;
  ShapeFix_Wireframe *arg1 = (ShapeFix_Wireframe *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (bool)ShapeFix_Wireframe_getDropSmallEdges(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Wireframe_getDropSmallEdges\n  * wrapname: _wrap_ShapeFix_Wireframe_getDropSmallEdges\n  * fulldecl: bool ShapeFix_Wireframe::getDropSmallEdges()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_delete_ShapeFix_Wireframe (ShapeFix_Wireframe *larg1) {
  ShapeFix_Wireframe *arg1 = (ShapeFix_Wireframe *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_ShapeFix_Wireframe\n  * wrapname: _wrap_delete_ShapeFix_Wireframe\n  * fulldecl: ShapeFix_Wireframe::~ShapeFix_Wireframe()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT ShapeFix_Shape *_wrap_new_ShapeFix_Shape (TopoDS_Shape *larg1) {
  ShapeFix_Shape * lresult = (ShapeFix_Shape *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  ShapeFix_Shape *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (ShapeFix_Shape *)new ShapeFix_Shape((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_ShapeFix_Shape\n  * wrapname: _wrap_new_ShapeFix_Shape\n  * fulldecl: ShapeFix_Shape::ShapeFix_Shape(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (ShapeFix_Shape *)0;
  }
}


EXPORT TopoDS_Shape *_wrap_ShapeFix_Shape_Shape (ShapeFix_Shape *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  ShapeFix_Shape *arg1 = (ShapeFix_Shape *) 0 ;
  TopoDS_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((ShapeFix_Shape const *)arg1)->Shape();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Shape_Shape\n  * wrapname: _wrap_ShapeFix_Shape_Shape\n  * fulldecl: TopoDS_Shape ShapeFix_Shape::Shape() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new TopoDS_Shape(result);
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT bool _wrap_ShapeFix_Shape_Perform__SWIG_0 (ShapeFix_Shape *larg1, Handle_Message_ProgressIndicator *larg2) {
  bool lresult = (bool)0 ;
  ShapeFix_Shape *arg1 = (ShapeFix_Shape *) 0 ;
  Handle_Message_ProgressIndicator *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->Perform((Handle_Message_ProgressIndicator const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Shape_Perform\n  * wrapname: _wrap_ShapeFix_Shape_Perform__SWIG_0\n  * fulldecl: Standard_Boolean ShapeFix_Shape::Perform(Handle_Message_ProgressIndicator const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_ShapeFix_Shape_Perform__SWIG_1 (ShapeFix_Shape *larg1) {
  bool lresult = (bool)0 ;
  ShapeFix_Shape *arg1 = (ShapeFix_Shape *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->Perform();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Shape_Perform\n  * wrapname: _wrap_ShapeFix_Shape_Perform__SWIG_1\n  * fulldecl: Standard_Boolean ShapeFix_Shape::Perform()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Handle_ShapeFix_Solid *_wrap_ShapeFix_Shape_FixSolidTool (ShapeFix_Shape *larg1) {
  Handle_ShapeFix_Solid * lresult = (Handle_ShapeFix_Solid *)0 ;
  ShapeFix_Shape *arg1 = (ShapeFix_Shape *) 0 ;
  Handle_ShapeFix_Solid result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((ShapeFix_Shape const *)arg1)->FixSolidTool();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Shape_FixSolidTool\n  * wrapname: _wrap_ShapeFix_Shape_FixSolidTool\n  * fulldecl: Handle_ShapeFix_Solid ShapeFix_Shape::FixSolidTool() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_ShapeFix_Solid(result);
    return lresult;
  } catch (...) {
    return (Handle_ShapeFix_Solid *)0;
  }
}


EXPORT Handle_ShapeFix_Shell *_wrap_ShapeFix_Shape_FixShellTool (ShapeFix_Shape *larg1) {
  Handle_ShapeFix_Shell * lresult = (Handle_ShapeFix_Shell *)0 ;
  ShapeFix_Shape *arg1 = (ShapeFix_Shape *) 0 ;
  Handle_ShapeFix_Shell result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((ShapeFix_Shape const *)arg1)->FixShellTool();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Shape_FixShellTool\n  * wrapname: _wrap_ShapeFix_Shape_FixShellTool\n  * fulldecl: Handle_ShapeFix_Shell ShapeFix_Shape::FixShellTool() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_ShapeFix_Shell(result);
    return lresult;
  } catch (...) {
    return (Handle_ShapeFix_Shell *)0;
  }
}


EXPORT Handle_ShapeFix_Face *_wrap_ShapeFix_Shape_FixFaceTool (ShapeFix_Shape *larg1) {
  Handle_ShapeFix_Face * lresult = (Handle_ShapeFix_Face *)0 ;
  ShapeFix_Shape *arg1 = (ShapeFix_Shape *) 0 ;
  Handle_ShapeFix_Face result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((ShapeFix_Shape const *)arg1)->FixFaceTool();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Shape_FixFaceTool\n  * wrapname: _wrap_ShapeFix_Shape_FixFaceTool\n  * fulldecl: Handle_ShapeFix_Face ShapeFix_Shape::FixFaceTool() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_ShapeFix_Face(result);
    return lresult;
  } catch (...) {
    return (Handle_ShapeFix_Face *)0;
  }
}


EXPORT Handle_ShapeFix_Wire *_wrap_ShapeFix_Shape_FixWireTool (ShapeFix_Shape *larg1) {
  Handle_ShapeFix_Wire * lresult = (Handle_ShapeFix_Wire *)0 ;
  ShapeFix_Shape *arg1 = (ShapeFix_Shape *) 0 ;
  Handle_ShapeFix_Wire result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((ShapeFix_Shape const *)arg1)->FixWireTool();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Shape_FixWireTool\n  * wrapname: _wrap_ShapeFix_Shape_FixWireTool\n  * fulldecl: Handle_ShapeFix_Wire ShapeFix_Shape::FixWireTool() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_ShapeFix_Wire(result);
    return lresult;
  } catch (...) {
    return (Handle_ShapeFix_Wire *)0;
  }
}


EXPORT Handle_ShapeFix_Edge *_wrap_ShapeFix_Shape_FixEdgeTool (ShapeFix_Shape *larg1) {
  Handle_ShapeFix_Edge * lresult = (Handle_ShapeFix_Edge *)0 ;
  ShapeFix_Shape *arg1 = (ShapeFix_Shape *) 0 ;
  Handle_ShapeFix_Edge result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((ShapeFix_Shape const *)arg1)->FixEdgeTool();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Shape_FixEdgeTool\n  * wrapname: _wrap_ShapeFix_Shape_FixEdgeTool\n  * fulldecl: Handle_ShapeFix_Edge ShapeFix_Shape::FixEdgeTool() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_ShapeFix_Edge(result);
    return lresult;
  } catch (...) {
    return (Handle_ShapeFix_Edge *)0;
  }
}


EXPORT void _wrap_delete_ShapeFix_Shape (ShapeFix_Shape *larg1) {
  ShapeFix_Shape *arg1 = (ShapeFix_Shape *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_ShapeFix_Shape\n  * wrapname: _wrap_delete_ShapeFix_Shape\n  * fulldecl: ShapeFix_Shape::~ShapeFix_Shape()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_Message_ProgressIndicator (Handle_Message_ProgressIndicator *larg1) {
  Handle_Message_ProgressIndicator *arg1 = (Handle_Message_ProgressIndicator *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Message_ProgressIndicator\n  * wrapname: _wrap_delete_Message_ProgressIndicator\n  * fulldecl: Handle_Message_ProgressIndicator::~Handle_Message_ProgressIndicator()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <ShapeAnalysis_Edge.hxx>
#include <ShapeAnalysis_Surface.hxx>

EXPORT ShapeAnalysis_Edge *_wrap_new_ShapeAnalysis_Edge () {
  ShapeAnalysis_Edge * lresult = (ShapeAnalysis_Edge *)0 ;
  ShapeAnalysis_Edge *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (ShapeAnalysis_Edge *)new ShapeAnalysis_Edge();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_ShapeAnalysis_Edge\n  * wrapname: _wrap_new_ShapeAnalysis_Edge\n  * fulldecl: ShapeAnalysis_Edge::ShapeAnalysis_Edge()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (ShapeAnalysis_Edge *)0;
  }
}


EXPORT bool _wrap_ShapeAnalysis_Edge_IsClosed3d (ShapeAnalysis_Edge *larg1, TopoDS_Edge *larg2) {
  bool lresult = (bool)0 ;
  ShapeAnalysis_Edge *arg1 = (ShapeAnalysis_Edge *) 0 ;
  TopoDS_Edge *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((ShapeAnalysis_Edge const *)arg1)->IsClosed3d((TopoDS_Edge const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeAnalysis_Edge_IsClosed3d\n  * wrapname: _wrap_ShapeAnalysis_Edge_IsClosed3d\n  * fulldecl: Standard_Boolean ShapeAnalysis_Edge::IsClosed3d(TopoDS_Edge const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_ShapeAnalysis_Edge_HasPCurve (ShapeAnalysis_Edge *larg1, TopoDS_Edge *larg2, TopoDS_Face *larg3) {
  bool lresult = (bool)0 ;
  ShapeAnalysis_Edge *arg1 = (ShapeAnalysis_Edge *) 0 ;
  TopoDS_Edge *arg2 = 0 ;
  TopoDS_Face *arg3 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((ShapeAnalysis_Edge const *)arg1)->HasPCurve((TopoDS_Edge const &)*arg2,(TopoDS_Face const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeAnalysis_Edge_HasPCurve\n  * wrapname: _wrap_ShapeAnalysis_Edge_HasPCurve\n  * fulldecl: Standard_Boolean ShapeAnalysis_Edge::HasPCurve(TopoDS_Edge const &,TopoDS_Face const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_ShapeAnalysis_Edge_IsSeam (ShapeAnalysis_Edge *larg1, TopoDS_Edge *larg2, TopoDS_Face *larg3) {
  bool lresult = (bool)0 ;
  ShapeAnalysis_Edge *arg1 = (ShapeAnalysis_Edge *) 0 ;
  TopoDS_Edge *arg2 = 0 ;
  TopoDS_Face *arg3 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((ShapeAnalysis_Edge const *)arg1)->IsSeam((TopoDS_Edge const &)*arg2,(TopoDS_Face const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeAnalysis_Edge_IsSeam\n  * wrapname: _wrap_ShapeAnalysis_Edge_IsSeam\n  * fulldecl: Standard_Boolean ShapeAnalysis_Edge::IsSeam(TopoDS_Edge const &,TopoDS_Face const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_delete_ShapeAnalysis_Edge (ShapeAnalysis_Edge *larg1) {
  ShapeAnalysis_Edge *arg1 = (ShapeAnalysis_Edge *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_ShapeAnalysis_Edge\n  * wrapname: _wrap_delete_ShapeAnalysis_Edge\n  * fulldecl: ShapeAnalysis_Edge::~ShapeAnalysis_Edge()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT ShapeAnalysis_Surface *_wrap_new_ShapeAnalysis_Surface (Handle_Geom_Surface *larg1) {
  ShapeAnalysis_Surface * lresult = (ShapeAnalysis_Surface *)0 ;
  Handle_Geom_Surface *arg1 = 0 ;
  ShapeAnalysis_Surface *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (ShapeAnalysis_Surface *)new ShapeAnalysis_Surface((Handle_Geom_Surface const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_ShapeAnalysis_Surface\n  * wrapname: _wrap_new_ShapeAnalysis_Surface\n  * fulldecl: ShapeAnalysis_Surface::ShapeAnalysis_Surface(Handle_Geom_Surface const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (ShapeAnalysis_Surface *)0;
  }
}


EXPORT bool _wrap_ShapeAnalysis_Surface_HasSingularities (ShapeAnalysis_Surface *larg1, Standard_Real larg2) {
  bool lresult = (bool)0 ;
  ShapeAnalysis_Surface *arg1 = (ShapeAnalysis_Surface *) 0 ;
  Standard_Real arg2 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->HasSingularities(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeAnalysis_Surface_HasSingularities\n  * wrapname: _wrap_ShapeAnalysis_Surface_HasSingularities\n  * fulldecl: Standard_Boolean ShapeAnalysis_Surface::HasSingularities(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Standard_Integer _wrap_ShapeAnalysis_Surface_NbSingularities (ShapeAnalysis_Surface *larg1, Standard_Real larg2) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  ShapeAnalysis_Surface *arg1 = (ShapeAnalysis_Surface *) 0 ;
  Standard_Real arg2 ;
  Standard_Integer result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)(arg1)->NbSingularities(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeAnalysis_Surface_NbSingularities\n  * wrapname: _wrap_ShapeAnalysis_Surface_NbSingularities\n  * fulldecl: Standard_Integer ShapeAnalysis_Surface::NbSingularities(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT bool _wrap_ShapeAnalysis_Surface_IsDegenerated (ShapeAnalysis_Surface *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  ShapeAnalysis_Surface *arg1 = (ShapeAnalysis_Surface *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->IsDegenerated((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeAnalysis_Surface_IsDegenerated\n  * wrapname: _wrap_ShapeAnalysis_Surface_IsDegenerated\n  * fulldecl: Standard_Boolean ShapeAnalysis_Surface::IsDegenerated(gp_Pnt const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_delete_ShapeAnalysis_Surface (ShapeAnalysis_Surface *larg1) {
  ShapeAnalysis_Surface *arg1 = (ShapeAnalysis_Surface *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_ShapeAnalysis_Surface\n  * wrapname: _wrap_delete_ShapeAnalysis_Surface\n  * fulldecl: ShapeAnalysis_Surface::~ShapeAnalysis_Surface()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <APIHeaderSection_MakeHeader.hxx>
#include <StepData_StepModel.hxx>

EXPORT APIHeaderSection_MakeHeader *_wrap_new_APIHeaderSection_MakeHeader (Handle_StepData_StepModel *larg1) {
  APIHeaderSection_MakeHeader * lresult = (APIHeaderSection_MakeHeader *)0 ;
  Handle_StepData_StepModel *arg1 = 0 ;
  APIHeaderSection_MakeHeader *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (APIHeaderSection_MakeHeader *)new APIHeaderSection_MakeHeader((Handle_StepData_StepModel const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_APIHeaderSection_MakeHeader\n  * wrapname: _wrap_new_APIHeaderSection_MakeHeader\n  * fulldecl: APIHeaderSection_MakeHeader::APIHeaderSection_MakeHeader(Handle_StepData_StepModel const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (APIHeaderSection_MakeHeader *)0;
  }
}


EXPORT void _wrap_APIHeaderSection_MakeHeader_SetName (APIHeaderSection_MakeHeader *larg1, Handle_TCollection_HAsciiString *larg2) {
  APIHeaderSection_MakeHeader *arg1 = (APIHeaderSection_MakeHeader *) 0 ;
  Handle_TCollection_HAsciiString *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetName((Handle_TCollection_HAsciiString const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: APIHeaderSection_MakeHeader_SetName\n  * wrapname: _wrap_APIHeaderSection_MakeHeader_SetName\n  * fulldecl: void APIHeaderSection_MakeHeader::SetName(Handle_TCollection_HAsciiString const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_APIHeaderSection_MakeHeader_SetAuthorValue (APIHeaderSection_MakeHeader *larg1, Standard_Integer larg2, Handle_TCollection_HAsciiString *larg3) {
  APIHeaderSection_MakeHeader *arg1 = (APIHeaderSection_MakeHeader *) 0 ;
  Standard_Integer arg2 ;
  Handle_TCollection_HAsciiString *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetAuthorValue(arg2,(Handle_TCollection_HAsciiString const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: APIHeaderSection_MakeHeader_SetAuthorValue\n  * wrapname: _wrap_APIHeaderSection_MakeHeader_SetAuthorValue\n  * fulldecl: void APIHeaderSection_MakeHeader::SetAuthorValue(Standard_Integer const,Handle_TCollection_HAsciiString const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_APIHeaderSection_MakeHeader_SetOrganizationValue (APIHeaderSection_MakeHeader *larg1, Standard_Integer larg2, Handle_TCollection_HAsciiString *larg3) {
  APIHeaderSection_MakeHeader *arg1 = (APIHeaderSection_MakeHeader *) 0 ;
  Standard_Integer arg2 ;
  Handle_TCollection_HAsciiString *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetOrganizationValue(arg2,(Handle_TCollection_HAsciiString const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: APIHeaderSection_MakeHeader_SetOrganizationValue\n  * wrapname: _wrap_APIHeaderSection_MakeHeader_SetOrganizationValue\n  * fulldecl: void APIHeaderSection_MakeHeader::SetOrganizationValue(Standard_Integer const,Handle_TCollection_HAsciiString const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_APIHeaderSection_MakeHeader_SetOriginatingSystem (APIHeaderSection_MakeHeader *larg1, Handle_TCollection_HAsciiString *larg2) {
  APIHeaderSection_MakeHeader *arg1 = (APIHeaderSection_MakeHeader *) 0 ;
  Handle_TCollection_HAsciiString *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetOriginatingSystem((Handle_TCollection_HAsciiString const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: APIHeaderSection_MakeHeader_SetOriginatingSystem\n  * wrapname: _wrap_APIHeaderSection_MakeHeader_SetOriginatingSystem\n  * fulldecl: void APIHeaderSection_MakeHeader::SetOriginatingSystem(Handle_TCollection_HAsciiString const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_APIHeaderSection_MakeHeader_SetDescriptionValue (APIHeaderSection_MakeHeader *larg1, Standard_Integer larg2, Handle_TCollection_HAsciiString *larg3) {
  APIHeaderSection_MakeHeader *arg1 = (APIHeaderSection_MakeHeader *) 0 ;
  Standard_Integer arg2 ;
  Handle_TCollection_HAsciiString *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetDescriptionValue(arg2,(Handle_TCollection_HAsciiString const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: APIHeaderSection_MakeHeader_SetDescriptionValue\n  * wrapname: _wrap_APIHeaderSection_MakeHeader_SetDescriptionValue\n  * fulldecl: void APIHeaderSection_MakeHeader::SetDescriptionValue(Standard_Integer const,Handle_TCollection_HAsciiString const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_APIHeaderSection_MakeHeader (APIHeaderSection_MakeHeader *larg1) {
  APIHeaderSection_MakeHeader *arg1 = (APIHeaderSection_MakeHeader *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_APIHeaderSection_MakeHeader\n  * wrapname: _wrap_delete_APIHeaderSection_MakeHeader\n  * fulldecl: APIHeaderSection_MakeHeader::~APIHeaderSection_MakeHeader()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


 #include <ShapeUpgrade_RemoveInternalWires.hxx> 
 #include <ShapeUpgrade_Tool.hxx> 
 #include <ShapeUpgrade_ShapeDivideArea.hxx> 
EXPORT void _wrap_delete_ShapeUpgrade_Tool (ShapeUpgrade_Tool *larg1) {
  ShapeUpgrade_Tool *arg1 = (ShapeUpgrade_Tool *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_ShapeUpgrade_Tool\n  * wrapname: _wrap_delete_ShapeUpgrade_Tool\n  * fulldecl: ShapeUpgrade_Tool::~ShapeUpgrade_Tool()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT ShapeUpgrade_RemoveInternalWires *_wrap_new_ShapeUpgrade_RemoveInternalWires (TopoDS_Shape *larg1) {
  ShapeUpgrade_RemoveInternalWires * lresult = (ShapeUpgrade_RemoveInternalWires *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  ShapeUpgrade_RemoveInternalWires *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (ShapeUpgrade_RemoveInternalWires *)new ShapeUpgrade_RemoveInternalWires((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_ShapeUpgrade_RemoveInternalWires\n  * wrapname: _wrap_new_ShapeUpgrade_RemoveInternalWires\n  * fulldecl: ShapeUpgrade_RemoveInternalWires::ShapeUpgrade_RemoveInternalWires(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (ShapeUpgrade_RemoveInternalWires *)0;
  }
}


EXPORT bool _wrap_ShapeUpgrade_RemoveInternalWires_Perform (ShapeUpgrade_RemoveInternalWires *larg1) {
  bool lresult = (bool)0 ;
  ShapeUpgrade_RemoveInternalWires *arg1 = (ShapeUpgrade_RemoveInternalWires *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->Perform();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeUpgrade_RemoveInternalWires_Perform\n  * wrapname: _wrap_ShapeUpgrade_RemoveInternalWires_Perform\n  * fulldecl: Standard_Boolean ShapeUpgrade_RemoveInternalWires::Perform()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT TopoDS_Shape *_wrap_ShapeUpgrade_RemoveInternalWires_GetResult (ShapeUpgrade_RemoveInternalWires *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  ShapeUpgrade_RemoveInternalWires *arg1 = (ShapeUpgrade_RemoveInternalWires *) 0 ;
  TopoDS_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((ShapeUpgrade_RemoveInternalWires const *)arg1)->GetResult();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeUpgrade_RemoveInternalWires_GetResult\n  * wrapname: _wrap_ShapeUpgrade_RemoveInternalWires_GetResult\n  * fulldecl: TopoDS_Shape ShapeUpgrade_RemoveInternalWires::GetResult() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new TopoDS_Shape(result);
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


SWIGINTERN void ShapeUpgrade_RemoveInternalWires_setMinArea(ShapeUpgrade_RemoveInternalWires *self,double d){
		self->MinArea()=d;
	}
EXPORT void _wrap_ShapeUpgrade_RemoveInternalWires_setMinArea (ShapeUpgrade_RemoveInternalWires *larg1, double larg2) {
  ShapeUpgrade_RemoveInternalWires *arg1 = (ShapeUpgrade_RemoveInternalWires *) 0 ;
  double arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ShapeUpgrade_RemoveInternalWires_setMinArea(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeUpgrade_RemoveInternalWires_setMinArea\n  * wrapname: _wrap_ShapeUpgrade_RemoveInternalWires_setMinArea\n  * fulldecl: void ShapeUpgrade_RemoveInternalWires::setMinArea(double)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN double ShapeUpgrade_RemoveInternalWires_getMinArea(ShapeUpgrade_RemoveInternalWires *self){
		return self->MinArea();
	}
EXPORT double _wrap_ShapeUpgrade_RemoveInternalWires_getMinArea (ShapeUpgrade_RemoveInternalWires *larg1) {
  double lresult = (double)0 ;
  ShapeUpgrade_RemoveInternalWires *arg1 = (ShapeUpgrade_RemoveInternalWires *) 0 ;
  double result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (double)ShapeUpgrade_RemoveInternalWires_getMinArea(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeUpgrade_RemoveInternalWires_getMinArea\n  * wrapname: _wrap_ShapeUpgrade_RemoveInternalWires_getMinArea\n  * fulldecl: double ShapeUpgrade_RemoveInternalWires::getMinArea()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (double)0;
  }
}


SWIGINTERN void ShapeUpgrade_RemoveInternalWires_setRemoveFaceMode(ShapeUpgrade_RemoveInternalWires *self,Standard_Boolean b){
		self->RemoveFaceMode()=b;
	}
EXPORT void _wrap_ShapeUpgrade_RemoveInternalWires_setRemoveFaceMode (ShapeUpgrade_RemoveInternalWires *larg1, bool larg2) {
  ShapeUpgrade_RemoveInternalWires *arg1 = (ShapeUpgrade_RemoveInternalWires *) 0 ;
  Standard_Boolean arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ShapeUpgrade_RemoveInternalWires_setRemoveFaceMode(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeUpgrade_RemoveInternalWires_setRemoveFaceMode\n  * wrapname: _wrap_ShapeUpgrade_RemoveInternalWires_setRemoveFaceMode\n  * fulldecl: void ShapeUpgrade_RemoveInternalWires::setRemoveFaceMode(Standard_Boolean)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Boolean ShapeUpgrade_RemoveInternalWires_getRemoveFaceMode(ShapeUpgrade_RemoveInternalWires *self){
		return self->RemoveFaceMode();
	}
EXPORT bool _wrap_ShapeUpgrade_RemoveInternalWires_getRemoveFaceMode (ShapeUpgrade_RemoveInternalWires *larg1) {
  bool lresult = (bool)0 ;
  ShapeUpgrade_RemoveInternalWires *arg1 = (ShapeUpgrade_RemoveInternalWires *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)ShapeUpgrade_RemoveInternalWires_getRemoveFaceMode(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeUpgrade_RemoveInternalWires_getRemoveFaceMode\n  * wrapname: _wrap_ShapeUpgrade_RemoveInternalWires_getRemoveFaceMode\n  * fulldecl: Standard_Boolean ShapeUpgrade_RemoveInternalWires::getRemoveFaceMode()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_delete_ShapeUpgrade_RemoveInternalWires (ShapeUpgrade_RemoveInternalWires *larg1) {
  ShapeUpgrade_RemoveInternalWires *arg1 = (ShapeUpgrade_RemoveInternalWires *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_ShapeUpgrade_RemoveInternalWires\n  * wrapname: _wrap_delete_ShapeUpgrade_RemoveInternalWires\n  * fulldecl: ShapeUpgrade_RemoveInternalWires::~ShapeUpgrade_RemoveInternalWires()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopoDS_Shape *_wrap_ShapeUpgrade_ShapeDivide_Result (ShapeUpgrade_ShapeDivide *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  ShapeUpgrade_ShapeDivide *arg1 = (ShapeUpgrade_ShapeDivide *) 0 ;
  TopoDS_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((ShapeUpgrade_ShapeDivide const *)arg1)->Result();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeUpgrade_ShapeDivide_Result\n  * wrapname: _wrap_ShapeUpgrade_ShapeDivide_Result\n  * fulldecl: TopoDS_Shape ShapeUpgrade_ShapeDivide::Result() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new TopoDS_Shape(result);
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT bool _wrap_ShapeUpgrade_ShapeDivide_Perform__SWIG_0 (ShapeUpgrade_ShapeDivide *larg1, bool larg2) {
  bool lresult = (bool)0 ;
  ShapeUpgrade_ShapeDivide *arg1 = (ShapeUpgrade_ShapeDivide *) 0 ;
  Standard_Boolean arg2 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->Perform(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeUpgrade_ShapeDivide_Perform\n  * wrapname: _wrap_ShapeUpgrade_ShapeDivide_Perform__SWIG_0\n  * fulldecl: Standard_Boolean ShapeUpgrade_ShapeDivide::Perform(Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_ShapeUpgrade_ShapeDivide_Perform__SWIG_1 (ShapeUpgrade_ShapeDivide *larg1) {
  bool lresult = (bool)0 ;
  ShapeUpgrade_ShapeDivide *arg1 = (ShapeUpgrade_ShapeDivide *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->Perform();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeUpgrade_ShapeDivide_Perform\n  * wrapname: _wrap_ShapeUpgrade_ShapeDivide_Perform__SWIG_1\n  * fulldecl: Standard_Boolean ShapeUpgrade_ShapeDivide::Perform()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_delete_ShapeUpgrade_ShapeDivide (ShapeUpgrade_ShapeDivide *larg1) {
  ShapeUpgrade_ShapeDivide *arg1 = (ShapeUpgrade_ShapeDivide *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_ShapeUpgrade_ShapeDivide\n  * wrapname: _wrap_delete_ShapeUpgrade_ShapeDivide\n  * fulldecl: ShapeUpgrade_ShapeDivide::~ShapeUpgrade_ShapeDivide()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT ShapeUpgrade_ShapeDivideArea *_wrap_new_ShapeUpgrade_ShapeDivideArea (TopoDS_Shape *larg1) {
  ShapeUpgrade_ShapeDivideArea * lresult = (ShapeUpgrade_ShapeDivideArea *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  ShapeUpgrade_ShapeDivideArea *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (ShapeUpgrade_ShapeDivideArea *)new ShapeUpgrade_ShapeDivideArea((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_ShapeUpgrade_ShapeDivideArea\n  * wrapname: _wrap_new_ShapeUpgrade_ShapeDivideArea\n  * fulldecl: ShapeUpgrade_ShapeDivideArea::ShapeUpgrade_ShapeDivideArea(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (ShapeUpgrade_ShapeDivideArea *)0;
  }
}


SWIGINTERN void ShapeUpgrade_ShapeDivideArea_setMaxArea(ShapeUpgrade_ShapeDivideArea *self,double d){
		self->MaxArea()=d;
	}
EXPORT void _wrap_ShapeUpgrade_ShapeDivideArea_setMaxArea (ShapeUpgrade_ShapeDivideArea *larg1, double larg2) {
  ShapeUpgrade_ShapeDivideArea *arg1 = (ShapeUpgrade_ShapeDivideArea *) 0 ;
  double arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ShapeUpgrade_ShapeDivideArea_setMaxArea(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeUpgrade_ShapeDivideArea_setMaxArea\n  * wrapname: _wrap_ShapeUpgrade_ShapeDivideArea_setMaxArea\n  * fulldecl: void ShapeUpgrade_ShapeDivideArea::setMaxArea(double)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN double ShapeUpgrade_ShapeDivideArea_getMaxArea(ShapeUpgrade_ShapeDivideArea *self){
		return self->MaxArea();
	}
EXPORT double _wrap_ShapeUpgrade_ShapeDivideArea_getMaxArea (ShapeUpgrade_ShapeDivideArea *larg1) {
  double lresult = (double)0 ;
  ShapeUpgrade_ShapeDivideArea *arg1 = (ShapeUpgrade_ShapeDivideArea *) 0 ;
  double result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (double)ShapeUpgrade_ShapeDivideArea_getMaxArea(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeUpgrade_ShapeDivideArea_getMaxArea\n  * wrapname: _wrap_ShapeUpgrade_ShapeDivideArea_getMaxArea\n  * fulldecl: double ShapeUpgrade_ShapeDivideArea::getMaxArea()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (double)0;
  }
}


EXPORT void _wrap_delete_ShapeUpgrade_ShapeDivideArea (ShapeUpgrade_ShapeDivideArea *larg1) {
  ShapeUpgrade_ShapeDivideArea *arg1 = (ShapeUpgrade_ShapeDivideArea *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_ShapeUpgrade_ShapeDivideArea\n  * wrapname: _wrap_delete_ShapeUpgrade_ShapeDivideArea\n  * fulldecl: ShapeUpgrade_ShapeDivideArea::~ShapeUpgrade_ShapeDivideArea()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include <GeomAPI_PointsToBSpline.hxx>
#include <GeomAPI_Interpolate.hxx>
EXPORT GeomAPI_PointsToBSpline *_wrap_new_GeomAPI_PointsToBSpline__SWIG_0 () {
  GeomAPI_PointsToBSpline * lresult = (GeomAPI_PointsToBSpline *)0 ;
  GeomAPI_PointsToBSpline *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAPI_PointsToBSpline *)new GeomAPI_PointsToBSpline();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GeomAPI_PointsToBSpline\n  * wrapname: _wrap_new_GeomAPI_PointsToBSpline__SWIG_0\n  * fulldecl: GeomAPI_PointsToBSpline::GeomAPI_PointsToBSpline()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAPI_PointsToBSpline *)0;
  }
}


EXPORT GeomAPI_PointsToBSpline *_wrap_new_GeomAPI_PointsToBSpline__SWIG_1 (TColgp_Array1OfPnt *larg1, Standard_Integer larg2, Standard_Integer larg3, GeomAbs_Shape larg4, Standard_Real larg5) {
  GeomAPI_PointsToBSpline * lresult = (GeomAPI_PointsToBSpline *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  GeomAbs_Shape arg4 ;
  Standard_Real arg5 ;
  GeomAPI_PointsToBSpline *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAPI_PointsToBSpline *)new GeomAPI_PointsToBSpline((TColgp_Array1OfPnt const &)*arg1,arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GeomAPI_PointsToBSpline\n  * wrapname: _wrap_new_GeomAPI_PointsToBSpline__SWIG_1\n  * fulldecl: GeomAPI_PointsToBSpline::GeomAPI_PointsToBSpline(TColgp_Array1OfPnt const &,Standard_Integer const,Standard_Integer const,GeomAbs_Shape const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAPI_PointsToBSpline *)0;
  }
}


EXPORT GeomAPI_PointsToBSpline *_wrap_new_GeomAPI_PointsToBSpline__SWIG_2 (TColgp_Array1OfPnt *larg1, Standard_Integer larg2, Standard_Integer larg3, GeomAbs_Shape larg4) {
  GeomAPI_PointsToBSpline * lresult = (GeomAPI_PointsToBSpline *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  GeomAbs_Shape arg4 ;
  GeomAPI_PointsToBSpline *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAPI_PointsToBSpline *)new GeomAPI_PointsToBSpline((TColgp_Array1OfPnt const &)*arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GeomAPI_PointsToBSpline\n  * wrapname: _wrap_new_GeomAPI_PointsToBSpline__SWIG_2\n  * fulldecl: GeomAPI_PointsToBSpline::GeomAPI_PointsToBSpline(TColgp_Array1OfPnt const &,Standard_Integer const,Standard_Integer const,GeomAbs_Shape const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAPI_PointsToBSpline *)0;
  }
}


EXPORT GeomAPI_PointsToBSpline *_wrap_new_GeomAPI_PointsToBSpline__SWIG_3 (TColgp_Array1OfPnt *larg1, Standard_Integer larg2, Standard_Integer larg3) {
  GeomAPI_PointsToBSpline * lresult = (GeomAPI_PointsToBSpline *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  GeomAPI_PointsToBSpline *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAPI_PointsToBSpline *)new GeomAPI_PointsToBSpline((TColgp_Array1OfPnt const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GeomAPI_PointsToBSpline\n  * wrapname: _wrap_new_GeomAPI_PointsToBSpline__SWIG_3\n  * fulldecl: GeomAPI_PointsToBSpline::GeomAPI_PointsToBSpline(TColgp_Array1OfPnt const &,Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAPI_PointsToBSpline *)0;
  }
}


EXPORT GeomAPI_PointsToBSpline *_wrap_new_GeomAPI_PointsToBSpline__SWIG_4 (TColgp_Array1OfPnt *larg1, Standard_Integer larg2) {
  GeomAPI_PointsToBSpline * lresult = (GeomAPI_PointsToBSpline *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  Standard_Integer arg2 ;
  GeomAPI_PointsToBSpline *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAPI_PointsToBSpline *)new GeomAPI_PointsToBSpline((TColgp_Array1OfPnt const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GeomAPI_PointsToBSpline\n  * wrapname: _wrap_new_GeomAPI_PointsToBSpline__SWIG_4\n  * fulldecl: GeomAPI_PointsToBSpline::GeomAPI_PointsToBSpline(TColgp_Array1OfPnt const &,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAPI_PointsToBSpline *)0;
  }
}


EXPORT GeomAPI_PointsToBSpline *_wrap_new_GeomAPI_PointsToBSpline__SWIG_5 (TColgp_Array1OfPnt *larg1) {
  GeomAPI_PointsToBSpline * lresult = (GeomAPI_PointsToBSpline *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  GeomAPI_PointsToBSpline *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAPI_PointsToBSpline *)new GeomAPI_PointsToBSpline((TColgp_Array1OfPnt const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GeomAPI_PointsToBSpline\n  * wrapname: _wrap_new_GeomAPI_PointsToBSpline__SWIG_5\n  * fulldecl: GeomAPI_PointsToBSpline::GeomAPI_PointsToBSpline(TColgp_Array1OfPnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAPI_PointsToBSpline *)0;
  }
}


EXPORT GeomAPI_PointsToBSpline *_wrap_new_GeomAPI_PointsToBSpline__SWIG_6 (TColgp_Array1OfPnt *larg1, TColStd_Array1OfReal *larg2, Standard_Integer larg3, Standard_Integer larg4, GeomAbs_Shape larg5, Standard_Real larg6) {
  GeomAPI_PointsToBSpline * lresult = (GeomAPI_PointsToBSpline *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  Standard_Integer arg3 ;
  Standard_Integer arg4 ;
  GeomAbs_Shape arg5 ;
  Standard_Real arg6 ;
  GeomAPI_PointsToBSpline *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAPI_PointsToBSpline *)new GeomAPI_PointsToBSpline((TColgp_Array1OfPnt const &)*arg1,(TColStd_Array1OfReal const &)*arg2,arg3,arg4,arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GeomAPI_PointsToBSpline\n  * wrapname: _wrap_new_GeomAPI_PointsToBSpline__SWIG_6\n  * fulldecl: GeomAPI_PointsToBSpline::GeomAPI_PointsToBSpline(TColgp_Array1OfPnt const &,TColStd_Array1OfReal const &,Standard_Integer const,Standard_Integer const,GeomAbs_Shape const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAPI_PointsToBSpline *)0;
  }
}


EXPORT GeomAPI_PointsToBSpline *_wrap_new_GeomAPI_PointsToBSpline__SWIG_7 (TColgp_Array1OfPnt *larg1, TColStd_Array1OfReal *larg2, Standard_Integer larg3, Standard_Integer larg4, GeomAbs_Shape larg5) {
  GeomAPI_PointsToBSpline * lresult = (GeomAPI_PointsToBSpline *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  Standard_Integer arg3 ;
  Standard_Integer arg4 ;
  GeomAbs_Shape arg5 ;
  GeomAPI_PointsToBSpline *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAPI_PointsToBSpline *)new GeomAPI_PointsToBSpline((TColgp_Array1OfPnt const &)*arg1,(TColStd_Array1OfReal const &)*arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GeomAPI_PointsToBSpline\n  * wrapname: _wrap_new_GeomAPI_PointsToBSpline__SWIG_7\n  * fulldecl: GeomAPI_PointsToBSpline::GeomAPI_PointsToBSpline(TColgp_Array1OfPnt const &,TColStd_Array1OfReal const &,Standard_Integer const,Standard_Integer const,GeomAbs_Shape const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAPI_PointsToBSpline *)0;
  }
}


EXPORT GeomAPI_PointsToBSpline *_wrap_new_GeomAPI_PointsToBSpline__SWIG_8 (TColgp_Array1OfPnt *larg1, TColStd_Array1OfReal *larg2, Standard_Integer larg3, Standard_Integer larg4) {
  GeomAPI_PointsToBSpline * lresult = (GeomAPI_PointsToBSpline *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  Standard_Integer arg3 ;
  Standard_Integer arg4 ;
  GeomAPI_PointsToBSpline *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAPI_PointsToBSpline *)new GeomAPI_PointsToBSpline((TColgp_Array1OfPnt const &)*arg1,(TColStd_Array1OfReal const &)*arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GeomAPI_PointsToBSpline\n  * wrapname: _wrap_new_GeomAPI_PointsToBSpline__SWIG_8\n  * fulldecl: GeomAPI_PointsToBSpline::GeomAPI_PointsToBSpline(TColgp_Array1OfPnt const &,TColStd_Array1OfReal const &,Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAPI_PointsToBSpline *)0;
  }
}


EXPORT GeomAPI_PointsToBSpline *_wrap_new_GeomAPI_PointsToBSpline__SWIG_9 (TColgp_Array1OfPnt *larg1, TColStd_Array1OfReal *larg2, Standard_Integer larg3) {
  GeomAPI_PointsToBSpline * lresult = (GeomAPI_PointsToBSpline *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  Standard_Integer arg3 ;
  GeomAPI_PointsToBSpline *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAPI_PointsToBSpline *)new GeomAPI_PointsToBSpline((TColgp_Array1OfPnt const &)*arg1,(TColStd_Array1OfReal const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GeomAPI_PointsToBSpline\n  * wrapname: _wrap_new_GeomAPI_PointsToBSpline__SWIG_9\n  * fulldecl: GeomAPI_PointsToBSpline::GeomAPI_PointsToBSpline(TColgp_Array1OfPnt const &,TColStd_Array1OfReal const &,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAPI_PointsToBSpline *)0;
  }
}


EXPORT GeomAPI_PointsToBSpline *_wrap_new_GeomAPI_PointsToBSpline__SWIG_10 (TColgp_Array1OfPnt *larg1, TColStd_Array1OfReal *larg2) {
  GeomAPI_PointsToBSpline * lresult = (GeomAPI_PointsToBSpline *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  GeomAPI_PointsToBSpline *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAPI_PointsToBSpline *)new GeomAPI_PointsToBSpline((TColgp_Array1OfPnt const &)*arg1,(TColStd_Array1OfReal const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GeomAPI_PointsToBSpline\n  * wrapname: _wrap_new_GeomAPI_PointsToBSpline__SWIG_10\n  * fulldecl: GeomAPI_PointsToBSpline::GeomAPI_PointsToBSpline(TColgp_Array1OfPnt const &,TColStd_Array1OfReal const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAPI_PointsToBSpline *)0;
  }
}


EXPORT Handle_Geom_BSplineCurve *_wrap_GeomAPI_PointsToBSpline_Curve (GeomAPI_PointsToBSpline *larg1) {
  Handle_Geom_BSplineCurve * lresult = (Handle_Geom_BSplineCurve *)0 ;
  GeomAPI_PointsToBSpline *arg1 = (GeomAPI_PointsToBSpline *) 0 ;
  Handle_Geom_BSplineCurve *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_BSplineCurve *) &((GeomAPI_PointsToBSpline const *)arg1)->Curve();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAPI_PointsToBSpline_Curve\n  * wrapname: _wrap_GeomAPI_PointsToBSpline_Curve\n  * fulldecl: Handle_Geom_BSplineCurve const & GeomAPI_PointsToBSpline::Curve() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_BSplineCurve *)0;
  }
}


EXPORT void _wrap_delete_GeomAPI_PointsToBSpline (GeomAPI_PointsToBSpline *larg1) {
  GeomAPI_PointsToBSpline *arg1 = (GeomAPI_PointsToBSpline *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_GeomAPI_PointsToBSpline\n  * wrapname: _wrap_delete_GeomAPI_PointsToBSpline\n  * fulldecl: GeomAPI_PointsToBSpline::~GeomAPI_PointsToBSpline()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT GeomAPI_Interpolate *_wrap_new_GeomAPI_Interpolate (Handle_TColgp_HArray1OfPnt *larg1, bool larg2, Standard_Real larg3) {
  GeomAPI_Interpolate * lresult = (GeomAPI_Interpolate *)0 ;
  Handle_TColgp_HArray1OfPnt *arg1 = 0 ;
  Standard_Boolean arg2 ;
  Standard_Real arg3 ;
  GeomAPI_Interpolate *result = 0 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAPI_Interpolate *)new GeomAPI_Interpolate((Handle_TColgp_HArray1OfPnt const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GeomAPI_Interpolate\n  * wrapname: _wrap_new_GeomAPI_Interpolate\n  * fulldecl: GeomAPI_Interpolate::GeomAPI_Interpolate(Handle_TColgp_HArray1OfPnt const &,Standard_Boolean const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAPI_Interpolate *)0;
  }
}


EXPORT void _wrap_GeomAPI_Interpolate_Load__SWIG_0 (GeomAPI_Interpolate *larg1, TColgp_Array1OfVec *larg2, Handle_TColStd_HArray1OfBoolean *larg3, bool larg4) {
  GeomAPI_Interpolate *arg1 = (GeomAPI_Interpolate *) 0 ;
  TColgp_Array1OfVec *arg2 = 0 ;
  Handle_TColStd_HArray1OfBoolean *arg3 = 0 ;
  Standard_Boolean arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Load((TColgp_Array1OfVec const &)*arg2,(Handle_TColStd_HArray1OfBoolean const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAPI_Interpolate_Load\n  * wrapname: _wrap_GeomAPI_Interpolate_Load__SWIG_0\n  * fulldecl: void GeomAPI_Interpolate::Load(TColgp_Array1OfVec const &,Handle_TColStd_HArray1OfBoolean const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_GeomAPI_Interpolate_Load__SWIG_1 (GeomAPI_Interpolate *larg1, TColgp_Array1OfVec *larg2, Handle_TColStd_HArray1OfBoolean *larg3) {
  GeomAPI_Interpolate *arg1 = (GeomAPI_Interpolate *) 0 ;
  TColgp_Array1OfVec *arg2 = 0 ;
  Handle_TColStd_HArray1OfBoolean *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Load((TColgp_Array1OfVec const &)*arg2,(Handle_TColStd_HArray1OfBoolean const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAPI_Interpolate_Load\n  * wrapname: _wrap_GeomAPI_Interpolate_Load__SWIG_1\n  * fulldecl: void GeomAPI_Interpolate::Load(TColgp_Array1OfVec const &,Handle_TColStd_HArray1OfBoolean const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_GeomAPI_Interpolate_Perform (GeomAPI_Interpolate *larg1) {
  GeomAPI_Interpolate *arg1 = (GeomAPI_Interpolate *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Perform();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAPI_Interpolate_Perform\n  * wrapname: _wrap_GeomAPI_Interpolate_Perform\n  * fulldecl: void GeomAPI_Interpolate::Perform()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Handle_Geom_BSplineCurve *_wrap_GeomAPI_Interpolate_Curve (GeomAPI_Interpolate *larg1) {
  Handle_Geom_BSplineCurve * lresult = (Handle_Geom_BSplineCurve *)0 ;
  GeomAPI_Interpolate *arg1 = (GeomAPI_Interpolate *) 0 ;
  Handle_Geom_BSplineCurve *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_BSplineCurve *) &((GeomAPI_Interpolate const *)arg1)->Curve();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAPI_Interpolate_Curve\n  * wrapname: _wrap_GeomAPI_Interpolate_Curve\n  * fulldecl: Handle_Geom_BSplineCurve const & GeomAPI_Interpolate::Curve() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_BSplineCurve *)0;
  }
}


EXPORT void _wrap_delete_GeomAPI_Interpolate (GeomAPI_Interpolate *larg1) {
  GeomAPI_Interpolate *arg1 = (GeomAPI_Interpolate *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_GeomAPI_Interpolate\n  * wrapname: _wrap_delete_GeomAPI_Interpolate\n  * fulldecl: GeomAPI_Interpolate::~GeomAPI_Interpolate()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include <GC_Root.hxx>
EXPORT bool _wrap_GC_Root_IsDone (GC_Root *larg1) {
  bool lresult = (bool)0 ;
  GC_Root *arg1 = (GC_Root *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((GC_Root const *)arg1)->IsDone();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GC_Root_IsDone\n  * wrapname: _wrap_GC_Root_IsDone\n  * fulldecl: Standard_Boolean GC_Root::IsDone() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT int _wrap_GC_Root_Status (GC_Root *larg1) {
  int lresult = (int)0 ;
  GC_Root *arg1 = (GC_Root *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (int)((GC_Root const *)arg1)->Status();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GC_Root_Status\n  * wrapname: _wrap_GC_Root_Status\n  * fulldecl: int GC_Root::Status() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_delete_GC_Root (GC_Root *larg1) {
  GC_Root *arg1 = (GC_Root *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_GC_Root\n  * wrapname: _wrap_delete_GC_Root\n  * fulldecl: GC_Root::~GC_Root()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include <GC_MakeArcOfCircle.hxx>
EXPORT GC_MakeArcOfCircle *_wrap_new_GC_MakeArcOfCircle__SWIG_0 (gp_Pnt *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  GC_MakeArcOfCircle * lresult = (GC_MakeArcOfCircle *)0 ;
  gp_Pnt *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  GC_MakeArcOfCircle *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GC_MakeArcOfCircle *)new GC_MakeArcOfCircle((gp_Pnt const &)*arg1,(gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GC_MakeArcOfCircle\n  * wrapname: _wrap_new_GC_MakeArcOfCircle__SWIG_0\n  * fulldecl: GC_MakeArcOfCircle::GC_MakeArcOfCircle(gp_Pnt const &,gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GC_MakeArcOfCircle *)0;
  }
}


EXPORT GC_MakeArcOfCircle *_wrap_new_GC_MakeArcOfCircle__SWIG_1 (gp_Circ *larg1, gp_Pnt *larg2, gp_Pnt *larg3, bool larg4) {
  GC_MakeArcOfCircle * lresult = (GC_MakeArcOfCircle *)0 ;
  gp_Circ *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  Standard_Boolean arg4 ;
  GC_MakeArcOfCircle *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GC_MakeArcOfCircle *)new GC_MakeArcOfCircle((gp_Circ const &)*arg1,(gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GC_MakeArcOfCircle\n  * wrapname: _wrap_new_GC_MakeArcOfCircle__SWIG_1\n  * fulldecl: GC_MakeArcOfCircle::GC_MakeArcOfCircle(gp_Circ const &,gp_Pnt const &,gp_Pnt const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GC_MakeArcOfCircle *)0;
  }
}


EXPORT Handle_Geom_TrimmedCurve *_wrap_GC_MakeArcOfCircle_Value (GC_MakeArcOfCircle *larg1) {
  Handle_Geom_TrimmedCurve * lresult = (Handle_Geom_TrimmedCurve *)0 ;
  GC_MakeArcOfCircle *arg1 = (GC_MakeArcOfCircle *) 0 ;
  Handle_Geom_TrimmedCurve *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_TrimmedCurve *) &((GC_MakeArcOfCircle const *)arg1)->Value();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GC_MakeArcOfCircle_Value\n  * wrapname: _wrap_GC_MakeArcOfCircle_Value\n  * fulldecl: Handle_Geom_TrimmedCurve const & GC_MakeArcOfCircle::Value() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_TrimmedCurve *)0;
  }
}


EXPORT void _wrap_delete_GC_MakeArcOfCircle (GC_MakeArcOfCircle *larg1) {
  GC_MakeArcOfCircle *arg1 = (GC_MakeArcOfCircle *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_GC_MakeArcOfCircle\n  * wrapname: _wrap_delete_GC_MakeArcOfCircle\n  * fulldecl: GC_MakeArcOfCircle::~GC_MakeArcOfCircle()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include <GC_MakeSegment.hxx>
EXPORT GC_MakeSegment *_wrap_new_GC_MakeSegment__SWIG_0 (gp_Pnt *larg1, gp_Pnt *larg2) {
  GC_MakeSegment * lresult = (GC_MakeSegment *)0 ;
  gp_Pnt *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  GC_MakeSegment *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GC_MakeSegment *)new GC_MakeSegment((gp_Pnt const &)*arg1,(gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GC_MakeSegment\n  * wrapname: _wrap_new_GC_MakeSegment__SWIG_0\n  * fulldecl: GC_MakeSegment::GC_MakeSegment(gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GC_MakeSegment *)0;
  }
}


EXPORT GC_MakeSegment *_wrap_new_GC_MakeSegment__SWIG_1 (gp_Lin *larg1, Standard_Real larg2, Standard_Real larg3) {
  GC_MakeSegment * lresult = (GC_MakeSegment *)0 ;
  gp_Lin *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  GC_MakeSegment *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GC_MakeSegment *)new GC_MakeSegment((gp_Lin const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GC_MakeSegment\n  * wrapname: _wrap_new_GC_MakeSegment__SWIG_1\n  * fulldecl: GC_MakeSegment::GC_MakeSegment(gp_Lin const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GC_MakeSegment *)0;
  }
}


EXPORT GC_MakeSegment *_wrap_new_GC_MakeSegment__SWIG_2 (gp_Lin *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  GC_MakeSegment * lresult = (GC_MakeSegment *)0 ;
  gp_Lin *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  GC_MakeSegment *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GC_MakeSegment *)new GC_MakeSegment((gp_Lin const &)*arg1,(gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GC_MakeSegment\n  * wrapname: _wrap_new_GC_MakeSegment__SWIG_2\n  * fulldecl: GC_MakeSegment::GC_MakeSegment(gp_Lin const &,gp_Pnt const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GC_MakeSegment *)0;
  }
}


EXPORT GC_MakeSegment *_wrap_new_GC_MakeSegment__SWIG_3 (gp_Lin *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  GC_MakeSegment * lresult = (GC_MakeSegment *)0 ;
  gp_Lin *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  GC_MakeSegment *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GC_MakeSegment *)new GC_MakeSegment((gp_Lin const &)*arg1,(gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GC_MakeSegment\n  * wrapname: _wrap_new_GC_MakeSegment__SWIG_3\n  * fulldecl: GC_MakeSegment::GC_MakeSegment(gp_Lin const &,gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GC_MakeSegment *)0;
  }
}


EXPORT Handle_Geom_TrimmedCurve *_wrap_GC_MakeSegment_Value (GC_MakeSegment *larg1) {
  Handle_Geom_TrimmedCurve * lresult = (Handle_Geom_TrimmedCurve *)0 ;
  GC_MakeSegment *arg1 = (GC_MakeSegment *) 0 ;
  Handle_Geom_TrimmedCurve *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_TrimmedCurve *) &((GC_MakeSegment const *)arg1)->Value();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GC_MakeSegment_Value\n  * wrapname: _wrap_GC_MakeSegment_Value\n  * fulldecl: Handle_Geom_TrimmedCurve const & GC_MakeSegment::Value() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_TrimmedCurve *)0;
  }
}


EXPORT void _wrap_delete_GC_MakeSegment (GC_MakeSegment *larg1) {
  GC_MakeSegment *arg1 = (GC_MakeSegment *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_GC_MakeSegment\n  * wrapname: _wrap_delete_GC_MakeSegment\n  * fulldecl: GC_MakeSegment::~GC_MakeSegment()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include <GCE2d_Root.hxx>
EXPORT bool _wrap_GCE2d_Root_IsDone (GCE2d_Root *larg1) {
  bool lresult = (bool)0 ;
  GCE2d_Root *arg1 = (GCE2d_Root *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((GCE2d_Root const *)arg1)->IsDone();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GCE2d_Root_IsDone\n  * wrapname: _wrap_GCE2d_Root_IsDone\n  * fulldecl: Standard_Boolean GCE2d_Root::IsDone() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT gce_ErrorType *_wrap_GCE2d_Root_Status (GCE2d_Root *larg1) {
  gce_ErrorType * lresult = (gce_ErrorType *)0 ;
  GCE2d_Root *arg1 = (GCE2d_Root *) 0 ;
  gce_ErrorType result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((GCE2d_Root const *)arg1)->Status();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GCE2d_Root_Status\n  * wrapname: _wrap_GCE2d_Root_Status\n  * fulldecl: gce_ErrorType GCE2d_Root::Status() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gce_ErrorType(result);
    return lresult;
  } catch (...) {
    return (gce_ErrorType *)0;
  }
}


EXPORT void _wrap_delete_GCE2d_Root (GCE2d_Root *larg1) {
  GCE2d_Root *arg1 = (GCE2d_Root *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_GCE2d_Root\n  * wrapname: _wrap_delete_GCE2d_Root\n  * fulldecl: GCE2d_Root::~GCE2d_Root()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include <GCE2d_MakeSegment.hxx>
EXPORT GCE2d_MakeSegment *_wrap_new_GCE2d_MakeSegment__SWIG_0 (gp_Pnt2d *larg1, gp_Pnt2d *larg2) {
  GCE2d_MakeSegment * lresult = (GCE2d_MakeSegment *)0 ;
  gp_Pnt2d *arg1 = 0 ;
  gp_Pnt2d *arg2 = 0 ;
  GCE2d_MakeSegment *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GCE2d_MakeSegment *)new GCE2d_MakeSegment((gp_Pnt2d const &)*arg1,(gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GCE2d_MakeSegment\n  * wrapname: _wrap_new_GCE2d_MakeSegment__SWIG_0\n  * fulldecl: GCE2d_MakeSegment::GCE2d_MakeSegment(gp_Pnt2d const &,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GCE2d_MakeSegment *)0;
  }
}


EXPORT GCE2d_MakeSegment *_wrap_new_GCE2d_MakeSegment__SWIG_1 (gp_Pnt2d *larg1, gp_Dir2d *larg2, gp_Pnt2d *larg3) {
  GCE2d_MakeSegment * lresult = (GCE2d_MakeSegment *)0 ;
  gp_Pnt2d *arg1 = 0 ;
  gp_Dir2d *arg2 = 0 ;
  gp_Pnt2d *arg3 = 0 ;
  GCE2d_MakeSegment *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GCE2d_MakeSegment *)new GCE2d_MakeSegment((gp_Pnt2d const &)*arg1,(gp_Dir2d const &)*arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GCE2d_MakeSegment\n  * wrapname: _wrap_new_GCE2d_MakeSegment__SWIG_1\n  * fulldecl: GCE2d_MakeSegment::GCE2d_MakeSegment(gp_Pnt2d const &,gp_Dir2d const &,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GCE2d_MakeSegment *)0;
  }
}


EXPORT GCE2d_MakeSegment *_wrap_new_GCE2d_MakeSegment__SWIG_2 (gp_Lin2d *larg1, Standard_Real larg2, Standard_Real larg3) {
  GCE2d_MakeSegment * lresult = (GCE2d_MakeSegment *)0 ;
  gp_Lin2d *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  GCE2d_MakeSegment *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GCE2d_MakeSegment *)new GCE2d_MakeSegment((gp_Lin2d const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GCE2d_MakeSegment\n  * wrapname: _wrap_new_GCE2d_MakeSegment__SWIG_2\n  * fulldecl: GCE2d_MakeSegment::GCE2d_MakeSegment(gp_Lin2d const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GCE2d_MakeSegment *)0;
  }
}


EXPORT GCE2d_MakeSegment *_wrap_new_GCE2d_MakeSegment__SWIG_3 (gp_Lin2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  GCE2d_MakeSegment * lresult = (GCE2d_MakeSegment *)0 ;
  gp_Lin2d *arg1 = 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  GCE2d_MakeSegment *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GCE2d_MakeSegment *)new GCE2d_MakeSegment((gp_Lin2d const &)*arg1,(gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GCE2d_MakeSegment\n  * wrapname: _wrap_new_GCE2d_MakeSegment__SWIG_3\n  * fulldecl: GCE2d_MakeSegment::GCE2d_MakeSegment(gp_Lin2d const &,gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GCE2d_MakeSegment *)0;
  }
}


EXPORT GCE2d_MakeSegment *_wrap_new_GCE2d_MakeSegment__SWIG_4 (gp_Lin2d *larg1, gp_Pnt2d *larg2, gp_Pnt2d *larg3) {
  GCE2d_MakeSegment * lresult = (GCE2d_MakeSegment *)0 ;
  gp_Lin2d *arg1 = 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Pnt2d *arg3 = 0 ;
  GCE2d_MakeSegment *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GCE2d_MakeSegment *)new GCE2d_MakeSegment((gp_Lin2d const &)*arg1,(gp_Pnt2d const &)*arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GCE2d_MakeSegment\n  * wrapname: _wrap_new_GCE2d_MakeSegment__SWIG_4\n  * fulldecl: GCE2d_MakeSegment::GCE2d_MakeSegment(gp_Lin2d const &,gp_Pnt2d const &,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GCE2d_MakeSegment *)0;
  }
}


EXPORT Handle_Geom2d_TrimmedCurve *_wrap_GCE2d_MakeSegment_Value (GCE2d_MakeSegment *larg1) {
  Handle_Geom2d_TrimmedCurve * lresult = (Handle_Geom2d_TrimmedCurve *)0 ;
  GCE2d_MakeSegment *arg1 = (GCE2d_MakeSegment *) 0 ;
  Handle_Geom2d_TrimmedCurve *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_TrimmedCurve *) &((GCE2d_MakeSegment const *)arg1)->Value();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GCE2d_MakeSegment_Value\n  * wrapname: _wrap_GCE2d_MakeSegment_Value\n  * fulldecl: Handle_Geom2d_TrimmedCurve const & GCE2d_MakeSegment::Value() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_TrimmedCurve *)0;
  }
}


EXPORT void _wrap_delete_GCE2d_MakeSegment (GCE2d_MakeSegment *larg1) {
  GCE2d_MakeSegment *arg1 = (GCE2d_MakeSegment *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_GCE2d_MakeSegment\n  * wrapname: _wrap_delete_GCE2d_MakeSegment\n  * fulldecl: GCE2d_MakeSegment::~GCE2d_MakeSegment()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <Bnd_Box.hxx>
  
EXPORT Bnd_Box *_wrap_new_Bnd_Box () {
  Bnd_Box * lresult = (Bnd_Box *)0 ;
  Bnd_Box *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Bnd_Box *)new Bnd_Box();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Bnd_Box\n  * wrapname: _wrap_new_Bnd_Box\n  * fulldecl: Bnd_Box::Bnd_Box()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Bnd_Box *)0;
  }
}


EXPORT void _wrap_Bnd_Box_SetWhole (Bnd_Box *larg1) {
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetWhole();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_SetWhole\n  * wrapname: _wrap_Bnd_Box_SetWhole\n  * fulldecl: void Bnd_Box::SetWhole()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Bnd_Box_SetVoid (Bnd_Box *larg1) {
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetVoid();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_SetVoid\n  * wrapname: _wrap_Bnd_Box_SetVoid\n  * fulldecl: void Bnd_Box::SetVoid()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Bnd_Box_Set__SWIG_0 (Bnd_Box *larg1, gp_Pnt *larg2) {
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Set((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_Set\n  * wrapname: _wrap_Bnd_Box_Set__SWIG_0\n  * fulldecl: void Bnd_Box::Set(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Bnd_Box_Set__SWIG_1 (Bnd_Box *larg1, gp_Pnt *larg2, gp_Dir *larg3) {
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Dir *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Set((gp_Pnt const &)*arg2,(gp_Dir const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_Set\n  * wrapname: _wrap_Bnd_Box_Set__SWIG_1\n  * fulldecl: void Bnd_Box::Set(gp_Pnt const &,gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Bnd_Box_Update (Bnd_Box *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5, Standard_Real larg6, Standard_Real larg7) {
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  Standard_Real arg6 ;
  Standard_Real arg7 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Update(arg2,arg3,arg4,arg5,arg6,arg7);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_Update\n  * wrapname: _wrap_Bnd_Box_Update\n  * fulldecl: void Bnd_Box::Update(Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Real _wrap_Bnd_Box_GetGap (Bnd_Box *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((Bnd_Box const *)arg1)->GetGap();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_GetGap\n  * wrapname: _wrap_Bnd_Box_GetGap\n  * fulldecl: Standard_Real Bnd_Box::GetGap() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_Bnd_Box_SetGap (Bnd_Box *larg1, Standard_Real larg2) {
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetGap(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_SetGap\n  * wrapname: _wrap_Bnd_Box_SetGap\n  * fulldecl: void Bnd_Box::SetGap(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Bnd_Box_Enlarge (Bnd_Box *larg1, Standard_Real larg2) {
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Enlarge(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_Enlarge\n  * wrapname: _wrap_Bnd_Box_Enlarge\n  * fulldecl: void Bnd_Box::Enlarge(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Bnd_Box_Get (Bnd_Box *larg1, Standard_Real *larg2, Standard_Real *larg3, Standard_Real *larg4, Standard_Real *larg5, Standard_Real *larg6, Standard_Real *larg7) {
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  Standard_Real *arg5 = 0 ;
  Standard_Real *arg6 = 0 ;
  Standard_Real *arg7 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((Bnd_Box const *)arg1)->Get(*arg2,*arg3,*arg4,*arg5,*arg6,*arg7);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_Get\n  * wrapname: _wrap_Bnd_Box_Get\n  * fulldecl: void Bnd_Box::Get(Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pnt *_wrap_Bnd_Box_CornerMin (Bnd_Box *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Bnd_Box const *)arg1)->CornerMin();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_CornerMin\n  * wrapname: _wrap_Bnd_Box_CornerMin\n  * fulldecl: gp_Pnt Bnd_Box::CornerMin() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT gp_Pnt *_wrap_Bnd_Box_CornerMax (Bnd_Box *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Bnd_Box const *)arg1)->CornerMax();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_CornerMax\n  * wrapname: _wrap_Bnd_Box_CornerMax\n  * fulldecl: gp_Pnt Bnd_Box::CornerMax() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT void _wrap_Bnd_Box_OpenXmin (Bnd_Box *larg1) {
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->OpenXmin();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_OpenXmin\n  * wrapname: _wrap_Bnd_Box_OpenXmin\n  * fulldecl: void Bnd_Box::OpenXmin()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Bnd_Box_OpenXmax (Bnd_Box *larg1) {
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->OpenXmax();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_OpenXmax\n  * wrapname: _wrap_Bnd_Box_OpenXmax\n  * fulldecl: void Bnd_Box::OpenXmax()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Bnd_Box_OpenYmin (Bnd_Box *larg1) {
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->OpenYmin();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_OpenYmin\n  * wrapname: _wrap_Bnd_Box_OpenYmin\n  * fulldecl: void Bnd_Box::OpenYmin()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Bnd_Box_OpenYmax (Bnd_Box *larg1) {
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->OpenYmax();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_OpenYmax\n  * wrapname: _wrap_Bnd_Box_OpenYmax\n  * fulldecl: void Bnd_Box::OpenYmax()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Bnd_Box_OpenZmin (Bnd_Box *larg1) {
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->OpenZmin();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_OpenZmin\n  * wrapname: _wrap_Bnd_Box_OpenZmin\n  * fulldecl: void Bnd_Box::OpenZmin()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Bnd_Box_OpenZmax (Bnd_Box *larg1) {
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->OpenZmax();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_OpenZmax\n  * wrapname: _wrap_Bnd_Box_OpenZmax\n  * fulldecl: void Bnd_Box::OpenZmax()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_Bnd_Box_IsOpenXmin (Bnd_Box *larg1) {
  bool lresult = (bool)0 ;
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Bnd_Box const *)arg1)->IsOpenXmin();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_IsOpenXmin\n  * wrapname: _wrap_Bnd_Box_IsOpenXmin\n  * fulldecl: Standard_Boolean Bnd_Box::IsOpenXmin() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_Bnd_Box_IsOpenXmax (Bnd_Box *larg1) {
  bool lresult = (bool)0 ;
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Bnd_Box const *)arg1)->IsOpenXmax();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_IsOpenXmax\n  * wrapname: _wrap_Bnd_Box_IsOpenXmax\n  * fulldecl: Standard_Boolean Bnd_Box::IsOpenXmax() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_Bnd_Box_IsOpenYmin (Bnd_Box *larg1) {
  bool lresult = (bool)0 ;
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Bnd_Box const *)arg1)->IsOpenYmin();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_IsOpenYmin\n  * wrapname: _wrap_Bnd_Box_IsOpenYmin\n  * fulldecl: Standard_Boolean Bnd_Box::IsOpenYmin() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_Bnd_Box_IsOpenYmax (Bnd_Box *larg1) {
  bool lresult = (bool)0 ;
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Bnd_Box const *)arg1)->IsOpenYmax();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_IsOpenYmax\n  * wrapname: _wrap_Bnd_Box_IsOpenYmax\n  * fulldecl: Standard_Boolean Bnd_Box::IsOpenYmax() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_Bnd_Box_IsOpenZmin (Bnd_Box *larg1) {
  bool lresult = (bool)0 ;
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Bnd_Box const *)arg1)->IsOpenZmin();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_IsOpenZmin\n  * wrapname: _wrap_Bnd_Box_IsOpenZmin\n  * fulldecl: Standard_Boolean Bnd_Box::IsOpenZmin() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_Bnd_Box_IsOpenZmax (Bnd_Box *larg1) {
  bool lresult = (bool)0 ;
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Bnd_Box const *)arg1)->IsOpenZmax();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_IsOpenZmax\n  * wrapname: _wrap_Bnd_Box_IsOpenZmax\n  * fulldecl: Standard_Boolean Bnd_Box::IsOpenZmax() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_Bnd_Box_IsWhole (Bnd_Box *larg1) {
  bool lresult = (bool)0 ;
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Bnd_Box const *)arg1)->IsWhole();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_IsWhole\n  * wrapname: _wrap_Bnd_Box_IsWhole\n  * fulldecl: Standard_Boolean Bnd_Box::IsWhole() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_Bnd_Box_IsVoid (Bnd_Box *larg1) {
  bool lresult = (bool)0 ;
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Bnd_Box const *)arg1)->IsVoid();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_IsVoid\n  * wrapname: _wrap_Bnd_Box_IsVoid\n  * fulldecl: Standard_Boolean Bnd_Box::IsVoid() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_Bnd_Box_IsXThin (Bnd_Box *larg1, Standard_Real larg2) {
  bool lresult = (bool)0 ;
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  Standard_Real arg2 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Bnd_Box const *)arg1)->IsXThin(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_IsXThin\n  * wrapname: _wrap_Bnd_Box_IsXThin\n  * fulldecl: Standard_Boolean Bnd_Box::IsXThin(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_Bnd_Box_IsYThin (Bnd_Box *larg1, Standard_Real larg2) {
  bool lresult = (bool)0 ;
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  Standard_Real arg2 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Bnd_Box const *)arg1)->IsYThin(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_IsYThin\n  * wrapname: _wrap_Bnd_Box_IsYThin\n  * fulldecl: Standard_Boolean Bnd_Box::IsYThin(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_Bnd_Box_IsZThin (Bnd_Box *larg1, Standard_Real larg2) {
  bool lresult = (bool)0 ;
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  Standard_Real arg2 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Bnd_Box const *)arg1)->IsZThin(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_IsZThin\n  * wrapname: _wrap_Bnd_Box_IsZThin\n  * fulldecl: Standard_Boolean Bnd_Box::IsZThin(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_Bnd_Box_IsThin (Bnd_Box *larg1, Standard_Real larg2) {
  bool lresult = (bool)0 ;
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  Standard_Real arg2 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Bnd_Box const *)arg1)->IsThin(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_IsThin\n  * wrapname: _wrap_Bnd_Box_IsThin\n  * fulldecl: Standard_Boolean Bnd_Box::IsThin(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Bnd_Box *_wrap_Bnd_Box_Transformed (Bnd_Box *larg1, gp_Trsf *larg2) {
  Bnd_Box * lresult = (Bnd_Box *)0 ;
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  gp_Trsf *arg2 = 0 ;
  Bnd_Box result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Bnd_Box const *)arg1)->Transformed((gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_Transformed\n  * wrapname: _wrap_Bnd_Box_Transformed\n  * fulldecl: Bnd_Box Bnd_Box::Transformed(gp_Trsf const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Bnd_Box(result);
    return lresult;
  } catch (...) {
    return (Bnd_Box *)0;
  }
}


EXPORT void _wrap_Bnd_Box_Add__SWIG_0 (Bnd_Box *larg1, Bnd_Box *larg2) {
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  Bnd_Box *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Add((Bnd_Box const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_Add\n  * wrapname: _wrap_Bnd_Box_Add__SWIG_0\n  * fulldecl: void Bnd_Box::Add(Bnd_Box const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Bnd_Box_Add__SWIG_1 (Bnd_Box *larg1, gp_Pnt *larg2) {
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Add((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_Add\n  * wrapname: _wrap_Bnd_Box_Add__SWIG_1\n  * fulldecl: void Bnd_Box::Add(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Bnd_Box_Add__SWIG_2 (Bnd_Box *larg1, gp_Pnt *larg2, gp_Dir *larg3) {
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Dir *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Add((gp_Pnt const &)*arg2,(gp_Dir const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_Add\n  * wrapname: _wrap_Bnd_Box_Add__SWIG_2\n  * fulldecl: void Bnd_Box::Add(gp_Pnt const &,gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Bnd_Box_Add__SWIG_3 (Bnd_Box *larg1, gp_Dir *larg2) {
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  gp_Dir *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Add((gp_Dir const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_Add\n  * wrapname: _wrap_Bnd_Box_Add__SWIG_3\n  * fulldecl: void Bnd_Box::Add(gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_Bnd_Box_IsOut__SWIG_0 (Bnd_Box *larg1, gp_Pnt *larg2) {
  bool lresult = (bool)0 ;
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Bnd_Box const *)arg1)->IsOut((gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_IsOut\n  * wrapname: _wrap_Bnd_Box_IsOut__SWIG_0\n  * fulldecl: Standard_Boolean Bnd_Box::IsOut(gp_Pnt const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_Bnd_Box_IsOut__SWIG_1 (Bnd_Box *larg1, gp_Lin *larg2) {
  bool lresult = (bool)0 ;
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  gp_Lin *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Bnd_Box const *)arg1)->IsOut((gp_Lin const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_IsOut\n  * wrapname: _wrap_Bnd_Box_IsOut__SWIG_1\n  * fulldecl: Standard_Boolean Bnd_Box::IsOut(gp_Lin const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_Bnd_Box_IsOut__SWIG_2 (Bnd_Box *larg1, gp_Pln *larg2) {
  bool lresult = (bool)0 ;
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  gp_Pln *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Bnd_Box const *)arg1)->IsOut((gp_Pln const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_IsOut\n  * wrapname: _wrap_Bnd_Box_IsOut__SWIG_2\n  * fulldecl: Standard_Boolean Bnd_Box::IsOut(gp_Pln const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_Bnd_Box_IsOut__SWIG_3 (Bnd_Box *larg1, Bnd_Box *larg2) {
  bool lresult = (bool)0 ;
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  Bnd_Box *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Bnd_Box const *)arg1)->IsOut((Bnd_Box const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_IsOut\n  * wrapname: _wrap_Bnd_Box_IsOut__SWIG_3\n  * fulldecl: Standard_Boolean Bnd_Box::IsOut(Bnd_Box const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_Bnd_Box_IsOut__SWIG_4 (Bnd_Box *larg1, Bnd_Box *larg2, gp_Trsf *larg3) {
  bool lresult = (bool)0 ;
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  Bnd_Box *arg2 = 0 ;
  gp_Trsf *arg3 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Bnd_Box const *)arg1)->IsOut((Bnd_Box const &)*arg2,(gp_Trsf const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_IsOut\n  * wrapname: _wrap_Bnd_Box_IsOut__SWIG_4\n  * fulldecl: Standard_Boolean Bnd_Box::IsOut(Bnd_Box const &,gp_Trsf const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_Bnd_Box_IsOut__SWIG_5 (Bnd_Box *larg1, gp_Trsf *larg2, Bnd_Box *larg3, gp_Trsf *larg4) {
  bool lresult = (bool)0 ;
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  gp_Trsf *arg2 = 0 ;
  Bnd_Box *arg3 = 0 ;
  gp_Trsf *arg4 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Bnd_Box const *)arg1)->IsOut((gp_Trsf const &)*arg2,(Bnd_Box const &)*arg3,(gp_Trsf const &)*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_IsOut\n  * wrapname: _wrap_Bnd_Box_IsOut__SWIG_5\n  * fulldecl: Standard_Boolean Bnd_Box::IsOut(gp_Trsf const &,Bnd_Box const &,gp_Trsf const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_Bnd_Box_IsOut__SWIG_6 (Bnd_Box *larg1, gp_Pnt *larg2, gp_Pnt *larg3, gp_Dir *larg4) {
  bool lresult = (bool)0 ;
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  gp_Dir *arg4 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Bnd_Box const *)arg1)->IsOut((gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3,(gp_Dir const &)*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_IsOut\n  * wrapname: _wrap_Bnd_Box_IsOut__SWIG_6\n  * fulldecl: Standard_Boolean Bnd_Box::IsOut(gp_Pnt const &,gp_Pnt const &,gp_Dir const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Standard_Real _wrap_Bnd_Box_Distance (Bnd_Box *larg1, Bnd_Box *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  Bnd_Box *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((Bnd_Box const *)arg1)->Distance((Bnd_Box const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_Distance\n  * wrapname: _wrap_Bnd_Box_Distance\n  * fulldecl: Standard_Real Bnd_Box::Distance(Bnd_Box const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_Bnd_Box_Dump (Bnd_Box *larg1) {
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((Bnd_Box const *)arg1)->Dump();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_Dump\n  * wrapname: _wrap_Bnd_Box_Dump\n  * fulldecl: void Bnd_Box::Dump() const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Real _wrap_Bnd_Box_SquareExtent (Bnd_Box *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((Bnd_Box const *)arg1)->SquareExtent();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_SquareExtent\n  * wrapname: _wrap_Bnd_Box_SquareExtent\n  * fulldecl: Standard_Real Bnd_Box::SquareExtent() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_delete_Bnd_Box (Bnd_Box *larg1) {
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Bnd_Box\n  * wrapname: _wrap_delete_Bnd_Box\n  * fulldecl: Bnd_Box::~Bnd_Box()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <BndLib_Add3dCurve.hxx>
  
EXPORT void _wrap_BndLib_Add3dCurve_Add__SWIG_0 (Adaptor3d_Curve *larg1, Standard_Real larg2, Bnd_Box *larg3) {
  Adaptor3d_Curve *arg1 = 0 ;
  Standard_Real arg2 ;
  Bnd_Box *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BndLib_Add3dCurve::Add((Adaptor3d_Curve const &)*arg1,arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BndLib_Add3dCurve_Add\n  * wrapname: _wrap_BndLib_Add3dCurve_Add__SWIG_0\n  * fulldecl: void BndLib_Add3dCurve::Add(Adaptor3d_Curve const &,Standard_Real const,Bnd_Box &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BndLib_Add3dCurve_Add__SWIG_1 (Adaptor3d_Curve *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4, Bnd_Box *larg5) {
  Adaptor3d_Curve *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Bnd_Box *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BndLib_Add3dCurve::Add((Adaptor3d_Curve const &)*arg1,arg2,arg3,arg4,*arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BndLib_Add3dCurve_Add\n  * wrapname: _wrap_BndLib_Add3dCurve_Add__SWIG_1\n  * fulldecl: void BndLib_Add3dCurve::Add(Adaptor3d_Curve const &,Standard_Real const,Standard_Real const,Standard_Real const,Bnd_Box &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BndLib_Add3dCurve_AddOptimal__SWIG_0 (Adaptor3d_Curve *larg1, Standard_Real larg2, Bnd_Box *larg3) {
  Adaptor3d_Curve *arg1 = 0 ;
  Standard_Real arg2 ;
  Bnd_Box *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BndLib_Add3dCurve::AddOptimal((Adaptor3d_Curve const &)*arg1,arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BndLib_Add3dCurve_AddOptimal\n  * wrapname: _wrap_BndLib_Add3dCurve_AddOptimal__SWIG_0\n  * fulldecl: void BndLib_Add3dCurve::AddOptimal(Adaptor3d_Curve const &,Standard_Real const,Bnd_Box &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BndLib_Add3dCurve_AddOptimal__SWIG_1 (Adaptor3d_Curve *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4, Bnd_Box *larg5) {
  Adaptor3d_Curve *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Bnd_Box *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BndLib_Add3dCurve::AddOptimal((Adaptor3d_Curve const &)*arg1,arg2,arg3,arg4,*arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BndLib_Add3dCurve_AddOptimal\n  * wrapname: _wrap_BndLib_Add3dCurve_AddOptimal__SWIG_1\n  * fulldecl: void BndLib_Add3dCurve::AddOptimal(Adaptor3d_Curve const &,Standard_Real const,Standard_Real const,Standard_Real const,Bnd_Box &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BndLib_Add3dCurve_AddGenCurv (Adaptor3d_Curve *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4, Bnd_Box *larg5) {
  Adaptor3d_Curve *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Bnd_Box *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BndLib_Add3dCurve::AddGenCurv((Adaptor3d_Curve const &)*arg1,arg2,arg3,arg4,*arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BndLib_Add3dCurve_AddGenCurv\n  * wrapname: _wrap_BndLib_Add3dCurve_AddGenCurv\n  * fulldecl: void BndLib_Add3dCurve::AddGenCurv(Adaptor3d_Curve const &,Standard_Real const,Standard_Real const,Standard_Real const,Bnd_Box &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



  #include <Adaptor2d_Curve2d.hxx>
  #include <Geom2dAdaptor_Curve.hxx>
  #include <Adaptor2d_HCurve2d.hxx>
 
EXPORT gp_Pnt2d *_wrap_Adaptor2d_Curve2d_Value (Adaptor2d_Curve2d *larg1, Standard_Real larg2) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Adaptor2d_Curve2d *arg1 = (Adaptor2d_Curve2d *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Adaptor2d_Curve2d const *)arg1)->Value(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_Curve2d_Value\n  * wrapname: _wrap_Adaptor2d_Curve2d_Value\n  * fulldecl: gp_Pnt2d Adaptor2d_Curve2d::Value(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT void _wrap_delete_Adaptor2d_Curve2d (Adaptor2d_Curve2d *larg1) {
  Adaptor2d_Curve2d *arg1 = (Adaptor2d_Curve2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Adaptor2d_Curve2d\n  * wrapname: _wrap_delete_Adaptor2d_Curve2d\n  * fulldecl: Adaptor2d_Curve2d::~Adaptor2d_Curve2d()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Geom2dAdaptor_Curve *_wrap_new_Geom2dAdaptor_Curve__SWIG_0 () {
  Geom2dAdaptor_Curve * lresult = (Geom2dAdaptor_Curve *)0 ;
  Geom2dAdaptor_Curve *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Geom2dAdaptor_Curve *)new Geom2dAdaptor_Curve();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2dAdaptor_Curve\n  * wrapname: _wrap_new_Geom2dAdaptor_Curve__SWIG_0\n  * fulldecl: Geom2dAdaptor_Curve::Geom2dAdaptor_Curve()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Geom2dAdaptor_Curve *)0;
  }
}


EXPORT Geom2dAdaptor_Curve *_wrap_new_Geom2dAdaptor_Curve__SWIG_1 (Handle_Geom2d_Curve *larg1) {
  Geom2dAdaptor_Curve * lresult = (Geom2dAdaptor_Curve *)0 ;
  Handle_Geom2d_Curve *arg1 = 0 ;
  Geom2dAdaptor_Curve *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Geom2dAdaptor_Curve *)new Geom2dAdaptor_Curve((Handle_Geom2d_Curve const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2dAdaptor_Curve\n  * wrapname: _wrap_new_Geom2dAdaptor_Curve__SWIG_1\n  * fulldecl: Geom2dAdaptor_Curve::Geom2dAdaptor_Curve(Handle_Geom2d_Curve const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Geom2dAdaptor_Curve *)0;
  }
}


EXPORT Geom2dAdaptor_Curve *_wrap_new_Geom2dAdaptor_Curve__SWIG_2 (Handle_Geom2d_Curve *larg1, Standard_Real larg2, Standard_Real larg3) {
  Geom2dAdaptor_Curve * lresult = (Geom2dAdaptor_Curve *)0 ;
  Handle_Geom2d_Curve *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Geom2dAdaptor_Curve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Geom2dAdaptor_Curve *)new Geom2dAdaptor_Curve((Handle_Geom2d_Curve const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2dAdaptor_Curve\n  * wrapname: _wrap_new_Geom2dAdaptor_Curve__SWIG_2\n  * fulldecl: Geom2dAdaptor_Curve::Geom2dAdaptor_Curve(Handle_Geom2d_Curve const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Geom2dAdaptor_Curve *)0;
  }
}


EXPORT void _wrap_Geom2dAdaptor_Curve_Load__SWIG_0 (Geom2dAdaptor_Curve *larg1, Handle_Geom2d_Curve *larg2) {
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Handle_Geom2d_Curve *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Load((Handle_Geom2d_Curve const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Load\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Load__SWIG_0\n  * fulldecl: void Geom2dAdaptor_Curve::Load(Handle_Geom2d_Curve const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Geom2dAdaptor_Curve_Load__SWIG_1 (Geom2dAdaptor_Curve *larg1, Handle_Geom2d_Curve *larg2, Standard_Real larg3, Standard_Real larg4) {
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Handle_Geom2d_Curve *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Load((Handle_Geom2d_Curve const &)*arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Load\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Load__SWIG_1\n  * fulldecl: void Geom2dAdaptor_Curve::Load(Handle_Geom2d_Curve const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Handle_Geom2d_Curve *_wrap_Geom2dAdaptor_Curve_Curve (Geom2dAdaptor_Curve *larg1) {
  Handle_Geom2d_Curve * lresult = (Handle_Geom2d_Curve *)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Handle_Geom2d_Curve *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Curve *) &((Geom2dAdaptor_Curve const *)arg1)->Curve();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Curve\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Curve\n  * fulldecl: Handle_Geom2d_Curve const & Geom2dAdaptor_Curve::Curve() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Curve *)0;
  }
}


EXPORT Standard_Real _wrap_Geom2dAdaptor_Curve_FirstParameter (Geom2dAdaptor_Curve *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((Geom2dAdaptor_Curve const *)arg1)->FirstParameter();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_FirstParameter\n  * wrapname: _wrap_Geom2dAdaptor_Curve_FirstParameter\n  * fulldecl: Standard_Real Geom2dAdaptor_Curve::FirstParameter() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_Geom2dAdaptor_Curve_LastParameter (Geom2dAdaptor_Curve *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((Geom2dAdaptor_Curve const *)arg1)->LastParameter();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_LastParameter\n  * wrapname: _wrap_Geom2dAdaptor_Curve_LastParameter\n  * fulldecl: Standard_Real Geom2dAdaptor_Curve::LastParameter() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT GeomAbs_Shape _wrap_Geom2dAdaptor_Curve_Continuity (Geom2dAdaptor_Curve *larg1) {
  GeomAbs_Shape lresult = (GeomAbs_Shape)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  GeomAbs_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAbs_Shape)((Geom2dAdaptor_Curve const *)arg1)->Continuity();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Continuity\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Continuity\n  * fulldecl: GeomAbs_Shape Geom2dAdaptor_Curve::Continuity() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAbs_Shape)0;
  }
}


EXPORT Standard_Integer _wrap_Geom2dAdaptor_Curve_NbIntervals (Geom2dAdaptor_Curve *larg1, GeomAbs_Shape larg2) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  GeomAbs_Shape arg2 ;
  Standard_Integer result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((Geom2dAdaptor_Curve const *)arg1)->NbIntervals(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_NbIntervals\n  * wrapname: _wrap_Geom2dAdaptor_Curve_NbIntervals\n  * fulldecl: Standard_Integer Geom2dAdaptor_Curve::NbIntervals(GeomAbs_Shape const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT void _wrap_Geom2dAdaptor_Curve_Intervals (Geom2dAdaptor_Curve *larg1, TColStd_Array1OfReal *larg2, GeomAbs_Shape larg3) {
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  GeomAbs_Shape arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((Geom2dAdaptor_Curve const *)arg1)->Intervals(*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Intervals\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Intervals\n  * fulldecl: void Geom2dAdaptor_Curve::Intervals(TColStd_Array1OfReal &,GeomAbs_Shape const) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Handle_Adaptor2d_HCurve2d *_wrap_Geom2dAdaptor_Curve_Trim (Geom2dAdaptor_Curve *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4) {
  Handle_Adaptor2d_HCurve2d * lresult = (Handle_Adaptor2d_HCurve2d *)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Handle_Adaptor2d_HCurve2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Geom2dAdaptor_Curve const *)arg1)->Trim(arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Trim\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Trim\n  * fulldecl: Handle_Adaptor2d_HCurve2d Geom2dAdaptor_Curve::Trim(Standard_Real const,Standard_Real const,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Adaptor2d_HCurve2d(result);
    return lresult;
  } catch (...) {
    return (Handle_Adaptor2d_HCurve2d *)0;
  }
}


EXPORT bool _wrap_Geom2dAdaptor_Curve_IsClosed (Geom2dAdaptor_Curve *larg1) {
  bool lresult = (bool)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Geom2dAdaptor_Curve const *)arg1)->IsClosed();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_IsClosed\n  * wrapname: _wrap_Geom2dAdaptor_Curve_IsClosed\n  * fulldecl: Standard_Boolean Geom2dAdaptor_Curve::IsClosed() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_Geom2dAdaptor_Curve_IsPeriodic (Geom2dAdaptor_Curve *larg1) {
  bool lresult = (bool)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Geom2dAdaptor_Curve const *)arg1)->IsPeriodic();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_IsPeriodic\n  * wrapname: _wrap_Geom2dAdaptor_Curve_IsPeriodic\n  * fulldecl: Standard_Boolean Geom2dAdaptor_Curve::IsPeriodic() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Standard_Real _wrap_Geom2dAdaptor_Curve_Period (Geom2dAdaptor_Curve *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((Geom2dAdaptor_Curve const *)arg1)->Period();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Period\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Period\n  * fulldecl: Standard_Real Geom2dAdaptor_Curve::Period() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Pnt2d *_wrap_Geom2dAdaptor_Curve_Value (Geom2dAdaptor_Curve *larg1, Standard_Real larg2) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Geom2dAdaptor_Curve const *)arg1)->Value(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Value\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Value\n  * fulldecl: gp_Pnt2d Geom2dAdaptor_Curve::Value(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT void _wrap_Geom2dAdaptor_Curve_D0 (Geom2dAdaptor_Curve *larg1, Standard_Real larg2, gp_Pnt2d *larg3) {
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((Geom2dAdaptor_Curve const *)arg1)->D0(arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_D0\n  * wrapname: _wrap_Geom2dAdaptor_Curve_D0\n  * fulldecl: void Geom2dAdaptor_Curve::D0(Standard_Real const,gp_Pnt2d &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Geom2dAdaptor_Curve_D1 (Geom2dAdaptor_Curve *larg1, Standard_Real larg2, gp_Pnt2d *larg3, gp_Vec2d *larg4) {
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  gp_Vec2d *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((Geom2dAdaptor_Curve const *)arg1)->D1(arg2,*arg3,*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_D1\n  * wrapname: _wrap_Geom2dAdaptor_Curve_D1\n  * fulldecl: void Geom2dAdaptor_Curve::D1(Standard_Real const,gp_Pnt2d &,gp_Vec2d &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Geom2dAdaptor_Curve_D2 (Geom2dAdaptor_Curve *larg1, Standard_Real larg2, gp_Pnt2d *larg3, gp_Vec2d *larg4, gp_Vec2d *larg5) {
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  gp_Vec2d *arg4 = 0 ;
  gp_Vec2d *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((Geom2dAdaptor_Curve const *)arg1)->D2(arg2,*arg3,*arg4,*arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_D2\n  * wrapname: _wrap_Geom2dAdaptor_Curve_D2\n  * fulldecl: void Geom2dAdaptor_Curve::D2(Standard_Real const,gp_Pnt2d &,gp_Vec2d &,gp_Vec2d &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Geom2dAdaptor_Curve_D3 (Geom2dAdaptor_Curve *larg1, Standard_Real larg2, gp_Pnt2d *larg3, gp_Vec2d *larg4, gp_Vec2d *larg5, gp_Vec2d *larg6) {
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  gp_Vec2d *arg4 = 0 ;
  gp_Vec2d *arg5 = 0 ;
  gp_Vec2d *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((Geom2dAdaptor_Curve const *)arg1)->D3(arg2,*arg3,*arg4,*arg5,*arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_D3\n  * wrapname: _wrap_Geom2dAdaptor_Curve_D3\n  * fulldecl: void Geom2dAdaptor_Curve::D3(Standard_Real const,gp_Pnt2d &,gp_Vec2d &,gp_Vec2d &,gp_Vec2d &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec2d *_wrap_Geom2dAdaptor_Curve_DN (Geom2dAdaptor_Curve *larg1, Standard_Real larg2, Standard_Integer larg3) {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Real arg2 ;
  Standard_Integer arg3 ;
  gp_Vec2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Geom2dAdaptor_Curve const *)arg1)->DN(arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_DN\n  * wrapname: _wrap_Geom2dAdaptor_Curve_DN\n  * fulldecl: gp_Vec2d Geom2dAdaptor_Curve::DN(Standard_Real const,Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec2d(result);
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


EXPORT Standard_Real _wrap_Geom2dAdaptor_Curve_Resolution (Geom2dAdaptor_Curve *larg1, Standard_Real larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Real arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((Geom2dAdaptor_Curve const *)arg1)->Resolution(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Resolution\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Resolution\n  * fulldecl: Standard_Real Geom2dAdaptor_Curve::Resolution(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT GeomAbs_CurveType *_wrap_Geom2dAdaptor_Curve_GetType (Geom2dAdaptor_Curve *larg1) {
  GeomAbs_CurveType * lresult = (GeomAbs_CurveType *)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  GeomAbs_CurveType result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Geom2dAdaptor_Curve const *)arg1)->GetType();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_GetType\n  * wrapname: _wrap_Geom2dAdaptor_Curve_GetType\n  * fulldecl: GeomAbs_CurveType Geom2dAdaptor_Curve::GetType() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new GeomAbs_CurveType(result);
    return lresult;
  } catch (...) {
    return (GeomAbs_CurveType *)0;
  }
}


EXPORT gp_Lin2d *_wrap_Geom2dAdaptor_Curve_Line (Geom2dAdaptor_Curve *larg1) {
  gp_Lin2d * lresult = (gp_Lin2d *)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  gp_Lin2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Geom2dAdaptor_Curve const *)arg1)->Line();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Line\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Line\n  * fulldecl: gp_Lin2d Geom2dAdaptor_Curve::Line() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Lin2d(result);
    return lresult;
  } catch (...) {
    return (gp_Lin2d *)0;
  }
}


EXPORT gp_Circ2d *_wrap_Geom2dAdaptor_Curve_Circle (Geom2dAdaptor_Curve *larg1) {
  gp_Circ2d * lresult = (gp_Circ2d *)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  gp_Circ2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Geom2dAdaptor_Curve const *)arg1)->Circle();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Circle\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Circle\n  * fulldecl: gp_Circ2d Geom2dAdaptor_Curve::Circle() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Circ2d(result);
    return lresult;
  } catch (...) {
    return (gp_Circ2d *)0;
  }
}


EXPORT gp_Elips2d *_wrap_Geom2dAdaptor_Curve_Ellipse (Geom2dAdaptor_Curve *larg1) {
  gp_Elips2d * lresult = (gp_Elips2d *)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  gp_Elips2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Geom2dAdaptor_Curve const *)arg1)->Ellipse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Ellipse\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Ellipse\n  * fulldecl: gp_Elips2d Geom2dAdaptor_Curve::Ellipse() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Elips2d(result);
    return lresult;
  } catch (...) {
    return (gp_Elips2d *)0;
  }
}


EXPORT gp_Hypr2d *_wrap_Geom2dAdaptor_Curve_Hyperbola (Geom2dAdaptor_Curve *larg1) {
  gp_Hypr2d * lresult = (gp_Hypr2d *)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  gp_Hypr2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Geom2dAdaptor_Curve const *)arg1)->Hyperbola();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Hyperbola\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Hyperbola\n  * fulldecl: gp_Hypr2d Geom2dAdaptor_Curve::Hyperbola() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr2d(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr2d *)0;
  }
}


EXPORT gp_Parab2d *_wrap_Geom2dAdaptor_Curve_Parabola (Geom2dAdaptor_Curve *larg1) {
  gp_Parab2d * lresult = (gp_Parab2d *)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  gp_Parab2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Geom2dAdaptor_Curve const *)arg1)->Parabola();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Parabola\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Parabola\n  * fulldecl: gp_Parab2d Geom2dAdaptor_Curve::Parabola() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Parab2d(result);
    return lresult;
  } catch (...) {
    return (gp_Parab2d *)0;
  }
}


EXPORT Standard_Integer _wrap_Geom2dAdaptor_Curve_Degree (Geom2dAdaptor_Curve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((Geom2dAdaptor_Curve const *)arg1)->Degree();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Degree\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Degree\n  * fulldecl: Standard_Integer Geom2dAdaptor_Curve::Degree() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT bool _wrap_Geom2dAdaptor_Curve_IsRational (Geom2dAdaptor_Curve *larg1) {
  bool lresult = (bool)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Geom2dAdaptor_Curve const *)arg1)->IsRational();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_IsRational\n  * wrapname: _wrap_Geom2dAdaptor_Curve_IsRational\n  * fulldecl: Standard_Boolean Geom2dAdaptor_Curve::IsRational() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Standard_Integer _wrap_Geom2dAdaptor_Curve_NbPoles (Geom2dAdaptor_Curve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((Geom2dAdaptor_Curve const *)arg1)->NbPoles();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_NbPoles\n  * wrapname: _wrap_Geom2dAdaptor_Curve_NbPoles\n  * fulldecl: Standard_Integer Geom2dAdaptor_Curve::NbPoles() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT Standard_Integer _wrap_Geom2dAdaptor_Curve_NbKnots (Geom2dAdaptor_Curve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((Geom2dAdaptor_Curve const *)arg1)->NbKnots();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_NbKnots\n  * wrapname: _wrap_Geom2dAdaptor_Curve_NbKnots\n  * fulldecl: Standard_Integer Geom2dAdaptor_Curve::NbKnots() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT Standard_Integer _wrap_Geom2dAdaptor_Curve_NbSamples (Geom2dAdaptor_Curve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((Geom2dAdaptor_Curve const *)arg1)->NbSamples();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_NbSamples\n  * wrapname: _wrap_Geom2dAdaptor_Curve_NbSamples\n  * fulldecl: Standard_Integer Geom2dAdaptor_Curve::NbSamples() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT Handle_Geom2d_BezierCurve *_wrap_Geom2dAdaptor_Curve_Bezier (Geom2dAdaptor_Curve *larg1) {
  Handle_Geom2d_BezierCurve * lresult = (Handle_Geom2d_BezierCurve *)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  SwigValueWrapper< Handle_Geom2d_BezierCurve > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Geom2dAdaptor_Curve const *)arg1)->Bezier();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Bezier\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Bezier\n  * fulldecl: Handle_Geom2d_BezierCurve Geom2dAdaptor_Curve::Bezier() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_BezierCurve(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_BezierCurve *)0;
  }
}


EXPORT Handle_Geom2d_BSplineCurve *_wrap_Geom2dAdaptor_Curve_BSpline (Geom2dAdaptor_Curve *larg1) {
  Handle_Geom2d_BSplineCurve * lresult = (Handle_Geom2d_BSplineCurve *)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  SwigValueWrapper< Handle_Geom2d_BSplineCurve > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Geom2dAdaptor_Curve const *)arg1)->BSpline();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_BSpline\n  * wrapname: _wrap_Geom2dAdaptor_Curve_BSpline\n  * fulldecl: Handle_Geom2d_BSplineCurve Geom2dAdaptor_Curve::BSpline() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_BSplineCurve(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_BSplineCurve *)0;
  }
}


EXPORT void _wrap_delete_Geom2dAdaptor_Curve (Geom2dAdaptor_Curve *larg1) {
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom2dAdaptor_Curve\n  * wrapname: _wrap_delete_Geom2dAdaptor_Curve\n  * fulldecl: Geom2dAdaptor_Curve::~Geom2dAdaptor_Curve()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Adaptor2d_Curve2d *_wrap_Adaptor2d_HCurve2d_Curve2d (Adaptor2d_HCurve2d *larg1) {
  Adaptor2d_Curve2d * lresult = (Adaptor2d_Curve2d *)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Adaptor2d_Curve2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Adaptor2d_Curve2d *) &((Adaptor2d_HCurve2d const *)arg1)->Curve2d();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_Curve2d\n  * wrapname: _wrap_Adaptor2d_HCurve2d_Curve2d\n  * fulldecl: Adaptor2d_Curve2d const & Adaptor2d_HCurve2d::Curve2d() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Adaptor2d_Curve2d *)0;
  }
}


EXPORT Standard_Real _wrap_Adaptor2d_HCurve2d_FirstParameter (Adaptor2d_HCurve2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((Adaptor2d_HCurve2d const *)arg1)->FirstParameter();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_FirstParameter\n  * wrapname: _wrap_Adaptor2d_HCurve2d_FirstParameter\n  * fulldecl: Standard_Real Adaptor2d_HCurve2d::FirstParameter() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_Adaptor2d_HCurve2d_LastParameter (Adaptor2d_HCurve2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((Adaptor2d_HCurve2d const *)arg1)->LastParameter();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_LastParameter\n  * wrapname: _wrap_Adaptor2d_HCurve2d_LastParameter\n  * fulldecl: Standard_Real Adaptor2d_HCurve2d::LastParameter() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT GeomAbs_Shape _wrap_Adaptor2d_HCurve2d_Continuity (Adaptor2d_HCurve2d *larg1) {
  GeomAbs_Shape lresult = (GeomAbs_Shape)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  GeomAbs_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAbs_Shape)((Adaptor2d_HCurve2d const *)arg1)->Continuity();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_Continuity\n  * wrapname: _wrap_Adaptor2d_HCurve2d_Continuity\n  * fulldecl: GeomAbs_Shape Adaptor2d_HCurve2d::Continuity() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAbs_Shape)0;
  }
}


EXPORT Standard_Integer _wrap_Adaptor2d_HCurve2d_NbIntervals (Adaptor2d_HCurve2d *larg1, GeomAbs_Shape larg2) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  GeomAbs_Shape arg2 ;
  Standard_Integer result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((Adaptor2d_HCurve2d const *)arg1)->NbIntervals(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_NbIntervals\n  * wrapname: _wrap_Adaptor2d_HCurve2d_NbIntervals\n  * fulldecl: Standard_Integer Adaptor2d_HCurve2d::NbIntervals(GeomAbs_Shape const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT void _wrap_Adaptor2d_HCurve2d_Intervals (Adaptor2d_HCurve2d *larg1, TColStd_Array1OfReal *larg2, GeomAbs_Shape larg3) {
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  GeomAbs_Shape arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((Adaptor2d_HCurve2d const *)arg1)->Intervals(*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_Intervals\n  * wrapname: _wrap_Adaptor2d_HCurve2d_Intervals\n  * fulldecl: void Adaptor2d_HCurve2d::Intervals(TColStd_Array1OfReal &,GeomAbs_Shape const) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Handle_Adaptor2d_HCurve2d *_wrap_Adaptor2d_HCurve2d_Trim (Adaptor2d_HCurve2d *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4) {
  Handle_Adaptor2d_HCurve2d * lresult = (Handle_Adaptor2d_HCurve2d *)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Handle_Adaptor2d_HCurve2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Adaptor2d_HCurve2d const *)arg1)->Trim(arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_Trim\n  * wrapname: _wrap_Adaptor2d_HCurve2d_Trim\n  * fulldecl: Handle_Adaptor2d_HCurve2d Adaptor2d_HCurve2d::Trim(Standard_Real const,Standard_Real const,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Adaptor2d_HCurve2d(result);
    return lresult;
  } catch (...) {
    return (Handle_Adaptor2d_HCurve2d *)0;
  }
}


EXPORT bool _wrap_Adaptor2d_HCurve2d_IsClosed (Adaptor2d_HCurve2d *larg1) {
  bool lresult = (bool)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Adaptor2d_HCurve2d const *)arg1)->IsClosed();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_IsClosed\n  * wrapname: _wrap_Adaptor2d_HCurve2d_IsClosed\n  * fulldecl: Standard_Boolean Adaptor2d_HCurve2d::IsClosed() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_Adaptor2d_HCurve2d_IsPeriodic (Adaptor2d_HCurve2d *larg1) {
  bool lresult = (bool)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Adaptor2d_HCurve2d const *)arg1)->IsPeriodic();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_IsPeriodic\n  * wrapname: _wrap_Adaptor2d_HCurve2d_IsPeriodic\n  * fulldecl: Standard_Boolean Adaptor2d_HCurve2d::IsPeriodic() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Standard_Real _wrap_Adaptor2d_HCurve2d_Period (Adaptor2d_HCurve2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((Adaptor2d_HCurve2d const *)arg1)->Period();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_Period\n  * wrapname: _wrap_Adaptor2d_HCurve2d_Period\n  * fulldecl: Standard_Real Adaptor2d_HCurve2d::Period() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Pnt2d *_wrap_Adaptor2d_HCurve2d_Value (Adaptor2d_HCurve2d *larg1, Standard_Real larg2) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Adaptor2d_HCurve2d const *)arg1)->Value(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_Value\n  * wrapname: _wrap_Adaptor2d_HCurve2d_Value\n  * fulldecl: gp_Pnt2d Adaptor2d_HCurve2d::Value(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT void _wrap_Adaptor2d_HCurve2d_D0 (Adaptor2d_HCurve2d *larg1, Standard_Real larg2, gp_Pnt2d *larg3) {
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((Adaptor2d_HCurve2d const *)arg1)->D0(arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_D0\n  * wrapname: _wrap_Adaptor2d_HCurve2d_D0\n  * fulldecl: void Adaptor2d_HCurve2d::D0(Standard_Real const,gp_Pnt2d &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Adaptor2d_HCurve2d_D1 (Adaptor2d_HCurve2d *larg1, Standard_Real larg2, gp_Pnt2d *larg3, gp_Vec2d *larg4) {
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  gp_Vec2d *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((Adaptor2d_HCurve2d const *)arg1)->D1(arg2,*arg3,*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_D1\n  * wrapname: _wrap_Adaptor2d_HCurve2d_D1\n  * fulldecl: void Adaptor2d_HCurve2d::D1(Standard_Real const,gp_Pnt2d &,gp_Vec2d &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Adaptor2d_HCurve2d_D2 (Adaptor2d_HCurve2d *larg1, Standard_Real larg2, gp_Pnt2d *larg3, gp_Vec2d *larg4, gp_Vec2d *larg5) {
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  gp_Vec2d *arg4 = 0 ;
  gp_Vec2d *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((Adaptor2d_HCurve2d const *)arg1)->D2(arg2,*arg3,*arg4,*arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_D2\n  * wrapname: _wrap_Adaptor2d_HCurve2d_D2\n  * fulldecl: void Adaptor2d_HCurve2d::D2(Standard_Real const,gp_Pnt2d &,gp_Vec2d &,gp_Vec2d &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Adaptor2d_HCurve2d_D3 (Adaptor2d_HCurve2d *larg1, Standard_Real larg2, gp_Pnt2d *larg3, gp_Vec2d *larg4, gp_Vec2d *larg5, gp_Vec2d *larg6) {
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  gp_Vec2d *arg4 = 0 ;
  gp_Vec2d *arg5 = 0 ;
  gp_Vec2d *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((Adaptor2d_HCurve2d const *)arg1)->D3(arg2,*arg3,*arg4,*arg5,*arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_D3\n  * wrapname: _wrap_Adaptor2d_HCurve2d_D3\n  * fulldecl: void Adaptor2d_HCurve2d::D3(Standard_Real const,gp_Pnt2d &,gp_Vec2d &,gp_Vec2d &,gp_Vec2d &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec2d *_wrap_Adaptor2d_HCurve2d_DN (Adaptor2d_HCurve2d *larg1, Standard_Real larg2, Standard_Integer larg3) {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Real arg2 ;
  Standard_Integer arg3 ;
  gp_Vec2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Adaptor2d_HCurve2d const *)arg1)->DN(arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_DN\n  * wrapname: _wrap_Adaptor2d_HCurve2d_DN\n  * fulldecl: gp_Vec2d Adaptor2d_HCurve2d::DN(Standard_Real const,Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec2d(result);
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


EXPORT Standard_Real _wrap_Adaptor2d_HCurve2d_Resolution (Adaptor2d_HCurve2d *larg1, Standard_Real larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Real arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((Adaptor2d_HCurve2d const *)arg1)->Resolution(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_Resolution\n  * wrapname: _wrap_Adaptor2d_HCurve2d_Resolution\n  * fulldecl: Standard_Real Adaptor2d_HCurve2d::Resolution(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT GeomAbs_CurveType *_wrap_Adaptor2d_HCurve2d_GetType (Adaptor2d_HCurve2d *larg1) {
  GeomAbs_CurveType * lresult = (GeomAbs_CurveType *)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  GeomAbs_CurveType result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Adaptor2d_HCurve2d const *)arg1)->GetType();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_GetType\n  * wrapname: _wrap_Adaptor2d_HCurve2d_GetType\n  * fulldecl: GeomAbs_CurveType Adaptor2d_HCurve2d::GetType() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new GeomAbs_CurveType(result);
    return lresult;
  } catch (...) {
    return (GeomAbs_CurveType *)0;
  }
}


EXPORT gp_Lin2d *_wrap_Adaptor2d_HCurve2d_Line (Adaptor2d_HCurve2d *larg1) {
  gp_Lin2d * lresult = (gp_Lin2d *)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  gp_Lin2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Adaptor2d_HCurve2d const *)arg1)->Line();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_Line\n  * wrapname: _wrap_Adaptor2d_HCurve2d_Line\n  * fulldecl: gp_Lin2d Adaptor2d_HCurve2d::Line() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Lin2d(result);
    return lresult;
  } catch (...) {
    return (gp_Lin2d *)0;
  }
}


EXPORT gp_Circ2d *_wrap_Adaptor2d_HCurve2d_Circle (Adaptor2d_HCurve2d *larg1) {
  gp_Circ2d * lresult = (gp_Circ2d *)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  gp_Circ2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Adaptor2d_HCurve2d const *)arg1)->Circle();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_Circle\n  * wrapname: _wrap_Adaptor2d_HCurve2d_Circle\n  * fulldecl: gp_Circ2d Adaptor2d_HCurve2d::Circle() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Circ2d(result);
    return lresult;
  } catch (...) {
    return (gp_Circ2d *)0;
  }
}


EXPORT gp_Elips2d *_wrap_Adaptor2d_HCurve2d_Ellipse (Adaptor2d_HCurve2d *larg1) {
  gp_Elips2d * lresult = (gp_Elips2d *)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  gp_Elips2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Adaptor2d_HCurve2d const *)arg1)->Ellipse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_Ellipse\n  * wrapname: _wrap_Adaptor2d_HCurve2d_Ellipse\n  * fulldecl: gp_Elips2d Adaptor2d_HCurve2d::Ellipse() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Elips2d(result);
    return lresult;
  } catch (...) {
    return (gp_Elips2d *)0;
  }
}


EXPORT gp_Hypr2d *_wrap_Adaptor2d_HCurve2d_Hyperbola (Adaptor2d_HCurve2d *larg1) {
  gp_Hypr2d * lresult = (gp_Hypr2d *)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  gp_Hypr2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Adaptor2d_HCurve2d const *)arg1)->Hyperbola();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_Hyperbola\n  * wrapname: _wrap_Adaptor2d_HCurve2d_Hyperbola\n  * fulldecl: gp_Hypr2d Adaptor2d_HCurve2d::Hyperbola() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr2d(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr2d *)0;
  }
}


EXPORT gp_Parab2d *_wrap_Adaptor2d_HCurve2d_Parabola (Adaptor2d_HCurve2d *larg1) {
  gp_Parab2d * lresult = (gp_Parab2d *)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  gp_Parab2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Adaptor2d_HCurve2d const *)arg1)->Parabola();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_Parabola\n  * wrapname: _wrap_Adaptor2d_HCurve2d_Parabola\n  * fulldecl: gp_Parab2d Adaptor2d_HCurve2d::Parabola() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Parab2d(result);
    return lresult;
  } catch (...) {
    return (gp_Parab2d *)0;
  }
}


EXPORT Standard_Integer _wrap_Adaptor2d_HCurve2d_Degree (Adaptor2d_HCurve2d *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((Adaptor2d_HCurve2d const *)arg1)->Degree();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_Degree\n  * wrapname: _wrap_Adaptor2d_HCurve2d_Degree\n  * fulldecl: Standard_Integer Adaptor2d_HCurve2d::Degree() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT bool _wrap_Adaptor2d_HCurve2d_IsRational (Adaptor2d_HCurve2d *larg1) {
  bool lresult = (bool)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Adaptor2d_HCurve2d const *)arg1)->IsRational();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_IsRational\n  * wrapname: _wrap_Adaptor2d_HCurve2d_IsRational\n  * fulldecl: Standard_Boolean Adaptor2d_HCurve2d::IsRational() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Standard_Integer _wrap_Adaptor2d_HCurve2d_NbPoles (Adaptor2d_HCurve2d *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((Adaptor2d_HCurve2d const *)arg1)->NbPoles();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_NbPoles\n  * wrapname: _wrap_Adaptor2d_HCurve2d_NbPoles\n  * fulldecl: Standard_Integer Adaptor2d_HCurve2d::NbPoles() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT Standard_Integer _wrap_Adaptor2d_HCurve2d_NbKnots (Adaptor2d_HCurve2d *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((Adaptor2d_HCurve2d const *)arg1)->NbKnots();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_NbKnots\n  * wrapname: _wrap_Adaptor2d_HCurve2d_NbKnots\n  * fulldecl: Standard_Integer Adaptor2d_HCurve2d::NbKnots() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT Handle_Geom2d_BezierCurve *_wrap_Adaptor2d_HCurve2d_Bezier (Adaptor2d_HCurve2d *larg1) {
  Handle_Geom2d_BezierCurve * lresult = (Handle_Geom2d_BezierCurve *)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  SwigValueWrapper< Handle_Geom2d_BezierCurve > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Adaptor2d_HCurve2d const *)arg1)->Bezier();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_Bezier\n  * wrapname: _wrap_Adaptor2d_HCurve2d_Bezier\n  * fulldecl: Handle_Geom2d_BezierCurve Adaptor2d_HCurve2d::Bezier() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_BezierCurve(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_BezierCurve *)0;
  }
}


EXPORT void _wrap_delete_Adaptor2d_HCurve2d (Adaptor2d_HCurve2d *larg1) {
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Adaptor2d_HCurve2d\n  * wrapname: _wrap_delete_Adaptor2d_HCurve2d\n  * fulldecl: Adaptor2d_HCurve2d::~Adaptor2d_HCurve2d()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



  #include <Adaptor3d_Curve.hxx>
  #include <Adaptor3d_HCurve.hxx>  
  #include <GeomAdaptor_Curve.hxx>
  
EXPORT gp_Pnt const *_wrap_Adaptor3d_Curve_Value (Adaptor3d_Curve *larg1, Standard_Real larg2) {
  gp_Pnt const * lresult = (gp_Pnt const *)0 ;
  Adaptor3d_Curve *arg1 = (Adaptor3d_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Adaptor3d_Curve const *)arg1)->Value(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor3d_Curve_Value\n  * wrapname: _wrap_Adaptor3d_Curve_Value\n  * fulldecl: gp_Pnt const Adaptor3d_Curve::Value(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt const(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt const *)0;
  }
}


EXPORT void _wrap_delete_Adaptor3d_Curve (Adaptor3d_Curve *larg1) {
  Adaptor3d_Curve *arg1 = (Adaptor3d_Curve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Adaptor3d_Curve\n  * wrapname: _wrap_delete_Adaptor3d_Curve\n  * fulldecl: Adaptor3d_Curve::~Adaptor3d_Curve()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT GeomAdaptor_Curve *_wrap_new_GeomAdaptor_Curve__SWIG_0 () {
  GeomAdaptor_Curve * lresult = (GeomAdaptor_Curve *)0 ;
  GeomAdaptor_Curve *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAdaptor_Curve *)new GeomAdaptor_Curve();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GeomAdaptor_Curve\n  * wrapname: _wrap_new_GeomAdaptor_Curve__SWIG_0\n  * fulldecl: GeomAdaptor_Curve::GeomAdaptor_Curve()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAdaptor_Curve *)0;
  }
}


EXPORT GeomAdaptor_Curve *_wrap_new_GeomAdaptor_Curve__SWIG_1 (Handle_Geom_Curve *larg1) {
  GeomAdaptor_Curve * lresult = (GeomAdaptor_Curve *)0 ;
  Handle_Geom_Curve *arg1 = 0 ;
  GeomAdaptor_Curve *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAdaptor_Curve *)new GeomAdaptor_Curve((Handle_Geom_Curve const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GeomAdaptor_Curve\n  * wrapname: _wrap_new_GeomAdaptor_Curve__SWIG_1\n  * fulldecl: GeomAdaptor_Curve::GeomAdaptor_Curve(Handle_Geom_Curve const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAdaptor_Curve *)0;
  }
}


EXPORT GeomAdaptor_Curve *_wrap_new_GeomAdaptor_Curve__SWIG_2 (Handle_Geom_Curve *larg1, Standard_Real larg2, Standard_Real larg3) {
  GeomAdaptor_Curve * lresult = (GeomAdaptor_Curve *)0 ;
  Handle_Geom_Curve *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  GeomAdaptor_Curve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAdaptor_Curve *)new GeomAdaptor_Curve((Handle_Geom_Curve const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GeomAdaptor_Curve\n  * wrapname: _wrap_new_GeomAdaptor_Curve__SWIG_2\n  * fulldecl: GeomAdaptor_Curve::GeomAdaptor_Curve(Handle_Geom_Curve const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAdaptor_Curve *)0;
  }
}


EXPORT void _wrap_GeomAdaptor_Curve_Load__SWIG_0 (GeomAdaptor_Curve *larg1, Handle_Geom_Curve *larg2) {
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  Handle_Geom_Curve *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Load((Handle_Geom_Curve const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_Load\n  * wrapname: _wrap_GeomAdaptor_Curve_Load__SWIG_0\n  * fulldecl: void GeomAdaptor_Curve::Load(Handle_Geom_Curve const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_GeomAdaptor_Curve_Load__SWIG_1 (GeomAdaptor_Curve *larg1, Handle_Geom_Curve *larg2, Standard_Real larg3, Standard_Real larg4) {
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  Handle_Geom_Curve *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Load((Handle_Geom_Curve const &)*arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_Load\n  * wrapname: _wrap_GeomAdaptor_Curve_Load__SWIG_1\n  * fulldecl: void GeomAdaptor_Curve::Load(Handle_Geom_Curve const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Handle_Geom_Curve *_wrap_GeomAdaptor_Curve_Curve (GeomAdaptor_Curve *larg1) {
  Handle_Geom_Curve * lresult = (Handle_Geom_Curve *)0 ;
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  Handle_Geom_Curve *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_Curve *) &((GeomAdaptor_Curve const *)arg1)->Curve();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_Curve\n  * wrapname: _wrap_GeomAdaptor_Curve_Curve\n  * fulldecl: Handle_Geom_Curve const & GeomAdaptor_Curve::Curve() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_Curve *)0;
  }
}


EXPORT Standard_Real _wrap_GeomAdaptor_Curve_FirstParameter (GeomAdaptor_Curve *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((GeomAdaptor_Curve const *)arg1)->FirstParameter();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_FirstParameter\n  * wrapname: _wrap_GeomAdaptor_Curve_FirstParameter\n  * fulldecl: Standard_Real GeomAdaptor_Curve::FirstParameter() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_GeomAdaptor_Curve_LastParameter (GeomAdaptor_Curve *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((GeomAdaptor_Curve const *)arg1)->LastParameter();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_LastParameter\n  * wrapname: _wrap_GeomAdaptor_Curve_LastParameter\n  * fulldecl: Standard_Real GeomAdaptor_Curve::LastParameter() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT GeomAbs_Shape _wrap_GeomAdaptor_Curve_Continuity (GeomAdaptor_Curve *larg1) {
  GeomAbs_Shape lresult = (GeomAbs_Shape)0 ;
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  GeomAbs_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAbs_Shape)((GeomAdaptor_Curve const *)arg1)->Continuity();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_Continuity\n  * wrapname: _wrap_GeomAdaptor_Curve_Continuity\n  * fulldecl: GeomAbs_Shape GeomAdaptor_Curve::Continuity() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAbs_Shape)0;
  }
}


EXPORT Standard_Integer _wrap_GeomAdaptor_Curve_NbIntervals (GeomAdaptor_Curve *larg1, GeomAbs_Shape larg2) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  GeomAbs_Shape arg2 ;
  Standard_Integer result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((GeomAdaptor_Curve const *)arg1)->NbIntervals(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_NbIntervals\n  * wrapname: _wrap_GeomAdaptor_Curve_NbIntervals\n  * fulldecl: Standard_Integer GeomAdaptor_Curve::NbIntervals(GeomAbs_Shape const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT void _wrap_GeomAdaptor_Curve_Intervals (GeomAdaptor_Curve *larg1, TColStd_Array1OfReal *larg2, GeomAbs_Shape larg3) {
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  GeomAbs_Shape arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((GeomAdaptor_Curve const *)arg1)->Intervals(*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_Intervals\n  * wrapname: _wrap_GeomAdaptor_Curve_Intervals\n  * fulldecl: void GeomAdaptor_Curve::Intervals(TColStd_Array1OfReal &,GeomAbs_Shape const) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Handle_Adaptor3d_HCurve *_wrap_GeomAdaptor_Curve_Trim (GeomAdaptor_Curve *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4) {
  Handle_Adaptor3d_HCurve * lresult = (Handle_Adaptor3d_HCurve *)0 ;
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Handle_Adaptor3d_HCurve result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((GeomAdaptor_Curve const *)arg1)->Trim(arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_Trim\n  * wrapname: _wrap_GeomAdaptor_Curve_Trim\n  * fulldecl: Handle_Adaptor3d_HCurve GeomAdaptor_Curve::Trim(Standard_Real const,Standard_Real const,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Adaptor3d_HCurve(result);
    return lresult;
  } catch (...) {
    return (Handle_Adaptor3d_HCurve *)0;
  }
}


EXPORT bool _wrap_GeomAdaptor_Curve_IsClosed (GeomAdaptor_Curve *larg1) {
  bool lresult = (bool)0 ;
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((GeomAdaptor_Curve const *)arg1)->IsClosed();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_IsClosed\n  * wrapname: _wrap_GeomAdaptor_Curve_IsClosed\n  * fulldecl: Standard_Boolean GeomAdaptor_Curve::IsClosed() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_GeomAdaptor_Curve_IsPeriodic (GeomAdaptor_Curve *larg1) {
  bool lresult = (bool)0 ;
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((GeomAdaptor_Curve const *)arg1)->IsPeriodic();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_IsPeriodic\n  * wrapname: _wrap_GeomAdaptor_Curve_IsPeriodic\n  * fulldecl: Standard_Boolean GeomAdaptor_Curve::IsPeriodic() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Standard_Real _wrap_GeomAdaptor_Curve_Period (GeomAdaptor_Curve *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((GeomAdaptor_Curve const *)arg1)->Period();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_Period\n  * wrapname: _wrap_GeomAdaptor_Curve_Period\n  * fulldecl: Standard_Real GeomAdaptor_Curve::Period() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Pnt *_wrap_GeomAdaptor_Curve_Value (GeomAdaptor_Curve *larg1, Standard_Real larg2) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((GeomAdaptor_Curve const *)arg1)->Value(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_Value\n  * wrapname: _wrap_GeomAdaptor_Curve_Value\n  * fulldecl: gp_Pnt GeomAdaptor_Curve::Value(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT void _wrap_GeomAdaptor_Curve_D0 (GeomAdaptor_Curve *larg1, Standard_Real larg2, gp_Pnt *larg3) {
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((GeomAdaptor_Curve const *)arg1)->D0(arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_D0\n  * wrapname: _wrap_GeomAdaptor_Curve_D0\n  * fulldecl: void GeomAdaptor_Curve::D0(Standard_Real const,gp_Pnt &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_GeomAdaptor_Curve_D1 (GeomAdaptor_Curve *larg1, Standard_Real larg2, gp_Pnt *larg3, gp_Vec *larg4) {
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt *arg3 = 0 ;
  gp_Vec *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((GeomAdaptor_Curve const *)arg1)->D1(arg2,*arg3,*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_D1\n  * wrapname: _wrap_GeomAdaptor_Curve_D1\n  * fulldecl: void GeomAdaptor_Curve::D1(Standard_Real const,gp_Pnt &,gp_Vec &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_GeomAdaptor_Curve_D2 (GeomAdaptor_Curve *larg1, Standard_Real larg2, gp_Pnt *larg3, gp_Vec *larg4, gp_Vec *larg5) {
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt *arg3 = 0 ;
  gp_Vec *arg4 = 0 ;
  gp_Vec *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((GeomAdaptor_Curve const *)arg1)->D2(arg2,*arg3,*arg4,*arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_D2\n  * wrapname: _wrap_GeomAdaptor_Curve_D2\n  * fulldecl: void GeomAdaptor_Curve::D2(Standard_Real const,gp_Pnt &,gp_Vec &,gp_Vec &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_GeomAdaptor_Curve_D3 (GeomAdaptor_Curve *larg1, Standard_Real larg2, gp_Pnt *larg3, gp_Vec *larg4, gp_Vec *larg5, gp_Vec *larg6) {
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt *arg3 = 0 ;
  gp_Vec *arg4 = 0 ;
  gp_Vec *arg5 = 0 ;
  gp_Vec *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((GeomAdaptor_Curve const *)arg1)->D3(arg2,*arg3,*arg4,*arg5,*arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_D3\n  * wrapname: _wrap_GeomAdaptor_Curve_D3\n  * fulldecl: void GeomAdaptor_Curve::D3(Standard_Real const,gp_Pnt &,gp_Vec &,gp_Vec &,gp_Vec &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec *_wrap_GeomAdaptor_Curve_DN (GeomAdaptor_Curve *larg1, Standard_Real larg2, Standard_Integer larg3) {
  gp_Vec * lresult = (gp_Vec *)0 ;
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  Standard_Real arg2 ;
  Standard_Integer arg3 ;
  gp_Vec result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((GeomAdaptor_Curve const *)arg1)->DN(arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_DN\n  * wrapname: _wrap_GeomAdaptor_Curve_DN\n  * fulldecl: gp_Vec GeomAdaptor_Curve::DN(Standard_Real const,Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec(result);
    return lresult;
  } catch (...) {
    return (gp_Vec *)0;
  }
}


EXPORT Standard_Real _wrap_GeomAdaptor_Curve_Resolution (GeomAdaptor_Curve *larg1, Standard_Real larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  Standard_Real arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((GeomAdaptor_Curve const *)arg1)->Resolution(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_Resolution\n  * wrapname: _wrap_GeomAdaptor_Curve_Resolution\n  * fulldecl: Standard_Real GeomAdaptor_Curve::Resolution(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT GeomAbs_CurveType *_wrap_GeomAdaptor_Curve_GetType (GeomAdaptor_Curve *larg1) {
  GeomAbs_CurveType * lresult = (GeomAbs_CurveType *)0 ;
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  GeomAbs_CurveType result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((GeomAdaptor_Curve const *)arg1)->GetType();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_GetType\n  * wrapname: _wrap_GeomAdaptor_Curve_GetType\n  * fulldecl: GeomAbs_CurveType GeomAdaptor_Curve::GetType() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new GeomAbs_CurveType(result);
    return lresult;
  } catch (...) {
    return (GeomAbs_CurveType *)0;
  }
}


EXPORT gp_Lin *_wrap_GeomAdaptor_Curve_Line (GeomAdaptor_Curve *larg1) {
  gp_Lin * lresult = (gp_Lin *)0 ;
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  gp_Lin result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((GeomAdaptor_Curve const *)arg1)->Line();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_Line\n  * wrapname: _wrap_GeomAdaptor_Curve_Line\n  * fulldecl: gp_Lin GeomAdaptor_Curve::Line() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Lin(result);
    return lresult;
  } catch (...) {
    return (gp_Lin *)0;
  }
}


EXPORT gp_Circ *_wrap_GeomAdaptor_Curve_Circle (GeomAdaptor_Curve *larg1) {
  gp_Circ * lresult = (gp_Circ *)0 ;
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  gp_Circ result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((GeomAdaptor_Curve const *)arg1)->Circle();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_Circle\n  * wrapname: _wrap_GeomAdaptor_Curve_Circle\n  * fulldecl: gp_Circ GeomAdaptor_Curve::Circle() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Circ(result);
    return lresult;
  } catch (...) {
    return (gp_Circ *)0;
  }
}


EXPORT gp_Elips *_wrap_GeomAdaptor_Curve_Ellipse (GeomAdaptor_Curve *larg1) {
  gp_Elips * lresult = (gp_Elips *)0 ;
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  gp_Elips result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((GeomAdaptor_Curve const *)arg1)->Ellipse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_Ellipse\n  * wrapname: _wrap_GeomAdaptor_Curve_Ellipse\n  * fulldecl: gp_Elips GeomAdaptor_Curve::Ellipse() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Elips(result);
    return lresult;
  } catch (...) {
    return (gp_Elips *)0;
  }
}


EXPORT gp_Hypr *_wrap_GeomAdaptor_Curve_Hyperbola (GeomAdaptor_Curve *larg1) {
  gp_Hypr * lresult = (gp_Hypr *)0 ;
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  gp_Hypr result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((GeomAdaptor_Curve const *)arg1)->Hyperbola();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_Hyperbola\n  * wrapname: _wrap_GeomAdaptor_Curve_Hyperbola\n  * fulldecl: gp_Hypr GeomAdaptor_Curve::Hyperbola() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr *)0;
  }
}


EXPORT gp_Parab *_wrap_GeomAdaptor_Curve_Parabola (GeomAdaptor_Curve *larg1) {
  gp_Parab * lresult = (gp_Parab *)0 ;
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  gp_Parab result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((GeomAdaptor_Curve const *)arg1)->Parabola();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_Parabola\n  * wrapname: _wrap_GeomAdaptor_Curve_Parabola\n  * fulldecl: gp_Parab GeomAdaptor_Curve::Parabola() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Parab(result);
    return lresult;
  } catch (...) {
    return (gp_Parab *)0;
  }
}


EXPORT Standard_Integer _wrap_GeomAdaptor_Curve_Degree (GeomAdaptor_Curve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((GeomAdaptor_Curve const *)arg1)->Degree();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_Degree\n  * wrapname: _wrap_GeomAdaptor_Curve_Degree\n  * fulldecl: Standard_Integer GeomAdaptor_Curve::Degree() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT bool _wrap_GeomAdaptor_Curve_IsRational (GeomAdaptor_Curve *larg1) {
  bool lresult = (bool)0 ;
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((GeomAdaptor_Curve const *)arg1)->IsRational();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_IsRational\n  * wrapname: _wrap_GeomAdaptor_Curve_IsRational\n  * fulldecl: Standard_Boolean GeomAdaptor_Curve::IsRational() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Standard_Integer _wrap_GeomAdaptor_Curve_NbPoles (GeomAdaptor_Curve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((GeomAdaptor_Curve const *)arg1)->NbPoles();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_NbPoles\n  * wrapname: _wrap_GeomAdaptor_Curve_NbPoles\n  * fulldecl: Standard_Integer GeomAdaptor_Curve::NbPoles() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT Standard_Integer _wrap_GeomAdaptor_Curve_NbKnots (GeomAdaptor_Curve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((GeomAdaptor_Curve const *)arg1)->NbKnots();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_NbKnots\n  * wrapname: _wrap_GeomAdaptor_Curve_NbKnots\n  * fulldecl: Standard_Integer GeomAdaptor_Curve::NbKnots() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT Handle_Geom_BezierCurve *_wrap_GeomAdaptor_Curve_Bezier (GeomAdaptor_Curve *larg1) {
  Handle_Geom_BezierCurve * lresult = (Handle_Geom_BezierCurve *)0 ;
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  SwigValueWrapper< Handle_Geom_BezierCurve > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((GeomAdaptor_Curve const *)arg1)->Bezier();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_Bezier\n  * wrapname: _wrap_GeomAdaptor_Curve_Bezier\n  * fulldecl: Handle_Geom_BezierCurve GeomAdaptor_Curve::Bezier() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_BezierCurve(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_BezierCurve *)0;
  }
}


EXPORT Handle_Geom_BSplineCurve *_wrap_GeomAdaptor_Curve_BSpline (GeomAdaptor_Curve *larg1) {
  Handle_Geom_BSplineCurve * lresult = (Handle_Geom_BSplineCurve *)0 ;
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  SwigValueWrapper< Handle_Geom_BSplineCurve > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((GeomAdaptor_Curve const *)arg1)->BSpline();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_BSpline\n  * wrapname: _wrap_GeomAdaptor_Curve_BSpline\n  * fulldecl: Handle_Geom_BSplineCurve GeomAdaptor_Curve::BSpline() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_BSplineCurve(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_BSplineCurve *)0;
  }
}


EXPORT Handle_Geom_OffsetCurve *_wrap_GeomAdaptor_Curve_OffsetCurve (GeomAdaptor_Curve *larg1) {
  Handle_Geom_OffsetCurve * lresult = (Handle_Geom_OffsetCurve *)0 ;
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  SwigValueWrapper< Handle_Geom_OffsetCurve > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((GeomAdaptor_Curve const *)arg1)->OffsetCurve();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAdaptor_Curve_OffsetCurve\n  * wrapname: _wrap_GeomAdaptor_Curve_OffsetCurve\n  * fulldecl: Handle_Geom_OffsetCurve GeomAdaptor_Curve::OffsetCurve() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_OffsetCurve(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_OffsetCurve *)0;
  }
}


EXPORT void _wrap_delete_GeomAdaptor_Curve (GeomAdaptor_Curve *larg1) {
  GeomAdaptor_Curve *arg1 = (GeomAdaptor_Curve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_GeomAdaptor_Curve\n  * wrapname: _wrap_delete_GeomAdaptor_Curve\n  * fulldecl: GeomAdaptor_Curve::~GeomAdaptor_Curve()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



  #include <Adaptor3d_Curve.hxx>
  #include <Adaptor2d_Curve2d.hxx>
  #include <CPnts_UniformDeflection.hxx>
  
EXPORT CPnts_UniformDeflection *_wrap_new_CPnts_UniformDeflection__SWIG_0 () {
  CPnts_UniformDeflection * lresult = (CPnts_UniformDeflection *)0 ;
  CPnts_UniformDeflection *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (CPnts_UniformDeflection *)new CPnts_UniformDeflection();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_CPnts_UniformDeflection\n  * wrapname: _wrap_new_CPnts_UniformDeflection__SWIG_0\n  * fulldecl: CPnts_UniformDeflection::CPnts_UniformDeflection()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (CPnts_UniformDeflection *)0;
  }
}


EXPORT CPnts_UniformDeflection *_wrap_new_CPnts_UniformDeflection__SWIG_1 (Adaptor3d_Curve *larg1, Standard_Real larg2, Standard_Real larg3, bool larg4) {
  CPnts_UniformDeflection * lresult = (CPnts_UniformDeflection *)0 ;
  Adaptor3d_Curve *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Boolean arg4 ;
  CPnts_UniformDeflection *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (CPnts_UniformDeflection *)new CPnts_UniformDeflection((Adaptor3d_Curve const &)*arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_CPnts_UniformDeflection\n  * wrapname: _wrap_new_CPnts_UniformDeflection__SWIG_1\n  * fulldecl: CPnts_UniformDeflection::CPnts_UniformDeflection(Adaptor3d_Curve const &,Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (CPnts_UniformDeflection *)0;
  }
}


EXPORT CPnts_UniformDeflection *_wrap_new_CPnts_UniformDeflection__SWIG_2 (Adaptor2d_Curve2d *larg1, Standard_Real larg2, Standard_Real larg3, bool larg4) {
  CPnts_UniformDeflection * lresult = (CPnts_UniformDeflection *)0 ;
  Adaptor2d_Curve2d *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Boolean arg4 ;
  CPnts_UniformDeflection *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (CPnts_UniformDeflection *)new CPnts_UniformDeflection((Adaptor2d_Curve2d const &)*arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_CPnts_UniformDeflection\n  * wrapname: _wrap_new_CPnts_UniformDeflection__SWIG_2\n  * fulldecl: CPnts_UniformDeflection::CPnts_UniformDeflection(Adaptor2d_Curve2d const &,Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (CPnts_UniformDeflection *)0;
  }
}


EXPORT CPnts_UniformDeflection *_wrap_new_CPnts_UniformDeflection__SWIG_3 (Adaptor3d_Curve *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5, bool larg6) {
  CPnts_UniformDeflection * lresult = (CPnts_UniformDeflection *)0 ;
  Adaptor3d_Curve *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  Standard_Boolean arg6 ;
  CPnts_UniformDeflection *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = (bool)larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (CPnts_UniformDeflection *)new CPnts_UniformDeflection((Adaptor3d_Curve const &)*arg1,arg2,arg3,arg4,arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_CPnts_UniformDeflection\n  * wrapname: _wrap_new_CPnts_UniformDeflection__SWIG_3\n  * fulldecl: CPnts_UniformDeflection::CPnts_UniformDeflection(Adaptor3d_Curve const &,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (CPnts_UniformDeflection *)0;
  }
}


EXPORT CPnts_UniformDeflection *_wrap_new_CPnts_UniformDeflection__SWIG_4 (Adaptor2d_Curve2d *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5, bool larg6) {
  CPnts_UniformDeflection * lresult = (CPnts_UniformDeflection *)0 ;
  Adaptor2d_Curve2d *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  Standard_Boolean arg6 ;
  CPnts_UniformDeflection *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = (bool)larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (CPnts_UniformDeflection *)new CPnts_UniformDeflection((Adaptor2d_Curve2d const &)*arg1,arg2,arg3,arg4,arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_CPnts_UniformDeflection\n  * wrapname: _wrap_new_CPnts_UniformDeflection__SWIG_4\n  * fulldecl: CPnts_UniformDeflection::CPnts_UniformDeflection(Adaptor2d_Curve2d const &,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (CPnts_UniformDeflection *)0;
  }
}


EXPORT void _wrap_CPnts_UniformDeflection_Initialize__SWIG_0 (CPnts_UniformDeflection *larg1, Adaptor3d_Curve *larg2, Standard_Real larg3, Standard_Real larg4, bool larg5) {
  CPnts_UniformDeflection *arg1 = (CPnts_UniformDeflection *) 0 ;
  Adaptor3d_Curve *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Boolean arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = (bool)larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Initialize((Adaptor3d_Curve const &)*arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: CPnts_UniformDeflection_Initialize\n  * wrapname: _wrap_CPnts_UniformDeflection_Initialize__SWIG_0\n  * fulldecl: void CPnts_UniformDeflection::Initialize(Adaptor3d_Curve const &,Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_CPnts_UniformDeflection_Initialize__SWIG_1 (CPnts_UniformDeflection *larg1, Adaptor2d_Curve2d *larg2, Standard_Real larg3, Standard_Real larg4, bool larg5) {
  CPnts_UniformDeflection *arg1 = (CPnts_UniformDeflection *) 0 ;
  Adaptor2d_Curve2d *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Boolean arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = (bool)larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Initialize((Adaptor2d_Curve2d const &)*arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: CPnts_UniformDeflection_Initialize\n  * wrapname: _wrap_CPnts_UniformDeflection_Initialize__SWIG_1\n  * fulldecl: void CPnts_UniformDeflection::Initialize(Adaptor2d_Curve2d const &,Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_CPnts_UniformDeflection_Initialize__SWIG_2 (CPnts_UniformDeflection *larg1, Adaptor3d_Curve *larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5, Standard_Real larg6, bool larg7) {
  CPnts_UniformDeflection *arg1 = (CPnts_UniformDeflection *) 0 ;
  Adaptor3d_Curve *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  Standard_Real arg6 ;
  Standard_Boolean arg7 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = (bool)larg7;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Initialize((Adaptor3d_Curve const &)*arg2,arg3,arg4,arg5,arg6,arg7);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: CPnts_UniformDeflection_Initialize\n  * wrapname: _wrap_CPnts_UniformDeflection_Initialize__SWIG_2\n  * fulldecl: void CPnts_UniformDeflection::Initialize(Adaptor3d_Curve const &,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_CPnts_UniformDeflection_Initialize__SWIG_3 (CPnts_UniformDeflection *larg1, Adaptor2d_Curve2d *larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5, Standard_Real larg6, bool larg7) {
  CPnts_UniformDeflection *arg1 = (CPnts_UniformDeflection *) 0 ;
  Adaptor2d_Curve2d *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  Standard_Real arg6 ;
  Standard_Boolean arg7 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = (bool)larg7;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Initialize((Adaptor2d_Curve2d const &)*arg2,arg3,arg4,arg5,arg6,arg7);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: CPnts_UniformDeflection_Initialize\n  * wrapname: _wrap_CPnts_UniformDeflection_Initialize__SWIG_3\n  * fulldecl: void CPnts_UniformDeflection::Initialize(Adaptor2d_Curve2d const &,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_CPnts_UniformDeflection_IsAllDone (CPnts_UniformDeflection *larg1) {
  bool lresult = (bool)0 ;
  CPnts_UniformDeflection *arg1 = (CPnts_UniformDeflection *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((CPnts_UniformDeflection const *)arg1)->IsAllDone();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: CPnts_UniformDeflection_IsAllDone\n  * wrapname: _wrap_CPnts_UniformDeflection_IsAllDone\n  * fulldecl: Standard_Boolean CPnts_UniformDeflection::IsAllDone() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_CPnts_UniformDeflection_Next (CPnts_UniformDeflection *larg1) {
  CPnts_UniformDeflection *arg1 = (CPnts_UniformDeflection *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Next();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: CPnts_UniformDeflection_Next\n  * wrapname: _wrap_CPnts_UniformDeflection_Next\n  * fulldecl: void CPnts_UniformDeflection::Next()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_CPnts_UniformDeflection_More (CPnts_UniformDeflection *larg1) {
  bool lresult = (bool)0 ;
  CPnts_UniformDeflection *arg1 = (CPnts_UniformDeflection *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->More();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: CPnts_UniformDeflection_More\n  * wrapname: _wrap_CPnts_UniformDeflection_More\n  * fulldecl: Standard_Boolean CPnts_UniformDeflection::More()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Standard_Real _wrap_CPnts_UniformDeflection_Value (CPnts_UniformDeflection *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  CPnts_UniformDeflection *arg1 = (CPnts_UniformDeflection *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((CPnts_UniformDeflection const *)arg1)->Value();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: CPnts_UniformDeflection_Value\n  * wrapname: _wrap_CPnts_UniformDeflection_Value\n  * fulldecl: Standard_Real CPnts_UniformDeflection::Value() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Pnt *_wrap_CPnts_UniformDeflection_Point (CPnts_UniformDeflection *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  CPnts_UniformDeflection *arg1 = (CPnts_UniformDeflection *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((CPnts_UniformDeflection const *)arg1)->Point();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: CPnts_UniformDeflection_Point\n  * wrapname: _wrap_CPnts_UniformDeflection_Point\n  * fulldecl: gp_Pnt CPnts_UniformDeflection::Point() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT void _wrap_delete_CPnts_UniformDeflection (CPnts_UniformDeflection *larg1) {
  CPnts_UniformDeflection *arg1 = (CPnts_UniformDeflection *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_CPnts_UniformDeflection\n  * wrapname: _wrap_delete_CPnts_UniformDeflection\n  * fulldecl: CPnts_UniformDeflection::~CPnts_UniformDeflection()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <TopExp.hxx>
  
EXPORT TopLoc_Location *_wrap_new_TopLoc_Location__SWIG_0 () {
  TopLoc_Location * lresult = (TopLoc_Location *)0 ;
  TopLoc_Location *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopLoc_Location *)new TopLoc_Location();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TopLoc_Location\n  * wrapname: _wrap_new_TopLoc_Location__SWIG_0\n  * fulldecl: TopLoc_Location::TopLoc_Location()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopLoc_Location *)0;
  }
}


EXPORT TopLoc_Location *_wrap_new_TopLoc_Location__SWIG_1 (gp_Trsf *larg1) {
  TopLoc_Location * lresult = (TopLoc_Location *)0 ;
  gp_Trsf *arg1 = 0 ;
  TopLoc_Location *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopLoc_Location *)new TopLoc_Location((gp_Trsf const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TopLoc_Location\n  * wrapname: _wrap_new_TopLoc_Location__SWIG_1\n  * fulldecl: TopLoc_Location::TopLoc_Location(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopLoc_Location *)0;
  }
}


EXPORT bool _wrap_TopLoc_Location_IsIdentity (TopLoc_Location *larg1) {
  bool lresult = (bool)0 ;
  TopLoc_Location *arg1 = (TopLoc_Location *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->IsIdentity();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopLoc_Location_IsIdentity\n  * wrapname: _wrap_TopLoc_Location_IsIdentity\n  * fulldecl: Standard_Boolean TopLoc_Location::IsIdentity()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT gp_Trsf *_wrap_TopLoc_Location_Transformation (TopLoc_Location *larg1) {
  gp_Trsf * lresult = (gp_Trsf *)0 ;
  TopLoc_Location *arg1 = (TopLoc_Location *) 0 ;
  gp_Trsf *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Trsf *) &(arg1)->Transformation();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopLoc_Location_Transformation\n  * wrapname: _wrap_TopLoc_Location_Transformation\n  * fulldecl: gp_Trsf const & TopLoc_Location::Transformation()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Trsf *)0;
  }
}


EXPORT void _wrap_delete_TopLoc_Location (TopLoc_Location *larg1) {
  TopLoc_Location *arg1 = (TopLoc_Location *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopLoc_Location\n  * wrapname: _wrap_delete_TopLoc_Location\n  * fulldecl: TopLoc_Location::~TopLoc_Location()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopExp_Vertices__SWIG_0 (TopoDS_Edge *larg1, TopoDS_Vertex *larg2, TopoDS_Vertex *larg3, bool larg4) {
  TopoDS_Edge *arg1 = 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  TopoDS_Vertex *arg3 = 0 ;
  Standard_Boolean arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        TopExp::Vertices((TopoDS_Edge const &)*arg1,*arg2,*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopExp_Vertices\n  * wrapname: _wrap_TopExp_Vertices__SWIG_0\n  * fulldecl: void TopExp::Vertices(TopoDS_Edge const &,TopoDS_Vertex &,TopoDS_Vertex &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopExp_Vertices__SWIG_1 (TopoDS_Edge *larg1, TopoDS_Vertex *larg2, TopoDS_Vertex *larg3) {
  TopoDS_Edge *arg1 = 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  TopoDS_Vertex *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        TopExp::Vertices((TopoDS_Edge const &)*arg1,*arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopExp_Vertices\n  * wrapname: _wrap_TopExp_Vertices__SWIG_1\n  * fulldecl: void TopExp::Vertices(TopoDS_Edge const &,TopoDS_Vertex &,TopoDS_Vertex &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_TopExp_CommonVertex (TopoDS_Edge *larg1, TopoDS_Edge *larg2, TopoDS_Vertex *larg3) {
  bool lresult = (bool)0 ;
  TopoDS_Edge *arg1 = 0 ;
  TopoDS_Edge *arg2 = 0 ;
  TopoDS_Vertex *arg3 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)TopExp::CommonVertex((TopoDS_Edge const &)*arg1,(TopoDS_Edge const &)*arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopExp_CommonVertex\n  * wrapname: _wrap_TopExp_CommonVertex\n  * fulldecl: Standard_Boolean TopExp::CommonVertex(TopoDS_Edge const &,TopoDS_Edge const &,TopoDS_Vertex &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_delete_TopExp (TopExp *larg1) {
  TopExp *arg1 = (TopExp *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopExp\n  * wrapname: _wrap_delete_TopExp\n  * fulldecl: TopExp::~TopExp()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include "TopExp_Explorer.hxx"
EXPORT TopExp_Explorer *_wrap_new_TopExp_Explorer__SWIG_0 () {
  TopExp_Explorer * lresult = (TopExp_Explorer *)0 ;
  TopExp_Explorer *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopExp_Explorer *)new TopExp_Explorer();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TopExp_Explorer\n  * wrapname: _wrap_new_TopExp_Explorer__SWIG_0\n  * fulldecl: TopExp_Explorer::TopExp_Explorer()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopExp_Explorer *)0;
  }
}


EXPORT TopExp_Explorer *_wrap_new_TopExp_Explorer__SWIG_1 (TopoDS_Shape *larg1, TopAbs_ShapeEnum larg2, TopAbs_ShapeEnum larg3) {
  TopExp_Explorer * lresult = (TopExp_Explorer *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  TopAbs_ShapeEnum arg2 ;
  TopAbs_ShapeEnum arg3 ;
  TopExp_Explorer *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopExp_Explorer *)new TopExp_Explorer((TopoDS_Shape const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TopExp_Explorer\n  * wrapname: _wrap_new_TopExp_Explorer__SWIG_1\n  * fulldecl: TopExp_Explorer::TopExp_Explorer(TopoDS_Shape const &,TopAbs_ShapeEnum const,TopAbs_ShapeEnum const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopExp_Explorer *)0;
  }
}


EXPORT TopExp_Explorer *_wrap_new_TopExp_Explorer__SWIG_2 (TopoDS_Shape *larg1, TopAbs_ShapeEnum larg2) {
  TopExp_Explorer * lresult = (TopExp_Explorer *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  TopAbs_ShapeEnum arg2 ;
  TopExp_Explorer *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopExp_Explorer *)new TopExp_Explorer((TopoDS_Shape const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TopExp_Explorer\n  * wrapname: _wrap_new_TopExp_Explorer__SWIG_2\n  * fulldecl: TopExp_Explorer::TopExp_Explorer(TopoDS_Shape const &,TopAbs_ShapeEnum const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopExp_Explorer *)0;
  }
}


EXPORT void _wrap_TopExp_Explorer_Init__SWIG_0 (TopExp_Explorer *larg1, TopoDS_Shape *larg2, TopAbs_ShapeEnum larg3, TopAbs_ShapeEnum larg4) {
  TopExp_Explorer *arg1 = (TopExp_Explorer *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopAbs_ShapeEnum arg3 ;
  TopAbs_ShapeEnum arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init((TopoDS_Shape const &)*arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopExp_Explorer_Init\n  * wrapname: _wrap_TopExp_Explorer_Init__SWIG_0\n  * fulldecl: void TopExp_Explorer::Init(TopoDS_Shape const &,TopAbs_ShapeEnum const,TopAbs_ShapeEnum const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopExp_Explorer_Init__SWIG_1 (TopExp_Explorer *larg1, TopoDS_Shape *larg2, TopAbs_ShapeEnum larg3) {
  TopExp_Explorer *arg1 = (TopExp_Explorer *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopAbs_ShapeEnum arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init((TopoDS_Shape const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopExp_Explorer_Init\n  * wrapname: _wrap_TopExp_Explorer_Init__SWIG_1\n  * fulldecl: void TopExp_Explorer::Init(TopoDS_Shape const &,TopAbs_ShapeEnum const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_TopExp_Explorer_More (TopExp_Explorer *larg1) {
  bool lresult = (bool)0 ;
  TopExp_Explorer *arg1 = (TopExp_Explorer *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TopExp_Explorer const *)arg1)->More();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopExp_Explorer_More\n  * wrapname: _wrap_TopExp_Explorer_More\n  * fulldecl: Standard_Boolean TopExp_Explorer::More() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_TopExp_Explorer_Next (TopExp_Explorer *larg1) {
  TopExp_Explorer *arg1 = (TopExp_Explorer *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Next();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopExp_Explorer_Next\n  * wrapname: _wrap_TopExp_Explorer_Next\n  * fulldecl: void TopExp_Explorer::Next()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopoDS_Shape *_wrap_TopExp_Explorer_Current (TopExp_Explorer *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  TopExp_Explorer *arg1 = (TopExp_Explorer *) 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &(arg1)->Current();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopExp_Explorer_Current\n  * wrapname: _wrap_TopExp_Explorer_Current\n  * fulldecl: TopoDS_Shape const & TopExp_Explorer::Current()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT void _wrap_delete_TopExp_Explorer (TopExp_Explorer *larg1) {
  TopExp_Explorer *arg1 = (TopExp_Explorer *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopExp_Explorer\n  * wrapname: _wrap_delete_TopExp_Explorer\n  * fulldecl: TopExp_Explorer::~TopExp_Explorer()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include "BRepBndLib.hxx"
EXPORT void _wrap_BRepBndLib_Add (TopoDS_Shape *larg1, Bnd_Box *larg2) {
  TopoDS_Shape *arg1 = 0 ;
  Bnd_Box *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepBndLib::Add((TopoDS_Shape const &)*arg1,*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBndLib_Add\n  * wrapname: _wrap_BRepBndLib_Add\n  * fulldecl: void BRepBndLib::Add(TopoDS_Shape const &,Bnd_Box &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include "GProp_GProps.hxx"
EXPORT GProp_GProps *_wrap_new_GProp_GProps () {
  GProp_GProps * lresult = (GProp_GProps *)0 ;
  GProp_GProps *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GProp_GProps *)new GProp_GProps();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GProp_GProps\n  * wrapname: _wrap_new_GProp_GProps\n  * fulldecl: GProp_GProps::GProp_GProps()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GProp_GProps *)0;
  }
}


EXPORT Standard_Real _wrap_GProp_GProps_Mass (GProp_GProps *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  GProp_GProps *arg1 = (GProp_GProps *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((GProp_GProps const *)arg1)->Mass();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GProp_GProps_Mass\n  * wrapname: _wrap_GProp_GProps_Mass\n  * fulldecl: Standard_Real GProp_GProps::Mass() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_delete_GProp_GProps (GProp_GProps *larg1) {
  GProp_GProps *arg1 = (GProp_GProps *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_GProp_GProps\n  * wrapname: _wrap_delete_GProp_GProps\n  * fulldecl: GProp_GProps::~GProp_GProps()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include "BRepGProp.hxx"
EXPORT void _wrap_BRepGProp_LinearProperties (TopoDS_Shape *larg1, GProp_GProps *larg2) {
  TopoDS_Shape *arg1 = 0 ;
  GProp_GProps *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepGProp::LinearProperties((TopoDS_Shape const &)*arg1,*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepGProp_LinearProperties\n  * wrapname: _wrap_BRepGProp_LinearProperties\n  * fulldecl: void BRepGProp::LinearProperties(TopoDS_Shape const &,GProp_GProps &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepGProp_VolumeProperties__SWIG_0 (TopoDS_Shape *larg1, GProp_GProps *larg2, bool larg3) {
  TopoDS_Shape *arg1 = 0 ;
  GProp_GProps *arg2 = 0 ;
  Standard_Boolean arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepGProp::VolumeProperties((TopoDS_Shape const &)*arg1,*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepGProp_VolumeProperties\n  * wrapname: _wrap_BRepGProp_VolumeProperties__SWIG_0\n  * fulldecl: void BRepGProp::VolumeProperties(TopoDS_Shape const &,GProp_GProps &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepGProp_VolumeProperties__SWIG_1 (TopoDS_Shape *larg1, GProp_GProps *larg2) {
  TopoDS_Shape *arg1 = 0 ;
  GProp_GProps *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepGProp::VolumeProperties((TopoDS_Shape const &)*arg1,*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepGProp_VolumeProperties\n  * wrapname: _wrap_BRepGProp_VolumeProperties__SWIG_1\n  * fulldecl: void BRepGProp::VolumeProperties(TopoDS_Shape const &,GProp_GProps &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Real _wrap_BRepGProp_VolumeProperties__SWIG_2 (TopoDS_Shape *larg1, GProp_GProps *larg2, Standard_Real larg3, bool larg4) {
  Standard_Real lresult = (Standard_Real)0 ;
  TopoDS_Shape *arg1 = 0 ;
  GProp_GProps *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean arg4 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)BRepGProp::VolumeProperties((TopoDS_Shape const &)*arg1,*arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepGProp_VolumeProperties\n  * wrapname: _wrap_BRepGProp_VolumeProperties__SWIG_2\n  * fulldecl: Standard_Real BRepGProp::VolumeProperties(TopoDS_Shape const &,GProp_GProps &,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_BRepGProp_VolumeProperties__SWIG_3 (TopoDS_Shape *larg1, GProp_GProps *larg2, Standard_Real larg3) {
  Standard_Real lresult = (Standard_Real)0 ;
  TopoDS_Shape *arg1 = 0 ;
  GProp_GProps *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)BRepGProp::VolumeProperties((TopoDS_Shape const &)*arg1,*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepGProp_VolumeProperties\n  * wrapname: _wrap_BRepGProp_VolumeProperties__SWIG_3\n  * fulldecl: Standard_Real BRepGProp::VolumeProperties(TopoDS_Shape const &,GProp_GProps &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_BRepGProp_SurfaceProperties__SWIG_0 (TopoDS_Shape *larg1, GProp_GProps *larg2) {
  TopoDS_Shape *arg1 = 0 ;
  GProp_GProps *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepGProp::SurfaceProperties((TopoDS_Shape const &)*arg1,*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepGProp_SurfaceProperties\n  * wrapname: _wrap_BRepGProp_SurfaceProperties__SWIG_0\n  * fulldecl: void BRepGProp::SurfaceProperties(TopoDS_Shape const &,GProp_GProps &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Real _wrap_BRepGProp_SurfaceProperties__SWIG_1 (TopoDS_Shape *larg1, GProp_GProps *larg2, Standard_Real larg3) {
  Standard_Real lresult = (Standard_Real)0 ;
  TopoDS_Shape *arg1 = 0 ;
  GProp_GProps *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)BRepGProp::SurfaceProperties((TopoDS_Shape const &)*arg1,*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepGProp_SurfaceProperties\n  * wrapname: _wrap_BRepGProp_SurfaceProperties__SWIG_1\n  * fulldecl: Standard_Real BRepGProp::SurfaceProperties(TopoDS_Shape const &,GProp_GProps &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_delete_BRepGProp (BRepGProp *larg1) {
  BRepGProp *arg1 = (BRepGProp *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepGProp\n  * wrapname: _wrap_delete_BRepGProp\n  * fulldecl: BRepGProp::~BRepGProp()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include <ShapeAnalysis_FreeBounds.hxx>
EXPORT ShapeAnalysis_FreeBounds *_wrap_new_ShapeAnalysis_FreeBounds__SWIG_0 (TopoDS_Shape *larg1, bool larg2, bool larg3) {
  ShapeAnalysis_FreeBounds * lresult = (ShapeAnalysis_FreeBounds *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Boolean arg2 ;
  Standard_Boolean arg3 ;
  ShapeAnalysis_FreeBounds *result = 0 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (ShapeAnalysis_FreeBounds *)new ShapeAnalysis_FreeBounds((TopoDS_Shape const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_ShapeAnalysis_FreeBounds\n  * wrapname: _wrap_new_ShapeAnalysis_FreeBounds__SWIG_0\n  * fulldecl: ShapeAnalysis_FreeBounds::ShapeAnalysis_FreeBounds(TopoDS_Shape const &,Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (ShapeAnalysis_FreeBounds *)0;
  }
}


EXPORT ShapeAnalysis_FreeBounds *_wrap_new_ShapeAnalysis_FreeBounds__SWIG_1 (TopoDS_Shape *larg1, bool larg2) {
  ShapeAnalysis_FreeBounds * lresult = (ShapeAnalysis_FreeBounds *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Boolean arg2 ;
  ShapeAnalysis_FreeBounds *result = 0 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (ShapeAnalysis_FreeBounds *)new ShapeAnalysis_FreeBounds((TopoDS_Shape const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_ShapeAnalysis_FreeBounds\n  * wrapname: _wrap_new_ShapeAnalysis_FreeBounds__SWIG_1\n  * fulldecl: ShapeAnalysis_FreeBounds::ShapeAnalysis_FreeBounds(TopoDS_Shape const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (ShapeAnalysis_FreeBounds *)0;
  }
}


EXPORT ShapeAnalysis_FreeBounds *_wrap_new_ShapeAnalysis_FreeBounds__SWIG_2 (TopoDS_Shape *larg1) {
  ShapeAnalysis_FreeBounds * lresult = (ShapeAnalysis_FreeBounds *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  ShapeAnalysis_FreeBounds *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (ShapeAnalysis_FreeBounds *)new ShapeAnalysis_FreeBounds((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_ShapeAnalysis_FreeBounds\n  * wrapname: _wrap_new_ShapeAnalysis_FreeBounds__SWIG_2\n  * fulldecl: ShapeAnalysis_FreeBounds::ShapeAnalysis_FreeBounds(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (ShapeAnalysis_FreeBounds *)0;
  }
}


EXPORT TopoDS_Compound *_wrap_ShapeAnalysis_FreeBounds_GetClosedWires (ShapeAnalysis_FreeBounds *larg1) {
  TopoDS_Compound * lresult = (TopoDS_Compound *)0 ;
  ShapeAnalysis_FreeBounds *arg1 = (ShapeAnalysis_FreeBounds *) 0 ;
  TopoDS_Compound *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Compound *) &((ShapeAnalysis_FreeBounds const *)arg1)->GetClosedWires();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeAnalysis_FreeBounds_GetClosedWires\n  * wrapname: _wrap_ShapeAnalysis_FreeBounds_GetClosedWires\n  * fulldecl: TopoDS_Compound const & ShapeAnalysis_FreeBounds::GetClosedWires() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Compound *)0;
  }
}


EXPORT TopoDS_Compound *_wrap_ShapeAnalysis_FreeBounds_GetOpenWires (ShapeAnalysis_FreeBounds *larg1) {
  TopoDS_Compound * lresult = (TopoDS_Compound *)0 ;
  ShapeAnalysis_FreeBounds *arg1 = (ShapeAnalysis_FreeBounds *) 0 ;
  TopoDS_Compound *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Compound *) &((ShapeAnalysis_FreeBounds const *)arg1)->GetOpenWires();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeAnalysis_FreeBounds_GetOpenWires\n  * wrapname: _wrap_ShapeAnalysis_FreeBounds_GetOpenWires\n  * fulldecl: TopoDS_Compound const & ShapeAnalysis_FreeBounds::GetOpenWires() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Compound *)0;
  }
}


EXPORT void _wrap_delete_ShapeAnalysis_FreeBounds (ShapeAnalysis_FreeBounds *larg1) {
  ShapeAnalysis_FreeBounds *arg1 = (ShapeAnalysis_FreeBounds *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_ShapeAnalysis_FreeBounds\n  * wrapname: _wrap_delete_ShapeAnalysis_FreeBounds\n  * fulldecl: ShapeAnalysis_FreeBounds::~ShapeAnalysis_FreeBounds()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include <GCPnts_UniformDeflection.hxx>
EXPORT GCPnts_UniformDeflection *_wrap_new_GCPnts_UniformDeflection () {
  GCPnts_UniformDeflection * lresult = (GCPnts_UniformDeflection *)0 ;
  GCPnts_UniformDeflection *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GCPnts_UniformDeflection *)new GCPnts_UniformDeflection();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GCPnts_UniformDeflection\n  * wrapname: _wrap_new_GCPnts_UniformDeflection\n  * fulldecl: GCPnts_UniformDeflection::GCPnts_UniformDeflection()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GCPnts_UniformDeflection *)0;
  }
}


EXPORT void _wrap_GCPnts_UniformDeflection_Initialize__SWIG_0 (GCPnts_UniformDeflection *larg1, Adaptor3d_Curve *larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5, bool larg6) {
  GCPnts_UniformDeflection *arg1 = (GCPnts_UniformDeflection *) 0 ;
  Adaptor3d_Curve *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  Standard_Boolean arg6 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = (bool)larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Initialize(*arg2,arg3,arg4,arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GCPnts_UniformDeflection_Initialize\n  * wrapname: _wrap_GCPnts_UniformDeflection_Initialize__SWIG_0\n  * fulldecl: void GCPnts_UniformDeflection::Initialize(Adaptor3d_Curve &,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_GCPnts_UniformDeflection_Initialize__SWIG_1 (GCPnts_UniformDeflection *larg1, Adaptor3d_Curve *larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5) {
  GCPnts_UniformDeflection *arg1 = (GCPnts_UniformDeflection *) 0 ;
  Adaptor3d_Curve *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Initialize(*arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GCPnts_UniformDeflection_Initialize\n  * wrapname: _wrap_GCPnts_UniformDeflection_Initialize__SWIG_1\n  * fulldecl: void GCPnts_UniformDeflection::Initialize(Adaptor3d_Curve &,Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Integer _wrap_GCPnts_UniformDeflection_NbPoints (GCPnts_UniformDeflection *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  GCPnts_UniformDeflection *arg1 = (GCPnts_UniformDeflection *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((GCPnts_UniformDeflection const *)arg1)->NbPoints();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GCPnts_UniformDeflection_NbPoints\n  * wrapname: _wrap_GCPnts_UniformDeflection_NbPoints\n  * fulldecl: Standard_Integer GCPnts_UniformDeflection::NbPoints() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT Standard_Real _wrap_GCPnts_UniformDeflection_Parameter (GCPnts_UniformDeflection *larg1, Standard_Integer larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  GCPnts_UniformDeflection *arg1 = (GCPnts_UniformDeflection *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((GCPnts_UniformDeflection const *)arg1)->Parameter(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GCPnts_UniformDeflection_Parameter\n  * wrapname: _wrap_GCPnts_UniformDeflection_Parameter\n  * fulldecl: Standard_Real GCPnts_UniformDeflection::Parameter(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_delete_GCPnts_UniformDeflection (GCPnts_UniformDeflection *larg1) {
  GCPnts_UniformDeflection *arg1 = (GCPnts_UniformDeflection *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_GCPnts_UniformDeflection\n  * wrapname: _wrap_delete_GCPnts_UniformDeflection\n  * fulldecl: GCPnts_UniformDeflection::~GCPnts_UniformDeflection()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include <BRepMesh_DiscretRoot.hxx>
EXPORT void _wrap_BRepMesh_DiscretRoot_Perform (BRepMesh_DiscretRoot *larg1) {
  BRepMesh_DiscretRoot *arg1 = (BRepMesh_DiscretRoot *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Perform();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepMesh_DiscretRoot_Perform\n  * wrapname: _wrap_BRepMesh_DiscretRoot_Perform\n  * fulldecl: void BRepMesh_DiscretRoot::Perform()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_BRepMesh_DiscretRoot (BRepMesh_DiscretRoot *larg1) {
  BRepMesh_DiscretRoot *arg1 = (BRepMesh_DiscretRoot *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepMesh_DiscretRoot\n  * wrapname: _wrap_delete_BRepMesh_DiscretRoot\n  * fulldecl: BRepMesh_DiscretRoot::~BRepMesh_DiscretRoot()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include <BRepMesh_IncrementalMesh.hxx>
EXPORT BRepMesh_IncrementalMesh *_wrap_new_BRepMesh_IncrementalMesh__SWIG_0 () {
  BRepMesh_IncrementalMesh * lresult = (BRepMesh_IncrementalMesh *)0 ;
  BRepMesh_IncrementalMesh *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepMesh_IncrementalMesh *)new BRepMesh_IncrementalMesh();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepMesh_IncrementalMesh\n  * wrapname: _wrap_new_BRepMesh_IncrementalMesh__SWIG_0\n  * fulldecl: BRepMesh_IncrementalMesh::BRepMesh_IncrementalMesh()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepMesh_IncrementalMesh *)0;
  }
}


EXPORT BRepMesh_IncrementalMesh *_wrap_new_BRepMesh_IncrementalMesh__SWIG_1 (TopoDS_Shape *larg1, Standard_Real larg2, bool larg3, Standard_Real larg4) {
  BRepMesh_IncrementalMesh * lresult = (BRepMesh_IncrementalMesh *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Boolean arg3 ;
  Standard_Real arg4 ;
  BRepMesh_IncrementalMesh *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepMesh_IncrementalMesh *)new BRepMesh_IncrementalMesh((TopoDS_Shape const &)*arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepMesh_IncrementalMesh\n  * wrapname: _wrap_new_BRepMesh_IncrementalMesh__SWIG_1\n  * fulldecl: BRepMesh_IncrementalMesh::BRepMesh_IncrementalMesh(TopoDS_Shape const &,Standard_Real const,Standard_Boolean const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepMesh_IncrementalMesh *)0;
  }
}


EXPORT BRepMesh_IncrementalMesh *_wrap_new_BRepMesh_IncrementalMesh__SWIG_2 (TopoDS_Shape *larg1, Standard_Real larg2, bool larg3) {
  BRepMesh_IncrementalMesh * lresult = (BRepMesh_IncrementalMesh *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Boolean arg3 ;
  BRepMesh_IncrementalMesh *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepMesh_IncrementalMesh *)new BRepMesh_IncrementalMesh((TopoDS_Shape const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepMesh_IncrementalMesh\n  * wrapname: _wrap_new_BRepMesh_IncrementalMesh__SWIG_2\n  * fulldecl: BRepMesh_IncrementalMesh::BRepMesh_IncrementalMesh(TopoDS_Shape const &,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepMesh_IncrementalMesh *)0;
  }
}


EXPORT BRepMesh_IncrementalMesh *_wrap_new_BRepMesh_IncrementalMesh__SWIG_3 (TopoDS_Shape *larg1, Standard_Real larg2) {
  BRepMesh_IncrementalMesh * lresult = (BRepMesh_IncrementalMesh *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  BRepMesh_IncrementalMesh *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepMesh_IncrementalMesh *)new BRepMesh_IncrementalMesh((TopoDS_Shape const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepMesh_IncrementalMesh\n  * wrapname: _wrap_new_BRepMesh_IncrementalMesh__SWIG_3\n  * fulldecl: BRepMesh_IncrementalMesh::BRepMesh_IncrementalMesh(TopoDS_Shape const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepMesh_IncrementalMesh *)0;
  }
}


EXPORT void _wrap_BRepMesh_IncrementalMesh_Perform (BRepMesh_IncrementalMesh *larg1) {
  BRepMesh_IncrementalMesh *arg1 = (BRepMesh_IncrementalMesh *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Perform();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepMesh_IncrementalMesh_Perform\n  * wrapname: _wrap_BRepMesh_IncrementalMesh_Perform\n  * fulldecl: void BRepMesh_IncrementalMesh::Perform()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_BRepMesh_IncrementalMesh_IsModified (BRepMesh_IncrementalMesh *larg1) {
  bool lresult = (bool)0 ;
  BRepMesh_IncrementalMesh *arg1 = (BRepMesh_IncrementalMesh *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepMesh_IncrementalMesh const *)arg1)->IsModified();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepMesh_IncrementalMesh_IsModified\n  * wrapname: _wrap_BRepMesh_IncrementalMesh_IsModified\n  * fulldecl: Standard_Boolean BRepMesh_IncrementalMesh::IsModified() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_delete_BRepMesh_IncrementalMesh (BRepMesh_IncrementalMesh *larg1) {
  BRepMesh_IncrementalMesh *arg1 = (BRepMesh_IncrementalMesh *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepMesh_IncrementalMesh\n  * wrapname: _wrap_delete_BRepMesh_IncrementalMesh\n  * fulldecl: BRepMesh_IncrementalMesh::~BRepMesh_IncrementalMesh()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include <GeomAPI_ProjectPointOnSurf.hxx>
EXPORT GeomAPI_ProjectPointOnSurf *_wrap_new_GeomAPI_ProjectPointOnSurf (gp_Pnt *larg1, Handle_Geom_Surface *larg2) {
  GeomAPI_ProjectPointOnSurf * lresult = (GeomAPI_ProjectPointOnSurf *)0 ;
  gp_Pnt *arg1 = 0 ;
  Handle_Geom_Surface *arg2 = 0 ;
  GeomAPI_ProjectPointOnSurf *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAPI_ProjectPointOnSurf *)new GeomAPI_ProjectPointOnSurf((gp_Pnt const &)*arg1,(Handle_Geom_Surface const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GeomAPI_ProjectPointOnSurf\n  * wrapname: _wrap_new_GeomAPI_ProjectPointOnSurf\n  * fulldecl: GeomAPI_ProjectPointOnSurf::GeomAPI_ProjectPointOnSurf(gp_Pnt const &,Handle_Geom_Surface const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAPI_ProjectPointOnSurf *)0;
  }
}


EXPORT void _wrap_GeomAPI_ProjectPointOnSurf_Init (GeomAPI_ProjectPointOnSurf *larg1, gp_Pnt *larg2, Handle_Geom_Surface *larg3) {
  GeomAPI_ProjectPointOnSurf *arg1 = (GeomAPI_ProjectPointOnSurf *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Handle_Geom_Surface *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init((gp_Pnt const &)*arg2,(Handle_Geom_Surface const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAPI_ProjectPointOnSurf_Init\n  * wrapname: _wrap_GeomAPI_ProjectPointOnSurf_Init\n  * fulldecl: void GeomAPI_ProjectPointOnSurf::Init(gp_Pnt const &,Handle_Geom_Surface const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Integer _wrap_GeomAPI_ProjectPointOnSurf_NbPoints (GeomAPI_ProjectPointOnSurf *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  GeomAPI_ProjectPointOnSurf *arg1 = (GeomAPI_ProjectPointOnSurf *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((GeomAPI_ProjectPointOnSurf const *)arg1)->NbPoints();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAPI_ProjectPointOnSurf_NbPoints\n  * wrapname: _wrap_GeomAPI_ProjectPointOnSurf_NbPoints\n  * fulldecl: Standard_Integer GeomAPI_ProjectPointOnSurf::NbPoints() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT Quantity_Length _wrap_GeomAPI_ProjectPointOnSurf_LowerDistance (GeomAPI_ProjectPointOnSurf *larg1) {
  Quantity_Length lresult = (Quantity_Length)0 ;
  GeomAPI_ProjectPointOnSurf *arg1 = (GeomAPI_ProjectPointOnSurf *) 0 ;
  Quantity_Length result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Quantity_Length)((GeomAPI_ProjectPointOnSurf const *)arg1)->LowerDistance();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAPI_ProjectPointOnSurf_LowerDistance\n  * wrapname: _wrap_GeomAPI_ProjectPointOnSurf_LowerDistance\n  * fulldecl: Quantity_Length GeomAPI_ProjectPointOnSurf::LowerDistance() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Quantity_Length)0;
  }
}


EXPORT gp_Pnt const *_wrap_GeomAPI_ProjectPointOnSurf_Point (GeomAPI_ProjectPointOnSurf *larg1, Standard_Integer larg2) {
  gp_Pnt const * lresult = (gp_Pnt const *)0 ;
  GeomAPI_ProjectPointOnSurf *arg1 = (GeomAPI_ProjectPointOnSurf *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((GeomAPI_ProjectPointOnSurf const *)arg1)->Point(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAPI_ProjectPointOnSurf_Point\n  * wrapname: _wrap_GeomAPI_ProjectPointOnSurf_Point\n  * fulldecl: gp_Pnt const GeomAPI_ProjectPointOnSurf::Point(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt const(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt const *)0;
  }
}


EXPORT void _wrap_GeomAPI_ProjectPointOnSurf_LowerDistanceParameters (GeomAPI_ProjectPointOnSurf *larg1, Quantity_Parameter *larg2, Quantity_Parameter *larg3) {
  GeomAPI_ProjectPointOnSurf *arg1 = (GeomAPI_ProjectPointOnSurf *) 0 ;
  Quantity_Parameter *arg2 = 0 ;
  Quantity_Parameter *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((GeomAPI_ProjectPointOnSurf const *)arg1)->LowerDistanceParameters(*arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAPI_ProjectPointOnSurf_LowerDistanceParameters\n  * wrapname: _wrap_GeomAPI_ProjectPointOnSurf_LowerDistanceParameters\n  * fulldecl: void GeomAPI_ProjectPointOnSurf::LowerDistanceParameters(Quantity_Parameter &,Quantity_Parameter &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_GeomAPI_ProjectPointOnSurf_Parameters (GeomAPI_ProjectPointOnSurf *larg1, Standard_Integer larg2, Quantity_Parameter *larg3, Quantity_Parameter *larg4) {
  GeomAPI_ProjectPointOnSurf *arg1 = (GeomAPI_ProjectPointOnSurf *) 0 ;
  Standard_Integer arg2 ;
  Quantity_Parameter *arg3 = 0 ;
  Quantity_Parameter *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((GeomAPI_ProjectPointOnSurf const *)arg1)->Parameters(arg2,*arg3,*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAPI_ProjectPointOnSurf_Parameters\n  * wrapname: _wrap_GeomAPI_ProjectPointOnSurf_Parameters\n  * fulldecl: void GeomAPI_ProjectPointOnSurf::Parameters(Standard_Integer const,Quantity_Parameter &,Quantity_Parameter &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pnt *_wrap_GeomAPI_ProjectPointOnSurf_NearestPoint (GeomAPI_ProjectPointOnSurf *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  GeomAPI_ProjectPointOnSurf *arg1 = (GeomAPI_ProjectPointOnSurf *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((GeomAPI_ProjectPointOnSurf const *)arg1)->NearestPoint();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAPI_ProjectPointOnSurf_NearestPoint\n  * wrapname: _wrap_GeomAPI_ProjectPointOnSurf_NearestPoint\n  * fulldecl: gp_Pnt GeomAPI_ProjectPointOnSurf::NearestPoint() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT void _wrap_delete_GeomAPI_ProjectPointOnSurf (GeomAPI_ProjectPointOnSurf *larg1) {
  GeomAPI_ProjectPointOnSurf *arg1 = (GeomAPI_ProjectPointOnSurf *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_GeomAPI_ProjectPointOnSurf\n  * wrapname: _wrap_delete_GeomAPI_ProjectPointOnSurf\n  * fulldecl: GeomAPI_ProjectPointOnSurf::~GeomAPI_ProjectPointOnSurf()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include <BRepAlgo.hxx>
EXPORT bool _wrap_BRepAlgo_IsValid (TopoDS_Shape *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepAlgo::IsValid((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepAlgo_IsValid\n  * wrapname: _wrap_BRepAlgo_IsValid\n  * fulldecl: Standard_Boolean BRepAlgo::IsValid(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepAlgo_IsTopologicallyValid (TopoDS_Shape *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepAlgo::IsTopologicallyValid((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepAlgo_IsTopologicallyValid\n  * wrapname: _wrap_BRepAlgo_IsTopologicallyValid\n  * fulldecl: Standard_Boolean BRepAlgo::IsTopologicallyValid(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_delete_BRepAlgo (BRepAlgo *larg1) {
  BRepAlgo *arg1 = (BRepAlgo *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepAlgo\n  * wrapname: _wrap_delete_BRepAlgo\n  * fulldecl: BRepAlgo::~BRepAlgo()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


