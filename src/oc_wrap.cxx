/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.0
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */


#ifndef SWIGCFFI
#define SWIGCFFI
#endif


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif



#ifdef __cplusplus
#  define EXTERN   extern "C"
#else
#  define EXTERN   extern
#endif

#define EXPORT   EXTERN SWIGEXPORT

#include <string.h>



#ifdef __cplusplus
#  define EXTERN   extern "C"
#else
#  define EXTERN   extern
#endif

#define EXPORT   EXTERN SWIGEXPORT

#include <string.h>
#include <stdlib.h>


  EXPORT void (* signal_lisp_error) (const char* message) = 0;
  

#include <Standard_Failure.hxx>
#include <Standard_ErrorHandler.hxx>

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1
#define  SWIG_IOError        	   -2
#define  SWIG_RuntimeError   	   -3
#define  SWIG_IndexError     	   -4
#define  SWIG_TypeError      	   -5
#define  SWIG_DivisionByZero 	   -6
#define  SWIG_OverflowError  	   -7
#define  SWIG_SyntaxError    	   -8
#define  SWIG_ValueError     	   -9
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12
#define  SWIG_NullReferenceError   -13




#include <typeinfo>
#include <stdexcept>


#include <Standard.hxx>
#include <Standard_DefineAlloc.hxx>
#include <Standard_Handle.hxx>
#include <Standard_Transient.hxx>
  

#include <Standard_Transient.hxx>
#include <MMgt_TShared.hxx>
  
EXPORT void _wrap_delete_MMgt_TShared (MMgt_TShared *larg1) {
  MMgt_TShared *arg1 = (MMgt_TShared *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_MMgt_TShared\n  * wrapname: _wrap_delete_MMgt_TShared\n  * fulldecl: MMgt_TShared::~MMgt_TShared()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Integer Handle_MMgt_TShared_GetRefCount(Handle_MMgt_TShared *self){
    return (*self)->GetRefCount();
  }
EXPORT Standard_Integer _wrap_Handle_MMgt_TShared_GetRefCount (Handle_MMgt_TShared *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_MMgt_TShared *arg1 = (Handle_MMgt_TShared *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_MMgt_TShared_GetRefCount(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Handle_MMgt_TShared_GetRefCount\n  * wrapname: _wrap_Handle_MMgt_TShared_GetRefCount\n  * fulldecl: Standard_Integer Handle_MMgt_TShared::GetRefCount()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN void Handle_MMgt_TShared_IncrementRefCounter(Handle_MMgt_TShared *self){
    (*self)->IncrementRefCounter();
  }
EXPORT void _wrap_Handle_MMgt_TShared_IncrementRefCounter (Handle_MMgt_TShared *larg1) {
  Handle_MMgt_TShared *arg1 = (Handle_MMgt_TShared *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_MMgt_TShared_IncrementRefCounter(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Handle_MMgt_TShared_IncrementRefCounter\n  * wrapname: _wrap_Handle_MMgt_TShared_IncrementRefCounter\n  * fulldecl: void Handle_MMgt_TShared::IncrementRefCounter()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Integer Handle_MMgt_TShared_DecrementRefCounter(Handle_MMgt_TShared *self){
    return (* self)->DecrementRefCounter();
  }
EXPORT Standard_Integer _wrap_Handle_MMgt_TShared_DecrementRefCounter (Handle_MMgt_TShared *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_MMgt_TShared *arg1 = (Handle_MMgt_TShared *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_MMgt_TShared_DecrementRefCounter(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Handle_MMgt_TShared_DecrementRefCounter\n  * wrapname: _wrap_Handle_MMgt_TShared_DecrementRefCounter\n  * fulldecl: Standard_Integer Handle_MMgt_TShared::DecrementRefCounter()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT void _wrap_delete_Handle_MMgt_TShared (Handle_MMgt_TShared *larg1) {
  Handle_MMgt_TShared *arg1 = (Handle_MMgt_TShared *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Handle_MMgt_TShared\n  * wrapname: _wrap_delete_Handle_MMgt_TShared\n  * fulldecl: Handle_MMgt_TShared::~Handle_MMgt_TShared()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <gp_Pnt.hxx>
#include <gp_Pnt2d.hxx>
#include <gp_Dir2d.hxx>
#include <gp_Vec2d.hxx>
#include <gp_Ax2d.hxx>
#include <gp_Ax22d.hxx>
#include <gp_Pln.hxx>
#include <gp_Vec.hxx>
#include <gp_Dir.hxx>
#include <gp_Ax3.hxx>
#include <gp_Ax2.hxx>
#include <gp_Ax1.hxx>
#include <gp_Trsf2d.hxx>
#include <gp_Trsf.hxx>
#include <gp_Circ.hxx>
#include <gp_Cone.hxx>
#include <gp_Cylinder.hxx>
#include <gp_Parab.hxx>
#include <gp_Hypr.hxx>
#include <gp_Torus.hxx>
#include <gp_Sphere.hxx>
#include <gp_XYZ.hxx>
#include <gp_XY.hxx>
#include <gp_Lin2d.hxx>

EXPORT gp_Pnt *_wrap_new_gp_Pnt__SWIG_0 () {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_Pnt *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt *)new gp_Pnt();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Pnt\n  * wrapname: _wrap_new_gp_Pnt__SWIG_0\n  * fulldecl: gp_Pnt::gp_Pnt()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT gp_Pnt *_wrap_new_gp_Pnt__SWIG_1 (gp_XYZ *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  gp_XYZ *arg1 = 0 ;
  gp_Pnt *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt *)new gp_Pnt((gp_XYZ const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Pnt\n  * wrapname: _wrap_new_gp_Pnt__SWIG_1\n  * fulldecl: gp_Pnt::gp_Pnt(gp_XYZ const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT gp_Pnt *_wrap_new_gp_Pnt__SWIG_2 (Standard_Real larg1, Standard_Real larg2, Standard_Real larg3) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  gp_Pnt *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt *)new gp_Pnt(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Pnt\n  * wrapname: _wrap_new_gp_Pnt__SWIG_2\n  * fulldecl: gp_Pnt::gp_Pnt(Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT Standard_Real _wrap_gp_Pnt_X (gp_Pnt *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Pnt const *)arg1)->X();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_X\n  * wrapname: _wrap_gp_Pnt_X\n  * fulldecl: Standard_Real gp_Pnt::X() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Pnt_Y (gp_Pnt *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Pnt const *)arg1)->Y();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_Y\n  * wrapname: _wrap_gp_Pnt_Y\n  * fulldecl: Standard_Real gp_Pnt::Y() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_gp_Pnt_Z (gp_Pnt *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((gp_Pnt const *)arg1)->Z();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Pnt_Z\n  * wrapname: _wrap_gp_Pnt_Z\n  * fulldecl: Standard_Real gp_Pnt::Z() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_delete_gp_Pnt (gp_Pnt *larg1) {
  gp_Pnt *arg1 = (gp_Pnt *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Pnt\n  * wrapname: _wrap_delete_gp_Pnt\n  * fulldecl: gp_Pnt::~gp_Pnt()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pnt2d *_wrap_new_gp_Pnt2d__SWIG_0 () {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  gp_Pnt2d *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt2d *)new gp_Pnt2d();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Pnt2d\n  * wrapname: _wrap_new_gp_Pnt2d__SWIG_0\n  * fulldecl: gp_Pnt2d::gp_Pnt2d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT gp_Pnt2d *_wrap_new_gp_Pnt2d__SWIG_1 (gp_XY *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  gp_XY *arg1 = 0 ;
  gp_Pnt2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt2d *)new gp_Pnt2d((gp_XY const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Pnt2d\n  * wrapname: _wrap_new_gp_Pnt2d__SWIG_1\n  * fulldecl: gp_Pnt2d::gp_Pnt2d(gp_XY const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT gp_Pnt2d *_wrap_new_gp_Pnt2d__SWIG_2 (Standard_Real larg1, Standard_Real larg2) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  gp_Pnt2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt2d *)new gp_Pnt2d(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Pnt2d\n  * wrapname: _wrap_new_gp_Pnt2d__SWIG_2\n  * fulldecl: gp_Pnt2d::gp_Pnt2d(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT void _wrap_delete_gp_Pnt2d (gp_Pnt2d *larg1) {
  gp_Pnt2d *arg1 = (gp_Pnt2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Pnt2d\n  * wrapname: _wrap_delete_gp_Pnt2d\n  * fulldecl: gp_Pnt2d::~gp_Pnt2d()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Dir2d *_wrap_new_gp_Dir2d__SWIG_0 () {
  gp_Dir2d * lresult = (gp_Dir2d *)0 ;
  gp_Dir2d *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Dir2d *)new gp_Dir2d();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Dir2d\n  * wrapname: _wrap_new_gp_Dir2d__SWIG_0\n  * fulldecl: gp_Dir2d::gp_Dir2d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Dir2d *)0;
  }
}


EXPORT gp_Dir2d *_wrap_new_gp_Dir2d__SWIG_1 (gp_Vec2d *larg1) {
  gp_Dir2d * lresult = (gp_Dir2d *)0 ;
  gp_Vec2d *arg1 = 0 ;
  gp_Dir2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Dir2d *)new gp_Dir2d((gp_Vec2d const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Dir2d\n  * wrapname: _wrap_new_gp_Dir2d__SWIG_1\n  * fulldecl: gp_Dir2d::gp_Dir2d(gp_Vec2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Dir2d *)0;
  }
}


EXPORT gp_Dir2d *_wrap_new_gp_Dir2d__SWIG_2 (gp_XY *larg1) {
  gp_Dir2d * lresult = (gp_Dir2d *)0 ;
  gp_XY *arg1 = 0 ;
  gp_Dir2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Dir2d *)new gp_Dir2d((gp_XY const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Dir2d\n  * wrapname: _wrap_new_gp_Dir2d__SWIG_2\n  * fulldecl: gp_Dir2d::gp_Dir2d(gp_XY const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Dir2d *)0;
  }
}


EXPORT gp_Dir2d *_wrap_new_gp_Dir2d__SWIG_3 (Standard_Real larg1, Standard_Real larg2) {
  gp_Dir2d * lresult = (gp_Dir2d *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  gp_Dir2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Dir2d *)new gp_Dir2d(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Dir2d\n  * wrapname: _wrap_new_gp_Dir2d__SWIG_3\n  * fulldecl: gp_Dir2d::gp_Dir2d(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Dir2d *)0;
  }
}


EXPORT void _wrap_delete_gp_Dir2d (gp_Dir2d *larg1) {
  gp_Dir2d *arg1 = (gp_Dir2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Dir2d\n  * wrapname: _wrap_delete_gp_Dir2d\n  * fulldecl: gp_Dir2d::~gp_Dir2d()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec2d *_wrap_new_gp_Vec2d__SWIG_0 () {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  gp_Vec2d *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Vec2d *)new gp_Vec2d();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Vec2d\n  * wrapname: _wrap_new_gp_Vec2d__SWIG_0\n  * fulldecl: gp_Vec2d::gp_Vec2d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


EXPORT gp_Vec2d *_wrap_new_gp_Vec2d__SWIG_1 (gp_Dir2d *larg1) {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  gp_Dir2d *arg1 = 0 ;
  gp_Vec2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Vec2d *)new gp_Vec2d((gp_Dir2d const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Vec2d\n  * wrapname: _wrap_new_gp_Vec2d__SWIG_1\n  * fulldecl: gp_Vec2d::gp_Vec2d(gp_Dir2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


EXPORT gp_Vec2d *_wrap_new_gp_Vec2d__SWIG_2 (gp_XY *larg1) {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  gp_XY *arg1 = 0 ;
  gp_Vec2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Vec2d *)new gp_Vec2d((gp_XY const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Vec2d\n  * wrapname: _wrap_new_gp_Vec2d__SWIG_2\n  * fulldecl: gp_Vec2d::gp_Vec2d(gp_XY const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


EXPORT gp_Vec2d *_wrap_new_gp_Vec2d__SWIG_3 (Standard_Real larg1, Standard_Real larg2) {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  gp_Vec2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Vec2d *)new gp_Vec2d(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Vec2d\n  * wrapname: _wrap_new_gp_Vec2d__SWIG_3\n  * fulldecl: gp_Vec2d::gp_Vec2d(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


EXPORT gp_Vec2d *_wrap_new_gp_Vec2d__SWIG_4 (gp_Pnt2d *larg1, gp_Pnt2d *larg2) {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  gp_Pnt2d *arg1 = 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Vec2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Vec2d *)new gp_Vec2d((gp_Pnt2d const &)*arg1,(gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Vec2d\n  * wrapname: _wrap_new_gp_Vec2d__SWIG_4\n  * fulldecl: gp_Vec2d::gp_Vec2d(gp_Pnt2d const &,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


EXPORT void _wrap_delete_gp_Vec2d (gp_Vec2d *larg1) {
  gp_Vec2d *arg1 = (gp_Vec2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Vec2d\n  * wrapname: _wrap_delete_gp_Vec2d\n  * fulldecl: gp_Vec2d::~gp_Vec2d()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax2d *_wrap_new_gp_Ax2d__SWIG_0 () {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  gp_Ax2d *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax2d *)new gp_Ax2d();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax2d\n  * wrapname: _wrap_new_gp_Ax2d__SWIG_0\n  * fulldecl: gp_Ax2d::gp_Ax2d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


EXPORT gp_Ax2d *_wrap_new_gp_Ax2d__SWIG_1 (gp_Pnt2d *larg1, gp_Dir2d *larg2) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  gp_Pnt2d *arg1 = 0 ;
  gp_Dir2d *arg2 = 0 ;
  gp_Ax2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax2d *)new gp_Ax2d((gp_Pnt2d const &)*arg1,(gp_Dir2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax2d\n  * wrapname: _wrap_new_gp_Ax2d__SWIG_1\n  * fulldecl: gp_Ax2d::gp_Ax2d(gp_Pnt2d const &,gp_Dir2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


EXPORT void _wrap_delete_gp_Ax2d (gp_Ax2d *larg1) {
  gp_Ax2d *arg1 = (gp_Ax2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Ax2d\n  * wrapname: _wrap_delete_gp_Ax2d\n  * fulldecl: gp_Ax2d::~gp_Ax2d()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax22d *_wrap_new_gp_Ax22d__SWIG_0 () {
  gp_Ax22d * lresult = (gp_Ax22d *)0 ;
  gp_Ax22d *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax22d *)new gp_Ax22d();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax22d\n  * wrapname: _wrap_new_gp_Ax22d__SWIG_0\n  * fulldecl: gp_Ax22d::gp_Ax22d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax22d *)0;
  }
}


EXPORT gp_Ax22d *_wrap_new_gp_Ax22d__SWIG_1 (gp_Pnt2d *larg1, gp_Dir2d *larg2, gp_Dir2d *larg3) {
  gp_Ax22d * lresult = (gp_Ax22d *)0 ;
  gp_Pnt2d *arg1 = 0 ;
  gp_Dir2d *arg2 = 0 ;
  gp_Dir2d *arg3 = 0 ;
  gp_Ax22d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax22d *)new gp_Ax22d((gp_Pnt2d const &)*arg1,(gp_Dir2d const &)*arg2,(gp_Dir2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax22d\n  * wrapname: _wrap_new_gp_Ax22d__SWIG_1\n  * fulldecl: gp_Ax22d::gp_Ax22d(gp_Pnt2d const &,gp_Dir2d const &,gp_Dir2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax22d *)0;
  }
}


EXPORT gp_Ax22d *_wrap_new_gp_Ax22d__SWIG_2 (gp_Pnt2d *larg1, gp_Dir2d *larg2, bool larg3) {
  gp_Ax22d * lresult = (gp_Ax22d *)0 ;
  gp_Pnt2d *arg1 = 0 ;
  gp_Dir2d *arg2 = 0 ;
  Standard_Boolean arg3 ;
  gp_Ax22d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax22d *)new gp_Ax22d((gp_Pnt2d const &)*arg1,(gp_Dir2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax22d\n  * wrapname: _wrap_new_gp_Ax22d__SWIG_2\n  * fulldecl: gp_Ax22d::gp_Ax22d(gp_Pnt2d const &,gp_Dir2d const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax22d *)0;
  }
}


EXPORT gp_Ax22d *_wrap_new_gp_Ax22d__SWIG_3 (gp_Pnt2d *larg1, gp_Dir2d *larg2) {
  gp_Ax22d * lresult = (gp_Ax22d *)0 ;
  gp_Pnt2d *arg1 = 0 ;
  gp_Dir2d *arg2 = 0 ;
  gp_Ax22d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax22d *)new gp_Ax22d((gp_Pnt2d const &)*arg1,(gp_Dir2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax22d\n  * wrapname: _wrap_new_gp_Ax22d__SWIG_3\n  * fulldecl: gp_Ax22d::gp_Ax22d(gp_Pnt2d const &,gp_Dir2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax22d *)0;
  }
}


EXPORT gp_Ax22d *_wrap_new_gp_Ax22d__SWIG_4 (gp_Ax2d *larg1, bool larg2) {
  gp_Ax22d * lresult = (gp_Ax22d *)0 ;
  gp_Ax2d *arg1 = 0 ;
  Standard_Boolean arg2 ;
  gp_Ax22d *result = 0 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax22d *)new gp_Ax22d((gp_Ax2d const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax22d\n  * wrapname: _wrap_new_gp_Ax22d__SWIG_4\n  * fulldecl: gp_Ax22d::gp_Ax22d(gp_Ax2d const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax22d *)0;
  }
}


EXPORT gp_Ax22d *_wrap_new_gp_Ax22d__SWIG_5 (gp_Ax2d *larg1) {
  gp_Ax22d * lresult = (gp_Ax22d *)0 ;
  gp_Ax2d *arg1 = 0 ;
  gp_Ax22d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax22d *)new gp_Ax22d((gp_Ax2d const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax22d\n  * wrapname: _wrap_new_gp_Ax22d__SWIG_5\n  * fulldecl: gp_Ax22d::gp_Ax22d(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax22d *)0;
  }
}


EXPORT void _wrap_delete_gp_Ax22d (gp_Ax22d *larg1) {
  gp_Ax22d *arg1 = (gp_Ax22d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Ax22d\n  * wrapname: _wrap_delete_gp_Ax22d\n  * fulldecl: gp_Ax22d::~gp_Ax22d()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pln *_wrap_new_gp_Pln__SWIG_0 (gp_Ax3 *larg1) {
  gp_Pln * lresult = (gp_Pln *)0 ;
  gp_Ax3 *arg1 = 0 ;
  gp_Pln *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pln *)new gp_Pln((gp_Ax3 const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Pln\n  * wrapname: _wrap_new_gp_Pln__SWIG_0\n  * fulldecl: gp_Pln::gp_Pln(gp_Ax3 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pln *)0;
  }
}


EXPORT gp_Pln *_wrap_new_gp_Pln__SWIG_1 (gp_Pnt *larg1, gp_Dir *larg2) {
  gp_Pln * lresult = (gp_Pln *)0 ;
  gp_Pnt *arg1 = 0 ;
  gp_Dir *arg2 = 0 ;
  gp_Pln *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pln *)new gp_Pln((gp_Pnt const &)*arg1,(gp_Dir const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Pln\n  * wrapname: _wrap_new_gp_Pln__SWIG_1\n  * fulldecl: gp_Pln::gp_Pln(gp_Pnt const &,gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pln *)0;
  }
}


EXPORT gp_Pln *_wrap_new_gp_Pln__SWIG_2 (Standard_Real larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4) {
  gp_Pln * lresult = (gp_Pln *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  gp_Pln *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pln *)new gp_Pln(arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Pln\n  * wrapname: _wrap_new_gp_Pln__SWIG_2\n  * fulldecl: gp_Pln::gp_Pln(Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pln *)0;
  }
}


EXPORT void _wrap_delete_gp_Pln (gp_Pln *larg1) {
  gp_Pln *arg1 = (gp_Pln *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Pln\n  * wrapname: _wrap_delete_gp_Pln\n  * fulldecl: gp_Pln::~gp_Pln()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec *_wrap_new_gp_Vec__SWIG_0 () {
  gp_Vec * lresult = (gp_Vec *)0 ;
  gp_Vec *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Vec *)new gp_Vec();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Vec\n  * wrapname: _wrap_new_gp_Vec__SWIG_0\n  * fulldecl: gp_Vec::gp_Vec()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Vec *)0;
  }
}


EXPORT gp_Vec *_wrap_new_gp_Vec__SWIG_1 (gp_Dir *larg1) {
  gp_Vec * lresult = (gp_Vec *)0 ;
  gp_Dir *arg1 = 0 ;
  gp_Vec *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Vec *)new gp_Vec((gp_Dir const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Vec\n  * wrapname: _wrap_new_gp_Vec__SWIG_1\n  * fulldecl: gp_Vec::gp_Vec(gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Vec *)0;
  }
}


EXPORT gp_Vec *_wrap_new_gp_Vec__SWIG_2 (gp_XYZ *larg1) {
  gp_Vec * lresult = (gp_Vec *)0 ;
  gp_XYZ *arg1 = 0 ;
  gp_Vec *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Vec *)new gp_Vec((gp_XYZ const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Vec\n  * wrapname: _wrap_new_gp_Vec__SWIG_2\n  * fulldecl: gp_Vec::gp_Vec(gp_XYZ const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Vec *)0;
  }
}


EXPORT gp_Vec *_wrap_new_gp_Vec__SWIG_3 (Standard_Real larg1, Standard_Real larg2, Standard_Real larg3) {
  gp_Vec * lresult = (gp_Vec *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  gp_Vec *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Vec *)new gp_Vec(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Vec\n  * wrapname: _wrap_new_gp_Vec__SWIG_3\n  * fulldecl: gp_Vec::gp_Vec(Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Vec *)0;
  }
}


EXPORT gp_Vec *_wrap_new_gp_Vec__SWIG_4 (gp_Pnt *larg1, gp_Pnt *larg2) {
  gp_Vec * lresult = (gp_Vec *)0 ;
  gp_Pnt *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Vec *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Vec *)new gp_Vec((gp_Pnt const &)*arg1,(gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Vec\n  * wrapname: _wrap_new_gp_Vec__SWIG_4\n  * fulldecl: gp_Vec::gp_Vec(gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Vec *)0;
  }
}


EXPORT void _wrap_delete_gp_Vec (gp_Vec *larg1) {
  gp_Vec *arg1 = (gp_Vec *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Vec\n  * wrapname: _wrap_delete_gp_Vec\n  * fulldecl: gp_Vec::~gp_Vec()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Dir *_wrap_new_gp_Dir__SWIG_0 () {
  gp_Dir * lresult = (gp_Dir *)0 ;
  gp_Dir *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Dir *)new gp_Dir();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Dir\n  * wrapname: _wrap_new_gp_Dir__SWIG_0\n  * fulldecl: gp_Dir::gp_Dir()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Dir *)0;
  }
}


EXPORT gp_Dir *_wrap_new_gp_Dir__SWIG_1 (gp_Vec *larg1) {
  gp_Dir * lresult = (gp_Dir *)0 ;
  gp_Vec *arg1 = 0 ;
  gp_Dir *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Dir *)new gp_Dir((gp_Vec const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Dir\n  * wrapname: _wrap_new_gp_Dir__SWIG_1\n  * fulldecl: gp_Dir::gp_Dir(gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Dir *)0;
  }
}


EXPORT gp_Dir *_wrap_new_gp_Dir__SWIG_2 (gp_XYZ *larg1) {
  gp_Dir * lresult = (gp_Dir *)0 ;
  gp_XYZ *arg1 = 0 ;
  gp_Dir *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Dir *)new gp_Dir((gp_XYZ const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Dir\n  * wrapname: _wrap_new_gp_Dir__SWIG_2\n  * fulldecl: gp_Dir::gp_Dir(gp_XYZ const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Dir *)0;
  }
}


EXPORT gp_Dir *_wrap_new_gp_Dir__SWIG_3 (Standard_Real larg1, Standard_Real larg2, Standard_Real larg3) {
  gp_Dir * lresult = (gp_Dir *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  gp_Dir *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Dir *)new gp_Dir(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Dir\n  * wrapname: _wrap_new_gp_Dir__SWIG_3\n  * fulldecl: gp_Dir::gp_Dir(Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Dir *)0;
  }
}


EXPORT void _wrap_delete_gp_Dir (gp_Dir *larg1) {
  gp_Dir *arg1 = (gp_Dir *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Dir\n  * wrapname: _wrap_delete_gp_Dir\n  * fulldecl: gp_Dir::~gp_Dir()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax3 *_wrap_new_gp_Ax3__SWIG_0 () {
  gp_Ax3 * lresult = (gp_Ax3 *)0 ;
  gp_Ax3 *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax3 *)new gp_Ax3();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax3\n  * wrapname: _wrap_new_gp_Ax3__SWIG_0\n  * fulldecl: gp_Ax3::gp_Ax3()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax3 *)0;
  }
}


EXPORT gp_Ax3 *_wrap_new_gp_Ax3__SWIG_1 (gp_Ax2 *larg1) {
  gp_Ax3 * lresult = (gp_Ax3 *)0 ;
  gp_Ax2 *arg1 = 0 ;
  gp_Ax3 *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax3 *)new gp_Ax3((gp_Ax2 const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax3\n  * wrapname: _wrap_new_gp_Ax3__SWIG_1\n  * fulldecl: gp_Ax3::gp_Ax3(gp_Ax2 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax3 *)0;
  }
}


EXPORT gp_Ax3 *_wrap_new_gp_Ax3__SWIG_2 (gp_Pnt *larg1, gp_Dir *larg2, gp_Dir *larg3) {
  gp_Ax3 * lresult = (gp_Ax3 *)0 ;
  gp_Pnt *arg1 = 0 ;
  gp_Dir *arg2 = 0 ;
  gp_Dir *arg3 = 0 ;
  gp_Ax3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax3 *)new gp_Ax3((gp_Pnt const &)*arg1,(gp_Dir const &)*arg2,(gp_Dir const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax3\n  * wrapname: _wrap_new_gp_Ax3__SWIG_2\n  * fulldecl: gp_Ax3::gp_Ax3(gp_Pnt const &,gp_Dir const &,gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax3 *)0;
  }
}


EXPORT gp_Ax3 *_wrap_new_gp_Ax3__SWIG_3 (gp_Pnt *larg1, gp_Dir *larg2) {
  gp_Ax3 * lresult = (gp_Ax3 *)0 ;
  gp_Pnt *arg1 = 0 ;
  gp_Dir *arg2 = 0 ;
  gp_Ax3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax3 *)new gp_Ax3((gp_Pnt const &)*arg1,(gp_Dir const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax3\n  * wrapname: _wrap_new_gp_Ax3__SWIG_3\n  * fulldecl: gp_Ax3::gp_Ax3(gp_Pnt const &,gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax3 *)0;
  }
}


EXPORT void _wrap_delete_gp_Ax3 (gp_Ax3 *larg1) {
  gp_Ax3 *arg1 = (gp_Ax3 *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Ax3\n  * wrapname: _wrap_delete_gp_Ax3\n  * fulldecl: gp_Ax3::~gp_Ax3()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax2 *_wrap_new_gp_Ax2__SWIG_0 () {
  gp_Ax2 * lresult = (gp_Ax2 *)0 ;
  gp_Ax2 *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax2 *)new gp_Ax2();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax2\n  * wrapname: _wrap_new_gp_Ax2__SWIG_0\n  * fulldecl: gp_Ax2::gp_Ax2()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax2 *)0;
  }
}


EXPORT gp_Ax2 *_wrap_new_gp_Ax2__SWIG_1 (gp_Pnt *larg1, gp_Dir *larg2) {
  gp_Ax2 * lresult = (gp_Ax2 *)0 ;
  gp_Pnt *arg1 = 0 ;
  gp_Dir *arg2 = 0 ;
  gp_Ax2 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax2 *)new gp_Ax2((gp_Pnt const &)*arg1,(gp_Dir const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax2\n  * wrapname: _wrap_new_gp_Ax2__SWIG_1\n  * fulldecl: gp_Ax2::gp_Ax2(gp_Pnt const &,gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax2 *)0;
  }
}


EXPORT gp_Ax2 *_wrap_new_gp_Ax2__SWIG_2 (gp_Pnt *larg1, gp_Dir *larg2, gp_Dir *larg3) {
  gp_Ax2 * lresult = (gp_Ax2 *)0 ;
  gp_Pnt *arg1 = 0 ;
  gp_Dir *arg2 = 0 ;
  gp_Dir *arg3 = 0 ;
  gp_Ax2 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax2 *)new gp_Ax2((gp_Pnt const &)*arg1,(gp_Dir const &)*arg2,(gp_Dir const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax2\n  * wrapname: _wrap_new_gp_Ax2__SWIG_2\n  * fulldecl: gp_Ax2::gp_Ax2(gp_Pnt const &,gp_Dir const &,gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax2 *)0;
  }
}


EXPORT void _wrap_delete_gp_Ax2 (gp_Ax2 *larg1) {
  gp_Ax2 *arg1 = (gp_Ax2 *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Ax2\n  * wrapname: _wrap_delete_gp_Ax2\n  * fulldecl: gp_Ax2::~gp_Ax2()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Ax1 *_wrap_new_gp_Ax1__SWIG_0 () {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Ax1 *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax1 *)new gp_Ax1();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax1\n  * wrapname: _wrap_new_gp_Ax1__SWIG_0\n  * fulldecl: gp_Ax1::gp_Ax1()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT gp_Ax1 *_wrap_new_gp_Ax1__SWIG_1 (gp_Pnt *larg1, gp_Dir *larg2) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  gp_Pnt *arg1 = 0 ;
  gp_Dir *arg2 = 0 ;
  gp_Ax1 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax1 *)new gp_Ax1((gp_Pnt const &)*arg1,(gp_Dir const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Ax1\n  * wrapname: _wrap_new_gp_Ax1__SWIG_1\n  * fulldecl: gp_Ax1::gp_Ax1(gp_Pnt const &,gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT void _wrap_delete_gp_Ax1 (gp_Ax1 *larg1) {
  gp_Ax1 *arg1 = (gp_Ax1 *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Ax1\n  * wrapname: _wrap_delete_gp_Ax1\n  * fulldecl: gp_Ax1::~gp_Ax1()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Trsf2d *_wrap_new_gp_Trsf2d__SWIG_0 () {
  gp_Trsf2d * lresult = (gp_Trsf2d *)0 ;
  gp_Trsf2d *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Trsf2d *)new gp_Trsf2d();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Trsf2d\n  * wrapname: _wrap_new_gp_Trsf2d__SWIG_0\n  * fulldecl: gp_Trsf2d::gp_Trsf2d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Trsf2d *)0;
  }
}


EXPORT gp_Trsf2d *_wrap_new_gp_Trsf2d__SWIG_1 (gp_Trsf *larg1) {
  gp_Trsf2d * lresult = (gp_Trsf2d *)0 ;
  gp_Trsf *arg1 = 0 ;
  gp_Trsf2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Trsf2d *)new gp_Trsf2d((gp_Trsf const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Trsf2d\n  * wrapname: _wrap_new_gp_Trsf2d__SWIG_1\n  * fulldecl: gp_Trsf2d::gp_Trsf2d(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Trsf2d *)0;
  }
}


EXPORT void _wrap_delete_gp_Trsf2d (gp_Trsf2d *larg1) {
  gp_Trsf2d *arg1 = (gp_Trsf2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Trsf2d\n  * wrapname: _wrap_delete_gp_Trsf2d\n  * fulldecl: gp_Trsf2d::~gp_Trsf2d()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Trsf *_wrap_new_gp_Trsf__SWIG_0 () {
  gp_Trsf * lresult = (gp_Trsf *)0 ;
  gp_Trsf *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Trsf *)new gp_Trsf();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Trsf\n  * wrapname: _wrap_new_gp_Trsf__SWIG_0\n  * fulldecl: gp_Trsf::gp_Trsf()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Trsf *)0;
  }
}


EXPORT gp_Trsf *_wrap_new_gp_Trsf__SWIG_1 (gp_Trsf2d *larg1) {
  gp_Trsf * lresult = (gp_Trsf *)0 ;
  gp_Trsf2d *arg1 = 0 ;
  gp_Trsf *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Trsf *)new gp_Trsf((gp_Trsf2d const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Trsf\n  * wrapname: _wrap_new_gp_Trsf__SWIG_1\n  * fulldecl: gp_Trsf::gp_Trsf(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Trsf *)0;
  }
}


EXPORT void _wrap_gp_Trsf_SetMirror__SWIG_0 (gp_Trsf *larg1, gp_Ax1 *larg2) {
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetMirror((gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_SetMirror\n  * wrapname: _wrap_gp_Trsf_SetMirror__SWIG_0\n  * fulldecl: void gp_Trsf::SetMirror(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf_SetMirror__SWIG_1 (gp_Trsf *larg1, gp_Ax2 *larg2) {
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetMirror((gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_SetMirror\n  * wrapname: _wrap_gp_Trsf_SetMirror__SWIG_1\n  * fulldecl: void gp_Trsf::SetMirror(gp_Ax2 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf_SetRotation (gp_Trsf *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetRotation((gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_SetRotation\n  * wrapname: _wrap_gp_Trsf_SetRotation\n  * fulldecl: void gp_Trsf::SetRotation(gp_Ax1 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf_SetTranslation (gp_Trsf *larg1, gp_Vec *larg2) {
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  gp_Vec *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetTranslation((gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_SetTranslation\n  * wrapname: _wrap_gp_Trsf_SetTranslation\n  * fulldecl: void gp_Trsf::SetTranslation(gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_gp_Trsf_SetValues (gp_Trsf *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5, Standard_Real larg6, Standard_Real larg7, Standard_Real larg8, Standard_Real larg9, Standard_Real larg10, Standard_Real larg11, Standard_Real larg12, Standard_Real larg13) {
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  Standard_Real arg6 ;
  Standard_Real arg7 ;
  Standard_Real arg8 ;
  Standard_Real arg9 ;
  Standard_Real arg10 ;
  Standard_Real arg11 ;
  Standard_Real arg12 ;
  Standard_Real arg13 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  arg11 = larg11;
  arg12 = larg12;
  arg13 = larg13;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetValues(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: gp_Trsf_SetValues\n  * wrapname: _wrap_gp_Trsf_SetValues\n  * fulldecl: void gp_Trsf::SetValues(Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_gp_Trsf (gp_Trsf *larg1) {
  gp_Trsf *arg1 = (gp_Trsf *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Trsf\n  * wrapname: _wrap_delete_gp_Trsf\n  * fulldecl: gp_Trsf::~gp_Trsf()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Circ *_wrap_new_gp_Circ (gp_Ax2 *larg1, Standard_Real larg2) {
  gp_Circ * lresult = (gp_Circ *)0 ;
  gp_Ax2 *arg1 = 0 ;
  Standard_Real arg2 ;
  gp_Circ *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Circ *)new gp_Circ((gp_Ax2 const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Circ\n  * wrapname: _wrap_new_gp_Circ\n  * fulldecl: gp_Circ::gp_Circ(gp_Ax2 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Circ *)0;
  }
}


EXPORT void _wrap_delete_gp_Circ (gp_Circ *larg1) {
  gp_Circ *arg1 = (gp_Circ *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Circ\n  * wrapname: _wrap_delete_gp_Circ\n  * fulldecl: gp_Circ::~gp_Circ()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Cone *_wrap_new_gp_Cone (gp_Ax3 *larg1, Standard_Real larg2, Standard_Real larg3) {
  gp_Cone * lresult = (gp_Cone *)0 ;
  gp_Ax3 *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  gp_Cone *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Cone *)new gp_Cone((gp_Ax3 const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Cone\n  * wrapname: _wrap_new_gp_Cone\n  * fulldecl: gp_Cone::gp_Cone(gp_Ax3 const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Cone *)0;
  }
}


EXPORT void _wrap_delete_gp_Cone (gp_Cone *larg1) {
  gp_Cone *arg1 = (gp_Cone *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Cone\n  * wrapname: _wrap_delete_gp_Cone\n  * fulldecl: gp_Cone::~gp_Cone()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Cylinder *_wrap_new_gp_Cylinder (gp_Ax3 *larg1, Standard_Real larg2) {
  gp_Cylinder * lresult = (gp_Cylinder *)0 ;
  gp_Ax3 *arg1 = 0 ;
  Standard_Real arg2 ;
  gp_Cylinder *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Cylinder *)new gp_Cylinder((gp_Ax3 const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Cylinder\n  * wrapname: _wrap_new_gp_Cylinder\n  * fulldecl: gp_Cylinder::gp_Cylinder(gp_Ax3 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Cylinder *)0;
  }
}


EXPORT void _wrap_delete_gp_Cylinder (gp_Cylinder *larg1) {
  gp_Cylinder *arg1 = (gp_Cylinder *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Cylinder\n  * wrapname: _wrap_delete_gp_Cylinder\n  * fulldecl: gp_Cylinder::~gp_Cylinder()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Parab *_wrap_new_gp_Parab__SWIG_0 (gp_Ax2 *larg1, Standard_Real larg2) {
  gp_Parab * lresult = (gp_Parab *)0 ;
  gp_Ax2 *arg1 = 0 ;
  Standard_Real arg2 ;
  gp_Parab *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Parab *)new gp_Parab((gp_Ax2 const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Parab\n  * wrapname: _wrap_new_gp_Parab__SWIG_0\n  * fulldecl: gp_Parab::gp_Parab(gp_Ax2 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Parab *)0;
  }
}


EXPORT gp_Parab *_wrap_new_gp_Parab__SWIG_1 (gp_Ax1 *larg1, gp_Pnt *larg2) {
  gp_Parab * lresult = (gp_Parab *)0 ;
  gp_Ax1 *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Parab *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Parab *)new gp_Parab((gp_Ax1 const &)*arg1,(gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Parab\n  * wrapname: _wrap_new_gp_Parab__SWIG_1\n  * fulldecl: gp_Parab::gp_Parab(gp_Ax1 const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Parab *)0;
  }
}


EXPORT void _wrap_delete_gp_Parab (gp_Parab *larg1) {
  gp_Parab *arg1 = (gp_Parab *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Parab\n  * wrapname: _wrap_delete_gp_Parab\n  * fulldecl: gp_Parab::~gp_Parab()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Hypr *_wrap_new_gp_Hypr (gp_Ax2 *larg1, Standard_Real larg2, Standard_Real larg3) {
  gp_Hypr * lresult = (gp_Hypr *)0 ;
  gp_Ax2 *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  gp_Hypr *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Hypr *)new gp_Hypr((gp_Ax2 const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Hypr\n  * wrapname: _wrap_new_gp_Hypr\n  * fulldecl: gp_Hypr::gp_Hypr(gp_Ax2 const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Hypr *)0;
  }
}


EXPORT void _wrap_delete_gp_Hypr (gp_Hypr *larg1) {
  gp_Hypr *arg1 = (gp_Hypr *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Hypr\n  * wrapname: _wrap_delete_gp_Hypr\n  * fulldecl: gp_Hypr::~gp_Hypr()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Torus *_wrap_new_gp_Torus (gp_Ax3 *larg1, Standard_Real *larg2, Standard_Real *larg3) {
  gp_Torus * lresult = (gp_Torus *)0 ;
  gp_Ax3 *arg1 = 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  gp_Torus *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Torus *)new gp_Torus((gp_Ax3 const &)*arg1,*arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Torus\n  * wrapname: _wrap_new_gp_Torus\n  * fulldecl: gp_Torus::gp_Torus(gp_Ax3 const &,Standard_Real &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Torus *)0;
  }
}


EXPORT void _wrap_delete_gp_Torus (gp_Torus *larg1) {
  gp_Torus *arg1 = (gp_Torus *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Torus\n  * wrapname: _wrap_delete_gp_Torus\n  * fulldecl: gp_Torus::~gp_Torus()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Sphere *_wrap_new_gp_Sphere (gp_Ax3 *larg1, Standard_Real *larg2) {
  gp_Sphere * lresult = (gp_Sphere *)0 ;
  gp_Ax3 *arg1 = 0 ;
  Standard_Real *arg2 = 0 ;
  gp_Sphere *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Sphere *)new gp_Sphere((gp_Ax3 const &)*arg1,*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Sphere\n  * wrapname: _wrap_new_gp_Sphere\n  * fulldecl: gp_Sphere::gp_Sphere(gp_Ax3 const &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Sphere *)0;
  }
}


EXPORT void _wrap_delete_gp_Sphere (gp_Sphere *larg1) {
  gp_Sphere *arg1 = (gp_Sphere *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Sphere\n  * wrapname: _wrap_delete_gp_Sphere\n  * fulldecl: gp_Sphere::~gp_Sphere()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_XYZ *_wrap_new_gp_XYZ__SWIG_0 () {
  gp_XYZ * lresult = (gp_XYZ *)0 ;
  gp_XYZ *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_XYZ *)new gp_XYZ();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_XYZ\n  * wrapname: _wrap_new_gp_XYZ__SWIG_0\n  * fulldecl: gp_XYZ::gp_XYZ()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_XYZ *)0;
  }
}


EXPORT gp_XYZ *_wrap_new_gp_XYZ__SWIG_1 (Standard_Real larg1, Standard_Real larg2, Standard_Real larg3) {
  gp_XYZ * lresult = (gp_XYZ *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  gp_XYZ *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_XYZ *)new gp_XYZ(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_XYZ\n  * wrapname: _wrap_new_gp_XYZ__SWIG_1\n  * fulldecl: gp_XYZ::gp_XYZ(Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_XYZ *)0;
  }
}


EXPORT void _wrap_delete_gp_XYZ (gp_XYZ *larg1) {
  gp_XYZ *arg1 = (gp_XYZ *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_XYZ\n  * wrapname: _wrap_delete_gp_XYZ\n  * fulldecl: gp_XYZ::~gp_XYZ()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_XY *_wrap_new_gp_XY__SWIG_0 () {
  gp_XY * lresult = (gp_XY *)0 ;
  gp_XY *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_XY *)new gp_XY();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_XY\n  * wrapname: _wrap_new_gp_XY__SWIG_0\n  * fulldecl: gp_XY::gp_XY()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_XY *)0;
  }
}


EXPORT gp_XY *_wrap_new_gp_XY__SWIG_1 (Standard_Real larg1, Standard_Real larg2) {
  gp_XY * lresult = (gp_XY *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  gp_XY *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_XY *)new gp_XY(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_XY\n  * wrapname: _wrap_new_gp_XY__SWIG_1\n  * fulldecl: gp_XY::gp_XY(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_XY *)0;
  }
}


EXPORT void _wrap_delete_gp_XY (gp_XY *larg1) {
  gp_XY *arg1 = (gp_XY *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_XY\n  * wrapname: _wrap_delete_gp_XY\n  * fulldecl: gp_XY::~gp_XY()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Lin2d *_wrap_new_gp_Lin2d__SWIG_0 () {
  gp_Lin2d * lresult = (gp_Lin2d *)0 ;
  gp_Lin2d *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Lin2d *)new gp_Lin2d();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Lin2d\n  * wrapname: _wrap_new_gp_Lin2d__SWIG_0\n  * fulldecl: gp_Lin2d::gp_Lin2d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Lin2d *)0;
  }
}


EXPORT gp_Lin2d *_wrap_new_gp_Lin2d__SWIG_1 (gp_Ax2d *larg1) {
  gp_Lin2d * lresult = (gp_Lin2d *)0 ;
  gp_Ax2d *arg1 = 0 ;
  gp_Lin2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Lin2d *)new gp_Lin2d((gp_Ax2d const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Lin2d\n  * wrapname: _wrap_new_gp_Lin2d__SWIG_1\n  * fulldecl: gp_Lin2d::gp_Lin2d(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Lin2d *)0;
  }
}


EXPORT gp_Lin2d *_wrap_new_gp_Lin2d__SWIG_2 (gp_Pnt2d *larg1, gp_Dir2d *larg2) {
  gp_Lin2d * lresult = (gp_Lin2d *)0 ;
  gp_Pnt2d *arg1 = 0 ;
  gp_Dir2d *arg2 = 0 ;
  gp_Lin2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Lin2d *)new gp_Lin2d((gp_Pnt2d const &)*arg1,(gp_Dir2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Lin2d\n  * wrapname: _wrap_new_gp_Lin2d__SWIG_2\n  * fulldecl: gp_Lin2d::gp_Lin2d(gp_Pnt2d const &,gp_Dir2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Lin2d *)0;
  }
}


EXPORT gp_Lin2d *_wrap_new_gp_Lin2d__SWIG_3 (Standard_Real larg1, Standard_Real larg2, Standard_Real larg3) {
  gp_Lin2d * lresult = (gp_Lin2d *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  gp_Lin2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Lin2d *)new gp_Lin2d(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_gp_Lin2d\n  * wrapname: _wrap_new_gp_Lin2d__SWIG_3\n  * fulldecl: gp_Lin2d::gp_Lin2d(Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Lin2d *)0;
  }
}


EXPORT void _wrap_delete_gp_Lin2d (gp_Lin2d *larg1) {
  gp_Lin2d *arg1 = (gp_Lin2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_gp_Lin2d\n  * wrapname: _wrap_delete_gp_Lin2d\n  * fulldecl: gp_Lin2d::~gp_Lin2d()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <TColStd_HArray1OfBoolean.hxx>


#include <TColgp_HArray1OfPnt.hxx>

EXPORT TColgp_HArray1OfPnt *_wrap_new_TColgp_HArray1OfPnt (Standard_Integer larg1, Standard_Integer larg2) {
  TColgp_HArray1OfPnt * lresult = (TColgp_HArray1OfPnt *)0 ;
  Standard_Integer arg1 ;
  Standard_Integer arg2 ;
  TColgp_HArray1OfPnt *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColgp_HArray1OfPnt *)new TColgp_HArray1OfPnt(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TColgp_HArray1OfPnt\n  * wrapname: _wrap_new_TColgp_HArray1OfPnt\n  * fulldecl: TColgp_HArray1OfPnt::TColgp_HArray1OfPnt(Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColgp_HArray1OfPnt *)0;
  }
}


EXPORT void _wrap_TColgp_HArray1OfPnt_SetValue (TColgp_HArray1OfPnt *larg1, Standard_Integer larg2, gp_Pnt *larg3) {
  TColgp_HArray1OfPnt *arg1 = (TColgp_HArray1OfPnt *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetValue(arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColgp_HArray1OfPnt_SetValue\n  * wrapname: _wrap_TColgp_HArray1OfPnt_SetValue\n  * fulldecl: void TColgp_HArray1OfPnt::SetValue(Standard_Integer const,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_TColgp_HArray1OfPnt (TColgp_HArray1OfPnt *larg1) {
  TColgp_HArray1OfPnt *arg1 = (TColgp_HArray1OfPnt *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TColgp_HArray1OfPnt\n  * wrapname: _wrap_delete_TColgp_HArray1OfPnt\n  * fulldecl: TColgp_HArray1OfPnt::~TColgp_HArray1OfPnt()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_Handle_TColgp_HArray1OfPnt (Handle_TColgp_HArray1OfPnt *larg1) {
  Handle_TColgp_HArray1OfPnt *arg1 = (Handle_TColgp_HArray1OfPnt *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Handle_TColgp_HArray1OfPnt\n  * wrapname: _wrap_delete_Handle_TColgp_HArray1OfPnt\n  * fulldecl: Handle_TColgp_HArray1OfPnt::~Handle_TColgp_HArray1OfPnt()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_Handle_TColStd_HArray1OfBoolean (Handle_TColStd_HArray1OfBoolean *larg1) {
  Handle_TColStd_HArray1OfBoolean *arg1 = (Handle_TColStd_HArray1OfBoolean *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Handle_TColStd_HArray1OfBoolean\n  * wrapname: _wrap_delete_Handle_TColStd_HArray1OfBoolean\n  * fulldecl: Handle_TColStd_HArray1OfBoolean::~Handle_TColStd_HArray1OfBoolean()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <TColgp_Array1OfVec.hxx>
  
EXPORT TColgp_Array1OfVec *_wrap_new_TColgp_Array1OfVec (Standard_Integer larg1, Standard_Integer larg2) {
  TColgp_Array1OfVec * lresult = (TColgp_Array1OfVec *)0 ;
  Standard_Integer arg1 ;
  Standard_Integer arg2 ;
  TColgp_Array1OfVec *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColgp_Array1OfVec *)new TColgp_Array1OfVec(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TColgp_Array1OfVec\n  * wrapname: _wrap_new_TColgp_Array1OfVec\n  * fulldecl: TColgp_Array1OfVec::TColgp_Array1OfVec(Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColgp_Array1OfVec *)0;
  }
}


EXPORT void _wrap_TColgp_Array1OfVec_SetValue (TColgp_Array1OfVec *larg1, Standard_Integer larg2, gp_Vec *larg3) {
  TColgp_Array1OfVec *arg1 = (TColgp_Array1OfVec *) 0 ;
  Standard_Integer arg2 ;
  gp_Vec *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetValue(arg2,(gp_Vec const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColgp_Array1OfVec_SetValue\n  * wrapname: _wrap_TColgp_Array1OfVec_SetValue\n  * fulldecl: void TColgp_Array1OfVec::SetValue(Standard_Integer const,gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_TColgp_Array1OfVec (TColgp_Array1OfVec *larg1) {
  TColgp_Array1OfVec *arg1 = (TColgp_Array1OfVec *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TColgp_Array1OfVec\n  * wrapname: _wrap_delete_TColgp_Array1OfVec\n  * fulldecl: TColgp_Array1OfVec::~TColgp_Array1OfVec()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <TColgp_Array1OfPnt2d.hxx>
  
EXPORT TColgp_Array1OfPnt2d *_wrap_new_TColgp_Array1OfPnt2d (Standard_Integer larg1, Standard_Integer larg2) {
  TColgp_Array1OfPnt2d * lresult = (TColgp_Array1OfPnt2d *)0 ;
  Standard_Integer arg1 ;
  Standard_Integer arg2 ;
  TColgp_Array1OfPnt2d *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColgp_Array1OfPnt2d *)new TColgp_Array1OfPnt2d(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TColgp_Array1OfPnt2d\n  * wrapname: _wrap_new_TColgp_Array1OfPnt2d\n  * fulldecl: TColgp_Array1OfPnt2d::TColgp_Array1OfPnt2d(Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColgp_Array1OfPnt2d *)0;
  }
}


EXPORT void _wrap_TColgp_Array1OfPnt2d_SetValue (TColgp_Array1OfPnt2d *larg1, Standard_Integer larg2, gp_Pnt2d *larg3) {
  TColgp_Array1OfPnt2d *arg1 = (TColgp_Array1OfPnt2d *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetValue(arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColgp_Array1OfPnt2d_SetValue\n  * wrapname: _wrap_TColgp_Array1OfPnt2d_SetValue\n  * fulldecl: void TColgp_Array1OfPnt2d::SetValue(Standard_Integer const,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_TColgp_Array1OfPnt2d (TColgp_Array1OfPnt2d *larg1) {
  TColgp_Array1OfPnt2d *arg1 = (TColgp_Array1OfPnt2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TColgp_Array1OfPnt2d\n  * wrapname: _wrap_delete_TColgp_Array1OfPnt2d\n  * fulldecl: TColgp_Array1OfPnt2d::~TColgp_Array1OfPnt2d()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <TColStd_Array1OfReal.hxx>
  
EXPORT TColStd_Array1OfReal *_wrap_new_TColStd_Array1OfReal (Standard_Integer larg1, Standard_Integer larg2) {
  TColStd_Array1OfReal * lresult = (TColStd_Array1OfReal *)0 ;
  Standard_Integer arg1 ;
  Standard_Integer arg2 ;
  TColStd_Array1OfReal *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColStd_Array1OfReal *)new TColStd_Array1OfReal(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TColStd_Array1OfReal\n  * wrapname: _wrap_new_TColStd_Array1OfReal\n  * fulldecl: TColStd_Array1OfReal::TColStd_Array1OfReal(Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColStd_Array1OfReal *)0;
  }
}


EXPORT void _wrap_TColStd_Array1OfReal_SetValue (TColStd_Array1OfReal *larg1, Standard_Integer larg2, Standard_Real *larg3) {
  TColStd_Array1OfReal *arg1 = (TColStd_Array1OfReal *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetValue(arg2,(Standard_Real const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColStd_Array1OfReal_SetValue\n  * wrapname: _wrap_TColStd_Array1OfReal_SetValue\n  * fulldecl: void TColStd_Array1OfReal::SetValue(Standard_Integer const,Standard_Real const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_TColStd_Array1OfReal (TColStd_Array1OfReal *larg1) {
  TColStd_Array1OfReal *arg1 = (TColStd_Array1OfReal *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TColStd_Array1OfReal\n  * wrapname: _wrap_delete_TColStd_Array1OfReal\n  * fulldecl: TColStd_Array1OfReal::~TColStd_Array1OfReal()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <TColStd_Array1OfInteger.hxx>
  
EXPORT TColStd_Array1OfInteger *_wrap_new_TColStd_Array1OfInteger (Standard_Integer larg1, Standard_Integer larg2) {
  TColStd_Array1OfInteger * lresult = (TColStd_Array1OfInteger *)0 ;
  Standard_Integer arg1 ;
  Standard_Integer arg2 ;
  TColStd_Array1OfInteger *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColStd_Array1OfInteger *)new TColStd_Array1OfInteger(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TColStd_Array1OfInteger\n  * wrapname: _wrap_new_TColStd_Array1OfInteger\n  * fulldecl: TColStd_Array1OfInteger::TColStd_Array1OfInteger(Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColStd_Array1OfInteger *)0;
  }
}


EXPORT void _wrap_TColStd_Array1OfInteger_SetValue (TColStd_Array1OfInteger *larg1, Standard_Integer larg2, Standard_Integer *larg3) {
  TColStd_Array1OfInteger *arg1 = (TColStd_Array1OfInteger *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetValue(arg2,(Standard_Integer const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColStd_Array1OfInteger_SetValue\n  * wrapname: _wrap_TColStd_Array1OfInteger_SetValue\n  * fulldecl: void TColStd_Array1OfInteger::SetValue(Standard_Integer const,Standard_Integer const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Integer _wrap_TColStd_Array1OfInteger_Value (TColStd_Array1OfInteger *larg1, Standard_Integer larg2) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  TColStd_Array1OfInteger *arg1 = (TColStd_Array1OfInteger *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)(arg1)->Value(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColStd_Array1OfInteger_Value\n  * wrapname: _wrap_TColStd_Array1OfInteger_Value\n  * fulldecl: Standard_Integer const TColStd_Array1OfInteger::Value(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT Standard_Integer _wrap_TColStd_Array1OfInteger_Lower (TColStd_Array1OfInteger *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  TColStd_Array1OfInteger *arg1 = (TColStd_Array1OfInteger *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((TColStd_Array1OfInteger const *)arg1)->Lower();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColStd_Array1OfInteger_Lower\n  * wrapname: _wrap_TColStd_Array1OfInteger_Lower\n  * fulldecl: Standard_Integer TColStd_Array1OfInteger::Lower() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT Standard_Integer _wrap_TColStd_Array1OfInteger_Upper (TColStd_Array1OfInteger *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  TColStd_Array1OfInteger *arg1 = (TColStd_Array1OfInteger *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((TColStd_Array1OfInteger const *)arg1)->Upper();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColStd_Array1OfInteger_Upper\n  * wrapname: _wrap_TColStd_Array1OfInteger_Upper\n  * fulldecl: Standard_Integer TColStd_Array1OfInteger::Upper() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT void _wrap_delete_TColStd_Array1OfInteger (TColStd_Array1OfInteger *larg1) {
  TColStd_Array1OfInteger *arg1 = (TColStd_Array1OfInteger *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TColStd_Array1OfInteger\n  * wrapname: _wrap_delete_TColStd_Array1OfInteger\n  * fulldecl: TColStd_Array1OfInteger::~TColStd_Array1OfInteger()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <TColgp_Array1OfPnt.hxx>
  
EXPORT TColgp_Array1OfPnt *_wrap_new_TColgp_Array1OfPnt (Standard_Integer larg1, Standard_Integer larg2) {
  TColgp_Array1OfPnt * lresult = (TColgp_Array1OfPnt *)0 ;
  Standard_Integer arg1 ;
  Standard_Integer arg2 ;
  TColgp_Array1OfPnt *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColgp_Array1OfPnt *)new TColgp_Array1OfPnt(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TColgp_Array1OfPnt\n  * wrapname: _wrap_new_TColgp_Array1OfPnt\n  * fulldecl: TColgp_Array1OfPnt::TColgp_Array1OfPnt(Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColgp_Array1OfPnt *)0;
  }
}


EXPORT gp_Pnt const *_wrap_TColgp_Array1OfPnt_Value (TColgp_Array1OfPnt *larg1, Standard_Integer larg2) {
  gp_Pnt const * lresult = (gp_Pnt const *)0 ;
  TColgp_Array1OfPnt *arg1 = (TColgp_Array1OfPnt *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (arg1)->Value(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColgp_Array1OfPnt_Value\n  * wrapname: _wrap_TColgp_Array1OfPnt_Value\n  * fulldecl: gp_Pnt const TColgp_Array1OfPnt::Value(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt const(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt const *)0;
  }
}


EXPORT void _wrap_TColgp_Array1OfPnt_SetValue (TColgp_Array1OfPnt *larg1, Standard_Integer larg2, gp_Pnt *larg3) {
  TColgp_Array1OfPnt *arg1 = (TColgp_Array1OfPnt *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetValue(arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColgp_Array1OfPnt_SetValue\n  * wrapname: _wrap_TColgp_Array1OfPnt_SetValue\n  * fulldecl: void TColgp_Array1OfPnt::SetValue(Standard_Integer const,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Integer _wrap_TColgp_Array1OfPnt_Lower (TColgp_Array1OfPnt *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  TColgp_Array1OfPnt *arg1 = (TColgp_Array1OfPnt *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((TColgp_Array1OfPnt const *)arg1)->Lower();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColgp_Array1OfPnt_Lower\n  * wrapname: _wrap_TColgp_Array1OfPnt_Lower\n  * fulldecl: Standard_Integer TColgp_Array1OfPnt::Lower() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT Standard_Integer _wrap_TColgp_Array1OfPnt_Upper (TColgp_Array1OfPnt *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  TColgp_Array1OfPnt *arg1 = (TColgp_Array1OfPnt *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((TColgp_Array1OfPnt const *)arg1)->Upper();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColgp_Array1OfPnt_Upper\n  * wrapname: _wrap_TColgp_Array1OfPnt_Upper\n  * fulldecl: Standard_Integer TColgp_Array1OfPnt::Upper() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT void _wrap_delete_TColgp_Array1OfPnt (TColgp_Array1OfPnt *larg1) {
  TColgp_Array1OfPnt *arg1 = (TColgp_Array1OfPnt *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TColgp_Array1OfPnt\n  * wrapname: _wrap_delete_TColgp_Array1OfPnt\n  * fulldecl: TColgp_Array1OfPnt::~TColgp_Array1OfPnt()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <TColgp_Array2OfPnt.hxx>
  
EXPORT TColgp_Array2OfPnt *_wrap_new_TColgp_Array2OfPnt (Standard_Integer larg1, Standard_Integer larg2, Standard_Integer larg3, Standard_Integer larg4) {
  TColgp_Array2OfPnt * lresult = (TColgp_Array2OfPnt *)0 ;
  Standard_Integer arg1 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  Standard_Integer arg4 ;
  TColgp_Array2OfPnt *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColgp_Array2OfPnt *)new TColgp_Array2OfPnt(arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TColgp_Array2OfPnt\n  * wrapname: _wrap_new_TColgp_Array2OfPnt\n  * fulldecl: TColgp_Array2OfPnt::TColgp_Array2OfPnt(Standard_Integer const,Standard_Integer const,Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColgp_Array2OfPnt *)0;
  }
}


EXPORT void _wrap_TColgp_Array2OfPnt_SetValue (TColgp_Array2OfPnt *larg1, Standard_Integer larg2, Standard_Integer larg3, gp_Pnt *larg4) {
  TColgp_Array2OfPnt *arg1 = (TColgp_Array2OfPnt *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  gp_Pnt *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetValue(arg2,arg3,(gp_Pnt const &)*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColgp_Array2OfPnt_SetValue\n  * wrapname: _wrap_TColgp_Array2OfPnt_SetValue\n  * fulldecl: void TColgp_Array2OfPnt::SetValue(Standard_Integer const,Standard_Integer const,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_TColgp_Array2OfPnt (TColgp_Array2OfPnt *larg1) {
  TColgp_Array2OfPnt *arg1 = (TColgp_Array2OfPnt *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TColgp_Array2OfPnt\n  * wrapname: _wrap_delete_TColgp_Array2OfPnt\n  * fulldecl: TColgp_Array2OfPnt::~TColgp_Array2OfPnt()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <TColStd_Array2OfReal.hxx>
  
EXPORT TColStd_Array2OfReal *_wrap_new_TColStd_Array2OfReal (Standard_Integer larg1, Standard_Integer larg2, Standard_Integer larg3, Standard_Integer larg4) {
  TColStd_Array2OfReal * lresult = (TColStd_Array2OfReal *)0 ;
  Standard_Integer arg1 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  Standard_Integer arg4 ;
  TColStd_Array2OfReal *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColStd_Array2OfReal *)new TColStd_Array2OfReal(arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TColStd_Array2OfReal\n  * wrapname: _wrap_new_TColStd_Array2OfReal\n  * fulldecl: TColStd_Array2OfReal::TColStd_Array2OfReal(Standard_Integer const,Standard_Integer const,Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColStd_Array2OfReal *)0;
  }
}


EXPORT void _wrap_TColStd_Array2OfReal_SetValue (TColStd_Array2OfReal *larg1, Standard_Integer larg2, Standard_Integer larg3, Standard_Real *larg4) {
  TColStd_Array2OfReal *arg1 = (TColStd_Array2OfReal *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  Standard_Real *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetValue(arg2,arg3,(Standard_Real const &)*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TColStd_Array2OfReal_SetValue\n  * wrapname: _wrap_TColStd_Array2OfReal_SetValue\n  * fulldecl: void TColStd_Array2OfReal::SetValue(Standard_Integer const,Standard_Integer const,Standard_Real const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_TColStd_Array2OfReal (TColStd_Array2OfReal *larg1) {
  TColStd_Array2OfReal *arg1 = (TColStd_Array2OfReal *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TColStd_Array2OfReal\n  * wrapname: _wrap_delete_TColStd_Array2OfReal\n  * fulldecl: TColStd_Array2OfReal::~TColStd_Array2OfReal()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <TopAbs_ShapeEnum.hxx>
#include <TopAbs_Orientation.hxx>
  

#include <TopoDS_Shape.hxx>
#include <TopoDS_Compound.hxx>
#include <TopoDS_CompSolid.hxx>
#include <TopoDS_Solid.hxx>
#include <TopoDS_Shell.hxx>
#include <TopoDS_Face.hxx>
#include <TopoDS_Wire.hxx>
#include <TopoDS_Edge.hxx>
#include <TopoDS_Vertex.hxx>
#include <TopoDS_Iterator.hxx>
#include <TopoDS_Builder.hxx>
  
EXPORT TopAbs_ShapeEnum _wrap_TopoDS_Shape_ShapeType (TopoDS_Shape *larg1) {
  TopAbs_ShapeEnum lresult = (TopAbs_ShapeEnum)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  TopAbs_ShapeEnum result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopAbs_ShapeEnum)(arg1)->ShapeType();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_ShapeType\n  * wrapname: _wrap_TopoDS_Shape_ShapeType\n  * fulldecl: TopAbs_ShapeEnum TopoDS_Shape::ShapeType()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopAbs_ShapeEnum)0;
  }
}


EXPORT bool _wrap_TopoDS_Shape_IsSame (TopoDS_Shape *larg1, TopoDS_Shape *larg2) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TopoDS_Shape const *)arg1)->IsSame((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_IsSame\n  * wrapname: _wrap_TopoDS_Shape_IsSame\n  * fulldecl: Standard_Boolean TopoDS_Shape::IsSame(TopoDS_Shape const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_TopoDS_Shape_IsPartner (TopoDS_Shape *larg1, TopoDS_Shape *larg2) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TopoDS_Shape const *)arg1)->IsPartner((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_IsPartner\n  * wrapname: _wrap_TopoDS_Shape_IsPartner\n  * fulldecl: Standard_Boolean TopoDS_Shape::IsPartner(TopoDS_Shape const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_TopoDS_Shape_IsEqual (TopoDS_Shape *larg1, TopoDS_Shape *larg2) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TopoDS_Shape const *)arg1)->IsEqual((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_IsEqual\n  * wrapname: _wrap_TopoDS_Shape_IsEqual\n  * fulldecl: Standard_Boolean TopoDS_Shape::IsEqual(TopoDS_Shape const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Handle_TopoDS_TShape *_wrap_TopoDS_Shape_TShape (TopoDS_Shape *larg1) {
  Handle_TopoDS_TShape * lresult = (Handle_TopoDS_TShape *)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Handle_TopoDS_TShape *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_TopoDS_TShape *) &((TopoDS_Shape const *)arg1)->TShape();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_TShape\n  * wrapname: _wrap_TopoDS_Shape_TShape\n  * fulldecl: Handle_TopoDS_TShape const & TopoDS_Shape::TShape() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_TopoDS_TShape *)0;
  }
}


EXPORT TopLoc_Location *_wrap_TopoDS_Shape_Location__SWIG_0 (TopoDS_Shape *larg1) {
  TopLoc_Location * lresult = (TopLoc_Location *)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  TopLoc_Location *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopLoc_Location *) &((TopoDS_Shape const *)arg1)->Location();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Location\n  * wrapname: _wrap_TopoDS_Shape_Location__SWIG_0\n  * fulldecl: TopLoc_Location const & TopoDS_Shape::Location() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopLoc_Location *)0;
  }
}


EXPORT void _wrap_TopoDS_Shape_Location__SWIG_1 (TopoDS_Shape *larg1, TopLoc_Location *larg2) {
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  TopLoc_Location *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Location((TopLoc_Location const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Location\n  * wrapname: _wrap_TopoDS_Shape_Location__SWIG_1\n  * fulldecl: void TopoDS_Shape::Location(TopLoc_Location const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopAbs_Orientation _wrap_TopoDS_Shape_Orientation__SWIG_0 (TopoDS_Shape *larg1) {
  TopAbs_Orientation lresult = (TopAbs_Orientation)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  TopAbs_Orientation result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopAbs_Orientation)((TopoDS_Shape const *)arg1)->Orientation();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Orientation\n  * wrapname: _wrap_TopoDS_Shape_Orientation__SWIG_0\n  * fulldecl: TopAbs_Orientation TopoDS_Shape::Orientation() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopAbs_Orientation)0;
  }
}


EXPORT void _wrap_TopoDS_Shape_Orientation__SWIG_1 (TopoDS_Shape *larg1, TopAbs_Orientation larg2) {
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  TopAbs_Orientation arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Orientation(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Orientation\n  * wrapname: _wrap_TopoDS_Shape_Orientation__SWIG_1\n  * fulldecl: void TopoDS_Shape::Orientation(TopAbs_Orientation const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopoDS_Shape_Reverse (TopoDS_Shape *larg1) {
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Reverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Reverse\n  * wrapname: _wrap_TopoDS_Shape_Reverse\n  * fulldecl: void TopoDS_Shape::Reverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopoDS_Shape *_wrap_TopoDS_Shape_Reversed (TopoDS_Shape *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  TopoDS_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((TopoDS_Shape const *)arg1)->Reversed();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Reversed\n  * wrapname: _wrap_TopoDS_Shape_Reversed\n  * fulldecl: TopoDS_Shape TopoDS_Shape::Reversed() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new TopoDS_Shape(result);
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT Standard_Integer _wrap_TopoDS_Shape_HashCode (TopoDS_Shape *larg1, Standard_Integer larg2) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((TopoDS_Shape const *)arg1)->HashCode(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_HashCode\n  * wrapname: _wrap_TopoDS_Shape_HashCode\n  * fulldecl: Standard_Integer TopoDS_Shape::HashCode(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT bool _wrap_TopoDS_Shape_Free__SWIG_0 (TopoDS_Shape *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TopoDS_Shape const *)arg1)->Free();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Free\n  * wrapname: _wrap_TopoDS_Shape_Free__SWIG_0\n  * fulldecl: Standard_Boolean TopoDS_Shape::Free() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_TopoDS_Shape_Free__SWIG_1 (TopoDS_Shape *larg1, bool larg2) {
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Free(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Free\n  * wrapname: _wrap_TopoDS_Shape_Free__SWIG_1\n  * fulldecl: void TopoDS_Shape::Free(Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_TopoDS_Shape_Locked__SWIG_0 (TopoDS_Shape *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TopoDS_Shape const *)arg1)->Locked();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Locked\n  * wrapname: _wrap_TopoDS_Shape_Locked__SWIG_0\n  * fulldecl: Standard_Boolean TopoDS_Shape::Locked() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_TopoDS_Shape_Locked__SWIG_1 (TopoDS_Shape *larg1, bool larg2) {
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Locked(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Locked\n  * wrapname: _wrap_TopoDS_Shape_Locked__SWIG_1\n  * fulldecl: void TopoDS_Shape::Locked(Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_TopoDS_Shape_Modified__SWIG_0 (TopoDS_Shape *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TopoDS_Shape const *)arg1)->Modified();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Modified\n  * wrapname: _wrap_TopoDS_Shape_Modified__SWIG_0\n  * fulldecl: Standard_Boolean TopoDS_Shape::Modified() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_TopoDS_Shape_Modified__SWIG_1 (TopoDS_Shape *larg1, bool larg2) {
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Modified(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Modified\n  * wrapname: _wrap_TopoDS_Shape_Modified__SWIG_1\n  * fulldecl: void TopoDS_Shape::Modified(Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_TopoDS_Shape_Checked__SWIG_0 (TopoDS_Shape *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TopoDS_Shape const *)arg1)->Checked();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Checked\n  * wrapname: _wrap_TopoDS_Shape_Checked__SWIG_0\n  * fulldecl: Standard_Boolean TopoDS_Shape::Checked() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_TopoDS_Shape_Checked__SWIG_1 (TopoDS_Shape *larg1, bool larg2) {
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Checked(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Checked\n  * wrapname: _wrap_TopoDS_Shape_Checked__SWIG_1\n  * fulldecl: void TopoDS_Shape::Checked(Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_TopoDS_Shape_Orientable__SWIG_0 (TopoDS_Shape *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TopoDS_Shape const *)arg1)->Orientable();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Orientable\n  * wrapname: _wrap_TopoDS_Shape_Orientable__SWIG_0\n  * fulldecl: Standard_Boolean TopoDS_Shape::Orientable() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_TopoDS_Shape_Orientable__SWIG_1 (TopoDS_Shape *larg1, bool larg2) {
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Orientable(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Orientable\n  * wrapname: _wrap_TopoDS_Shape_Orientable__SWIG_1\n  * fulldecl: void TopoDS_Shape::Orientable(Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_TopoDS_Shape_Closed__SWIG_0 (TopoDS_Shape *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TopoDS_Shape const *)arg1)->Closed();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Closed\n  * wrapname: _wrap_TopoDS_Shape_Closed__SWIG_0\n  * fulldecl: Standard_Boolean TopoDS_Shape::Closed() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_TopoDS_Shape_Closed__SWIG_1 (TopoDS_Shape *larg1, bool larg2) {
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Closed(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Closed\n  * wrapname: _wrap_TopoDS_Shape_Closed__SWIG_1\n  * fulldecl: void TopoDS_Shape::Closed(Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_TopoDS_Shape_Infinite__SWIG_0 (TopoDS_Shape *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TopoDS_Shape const *)arg1)->Infinite();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Infinite\n  * wrapname: _wrap_TopoDS_Shape_Infinite__SWIG_0\n  * fulldecl: Standard_Boolean TopoDS_Shape::Infinite() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_TopoDS_Shape_Infinite__SWIG_1 (TopoDS_Shape *larg1, bool larg2) {
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Infinite(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Infinite\n  * wrapname: _wrap_TopoDS_Shape_Infinite__SWIG_1\n  * fulldecl: void TopoDS_Shape::Infinite(Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_TopoDS_Shape_Convex__SWIG_0 (TopoDS_Shape *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TopoDS_Shape const *)arg1)->Convex();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Convex\n  * wrapname: _wrap_TopoDS_Shape_Convex__SWIG_0\n  * fulldecl: Standard_Boolean TopoDS_Shape::Convex() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_TopoDS_Shape_Convex__SWIG_1 (TopoDS_Shape *larg1, bool larg2) {
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Standard_Boolean arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Convex(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_Convex\n  * wrapname: _wrap_TopoDS_Shape_Convex__SWIG_1\n  * fulldecl: void TopoDS_Shape::Convex(Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN TopoDS_Shape *TopoDS_Shape_copy_reference(TopoDS_Shape *self){
    TopoDS_Shape *copy = new TopoDS_Shape();
    *copy=*self;
    return copy;
  }
EXPORT TopoDS_Shape *_wrap_TopoDS_Shape_copy_reference (TopoDS_Shape *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *)TopoDS_Shape_copy_reference(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_copy_reference\n  * wrapname: _wrap_TopoDS_Shape_copy_reference\n  * fulldecl: TopoDS_Shape * TopoDS_Shape::copy_reference()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


SWIGINTERN Handle_TopoDS_TShape TopoDS_Shape_getTShape(TopoDS_Shape *self){
    return (Handle_TopoDS_TShape)&*self->TShape();
  }
EXPORT Handle_TopoDS_TShape *_wrap_TopoDS_Shape_getTShape (TopoDS_Shape *larg1) {
  Handle_TopoDS_TShape * lresult = (Handle_TopoDS_TShape *)0 ;
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  Handle_TopoDS_TShape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = TopoDS_Shape_getTShape(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Shape_getTShape\n  * wrapname: _wrap_TopoDS_Shape_getTShape\n  * fulldecl: Handle_TopoDS_TShape TopoDS_Shape::getTShape()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_TopoDS_TShape(result);
    return lresult;
  } catch (...) {
    return (Handle_TopoDS_TShape *)0;
  }
}


EXPORT void _wrap_delete_TopoDS_Shape (TopoDS_Shape *larg1) {
  TopoDS_Shape *arg1 = (TopoDS_Shape *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopoDS_Shape\n  * wrapname: _wrap_delete_TopoDS_Shape\n  * fulldecl: TopoDS_Shape::~TopoDS_Shape()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopoDS_Compound *_wrap_new_TopoDS_Compound () {
  TopoDS_Compound * lresult = (TopoDS_Compound *)0 ;
  TopoDS_Compound *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Compound *)new TopoDS_Compound();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TopoDS_Compound\n  * wrapname: _wrap_new_TopoDS_Compound\n  * fulldecl: TopoDS_Compound::TopoDS_Compound()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Compound *)0;
  }
}


EXPORT void _wrap_delete_TopoDS_Compound (TopoDS_Compound *larg1) {
  TopoDS_Compound *arg1 = (TopoDS_Compound *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopoDS_Compound\n  * wrapname: _wrap_delete_TopoDS_Compound\n  * fulldecl: TopoDS_Compound::~TopoDS_Compound()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_TopoDS_CompSolid (TopoDS_CompSolid *larg1) {
  TopoDS_CompSolid *arg1 = (TopoDS_CompSolid *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopoDS_CompSolid\n  * wrapname: _wrap_delete_TopoDS_CompSolid\n  * fulldecl: TopoDS_CompSolid::~TopoDS_CompSolid()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_TopoDS_Solid (TopoDS_Solid *larg1) {
  TopoDS_Solid *arg1 = (TopoDS_Solid *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopoDS_Solid\n  * wrapname: _wrap_delete_TopoDS_Solid\n  * fulldecl: TopoDS_Solid::~TopoDS_Solid()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_TopoDS_Shell (TopoDS_Shell *larg1) {
  TopoDS_Shell *arg1 = (TopoDS_Shell *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopoDS_Shell\n  * wrapname: _wrap_delete_TopoDS_Shell\n  * fulldecl: TopoDS_Shell::~TopoDS_Shell()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_TopoDS_Face (TopoDS_Face *larg1) {
  TopoDS_Face *arg1 = (TopoDS_Face *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopoDS_Face\n  * wrapname: _wrap_delete_TopoDS_Face\n  * fulldecl: TopoDS_Face::~TopoDS_Face()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_TopoDS_Wire (TopoDS_Wire *larg1) {
  TopoDS_Wire *arg1 = (TopoDS_Wire *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopoDS_Wire\n  * wrapname: _wrap_delete_TopoDS_Wire\n  * fulldecl: TopoDS_Wire::~TopoDS_Wire()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_TopoDS_Edge (TopoDS_Edge *larg1) {
  TopoDS_Edge *arg1 = (TopoDS_Edge *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopoDS_Edge\n  * wrapname: _wrap_delete_TopoDS_Edge\n  * fulldecl: TopoDS_Edge::~TopoDS_Edge()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_TopoDS_Vertex (TopoDS_Vertex *larg1) {
  TopoDS_Vertex *arg1 = (TopoDS_Vertex *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopoDS_Vertex\n  * wrapname: _wrap_delete_TopoDS_Vertex\n  * fulldecl: TopoDS_Vertex::~TopoDS_Vertex()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopoDS_Iterator *_wrap_new_TopoDS_Iterator__SWIG_0 () {
  TopoDS_Iterator * lresult = (TopoDS_Iterator *)0 ;
  TopoDS_Iterator *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Iterator *)new TopoDS_Iterator();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TopoDS_Iterator\n  * wrapname: _wrap_new_TopoDS_Iterator__SWIG_0\n  * fulldecl: TopoDS_Iterator::TopoDS_Iterator()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Iterator *)0;
  }
}


EXPORT TopoDS_Iterator *_wrap_new_TopoDS_Iterator__SWIG_1 (TopoDS_Shape *larg1, bool larg2, bool larg3) {
  TopoDS_Iterator * lresult = (TopoDS_Iterator *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Boolean arg2 ;
  Standard_Boolean arg3 ;
  TopoDS_Iterator *result = 0 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Iterator *)new TopoDS_Iterator((TopoDS_Shape const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TopoDS_Iterator\n  * wrapname: _wrap_new_TopoDS_Iterator__SWIG_1\n  * fulldecl: TopoDS_Iterator::TopoDS_Iterator(TopoDS_Shape const &,Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Iterator *)0;
  }
}


EXPORT TopoDS_Iterator *_wrap_new_TopoDS_Iterator__SWIG_2 (TopoDS_Shape *larg1, bool larg2) {
  TopoDS_Iterator * lresult = (TopoDS_Iterator *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Boolean arg2 ;
  TopoDS_Iterator *result = 0 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Iterator *)new TopoDS_Iterator((TopoDS_Shape const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TopoDS_Iterator\n  * wrapname: _wrap_new_TopoDS_Iterator__SWIG_2\n  * fulldecl: TopoDS_Iterator::TopoDS_Iterator(TopoDS_Shape const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Iterator *)0;
  }
}


EXPORT TopoDS_Iterator *_wrap_new_TopoDS_Iterator__SWIG_3 (TopoDS_Shape *larg1) {
  TopoDS_Iterator * lresult = (TopoDS_Iterator *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  TopoDS_Iterator *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Iterator *)new TopoDS_Iterator((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TopoDS_Iterator\n  * wrapname: _wrap_new_TopoDS_Iterator__SWIG_3\n  * fulldecl: TopoDS_Iterator::TopoDS_Iterator(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Iterator *)0;
  }
}


EXPORT void _wrap_TopoDS_Iterator_Initialize__SWIG_0 (TopoDS_Iterator *larg1, TopoDS_Shape *larg2, bool larg3, bool larg4) {
  TopoDS_Iterator *arg1 = (TopoDS_Iterator *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean arg3 ;
  Standard_Boolean arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Initialize((TopoDS_Shape const &)*arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Iterator_Initialize\n  * wrapname: _wrap_TopoDS_Iterator_Initialize__SWIG_0\n  * fulldecl: void TopoDS_Iterator::Initialize(TopoDS_Shape const &,Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopoDS_Iterator_Initialize__SWIG_1 (TopoDS_Iterator *larg1, TopoDS_Shape *larg2, bool larg3) {
  TopoDS_Iterator *arg1 = (TopoDS_Iterator *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Initialize((TopoDS_Shape const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Iterator_Initialize\n  * wrapname: _wrap_TopoDS_Iterator_Initialize__SWIG_1\n  * fulldecl: void TopoDS_Iterator::Initialize(TopoDS_Shape const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopoDS_Iterator_Initialize__SWIG_2 (TopoDS_Iterator *larg1, TopoDS_Shape *larg2) {
  TopoDS_Iterator *arg1 = (TopoDS_Iterator *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Initialize((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Iterator_Initialize\n  * wrapname: _wrap_TopoDS_Iterator_Initialize__SWIG_2\n  * fulldecl: void TopoDS_Iterator::Initialize(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_TopoDS_Iterator_More (TopoDS_Iterator *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Iterator *arg1 = (TopoDS_Iterator *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TopoDS_Iterator const *)arg1)->More();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Iterator_More\n  * wrapname: _wrap_TopoDS_Iterator_More\n  * fulldecl: Standard_Boolean TopoDS_Iterator::More() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_TopoDS_Iterator_Next (TopoDS_Iterator *larg1) {
  TopoDS_Iterator *arg1 = (TopoDS_Iterator *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Next();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Iterator_Next\n  * wrapname: _wrap_TopoDS_Iterator_Next\n  * fulldecl: void TopoDS_Iterator::Next()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopoDS_Shape *_wrap_TopoDS_Iterator_Value (TopoDS_Iterator *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  TopoDS_Iterator *arg1 = (TopoDS_Iterator *) 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &((TopoDS_Iterator const *)arg1)->Value();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Iterator_Value\n  * wrapname: _wrap_TopoDS_Iterator_Value\n  * fulldecl: TopoDS_Shape const & TopoDS_Iterator::Value() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT void _wrap_delete_TopoDS_Iterator (TopoDS_Iterator *larg1) {
  TopoDS_Iterator *arg1 = (TopoDS_Iterator *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopoDS_Iterator\n  * wrapname: _wrap_delete_TopoDS_Iterator\n  * fulldecl: TopoDS_Iterator::~TopoDS_Iterator()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopoDS_Builder_MakeWire (TopoDS_Builder *larg1, TopoDS_Wire *larg2) {
  TopoDS_Builder *arg1 = (TopoDS_Builder *) 0 ;
  TopoDS_Wire *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((TopoDS_Builder const *)arg1)->MakeWire(*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Builder_MakeWire\n  * wrapname: _wrap_TopoDS_Builder_MakeWire\n  * fulldecl: void TopoDS_Builder::MakeWire(TopoDS_Wire &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopoDS_Builder_MakeShell (TopoDS_Builder *larg1, TopoDS_Shell *larg2) {
  TopoDS_Builder *arg1 = (TopoDS_Builder *) 0 ;
  TopoDS_Shell *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((TopoDS_Builder const *)arg1)->MakeShell(*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Builder_MakeShell\n  * wrapname: _wrap_TopoDS_Builder_MakeShell\n  * fulldecl: void TopoDS_Builder::MakeShell(TopoDS_Shell &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopoDS_Builder_MakeSolid (TopoDS_Builder *larg1, TopoDS_Solid *larg2) {
  TopoDS_Builder *arg1 = (TopoDS_Builder *) 0 ;
  TopoDS_Solid *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((TopoDS_Builder const *)arg1)->MakeSolid(*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Builder_MakeSolid\n  * wrapname: _wrap_TopoDS_Builder_MakeSolid\n  * fulldecl: void TopoDS_Builder::MakeSolid(TopoDS_Solid &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopoDS_Builder_MakeCompSolid (TopoDS_Builder *larg1, TopoDS_CompSolid *larg2) {
  TopoDS_Builder *arg1 = (TopoDS_Builder *) 0 ;
  TopoDS_CompSolid *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((TopoDS_Builder const *)arg1)->MakeCompSolid(*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Builder_MakeCompSolid\n  * wrapname: _wrap_TopoDS_Builder_MakeCompSolid\n  * fulldecl: void TopoDS_Builder::MakeCompSolid(TopoDS_CompSolid &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopoDS_Builder_MakeCompound (TopoDS_Builder *larg1, TopoDS_Compound *larg2) {
  TopoDS_Builder *arg1 = (TopoDS_Builder *) 0 ;
  TopoDS_Compound *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((TopoDS_Builder const *)arg1)->MakeCompound(*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Builder_MakeCompound\n  * wrapname: _wrap_TopoDS_Builder_MakeCompound\n  * fulldecl: void TopoDS_Builder::MakeCompound(TopoDS_Compound &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopoDS_Builder_Add (TopoDS_Builder *larg1, TopoDS_Shape *larg2, TopoDS_Shape *larg3) {
  TopoDS_Builder *arg1 = (TopoDS_Builder *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopoDS_Shape *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((TopoDS_Builder const *)arg1)->Add(*arg2,(TopoDS_Shape const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Builder_Add\n  * wrapname: _wrap_TopoDS_Builder_Add\n  * fulldecl: void TopoDS_Builder::Add(TopoDS_Shape &,TopoDS_Shape const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopoDS_Builder_Remove (TopoDS_Builder *larg1, TopoDS_Shape *larg2, TopoDS_Shape *larg3) {
  TopoDS_Builder *arg1 = (TopoDS_Builder *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopoDS_Shape *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((TopoDS_Builder const *)arg1)->Remove(*arg2,(TopoDS_Shape const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopoDS_Builder_Remove\n  * wrapname: _wrap_TopoDS_Builder_Remove\n  * fulldecl: void TopoDS_Builder::Remove(TopoDS_Shape &,TopoDS_Shape const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_TopoDS_Builder (TopoDS_Builder *larg1) {
  TopoDS_Builder *arg1 = (TopoDS_Builder *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopoDS_Builder\n  * wrapname: _wrap_delete_TopoDS_Builder\n  * fulldecl: TopoDS_Builder::~TopoDS_Builder()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <TopTools_HSequenceOfShape.hxx>

EXPORT TopTools_HSequenceOfShape *_wrap_new_TopTools_HSequenceOfShape () {
  TopTools_HSequenceOfShape * lresult = (TopTools_HSequenceOfShape *)0 ;
  TopTools_HSequenceOfShape *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopTools_HSequenceOfShape *)new TopTools_HSequenceOfShape();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TopTools_HSequenceOfShape\n  * wrapname: _wrap_new_TopTools_HSequenceOfShape\n  * fulldecl: TopTools_HSequenceOfShape::TopTools_HSequenceOfShape()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopTools_HSequenceOfShape *)0;
  }
}


EXPORT bool _wrap_TopTools_HSequenceOfShape_IsEmpty (TopTools_HSequenceOfShape *larg1) {
  bool lresult = (bool)0 ;
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TopTools_HSequenceOfShape const *)arg1)->IsEmpty();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_HSequenceOfShape_IsEmpty\n  * wrapname: _wrap_TopTools_HSequenceOfShape_IsEmpty\n  * fulldecl: Standard_Boolean TopTools_HSequenceOfShape::IsEmpty() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Standard_Integer _wrap_TopTools_HSequenceOfShape_Length (TopTools_HSequenceOfShape *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((TopTools_HSequenceOfShape const *)arg1)->Length();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_HSequenceOfShape_Length\n  * wrapname: _wrap_TopTools_HSequenceOfShape_Length\n  * fulldecl: Standard_Integer TopTools_HSequenceOfShape::Length() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT void _wrap_TopTools_HSequenceOfShape_Clear (TopTools_HSequenceOfShape *larg1) {
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Clear();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_HSequenceOfShape_Clear\n  * wrapname: _wrap_TopTools_HSequenceOfShape_Clear\n  * fulldecl: void TopTools_HSequenceOfShape::Clear()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopTools_HSequenceOfShape_Append (TopTools_HSequenceOfShape *larg1, TopoDS_Shape *larg2) {
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Append((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_HSequenceOfShape_Append\n  * wrapname: _wrap_TopTools_HSequenceOfShape_Append\n  * fulldecl: void TopTools_HSequenceOfShape::Append(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopTools_HSequenceOfShape_Prepend (TopTools_HSequenceOfShape *larg1, TopoDS_Shape *larg2) {
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Prepend((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_HSequenceOfShape_Prepend\n  * wrapname: _wrap_TopTools_HSequenceOfShape_Prepend\n  * fulldecl: void TopTools_HSequenceOfShape::Prepend(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopTools_HSequenceOfShape_Reverse (TopTools_HSequenceOfShape *larg1) {
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Reverse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_HSequenceOfShape_Reverse\n  * wrapname: _wrap_TopTools_HSequenceOfShape_Reverse\n  * fulldecl: void TopTools_HSequenceOfShape::Reverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopTools_HSequenceOfShape_InsertBefore (TopTools_HSequenceOfShape *larg1, Standard_Integer larg2, TopoDS_Shape *larg3) {
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  Standard_Integer arg2 ;
  TopoDS_Shape *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->InsertBefore(arg2,(TopoDS_Shape const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_HSequenceOfShape_InsertBefore\n  * wrapname: _wrap_TopTools_HSequenceOfShape_InsertBefore\n  * fulldecl: void TopTools_HSequenceOfShape::InsertBefore(Standard_Integer const,TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopTools_HSequenceOfShape_InsertAfter (TopTools_HSequenceOfShape *larg1, Standard_Integer larg2, TopoDS_Shape *larg3) {
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  Standard_Integer arg2 ;
  TopoDS_Shape *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->InsertAfter(arg2,(TopoDS_Shape const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_HSequenceOfShape_InsertAfter\n  * wrapname: _wrap_TopTools_HSequenceOfShape_InsertAfter\n  * fulldecl: void TopTools_HSequenceOfShape::InsertAfter(Standard_Integer const,TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopTools_HSequenceOfShape_Exchange (TopTools_HSequenceOfShape *larg1, Standard_Integer larg2, Standard_Integer larg3) {
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Exchange(arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_HSequenceOfShape_Exchange\n  * wrapname: _wrap_TopTools_HSequenceOfShape_Exchange\n  * fulldecl: void TopTools_HSequenceOfShape::Exchange(Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopTools_HSequenceOfShape_SetValue (TopTools_HSequenceOfShape *larg1, Standard_Integer larg2, TopoDS_Shape *larg3) {
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  Standard_Integer arg2 ;
  TopoDS_Shape *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetValue(arg2,(TopoDS_Shape const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_HSequenceOfShape_SetValue\n  * wrapname: _wrap_TopTools_HSequenceOfShape_SetValue\n  * fulldecl: void TopTools_HSequenceOfShape::SetValue(Standard_Integer const,TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopoDS_Shape *_wrap_TopTools_HSequenceOfShape_Value (TopTools_HSequenceOfShape *larg1, Standard_Integer larg2) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  Standard_Integer arg2 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &((TopTools_HSequenceOfShape const *)arg1)->Value(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_HSequenceOfShape_Value\n  * wrapname: _wrap_TopTools_HSequenceOfShape_Value\n  * fulldecl: TopoDS_Shape const & TopTools_HSequenceOfShape::Value(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT TopoDS_Shape *_wrap_TopTools_HSequenceOfShape_ChangeValue (TopTools_HSequenceOfShape *larg1, Standard_Integer larg2) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  Standard_Integer arg2 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &(arg1)->ChangeValue(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_HSequenceOfShape_ChangeValue\n  * wrapname: _wrap_TopTools_HSequenceOfShape_ChangeValue\n  * fulldecl: TopoDS_Shape & TopTools_HSequenceOfShape::ChangeValue(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT void _wrap_TopTools_HSequenceOfShape_Remove__SWIG_0 (TopTools_HSequenceOfShape *larg1, Standard_Integer larg2) {
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  Standard_Integer arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Remove(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_HSequenceOfShape_Remove\n  * wrapname: _wrap_TopTools_HSequenceOfShape_Remove__SWIG_0\n  * fulldecl: void TopTools_HSequenceOfShape::Remove(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopTools_HSequenceOfShape_Remove__SWIG_1 (TopTools_HSequenceOfShape *larg1, Standard_Integer larg2, Standard_Integer larg3) {
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Remove(arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_HSequenceOfShape_Remove\n  * wrapname: _wrap_TopTools_HSequenceOfShape_Remove__SWIG_1\n  * fulldecl: void TopTools_HSequenceOfShape::Remove(Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopTools_SequenceOfShape *_wrap_TopTools_HSequenceOfShape_Sequence (TopTools_HSequenceOfShape *larg1) {
  TopTools_SequenceOfShape * lresult = (TopTools_SequenceOfShape *)0 ;
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  TopTools_SequenceOfShape *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopTools_SequenceOfShape *) &((TopTools_HSequenceOfShape const *)arg1)->Sequence();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_HSequenceOfShape_Sequence\n  * wrapname: _wrap_TopTools_HSequenceOfShape_Sequence\n  * fulldecl: TopTools_SequenceOfShape const & TopTools_HSequenceOfShape::Sequence() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopTools_SequenceOfShape *)0;
  }
}


EXPORT void _wrap_delete_TopTools_HSequenceOfShape (TopTools_HSequenceOfShape *larg1) {
  TopTools_HSequenceOfShape *arg1 = (TopTools_HSequenceOfShape *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopTools_HSequenceOfShape\n  * wrapname: _wrap_delete_TopTools_HSequenceOfShape\n  * fulldecl: TopTools_HSequenceOfShape::~TopTools_HSequenceOfShape()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <TopTools_ListOfShape.hxx>

EXPORT TopTools_ListOfShape *_wrap_new_TopTools_ListOfShape () {
  TopTools_ListOfShape * lresult = (TopTools_ListOfShape *)0 ;
  TopTools_ListOfShape *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopTools_ListOfShape *)new TopTools_ListOfShape();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TopTools_ListOfShape\n  * wrapname: _wrap_new_TopTools_ListOfShape\n  * fulldecl: TopTools_ListOfShape::TopTools_ListOfShape()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopTools_ListOfShape *)0;
  }
}


EXPORT TopoDS_Shape *_wrap_TopTools_ListOfShape_Append (TopTools_ListOfShape *larg1, TopoDS_Shape *larg2) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  TopTools_ListOfShape *arg1 = (TopTools_ListOfShape *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &(arg1)->Append((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_ListOfShape_Append\n  * wrapname: _wrap_TopTools_ListOfShape_Append\n  * fulldecl: TopoDS_Shape & TopTools_ListOfShape::Append(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT TopoDS_Shape *_wrap_TopTools_ListOfShape_Prepend (TopTools_ListOfShape *larg1, TopoDS_Shape *larg2) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  TopTools_ListOfShape *arg1 = (TopTools_ListOfShape *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &(arg1)->Prepend((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_ListOfShape_Prepend\n  * wrapname: _wrap_TopTools_ListOfShape_Prepend\n  * fulldecl: TopoDS_Shape & TopTools_ListOfShape::Prepend(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT void _wrap_delete_TopTools_ListOfShape (TopTools_ListOfShape *larg1) {
  TopTools_ListOfShape *arg1 = (TopTools_ListOfShape *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopTools_ListOfShape\n  * wrapname: _wrap_delete_TopTools_ListOfShape\n  * fulldecl: TopTools_ListOfShape::~TopTools_ListOfShape()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



  #include <TopTools_MapOfShape.hxx>
  
EXPORT TopTools_MapOfShape *_wrap_new_TopTools_MapOfShape () {
  TopTools_MapOfShape * lresult = (TopTools_MapOfShape *)0 ;
  TopTools_MapOfShape *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopTools_MapOfShape *)new TopTools_MapOfShape();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TopTools_MapOfShape\n  * wrapname: _wrap_new_TopTools_MapOfShape\n  * fulldecl: TopTools_MapOfShape::TopTools_MapOfShape()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopTools_MapOfShape *)0;
  }
}


EXPORT bool _wrap_TopTools_MapOfShape_Add (TopTools_MapOfShape *larg1, TopoDS_Shape *larg2) {
  bool lresult = (bool)0 ;
  TopTools_MapOfShape *arg1 = (TopTools_MapOfShape *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->Add((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_MapOfShape_Add\n  * wrapname: _wrap_TopTools_MapOfShape_Add\n  * fulldecl: Standard_Boolean TopTools_MapOfShape::Add(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_TopTools_MapOfShape_Contains (TopTools_MapOfShape *larg1, TopoDS_Shape *larg2) {
  bool lresult = (bool)0 ;
  TopTools_MapOfShape *arg1 = (TopTools_MapOfShape *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TopTools_MapOfShape const *)arg1)->Contains((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_MapOfShape_Contains\n  * wrapname: _wrap_TopTools_MapOfShape_Contains\n  * fulldecl: Standard_Boolean TopTools_MapOfShape::Contains(TopoDS_Shape const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_delete_TopTools_MapOfShape (TopTools_MapOfShape *larg1) {
  TopTools_MapOfShape *arg1 = (TopTools_MapOfShape *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopTools_MapOfShape\n  * wrapname: _wrap_delete_TopTools_MapOfShape\n  * fulldecl: TopTools_MapOfShape::~TopTools_MapOfShape()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <TCollection_BasicMapIterator.hxx>
#include <TopTools_MapIteratorOfMapOfShape.hxx>
  
EXPORT bool _wrap_TCollection_BasicMapIterator_More (TCollection_BasicMapIterator *larg1) {
  bool lresult = (bool)0 ;
  TCollection_BasicMapIterator *arg1 = (TCollection_BasicMapIterator *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TCollection_BasicMapIterator const *)arg1)->More();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TCollection_BasicMapIterator_More\n  * wrapname: _wrap_TCollection_BasicMapIterator_More\n  * fulldecl: Standard_Boolean TCollection_BasicMapIterator::More() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_TCollection_BasicMapIterator_Next (TCollection_BasicMapIterator *larg1) {
  TCollection_BasicMapIterator *arg1 = (TCollection_BasicMapIterator *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Next();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TCollection_BasicMapIterator_Next\n  * wrapname: _wrap_TCollection_BasicMapIterator_Next\n  * fulldecl: void TCollection_BasicMapIterator::Next()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_TCollection_BasicMapIterator (TCollection_BasicMapIterator *larg1) {
  TCollection_BasicMapIterator *arg1 = (TCollection_BasicMapIterator *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TCollection_BasicMapIterator\n  * wrapname: _wrap_delete_TCollection_BasicMapIterator\n  * fulldecl: TCollection_BasicMapIterator::~TCollection_BasicMapIterator()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopTools_MapIteratorOfMapOfShape *_wrap_new_TopTools_MapIteratorOfMapOfShape (TopTools_MapOfShape *larg1) {
  TopTools_MapIteratorOfMapOfShape * lresult = (TopTools_MapIteratorOfMapOfShape *)0 ;
  TopTools_MapOfShape *arg1 = 0 ;
  TopTools_MapIteratorOfMapOfShape *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopTools_MapIteratorOfMapOfShape *)new TopTools_MapIteratorOfMapOfShape((TopTools_MapOfShape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TopTools_MapIteratorOfMapOfShape\n  * wrapname: _wrap_new_TopTools_MapIteratorOfMapOfShape\n  * fulldecl: TopTools_MapIteratorOfMapOfShape::TopTools_MapIteratorOfMapOfShape(TopTools_MapOfShape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopTools_MapIteratorOfMapOfShape *)0;
  }
}


EXPORT TopoDS_Shape *_wrap_TopTools_MapIteratorOfMapOfShape_Key (TopTools_MapIteratorOfMapOfShape *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  TopTools_MapIteratorOfMapOfShape *arg1 = (TopTools_MapIteratorOfMapOfShape *) 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &((TopTools_MapIteratorOfMapOfShape const *)arg1)->Key();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopTools_MapIteratorOfMapOfShape_Key\n  * wrapname: _wrap_TopTools_MapIteratorOfMapOfShape_Key\n  * fulldecl: TopoDS_Shape const & TopTools_MapIteratorOfMapOfShape::Key() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT void _wrap_delete_TopTools_MapIteratorOfMapOfShape (TopTools_MapIteratorOfMapOfShape *larg1) {
  TopTools_MapIteratorOfMapOfShape *arg1 = (TopTools_MapIteratorOfMapOfShape *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopTools_MapIteratorOfMapOfShape\n  * wrapname: _wrap_delete_TopTools_MapIteratorOfMapOfShape\n  * fulldecl: TopTools_MapIteratorOfMapOfShape::~TopTools_MapIteratorOfMapOfShape()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <BRep_Tool.hxx>
#include <Geom_Curve.hxx>
#include <BRep_Builder.hxx>
#include <TopoDS_Builder.hxx>
#include <TopLoc_Location.hxx>
#include <Poly_Triangulation.hxx>

EXPORT gp_Pnt const *_wrap_BRep_Tool_Pnt (TopoDS_Vertex *larg1) {
  gp_Pnt const * lresult = (gp_Pnt const *)0 ;
  TopoDS_Vertex *arg1 = 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = BRep_Tool::Pnt((TopoDS_Vertex const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_Pnt\n  * wrapname: _wrap_BRep_Tool_Pnt\n  * fulldecl: gp_Pnt const BRep_Tool::Pnt(TopoDS_Vertex const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt const(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt const *)0;
  }
}


EXPORT gp_Pnt2d *_wrap_BRep_Tool_Parameters (TopoDS_Vertex *larg1, TopoDS_Face *larg2) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  TopoDS_Vertex *arg1 = 0 ;
  TopoDS_Face *arg2 = 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = BRep_Tool::Parameters((TopoDS_Vertex const &)*arg1,(TopoDS_Face const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_Parameters\n  * wrapname: _wrap_BRep_Tool_Parameters\n  * fulldecl: gp_Pnt2d BRep_Tool::Parameters(TopoDS_Vertex const &,TopoDS_Face const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT Standard_Real _wrap_BRep_Tool_Parameter (TopoDS_Vertex *larg1, TopoDS_Edge *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  TopoDS_Vertex *arg1 = 0 ;
  TopoDS_Edge *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)BRep_Tool::Parameter((TopoDS_Vertex const &)*arg1,(TopoDS_Edge const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_Parameter\n  * wrapname: _wrap_BRep_Tool_Parameter\n  * fulldecl: Standard_Real BRep_Tool::Parameter(TopoDS_Vertex const &,TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT bool _wrap_BRep_Tool_Degenerated (TopoDS_Edge *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Edge *arg1 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRep_Tool::Degenerated((TopoDS_Edge const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_Degenerated\n  * wrapname: _wrap_BRep_Tool_Degenerated\n  * fulldecl: Standard_Boolean BRep_Tool::Degenerated(TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRep_Tool_SameParameter (TopoDS_Edge *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Edge *arg1 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRep_Tool::SameParameter((TopoDS_Edge const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_SameParameter\n  * wrapname: _wrap_BRep_Tool_SameParameter\n  * fulldecl: Standard_Boolean BRep_Tool::SameParameter(TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRep_Tool_SameRange (TopoDS_Edge *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Edge *arg1 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRep_Tool::SameRange((TopoDS_Edge const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_SameRange\n  * wrapname: _wrap_BRep_Tool_SameRange\n  * fulldecl: Standard_Boolean BRep_Tool::SameRange(TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRep_Tool_HasContinuity (TopoDS_Edge *larg1, TopoDS_Face *larg2, TopoDS_Face *larg3) {
  bool lresult = (bool)0 ;
  TopoDS_Edge *arg1 = 0 ;
  TopoDS_Face *arg2 = 0 ;
  TopoDS_Face *arg3 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRep_Tool::HasContinuity((TopoDS_Edge const &)*arg1,(TopoDS_Face const &)*arg2,(TopoDS_Face const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_HasContinuity\n  * wrapname: _wrap_BRep_Tool_HasContinuity\n  * fulldecl: Standard_Boolean BRep_Tool::HasContinuity(TopoDS_Edge const &,TopoDS_Face const &,TopoDS_Face const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT GeomAbs_Shape _wrap_BRep_Tool_Continuity (TopoDS_Edge *larg1, TopoDS_Face *larg2, TopoDS_Face *larg3) {
  GeomAbs_Shape lresult = (GeomAbs_Shape)0 ;
  TopoDS_Edge *arg1 = 0 ;
  TopoDS_Face *arg2 = 0 ;
  TopoDS_Face *arg3 = 0 ;
  GeomAbs_Shape result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAbs_Shape)BRep_Tool::Continuity((TopoDS_Edge const &)*arg1,(TopoDS_Face const &)*arg2,(TopoDS_Face const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_Continuity\n  * wrapname: _wrap_BRep_Tool_Continuity\n  * fulldecl: GeomAbs_Shape BRep_Tool::Continuity(TopoDS_Edge const &,TopoDS_Face const &,TopoDS_Face const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAbs_Shape)0;
  }
}


EXPORT Standard_Real _wrap_BRep_Tool_Tolerance__SWIG_0 (TopoDS_Face *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  TopoDS_Face *arg1 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)BRep_Tool::Tolerance((TopoDS_Face const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_Tolerance\n  * wrapname: _wrap_BRep_Tool_Tolerance__SWIG_0\n  * fulldecl: Standard_Real BRep_Tool::Tolerance(TopoDS_Face const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_BRep_Tool_Tolerance__SWIG_1 (TopoDS_Edge *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  TopoDS_Edge *arg1 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)BRep_Tool::Tolerance((TopoDS_Edge const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_Tolerance\n  * wrapname: _wrap_BRep_Tool_Tolerance__SWIG_1\n  * fulldecl: Standard_Real BRep_Tool::Tolerance(TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_BRep_Tool_Tolerance__SWIG_2 (TopoDS_Vertex *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  TopoDS_Vertex *arg1 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)BRep_Tool::Tolerance((TopoDS_Vertex const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_Tolerance\n  * wrapname: _wrap_BRep_Tool_Tolerance__SWIG_2\n  * fulldecl: Standard_Real BRep_Tool::Tolerance(TopoDS_Vertex const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT bool _wrap_BRep_Tool_IsClosed (TopoDS_Shape *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRep_Tool::IsClosed((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_IsClosed\n  * wrapname: _wrap_BRep_Tool_IsClosed\n  * fulldecl: Standard_Boolean BRep_Tool::IsClosed(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Handle_Poly_Triangulation *_wrap_BRep_Tool_Triangulation (TopoDS_Face *larg1, TopLoc_Location *larg2) {
  Handle_Poly_Triangulation * lresult = (Handle_Poly_Triangulation *)0 ;
  TopoDS_Face *arg1 = 0 ;
  TopLoc_Location *arg2 = 0 ;
  Handle_Poly_Triangulation *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Poly_Triangulation *) &BRep_Tool::Triangulation((TopoDS_Face const &)*arg1,*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_Triangulation\n  * wrapname: _wrap_BRep_Tool_Triangulation\n  * fulldecl: Handle_Poly_Triangulation const & BRep_Tool::Triangulation(TopoDS_Face const &,TopLoc_Location &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Poly_Triangulation *)0;
  }
}


SWIGINTERN Poly_Polygon3D *BRep_Tool_Polygon3D(TopoDS_Edge const &E,TopLoc_Location &L){
	  Handle_Poly_Polygon3D hgc=BRep_Tool::Polygon3D(E,L);
	  if (hgc.IsNull())
	    return NULL;
	  else
	    return (Poly_Polygon3D *)hgc.get();
	}
EXPORT Poly_Polygon3D *_wrap_BRep_Tool_Polygon3D (TopoDS_Edge *larg1, TopLoc_Location *larg2) {
  Poly_Polygon3D * lresult = (Poly_Polygon3D *)0 ;
  TopoDS_Edge *arg1 = 0 ;
  TopLoc_Location *arg2 = 0 ;
  Poly_Polygon3D *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Poly_Polygon3D *)BRep_Tool_Polygon3D((TopoDS_Edge const &)*arg1,*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_Polygon3D\n  * wrapname: _wrap_BRep_Tool_Polygon3D\n  * fulldecl: Poly_Polygon3D * BRep_Tool::BRep_Tool_Polygon3D(TopoDS_Edge const &,TopLoc_Location &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Poly_Polygon3D *)0;
  }
}


SWIGINTERN void BRep_Tool_range(TopoDS_Edge const &E,double range[2]){
		BRep_Tool::Range(E, range[0], range[1]);
	}
EXPORT void _wrap_BRep_Tool_range (TopoDS_Edge *larg1, double *larg2) {
  TopoDS_Edge *arg1 = 0 ;
  double *arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRep_Tool_range((TopoDS_Edge const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_range\n  * wrapname: _wrap_BRep_Tool_range\n  * fulldecl: void BRep_Tool::BRep_Tool_range(TopoDS_Edge const &,double [2])";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom_Curve *BRep_Tool_curve(TopoDS_Edge const &E,Standard_Real &First,Standard_Real &Last){
		Handle_Geom_Curve * hgc=new Handle_Geom_Curve(BRep_Tool::Curve(E, First, Last));
		if(hgc->IsNull())
			return NULL;
		else
			return hgc;
	}
EXPORT Handle_Geom_Curve *_wrap_BRep_Tool_curve (TopoDS_Edge *larg1, Standard_Real *larg2, Standard_Real *larg3) {
  Handle_Geom_Curve * lresult = (Handle_Geom_Curve *)0 ;
  TopoDS_Edge *arg1 = 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Handle_Geom_Curve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_Curve *)BRep_Tool_curve((TopoDS_Edge const &)*arg1,*arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_curve\n  * wrapname: _wrap_BRep_Tool_curve\n  * fulldecl: Handle_Geom_Curve * BRep_Tool::BRep_Tool_curve(TopoDS_Edge const &,Standard_Real &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_Curve *)0;
  }
}


SWIGINTERN Handle_Geom_Surface *BRep_Tool_surface(TopoDS_Face const &F){
		Handle_Geom_Surface * hgc=new Handle_Geom_Surface(BRep_Tool::Surface(F));
		if(hgc->IsNull())
			return NULL;
		else
			return hgc;
	}
EXPORT Handle_Geom_Surface *_wrap_BRep_Tool_surface (TopoDS_Face *larg1) {
  Handle_Geom_Surface * lresult = (Handle_Geom_Surface *)0 ;
  TopoDS_Face *arg1 = 0 ;
  Handle_Geom_Surface *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_Surface *)BRep_Tool_surface((TopoDS_Face const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_surface\n  * wrapname: _wrap_BRep_Tool_surface\n  * fulldecl: Handle_Geom_Surface * BRep_Tool::BRep_Tool_surface(TopoDS_Face const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_Surface *)0;
  }
}


SWIGINTERN Handle_Geom2d_Curve *BRep_Tool_curveOnSurface(TopoDS_Edge const &E,TopoDS_Face const &F,Standard_Real &First,Standard_Real &Last){
		Handle_Geom2d_Curve * hgc=new Handle_Geom2d_Curve(BRep_Tool::CurveOnSurface(E, F, First, Last));
		if(hgc->IsNull())
			return NULL;
		else
			return hgc;
	}
EXPORT Handle_Geom2d_Curve *_wrap_BRep_Tool_curveOnSurface (TopoDS_Edge *larg1, TopoDS_Face *larg2, Standard_Real *larg3, Standard_Real *larg4) {
  Handle_Geom2d_Curve * lresult = (Handle_Geom2d_Curve *)0 ;
  TopoDS_Edge *arg1 = 0 ;
  TopoDS_Face *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  Handle_Geom2d_Curve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Curve *)BRep_Tool_curveOnSurface((TopoDS_Edge const &)*arg1,(TopoDS_Face const &)*arg2,*arg3,*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_curveOnSurface\n  * wrapname: _wrap_BRep_Tool_curveOnSurface\n  * fulldecl: Handle_Geom2d_Curve * BRep_Tool::BRep_Tool_curveOnSurface(TopoDS_Edge const &,TopoDS_Face const &,Standard_Real &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Curve *)0;
  }
}


SWIGINTERN Poly_PolygonOnTriangulation *BRep_Tool_PolygonOnTriangulation(TopoDS_Edge const &E,Handle_Poly_Triangulation const &T,TopLoc_Location const &L){
	  Handle_Poly_PolygonOnTriangulation hgc=BRep_Tool::PolygonOnTriangulation(E, T, L);
	  if (hgc.IsNull())
	    return (Poly_PolygonOnTriangulation *)NULL;
	  else
	    return (Poly_PolygonOnTriangulation *)hgc.get();
	}
EXPORT Poly_PolygonOnTriangulation *_wrap_BRep_Tool_PolygonOnTriangulation (TopoDS_Edge *larg1, Handle_Poly_Triangulation *larg2, TopLoc_Location *larg3) {
  Poly_PolygonOnTriangulation * lresult = (Poly_PolygonOnTriangulation *)0 ;
  TopoDS_Edge *arg1 = 0 ;
  Handle_Poly_Triangulation *arg2 = 0 ;
  TopLoc_Location *arg3 = 0 ;
  Poly_PolygonOnTriangulation *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Poly_PolygonOnTriangulation *)BRep_Tool_PolygonOnTriangulation((TopoDS_Edge const &)*arg1,(Handle_Poly_Triangulation const &)*arg2,(TopLoc_Location const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Tool_PolygonOnTriangulation\n  * wrapname: _wrap_BRep_Tool_PolygonOnTriangulation\n  * fulldecl: Poly_PolygonOnTriangulation * BRep_Tool::BRep_Tool_PolygonOnTriangulation(TopoDS_Edge const &,Handle_Poly_Triangulation const &,TopLoc_Location const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Poly_PolygonOnTriangulation *)0;
  }
}


EXPORT void _wrap_delete_BRep_Tool (BRep_Tool *larg1) {
  BRep_Tool *arg1 = (BRep_Tool *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRep_Tool\n  * wrapname: _wrap_delete_BRep_Tool\n  * fulldecl: BRep_Tool::~BRep_Tool()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRep_Builder *_wrap_new_BRep_Builder () {
  BRep_Builder * lresult = (BRep_Builder *)0 ;
  BRep_Builder *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRep_Builder *)new BRep_Builder();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRep_Builder\n  * wrapname: _wrap_new_BRep_Builder\n  * fulldecl: BRep_Builder::BRep_Builder()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRep_Builder *)0;
  }
}


EXPORT void _wrap_BRep_Builder_MakeFace__SWIG_0 (BRep_Builder *larg1, TopoDS_Face *larg2) {
  BRep_Builder *arg1 = (BRep_Builder *) 0 ;
  TopoDS_Face *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRep_Builder const *)arg1)->MakeFace(*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Builder_MakeFace\n  * wrapname: _wrap_BRep_Builder_MakeFace__SWIG_0\n  * fulldecl: void BRep_Builder::MakeFace(TopoDS_Face &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRep_Builder_MakeFace__SWIG_1 (BRep_Builder *larg1, TopoDS_Face *larg2, Handle_Geom_Surface *larg3, Standard_Real larg4) {
  BRep_Builder *arg1 = (BRep_Builder *) 0 ;
  TopoDS_Face *arg2 = 0 ;
  Handle_Geom_Surface *arg3 = 0 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRep_Builder const *)arg1)->MakeFace(*arg2,(Handle_Geom_Surface const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Builder_MakeFace\n  * wrapname: _wrap_BRep_Builder_MakeFace__SWIG_1\n  * fulldecl: void BRep_Builder::MakeFace(TopoDS_Face &,Handle_Geom_Surface const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRep_Builder_MakeFace__SWIG_2 (BRep_Builder *larg1, TopoDS_Face *larg2, Handle_Geom_Surface *larg3, TopLoc_Location *larg4, Standard_Real larg5) {
  BRep_Builder *arg1 = (BRep_Builder *) 0 ;
  TopoDS_Face *arg2 = 0 ;
  Handle_Geom_Surface *arg3 = 0 ;
  TopLoc_Location *arg4 = 0 ;
  Standard_Real arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRep_Builder const *)arg1)->MakeFace(*arg2,(Handle_Geom_Surface const &)*arg3,(TopLoc_Location const &)*arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Builder_MakeFace\n  * wrapname: _wrap_BRep_Builder_MakeFace__SWIG_2\n  * fulldecl: void BRep_Builder::MakeFace(TopoDS_Face &,Handle_Geom_Surface const &,TopLoc_Location const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRep_Builder_MakeEdge__SWIG_0 (BRep_Builder *larg1, TopoDS_Edge *larg2) {
  BRep_Builder *arg1 = (BRep_Builder *) 0 ;
  TopoDS_Edge *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRep_Builder const *)arg1)->MakeEdge(*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Builder_MakeEdge\n  * wrapname: _wrap_BRep_Builder_MakeEdge__SWIG_0\n  * fulldecl: void BRep_Builder::MakeEdge(TopoDS_Edge &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRep_Builder_MakeEdge__SWIG_1 (BRep_Builder *larg1, TopoDS_Edge *larg2, Handle_Geom_Curve *larg3, Standard_Real larg4) {
  BRep_Builder *arg1 = (BRep_Builder *) 0 ;
  TopoDS_Edge *arg2 = 0 ;
  Handle_Geom_Curve *arg3 = 0 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRep_Builder const *)arg1)->MakeEdge(*arg2,(Handle_Geom_Curve const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Builder_MakeEdge\n  * wrapname: _wrap_BRep_Builder_MakeEdge__SWIG_1\n  * fulldecl: void BRep_Builder::MakeEdge(TopoDS_Edge &,Handle_Geom_Curve const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRep_Builder_MakeEdge__SWIG_2 (BRep_Builder *larg1, TopoDS_Edge *larg2, Handle_Geom_Curve *larg3, TopLoc_Location *larg4, Standard_Real larg5) {
  BRep_Builder *arg1 = (BRep_Builder *) 0 ;
  TopoDS_Edge *arg2 = 0 ;
  Handle_Geom_Curve *arg3 = 0 ;
  TopLoc_Location *arg4 = 0 ;
  Standard_Real arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRep_Builder const *)arg1)->MakeEdge(*arg2,(Handle_Geom_Curve const &)*arg3,(TopLoc_Location const &)*arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Builder_MakeEdge\n  * wrapname: _wrap_BRep_Builder_MakeEdge__SWIG_2\n  * fulldecl: void BRep_Builder::MakeEdge(TopoDS_Edge &,Handle_Geom_Curve const &,TopLoc_Location const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRep_Builder_UpdateEdge__SWIG_0 (BRep_Builder *larg1, TopoDS_Edge *larg2, Handle_Geom_Curve *larg3, Standard_Real larg4) {
  BRep_Builder *arg1 = (BRep_Builder *) 0 ;
  TopoDS_Edge *arg2 = 0 ;
  Handle_Geom_Curve *arg3 = 0 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRep_Builder const *)arg1)->UpdateEdge((TopoDS_Edge const &)*arg2,(Handle_Geom_Curve const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Builder_UpdateEdge\n  * wrapname: _wrap_BRep_Builder_UpdateEdge__SWIG_0\n  * fulldecl: void BRep_Builder::UpdateEdge(TopoDS_Edge const &,Handle_Geom_Curve const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRep_Builder_UpdateEdge__SWIG_1 (BRep_Builder *larg1, TopoDS_Edge *larg2, Handle_Geom2d_Curve *larg3, TopoDS_Face *larg4, Standard_Real larg5) {
  BRep_Builder *arg1 = (BRep_Builder *) 0 ;
  TopoDS_Edge *arg2 = 0 ;
  Handle_Geom2d_Curve *arg3 = 0 ;
  TopoDS_Face *arg4 = 0 ;
  Standard_Real arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRep_Builder const *)arg1)->UpdateEdge((TopoDS_Edge const &)*arg2,(Handle_Geom2d_Curve const &)*arg3,(TopoDS_Face const &)*arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Builder_UpdateEdge\n  * wrapname: _wrap_BRep_Builder_UpdateEdge__SWIG_1\n  * fulldecl: void BRep_Builder::UpdateEdge(TopoDS_Edge const &,Handle_Geom2d_Curve const &,TopoDS_Face const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRep_Builder_UpdateEdge__SWIG_2 (BRep_Builder *larg1, TopoDS_Edge *larg2, Handle_Geom2d_Curve *larg3, Handle_Geom2d_Curve *larg4, TopoDS_Face *larg5, Standard_Real larg6) {
  BRep_Builder *arg1 = (BRep_Builder *) 0 ;
  TopoDS_Edge *arg2 = 0 ;
  Handle_Geom2d_Curve *arg3 = 0 ;
  Handle_Geom2d_Curve *arg4 = 0 ;
  TopoDS_Face *arg5 = 0 ;
  Standard_Real arg6 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRep_Builder const *)arg1)->UpdateEdge((TopoDS_Edge const &)*arg2,(Handle_Geom2d_Curve const &)*arg3,(Handle_Geom2d_Curve const &)*arg4,(TopoDS_Face const &)*arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Builder_UpdateEdge\n  * wrapname: _wrap_BRep_Builder_UpdateEdge__SWIG_2\n  * fulldecl: void BRep_Builder::UpdateEdge(TopoDS_Edge const &,Handle_Geom2d_Curve const &,Handle_Geom2d_Curve const &,TopoDS_Face const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRep_Builder_MakeVertex__SWIG_0 (BRep_Builder *larg1, TopoDS_Vertex *larg2) {
  BRep_Builder *arg1 = (BRep_Builder *) 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRep_Builder const *)arg1)->MakeVertex(*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Builder_MakeVertex\n  * wrapname: _wrap_BRep_Builder_MakeVertex__SWIG_0\n  * fulldecl: void BRep_Builder::MakeVertex(TopoDS_Vertex &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRep_Builder_MakeVertex__SWIG_1 (BRep_Builder *larg1, TopoDS_Vertex *larg2, gp_Pnt *larg3, Standard_Real larg4) {
  BRep_Builder *arg1 = (BRep_Builder *) 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRep_Builder const *)arg1)->MakeVertex(*arg2,(gp_Pnt const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Builder_MakeVertex\n  * wrapname: _wrap_BRep_Builder_MakeVertex__SWIG_1\n  * fulldecl: void BRep_Builder::MakeVertex(TopoDS_Vertex &,gp_Pnt const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRep_Builder_UpdateVertex__SWIG_0 (BRep_Builder *larg1, TopoDS_Vertex *larg2, Standard_Real larg3, Standard_Real larg4, TopoDS_Face *larg5, Standard_Real larg6) {
  BRep_Builder *arg1 = (BRep_Builder *) 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  TopoDS_Face *arg5 = 0 ;
  Standard_Real arg6 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRep_Builder const *)arg1)->UpdateVertex((TopoDS_Vertex const &)*arg2,arg3,arg4,(TopoDS_Face const &)*arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Builder_UpdateVertex\n  * wrapname: _wrap_BRep_Builder_UpdateVertex__SWIG_0\n  * fulldecl: void BRep_Builder::UpdateVertex(TopoDS_Vertex const &,Standard_Real const,Standard_Real const,TopoDS_Face const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRep_Builder_UpdateVertex__SWIG_1 (BRep_Builder *larg1, TopoDS_Vertex *larg2, Standard_Real larg3) {
  BRep_Builder *arg1 = (BRep_Builder *) 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRep_Builder const *)arg1)->UpdateVertex((TopoDS_Vertex const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Builder_UpdateVertex\n  * wrapname: _wrap_BRep_Builder_UpdateVertex__SWIG_1\n  * fulldecl: void BRep_Builder::UpdateVertex(TopoDS_Vertex const &,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRep_Builder_Degenerated (BRep_Builder *larg1, TopoDS_Edge *larg2, bool larg3) {
  BRep_Builder *arg1 = (BRep_Builder *) 0 ;
  TopoDS_Edge *arg2 = 0 ;
  Standard_Boolean arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRep_Builder const *)arg1)->Degenerated((TopoDS_Edge const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRep_Builder_Degenerated\n  * wrapname: _wrap_BRep_Builder_Degenerated\n  * fulldecl: void BRep_Builder::Degenerated(TopoDS_Edge const &,Standard_Boolean const) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_BRep_Builder (BRep_Builder *larg1) {
  BRep_Builder *arg1 = (BRep_Builder *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRep_Builder\n  * wrapname: _wrap_delete_BRep_Builder\n  * fulldecl: BRep_Builder::~BRep_Builder()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include "GeomLProp_SLProps.hxx"
SWIGINTERN void GeomLProp_SLProps_normal(GeomLProp_SLProps *self,double normal[3]){
		if(!self->IsNormalDefined())
		{
			normal[0]=0;
			normal[1]=0;
			normal[2]=0;
		}
		else
		{
			const gp_Dir & d=self->Normal();
			normal[0]=d.X();
			normal[1]=d.Y();
			normal[2]=d.Z();
		}
	}
EXPORT void _wrap_GeomLProp_SLProps_normal (GeomLProp_SLProps *larg1, double *larg2) {
  GeomLProp_SLProps *arg1 = (GeomLProp_SLProps *) 0 ;
  double *arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        GeomLProp_SLProps_normal(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomLProp_SLProps_normal\n  * wrapname: _wrap_GeomLProp_SLProps_normal\n  * fulldecl: void GeomLProp_SLProps::normal(double [3])";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void GeomLProp_SLProps_normalArray(GeomLProp_SLProps *self,double *uvNodes,double *normalArray,int numNodes){
		for(int i=0;i<numNodes;i++)
		{
			self->SetParameters(uvNodes[2*i],uvNodes[2*i+1]);
			
			if(!self->IsNormalDefined())
			{
				normalArray[3*i]=0;
				normalArray[3*i+1]=0;
				normalArray[3*i+2]=0;
			}
			else
			{
				const gp_Dir & d=self->Normal();
				
				normalArray[3*i]=d.X();
				normalArray[3*i+1]=d.Y();
				normalArray[3*i+2]=d.Z();
			}
		}
	}
EXPORT void _wrap_GeomLProp_SLProps_normalArray (GeomLProp_SLProps *larg1, double *larg2, double *larg3, int larg4) {
  GeomLProp_SLProps *arg1 = (GeomLProp_SLProps *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        GeomLProp_SLProps_normalArray(arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomLProp_SLProps_normalArray\n  * wrapname: _wrap_GeomLProp_SLProps_normalArray\n  * fulldecl: void GeomLProp_SLProps::normalArray(double *,double *,int)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real GeomLProp_SLProps_minCurvature(GeomLProp_SLProps *self){
		if (!self->IsCurvatureDefined())
			return sqrt(-1.0);
		else
			return self->MinCurvature ();
	}
EXPORT Standard_Real _wrap_GeomLProp_SLProps_minCurvature (GeomLProp_SLProps *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  GeomLProp_SLProps *arg1 = (GeomLProp_SLProps *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)GeomLProp_SLProps_minCurvature(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomLProp_SLProps_minCurvature\n  * wrapname: _wrap_GeomLProp_SLProps_minCurvature\n  * fulldecl: Standard_Real GeomLProp_SLProps::minCurvature()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real GeomLProp_SLProps_maxCurvature(GeomLProp_SLProps *self){
		if (!self->IsCurvatureDefined())
			return sqrt(-1.0);
		else
			return self->MaxCurvature ();
	}
EXPORT Standard_Real _wrap_GeomLProp_SLProps_maxCurvature (GeomLProp_SLProps *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  GeomLProp_SLProps *arg1 = (GeomLProp_SLProps *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)GeomLProp_SLProps_maxCurvature(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomLProp_SLProps_maxCurvature\n  * wrapname: _wrap_GeomLProp_SLProps_maxCurvature\n  * fulldecl: Standard_Real GeomLProp_SLProps::maxCurvature()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN void GeomLProp_SLProps_curvatureDirection(GeomLProp_SLProps *self,double jmax[3],double jmin[3]){
		gp_Dir max, min;
		self->CurvatureDirections(max, min);
		jmax[0]=max.X();
		jmax[1]=max.Y();
		jmax[2]=max.Z();
		jmin[0]=min.X();
		jmin[1]=min.Y();
		jmin[2]=min.Z();
	}
EXPORT void _wrap_GeomLProp_SLProps_curvatureDirection (GeomLProp_SLProps *larg1, double *larg2, double *larg3) {
  GeomLProp_SLProps *arg1 = (GeomLProp_SLProps *) 0 ;
  double *arg2 ;
  double *arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        GeomLProp_SLProps_curvatureDirection(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomLProp_SLProps_curvatureDirection\n  * wrapname: _wrap_GeomLProp_SLProps_curvatureDirection\n  * fulldecl: void GeomLProp_SLProps::curvatureDirection(double [3],double [3])";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_GeomLProp_SLProps (GeomLProp_SLProps *larg1) {
  GeomLProp_SLProps *arg1 = (GeomLProp_SLProps *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_GeomLProp_SLProps\n  * wrapname: _wrap_delete_GeomLProp_SLProps\n  * fulldecl: GeomLProp_SLProps::~GeomLProp_SLProps()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <BRepTools.hxx>
#include <BRepTools_ShapeSet.hxx>    

EXPORT bool _wrap_BRepTools_read__SWIG_0 (TopoDS_Shape *larg1, Standard_CString larg2, BRep_Builder *larg3) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_CString arg2 = (Standard_CString) (Standard_CString)0 ;
  BRep_Builder *arg3 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepTools::Read(*arg1,(char const *)arg2,(BRep_Builder const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_read\n  * wrapname: _wrap_BRepTools_read__SWIG_0\n  * fulldecl: Standard_Boolean BRepTools::Read(TopoDS_Shape &,Standard_CString const,BRep_Builder const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepTools_write__SWIG_0 (TopoDS_Shape *larg1, Standard_CString larg2) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_CString arg2 = (Standard_CString) (Standard_CString)0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepTools::Write((TopoDS_Shape const &)*arg1,(char const *)arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_write\n  * wrapname: _wrap_BRepTools_write__SWIG_0\n  * fulldecl: Standard_Boolean BRepTools::Write(TopoDS_Shape const &,Standard_CString const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_BRepTools_write__SWIG_1 (TopoDS_Shape *larg1, Standard_OStream *larg2) {
  TopoDS_Shape *arg1 = 0 ;
  Standard_OStream *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepTools::Write((TopoDS_Shape const &)*arg1,*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_write\n  * wrapname: _wrap_BRepTools_write__SWIG_1\n  * fulldecl: void BRepTools::Write(TopoDS_Shape const &,Standard_OStream &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepTools_clean (TopoDS_Shape *larg1) {
  TopoDS_Shape *arg1 = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepTools::Clean((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_clean\n  * wrapname: _wrap_BRepTools_clean\n  * fulldecl: void BRepTools::Clean(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopoDS_Wire *_wrap_BRepTools_getOuterWire (TopoDS_Face *larg1) {
  TopoDS_Wire * lresult = (TopoDS_Wire *)0 ;
  TopoDS_Face *arg1 = 0 ;
  TopoDS_Wire result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = BRepTools::OuterWire((TopoDS_Face const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_getOuterWire\n  * wrapname: _wrap_BRepTools_getOuterWire\n  * fulldecl: TopoDS_Wire BRepTools::OuterWire(TopoDS_Face const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new TopoDS_Wire(result);
    return lresult;
  } catch (...) {
    return (TopoDS_Wire *)0;
  }
}


SWIGINTERN Standard_Boolean BRepTools_read__SWIG_1(TopoDS_Shape &shape,Standard_IStream &input,BRep_Builder const &builder){
		BRepTools_ShapeSet SS(builder);
		SS.Read(input);
		if(!SS.NbShapes()) return Standard_False;
		SS.Read(shape,input);
		return Standard_True;
	}
EXPORT bool _wrap_BRepTools_read__SWIG_1 (TopoDS_Shape *larg1, Standard_IStream *larg2, BRep_Builder *larg3) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_IStream *arg2 = 0 ;
  BRep_Builder *arg3 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepTools_read__SWIG_1(*arg1,*arg2,(BRep_Builder const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_read\n  * wrapname: _wrap_BRepTools_read__SWIG_1\n  * fulldecl: Standard_Boolean BRepTools::BRepTools_read__SWIG_1(TopoDS_Shape &,Standard_IStream &,BRep_Builder const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_delete_BRepTools (BRepTools *larg1) {
  BRepTools *arg1 = (BRepTools *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepTools\n  * wrapname: _wrap_delete_BRepTools\n  * fulldecl: BRepTools::~BRepTools()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <BRepTools_WireExplorer.hxx>
  
EXPORT BRepTools_WireExplorer *_wrap_new_BRepTools_WireExplorer__SWIG_0 () {
  BRepTools_WireExplorer * lresult = (BRepTools_WireExplorer *)0 ;
  BRepTools_WireExplorer *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepTools_WireExplorer *)new BRepTools_WireExplorer();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepTools_WireExplorer\n  * wrapname: _wrap_new_BRepTools_WireExplorer__SWIG_0\n  * fulldecl: BRepTools_WireExplorer::BRepTools_WireExplorer()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepTools_WireExplorer *)0;
  }
}


EXPORT BRepTools_WireExplorer *_wrap_new_BRepTools_WireExplorer__SWIG_1 (TopoDS_Wire *larg1) {
  BRepTools_WireExplorer * lresult = (BRepTools_WireExplorer *)0 ;
  TopoDS_Wire *arg1 = 0 ;
  BRepTools_WireExplorer *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepTools_WireExplorer *)new BRepTools_WireExplorer((TopoDS_Wire const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepTools_WireExplorer\n  * wrapname: _wrap_new_BRepTools_WireExplorer__SWIG_1\n  * fulldecl: BRepTools_WireExplorer::BRepTools_WireExplorer(TopoDS_Wire const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepTools_WireExplorer *)0;
  }
}


EXPORT BRepTools_WireExplorer *_wrap_new_BRepTools_WireExplorer__SWIG_2 (TopoDS_Wire *larg1, TopoDS_Face *larg2) {
  BRepTools_WireExplorer * lresult = (BRepTools_WireExplorer *)0 ;
  TopoDS_Wire *arg1 = 0 ;
  TopoDS_Face *arg2 = 0 ;
  BRepTools_WireExplorer *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepTools_WireExplorer *)new BRepTools_WireExplorer((TopoDS_Wire const &)*arg1,(TopoDS_Face const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepTools_WireExplorer\n  * wrapname: _wrap_new_BRepTools_WireExplorer__SWIG_2\n  * fulldecl: BRepTools_WireExplorer::BRepTools_WireExplorer(TopoDS_Wire const &,TopoDS_Face const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepTools_WireExplorer *)0;
  }
}


EXPORT void _wrap_BRepTools_WireExplorer_init__SWIG_0 (BRepTools_WireExplorer *larg1, TopoDS_Wire *larg2) {
  BRepTools_WireExplorer *arg1 = (BRepTools_WireExplorer *) 0 ;
  TopoDS_Wire *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init((TopoDS_Wire const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_WireExplorer_init\n  * wrapname: _wrap_BRepTools_WireExplorer_init__SWIG_0\n  * fulldecl: void BRepTools_WireExplorer::Init(TopoDS_Wire const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepTools_WireExplorer_init__SWIG_1 (BRepTools_WireExplorer *larg1, TopoDS_Wire *larg2, TopoDS_Face *larg3) {
  BRepTools_WireExplorer *arg1 = (BRepTools_WireExplorer *) 0 ;
  TopoDS_Wire *arg2 = 0 ;
  TopoDS_Face *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init((TopoDS_Wire const &)*arg2,(TopoDS_Face const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_WireExplorer_init\n  * wrapname: _wrap_BRepTools_WireExplorer_init__SWIG_1\n  * fulldecl: void BRepTools_WireExplorer::Init(TopoDS_Wire const &,TopoDS_Face const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_BRepTools_WireExplorer_more (BRepTools_WireExplorer *larg1) {
  bool lresult = (bool)0 ;
  BRepTools_WireExplorer *arg1 = (BRepTools_WireExplorer *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepTools_WireExplorer const *)arg1)->More();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_WireExplorer_more\n  * wrapname: _wrap_BRepTools_WireExplorer_more\n  * fulldecl: Standard_Boolean BRepTools_WireExplorer::More() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_BRepTools_WireExplorer_next (BRepTools_WireExplorer *larg1) {
  BRepTools_WireExplorer *arg1 = (BRepTools_WireExplorer *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Next();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_WireExplorer_next\n  * wrapname: _wrap_BRepTools_WireExplorer_next\n  * fulldecl: void BRepTools_WireExplorer::Next()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopoDS_Edge *_wrap_BRepTools_WireExplorer_current (BRepTools_WireExplorer *larg1) {
  TopoDS_Edge * lresult = (TopoDS_Edge *)0 ;
  BRepTools_WireExplorer *arg1 = (BRepTools_WireExplorer *) 0 ;
  TopoDS_Edge *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Edge *) &((BRepTools_WireExplorer const *)arg1)->Current();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_WireExplorer_current\n  * wrapname: _wrap_BRepTools_WireExplorer_current\n  * fulldecl: TopoDS_Edge const & BRepTools_WireExplorer::Current() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Edge *)0;
  }
}


EXPORT TopAbs_Orientation _wrap_BRepTools_WireExplorer_orientation (BRepTools_WireExplorer *larg1) {
  TopAbs_Orientation lresult = (TopAbs_Orientation)0 ;
  BRepTools_WireExplorer *arg1 = (BRepTools_WireExplorer *) 0 ;
  TopAbs_Orientation result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopAbs_Orientation)((BRepTools_WireExplorer const *)arg1)->Orientation();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_WireExplorer_orientation\n  * wrapname: _wrap_BRepTools_WireExplorer_orientation\n  * fulldecl: TopAbs_Orientation BRepTools_WireExplorer::Orientation() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopAbs_Orientation)0;
  }
}


EXPORT TopoDS_Vertex *_wrap_BRepTools_WireExplorer_currentVertex (BRepTools_WireExplorer *larg1) {
  TopoDS_Vertex * lresult = (TopoDS_Vertex *)0 ;
  BRepTools_WireExplorer *arg1 = (BRepTools_WireExplorer *) 0 ;
  TopoDS_Vertex *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Vertex *) &((BRepTools_WireExplorer const *)arg1)->CurrentVertex();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_WireExplorer_currentVertex\n  * wrapname: _wrap_BRepTools_WireExplorer_currentVertex\n  * fulldecl: TopoDS_Vertex const & BRepTools_WireExplorer::CurrentVertex() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Vertex *)0;
  }
}


EXPORT void _wrap_BRepTools_WireExplorer_clear (BRepTools_WireExplorer *larg1) {
  BRepTools_WireExplorer *arg1 = (BRepTools_WireExplorer *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Clear();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_WireExplorer_clear\n  * wrapname: _wrap_BRepTools_WireExplorer_clear\n  * fulldecl: void BRepTools_WireExplorer::Clear()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_BRepTools_WireExplorer (BRepTools_WireExplorer *larg1) {
  BRepTools_WireExplorer *arg1 = (BRepTools_WireExplorer *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepTools_WireExplorer\n  * wrapname: _wrap_delete_BRepTools_WireExplorer\n  * fulldecl: BRepTools_WireExplorer::~BRepTools_WireExplorer()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <BRepTools_Quilt.hxx>
  
EXPORT BRepTools_Quilt *_wrap_new_BRepTools_Quilt () {
  BRepTools_Quilt * lresult = (BRepTools_Quilt *)0 ;
  BRepTools_Quilt *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepTools_Quilt *)new BRepTools_Quilt();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepTools_Quilt\n  * wrapname: _wrap_new_BRepTools_Quilt\n  * fulldecl: BRepTools_Quilt::BRepTools_Quilt()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepTools_Quilt *)0;
  }
}


EXPORT void _wrap_BRepTools_Quilt_bind__SWIG_0 (BRepTools_Quilt *larg1, TopoDS_Edge *larg2, TopoDS_Edge *larg3) {
  BRepTools_Quilt *arg1 = (BRepTools_Quilt *) 0 ;
  TopoDS_Edge *arg2 = 0 ;
  TopoDS_Edge *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Bind((TopoDS_Edge const &)*arg2,(TopoDS_Edge const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_Quilt_bind\n  * wrapname: _wrap_BRepTools_Quilt_bind__SWIG_0\n  * fulldecl: void BRepTools_Quilt::Bind(TopoDS_Edge const &,TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepTools_Quilt_bind__SWIG_1 (BRepTools_Quilt *larg1, TopoDS_Vertex *larg2, TopoDS_Vertex *larg3) {
  BRepTools_Quilt *arg1 = (BRepTools_Quilt *) 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  TopoDS_Vertex *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Bind((TopoDS_Vertex const &)*arg2,(TopoDS_Vertex const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_Quilt_bind\n  * wrapname: _wrap_BRepTools_Quilt_bind__SWIG_1\n  * fulldecl: void BRepTools_Quilt::Bind(TopoDS_Vertex const &,TopoDS_Vertex const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepTools_Quilt_add (BRepTools_Quilt *larg1, TopoDS_Shape *larg2) {
  BRepTools_Quilt *arg1 = (BRepTools_Quilt *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Add((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_Quilt_add\n  * wrapname: _wrap_BRepTools_Quilt_add\n  * fulldecl: void BRepTools_Quilt::Add(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_BRepTools_Quilt_isCopied (BRepTools_Quilt *larg1, TopoDS_Shape *larg2) {
  bool lresult = (bool)0 ;
  BRepTools_Quilt *arg1 = (BRepTools_Quilt *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepTools_Quilt const *)arg1)->IsCopied((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_Quilt_isCopied\n  * wrapname: _wrap_BRepTools_Quilt_isCopied\n  * fulldecl: Standard_Boolean BRepTools_Quilt::IsCopied(TopoDS_Shape const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT TopoDS_Shape *_wrap_BRepTools_Quilt_copy (BRepTools_Quilt *larg1, TopoDS_Shape *larg2) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  BRepTools_Quilt *arg1 = (BRepTools_Quilt *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &((BRepTools_Quilt const *)arg1)->Copy((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_Quilt_copy\n  * wrapname: _wrap_BRepTools_Quilt_copy\n  * fulldecl: TopoDS_Shape const & BRepTools_Quilt::Copy(TopoDS_Shape const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT TopoDS_Shape *_wrap_BRepTools_Quilt_shells (BRepTools_Quilt *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  BRepTools_Quilt *arg1 = (BRepTools_Quilt *) 0 ;
  TopoDS_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((BRepTools_Quilt const *)arg1)->Shells();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepTools_Quilt_shells\n  * wrapname: _wrap_BRepTools_Quilt_shells\n  * fulldecl: TopoDS_Shape BRepTools_Quilt::Shells() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new TopoDS_Shape(result);
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT void _wrap_delete_BRepTools_Quilt (BRepTools_Quilt *larg1) {
  BRepTools_Quilt *arg1 = (BRepTools_Quilt *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepTools_Quilt\n  * wrapname: _wrap_delete_BRepTools_Quilt\n  * fulldecl: BRepTools_Quilt::~BRepTools_Quilt()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <BRepBuilderAPI_Transform.hxx>
#include <BRepBuilderAPI_ModifyShape.hxx>
#include <BRepBuilderAPI_MakeShape.hxx>
#include <BRepBuilderAPI_MakeShell.hxx>
#include <BRepBuilderAPI_MakeWire.hxx>
#include <BRepBuilderAPI_MakeVertex.hxx>
#include <BRepBuilderAPI_MakeEdge.hxx>
#include <BRepBuilderAPI_MakeFace.hxx>
#include <BRepBuilderAPI_MakeSolid.hxx>
#include <BRepBuilderAPI_NurbsConvert.hxx>
#include <Standard_Version.hxx>
#if OCC_VERSION_MAJOR >= 6
#include <BRepBuilderAPI_Sewing.hxx>
#else
#include <BRepAlgo_Sewing.hxx>
#define BRepBuilderAPI_Sewing BRepAlgo_Sewing
#endif

EXPORT bool _wrap_BRepBuilderAPI_Command_IsDone (BRepBuilderAPI_Command *larg1) {
  bool lresult = (bool)0 ;
  BRepBuilderAPI_Command *arg1 = (BRepBuilderAPI_Command *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepBuilderAPI_Command const *)arg1)->IsDone();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Command_IsDone\n  * wrapname: _wrap_BRepBuilderAPI_Command_IsDone\n  * fulldecl: Standard_Boolean BRepBuilderAPI_Command::IsDone() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_delete_BRepBuilderAPI_Command (BRepBuilderAPI_Command *larg1) {
  BRepBuilderAPI_Command *arg1 = (BRepBuilderAPI_Command *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepBuilderAPI_Command\n  * wrapname: _wrap_delete_BRepBuilderAPI_Command\n  * fulldecl: BRepBuilderAPI_Command::~BRepBuilderAPI_Command()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepBuilderAPI_MakeShape_Build (BRepBuilderAPI_MakeShape *larg1) {
  BRepBuilderAPI_MakeShape *arg1 = (BRepBuilderAPI_MakeShape *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Build();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeShape_Build\n  * wrapname: _wrap_BRepBuilderAPI_MakeShape_Build\n  * fulldecl: void BRepBuilderAPI_MakeShape::Build()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopoDS_Shape *_wrap_BRepBuilderAPI_MakeShape_Shape (BRepBuilderAPI_MakeShape *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  BRepBuilderAPI_MakeShape *arg1 = (BRepBuilderAPI_MakeShape *) 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &(arg1)->Shape();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeShape_Shape\n  * wrapname: _wrap_BRepBuilderAPI_MakeShape_Shape\n  * fulldecl: TopoDS_Shape const & BRepBuilderAPI_MakeShape::Shape()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT void _wrap_delete_BRepBuilderAPI_MakeShape (BRepBuilderAPI_MakeShape *larg1) {
  BRepBuilderAPI_MakeShape *arg1 = (BRepBuilderAPI_MakeShape *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepBuilderAPI_MakeShape\n  * wrapname: _wrap_delete_BRepBuilderAPI_MakeShape\n  * fulldecl: BRepBuilderAPI_MakeShape::~BRepBuilderAPI_MakeShape()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopoDS_Shape *_wrap_BRepBuilderAPI_ModifyShape_ModifiedShape (BRepBuilderAPI_ModifyShape *larg1, TopoDS_Shape *larg2) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  BRepBuilderAPI_ModifyShape *arg1 = (BRepBuilderAPI_ModifyShape *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopoDS_Shape result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((BRepBuilderAPI_ModifyShape const *)arg1)->ModifiedShape((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_ModifyShape_ModifiedShape\n  * wrapname: _wrap_BRepBuilderAPI_ModifyShape_ModifiedShape\n  * fulldecl: TopoDS_Shape BRepBuilderAPI_ModifyShape::ModifiedShape(TopoDS_Shape const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new TopoDS_Shape(result);
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT void _wrap_delete_BRepBuilderAPI_ModifyShape (BRepBuilderAPI_ModifyShape *larg1) {
  BRepBuilderAPI_ModifyShape *arg1 = (BRepBuilderAPI_ModifyShape *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepBuilderAPI_ModifyShape\n  * wrapname: _wrap_delete_BRepBuilderAPI_ModifyShape\n  * fulldecl: BRepBuilderAPI_ModifyShape::~BRepBuilderAPI_ModifyShape()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepBuilderAPI_Transform *_wrap_new_BRepBuilderAPI_Transform__SWIG_0 (gp_Trsf *larg1) {
  BRepBuilderAPI_Transform * lresult = (BRepBuilderAPI_Transform *)0 ;
  gp_Trsf *arg1 = 0 ;
  BRepBuilderAPI_Transform *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_Transform *)new BRepBuilderAPI_Transform((gp_Trsf const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_Transform\n  * wrapname: _wrap_new_BRepBuilderAPI_Transform__SWIG_0\n  * fulldecl: BRepBuilderAPI_Transform::BRepBuilderAPI_Transform(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_Transform *)0;
  }
}


EXPORT BRepBuilderAPI_Transform *_wrap_new_BRepBuilderAPI_Transform__SWIG_1 (TopoDS_Shape *larg1, gp_Trsf *larg2, bool larg3) {
  BRepBuilderAPI_Transform * lresult = (BRepBuilderAPI_Transform *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  gp_Trsf *arg2 = 0 ;
  Standard_Boolean arg3 ;
  BRepBuilderAPI_Transform *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_Transform *)new BRepBuilderAPI_Transform((TopoDS_Shape const &)*arg1,(gp_Trsf const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_Transform\n  * wrapname: _wrap_new_BRepBuilderAPI_Transform__SWIG_1\n  * fulldecl: BRepBuilderAPI_Transform::BRepBuilderAPI_Transform(TopoDS_Shape const &,gp_Trsf const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_Transform *)0;
  }
}


EXPORT BRepBuilderAPI_Transform *_wrap_new_BRepBuilderAPI_Transform__SWIG_2 (TopoDS_Shape *larg1, gp_Trsf *larg2) {
  BRepBuilderAPI_Transform * lresult = (BRepBuilderAPI_Transform *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  gp_Trsf *arg2 = 0 ;
  BRepBuilderAPI_Transform *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_Transform *)new BRepBuilderAPI_Transform((TopoDS_Shape const &)*arg1,(gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_Transform\n  * wrapname: _wrap_new_BRepBuilderAPI_Transform__SWIG_2\n  * fulldecl: BRepBuilderAPI_Transform::BRepBuilderAPI_Transform(TopoDS_Shape const &,gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_Transform *)0;
  }
}


EXPORT void _wrap_BRepBuilderAPI_Transform_Perform__SWIG_0 (BRepBuilderAPI_Transform *larg1, TopoDS_Shape *larg2, bool larg3) {
  BRepBuilderAPI_Transform *arg1 = (BRepBuilderAPI_Transform *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Perform((TopoDS_Shape const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Transform_Perform\n  * wrapname: _wrap_BRepBuilderAPI_Transform_Perform__SWIG_0\n  * fulldecl: void BRepBuilderAPI_Transform::Perform(TopoDS_Shape const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepBuilderAPI_Transform_Perform__SWIG_1 (BRepBuilderAPI_Transform *larg1, TopoDS_Shape *larg2) {
  BRepBuilderAPI_Transform *arg1 = (BRepBuilderAPI_Transform *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Perform((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Transform_Perform\n  * wrapname: _wrap_BRepBuilderAPI_Transform_Perform__SWIG_1\n  * fulldecl: void BRepBuilderAPI_Transform::Perform(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_BRepBuilderAPI_Transform (BRepBuilderAPI_Transform *larg1) {
  BRepBuilderAPI_Transform *arg1 = (BRepBuilderAPI_Transform *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepBuilderAPI_Transform\n  * wrapname: _wrap_delete_BRepBuilderAPI_Transform\n  * fulldecl: BRepBuilderAPI_Transform::~BRepBuilderAPI_Transform()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepBuilderAPI_MakeVertex *_wrap_new_BRepBuilderAPI_MakeVertex (gp_Pnt *larg1) {
  BRepBuilderAPI_MakeVertex * lresult = (BRepBuilderAPI_MakeVertex *)0 ;
  gp_Pnt *arg1 = 0 ;
  BRepBuilderAPI_MakeVertex *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeVertex *)new BRepBuilderAPI_MakeVertex((gp_Pnt const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeVertex\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeVertex\n  * fulldecl: BRepBuilderAPI_MakeVertex::BRepBuilderAPI_MakeVertex(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeVertex *)0;
  }
}


EXPORT TopoDS_Vertex *_wrap_BRepBuilderAPI_MakeVertex_Vertex (BRepBuilderAPI_MakeVertex *larg1) {
  TopoDS_Vertex * lresult = (TopoDS_Vertex *)0 ;
  BRepBuilderAPI_MakeVertex *arg1 = (BRepBuilderAPI_MakeVertex *) 0 ;
  TopoDS_Vertex *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Vertex *) &((BRepBuilderAPI_MakeVertex *)arg1)->Vertex();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeVertex_Vertex\n  * wrapname: _wrap_BRepBuilderAPI_MakeVertex_Vertex\n  * fulldecl: TopoDS_Vertex const & BRepBuilderAPI_MakeVertex::Vertex() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Vertex *)0;
  }
}


EXPORT void _wrap_delete_BRepBuilderAPI_MakeVertex (BRepBuilderAPI_MakeVertex *larg1) {
  BRepBuilderAPI_MakeVertex *arg1 = (BRepBuilderAPI_MakeVertex *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepBuilderAPI_MakeVertex\n  * wrapname: _wrap_delete_BRepBuilderAPI_MakeVertex\n  * fulldecl: BRepBuilderAPI_MakeVertex::~BRepBuilderAPI_MakeVertex()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepBuilderAPI_MakeWire *_wrap_new_BRepBuilderAPI_MakeWire__SWIG_0 () {
  BRepBuilderAPI_MakeWire * lresult = (BRepBuilderAPI_MakeWire *)0 ;
  BRepBuilderAPI_MakeWire *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeWire *)new BRepBuilderAPI_MakeWire();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeWire\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeWire__SWIG_0\n  * fulldecl: BRepBuilderAPI_MakeWire::BRepBuilderAPI_MakeWire()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeWire *)0;
  }
}


EXPORT BRepBuilderAPI_MakeWire *_wrap_new_BRepBuilderAPI_MakeWire__SWIG_1 (TopoDS_Edge *larg1) {
  BRepBuilderAPI_MakeWire * lresult = (BRepBuilderAPI_MakeWire *)0 ;
  TopoDS_Edge *arg1 = 0 ;
  BRepBuilderAPI_MakeWire *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeWire *)new BRepBuilderAPI_MakeWire((TopoDS_Edge const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeWire\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeWire__SWIG_1\n  * fulldecl: BRepBuilderAPI_MakeWire::BRepBuilderAPI_MakeWire(TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeWire *)0;
  }
}


EXPORT BRepBuilderAPI_MakeWire *_wrap_new_BRepBuilderAPI_MakeWire__SWIG_2 (TopoDS_Edge *larg1, TopoDS_Edge *larg2) {
  BRepBuilderAPI_MakeWire * lresult = (BRepBuilderAPI_MakeWire *)0 ;
  TopoDS_Edge *arg1 = 0 ;
  TopoDS_Edge *arg2 = 0 ;
  BRepBuilderAPI_MakeWire *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeWire *)new BRepBuilderAPI_MakeWire((TopoDS_Edge const &)*arg1,(TopoDS_Edge const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeWire\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeWire__SWIG_2\n  * fulldecl: BRepBuilderAPI_MakeWire::BRepBuilderAPI_MakeWire(TopoDS_Edge const &,TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeWire *)0;
  }
}


EXPORT BRepBuilderAPI_MakeWire *_wrap_new_BRepBuilderAPI_MakeWire__SWIG_3 (TopoDS_Edge *larg1, TopoDS_Edge *larg2, TopoDS_Edge *larg3) {
  BRepBuilderAPI_MakeWire * lresult = (BRepBuilderAPI_MakeWire *)0 ;
  TopoDS_Edge *arg1 = 0 ;
  TopoDS_Edge *arg2 = 0 ;
  TopoDS_Edge *arg3 = 0 ;
  BRepBuilderAPI_MakeWire *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeWire *)new BRepBuilderAPI_MakeWire((TopoDS_Edge const &)*arg1,(TopoDS_Edge const &)*arg2,(TopoDS_Edge const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeWire\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeWire__SWIG_3\n  * fulldecl: BRepBuilderAPI_MakeWire::BRepBuilderAPI_MakeWire(TopoDS_Edge const &,TopoDS_Edge const &,TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeWire *)0;
  }
}


EXPORT BRepBuilderAPI_MakeWire *_wrap_new_BRepBuilderAPI_MakeWire__SWIG_4 (TopoDS_Edge *larg1, TopoDS_Edge *larg2, TopoDS_Edge *larg3, TopoDS_Edge *larg4) {
  BRepBuilderAPI_MakeWire * lresult = (BRepBuilderAPI_MakeWire *)0 ;
  TopoDS_Edge *arg1 = 0 ;
  TopoDS_Edge *arg2 = 0 ;
  TopoDS_Edge *arg3 = 0 ;
  TopoDS_Edge *arg4 = 0 ;
  BRepBuilderAPI_MakeWire *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeWire *)new BRepBuilderAPI_MakeWire((TopoDS_Edge const &)*arg1,(TopoDS_Edge const &)*arg2,(TopoDS_Edge const &)*arg3,(TopoDS_Edge const &)*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeWire\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeWire__SWIG_4\n  * fulldecl: BRepBuilderAPI_MakeWire::BRepBuilderAPI_MakeWire(TopoDS_Edge const &,TopoDS_Edge const &,TopoDS_Edge const &,TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeWire *)0;
  }
}


EXPORT BRepBuilderAPI_MakeWire *_wrap_new_BRepBuilderAPI_MakeWire__SWIG_5 (TopoDS_Wire *larg1) {
  BRepBuilderAPI_MakeWire * lresult = (BRepBuilderAPI_MakeWire *)0 ;
  TopoDS_Wire *arg1 = 0 ;
  BRepBuilderAPI_MakeWire *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeWire *)new BRepBuilderAPI_MakeWire((TopoDS_Wire const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeWire\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeWire__SWIG_5\n  * fulldecl: BRepBuilderAPI_MakeWire::BRepBuilderAPI_MakeWire(TopoDS_Wire const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeWire *)0;
  }
}


EXPORT BRepBuilderAPI_MakeWire *_wrap_new_BRepBuilderAPI_MakeWire__SWIG_6 (TopoDS_Wire *larg1, TopoDS_Edge *larg2) {
  BRepBuilderAPI_MakeWire * lresult = (BRepBuilderAPI_MakeWire *)0 ;
  TopoDS_Wire *arg1 = 0 ;
  TopoDS_Edge *arg2 = 0 ;
  BRepBuilderAPI_MakeWire *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeWire *)new BRepBuilderAPI_MakeWire((TopoDS_Wire const &)*arg1,(TopoDS_Edge const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeWire\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeWire__SWIG_6\n  * fulldecl: BRepBuilderAPI_MakeWire::BRepBuilderAPI_MakeWire(TopoDS_Wire const &,TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeWire *)0;
  }
}


EXPORT void _wrap_BRepBuilderAPI_MakeWire_Add__SWIG_0 (BRepBuilderAPI_MakeWire *larg1, TopoDS_Edge *larg2) {
  BRepBuilderAPI_MakeWire *arg1 = (BRepBuilderAPI_MakeWire *) 0 ;
  TopoDS_Edge *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Add((TopoDS_Edge const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeWire_Add\n  * wrapname: _wrap_BRepBuilderAPI_MakeWire_Add__SWIG_0\n  * fulldecl: void BRepBuilderAPI_MakeWire::Add(TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepBuilderAPI_MakeWire_Add__SWIG_1 (BRepBuilderAPI_MakeWire *larg1, TopoDS_Wire *larg2) {
  BRepBuilderAPI_MakeWire *arg1 = (BRepBuilderAPI_MakeWire *) 0 ;
  TopoDS_Wire *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Add((TopoDS_Wire const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeWire_Add\n  * wrapname: _wrap_BRepBuilderAPI_MakeWire_Add__SWIG_1\n  * fulldecl: void BRepBuilderAPI_MakeWire::Add(TopoDS_Wire const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepBuilderAPI_MakeWire_Add__SWIG_2 (BRepBuilderAPI_MakeWire *larg1, TopTools_ListOfShape *larg2) {
  BRepBuilderAPI_MakeWire *arg1 = (BRepBuilderAPI_MakeWire *) 0 ;
  TopTools_ListOfShape *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Add((TopTools_ListOfShape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeWire_Add\n  * wrapname: _wrap_BRepBuilderAPI_MakeWire_Add__SWIG_2\n  * fulldecl: void BRepBuilderAPI_MakeWire::Add(TopTools_ListOfShape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_BRepBuilderAPI_MakeWire_IsDone (BRepBuilderAPI_MakeWire *larg1) {
  bool lresult = (bool)0 ;
  BRepBuilderAPI_MakeWire *arg1 = (BRepBuilderAPI_MakeWire *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepBuilderAPI_MakeWire const *)arg1)->IsDone();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeWire_IsDone\n  * wrapname: _wrap_BRepBuilderAPI_MakeWire_IsDone\n  * fulldecl: Standard_Boolean BRepBuilderAPI_MakeWire::IsDone() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT BRepBuilderAPI_WireError _wrap_BRepBuilderAPI_MakeWire_Error (BRepBuilderAPI_MakeWire *larg1) {
  BRepBuilderAPI_WireError lresult = (BRepBuilderAPI_WireError)0 ;
  BRepBuilderAPI_MakeWire *arg1 = (BRepBuilderAPI_MakeWire *) 0 ;
  BRepBuilderAPI_WireError result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_WireError)((BRepBuilderAPI_MakeWire const *)arg1)->Error();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeWire_Error\n  * wrapname: _wrap_BRepBuilderAPI_MakeWire_Error\n  * fulldecl: BRepBuilderAPI_WireError BRepBuilderAPI_MakeWire::Error() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_WireError)0;
  }
}


EXPORT TopoDS_Wire *_wrap_BRepBuilderAPI_MakeWire_Wire (BRepBuilderAPI_MakeWire *larg1) {
  TopoDS_Wire * lresult = (TopoDS_Wire *)0 ;
  BRepBuilderAPI_MakeWire *arg1 = (BRepBuilderAPI_MakeWire *) 0 ;
  TopoDS_Wire *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Wire *) &((BRepBuilderAPI_MakeWire *)arg1)->Wire();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeWire_Wire\n  * wrapname: _wrap_BRepBuilderAPI_MakeWire_Wire\n  * fulldecl: TopoDS_Wire const & BRepBuilderAPI_MakeWire::Wire() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Wire *)0;
  }
}


EXPORT void _wrap_delete_BRepBuilderAPI_MakeWire (BRepBuilderAPI_MakeWire *larg1) {
  BRepBuilderAPI_MakeWire *arg1 = (BRepBuilderAPI_MakeWire *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepBuilderAPI_MakeWire\n  * wrapname: _wrap_delete_BRepBuilderAPI_MakeWire\n  * fulldecl: BRepBuilderAPI_MakeWire::~BRepBuilderAPI_MakeWire()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepBuilderAPI_MakeShell *_wrap_new_BRepBuilderAPI_MakeShell () {
  BRepBuilderAPI_MakeShell * lresult = (BRepBuilderAPI_MakeShell *)0 ;
  BRepBuilderAPI_MakeShell *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeShell *)new BRepBuilderAPI_MakeShell();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeShell\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeShell\n  * fulldecl: BRepBuilderAPI_MakeShell::BRepBuilderAPI_MakeShell()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeShell *)0;
  }
}


EXPORT bool _wrap_BRepBuilderAPI_MakeShell_IsDone (BRepBuilderAPI_MakeShell *larg1) {
  bool lresult = (bool)0 ;
  BRepBuilderAPI_MakeShell *arg1 = (BRepBuilderAPI_MakeShell *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepBuilderAPI_MakeShell const *)arg1)->IsDone();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeShell_IsDone\n  * wrapname: _wrap_BRepBuilderAPI_MakeShell_IsDone\n  * fulldecl: Standard_Boolean BRepBuilderAPI_MakeShell::IsDone() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT BRepBuilderAPI_ShellError _wrap_BRepBuilderAPI_MakeShell_Error (BRepBuilderAPI_MakeShell *larg1) {
  BRepBuilderAPI_ShellError lresult = (BRepBuilderAPI_ShellError)0 ;
  BRepBuilderAPI_MakeShell *arg1 = (BRepBuilderAPI_MakeShell *) 0 ;
  BRepBuilderAPI_ShellError result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_ShellError)((BRepBuilderAPI_MakeShell const *)arg1)->Error();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeShell_Error\n  * wrapname: _wrap_BRepBuilderAPI_MakeShell_Error\n  * fulldecl: BRepBuilderAPI_ShellError BRepBuilderAPI_MakeShell::Error() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_ShellError)0;
  }
}


EXPORT TopoDS_Shell *_wrap_BRepBuilderAPI_MakeShell_Shell (BRepBuilderAPI_MakeShell *larg1) {
  TopoDS_Shell * lresult = (TopoDS_Shell *)0 ;
  BRepBuilderAPI_MakeShell *arg1 = (BRepBuilderAPI_MakeShell *) 0 ;
  TopoDS_Shell *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shell *) &((BRepBuilderAPI_MakeShell const *)arg1)->Shell();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeShell_Shell\n  * wrapname: _wrap_BRepBuilderAPI_MakeShell_Shell\n  * fulldecl: TopoDS_Shell const & BRepBuilderAPI_MakeShell::Shell() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shell *)0;
  }
}


EXPORT void _wrap_delete_BRepBuilderAPI_MakeShell (BRepBuilderAPI_MakeShell *larg1) {
  BRepBuilderAPI_MakeShell *arg1 = (BRepBuilderAPI_MakeShell *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepBuilderAPI_MakeShell\n  * wrapname: _wrap_delete_BRepBuilderAPI_MakeShell\n  * fulldecl: BRepBuilderAPI_MakeShell::~BRepBuilderAPI_MakeShell()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_0 () {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_0\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_1 (TopoDS_Vertex *larg1, TopoDS_Vertex *larg2) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  TopoDS_Vertex *arg1 = 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((TopoDS_Vertex const &)*arg1,(TopoDS_Vertex const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_1\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(TopoDS_Vertex const &,TopoDS_Vertex const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_2 (gp_Pnt *larg1, gp_Pnt *larg2) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Pnt *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Pnt const &)*arg1,(gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_2\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_3 (gp_Lin *larg1) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Lin *arg1 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Lin const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_3\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Lin const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_4 (gp_Lin *larg1, Standard_Real larg2, Standard_Real larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Lin *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Lin const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_4\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Lin const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_5 (gp_Lin *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Lin *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Lin const &)*arg1,(gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_5\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Lin const &,gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_6 (gp_Lin *larg1, TopoDS_Vertex *larg2, TopoDS_Vertex *larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Lin *arg1 = 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  TopoDS_Vertex *arg3 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Lin const &)*arg1,(TopoDS_Vertex const &)*arg2,(TopoDS_Vertex const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_6\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Lin const &,TopoDS_Vertex const &,TopoDS_Vertex const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_7 (gp_Circ *larg1) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Circ *arg1 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Circ const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_7\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Circ const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_8 (gp_Circ *larg1, Standard_Real larg2, Standard_Real larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Circ *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Circ const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_8\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Circ const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_9 (gp_Circ *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Circ *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Circ const &)*arg1,(gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_9\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Circ const &,gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_10 (gp_Circ *larg1, TopoDS_Vertex *larg2, TopoDS_Vertex *larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Circ *arg1 = 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  TopoDS_Vertex *arg3 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Circ const &)*arg1,(TopoDS_Vertex const &)*arg2,(TopoDS_Vertex const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_10\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Circ const &,TopoDS_Vertex const &,TopoDS_Vertex const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_11 (gp_Elips *larg1) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Elips *arg1 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Elips const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_11\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Elips const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_12 (gp_Elips *larg1, Standard_Real larg2, Standard_Real larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Elips *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Elips const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_12\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Elips const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_13 (gp_Elips *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Elips *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Elips const &)*arg1,(gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_13\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Elips const &,gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_14 (gp_Elips *larg1, TopoDS_Vertex *larg2, TopoDS_Vertex *larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Elips *arg1 = 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  TopoDS_Vertex *arg3 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Elips const &)*arg1,(TopoDS_Vertex const &)*arg2,(TopoDS_Vertex const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_14\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Elips const &,TopoDS_Vertex const &,TopoDS_Vertex const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_15 (gp_Hypr *larg1) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Hypr *arg1 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Hypr const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_15\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Hypr const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_16 (gp_Hypr *larg1, Standard_Real larg2, Standard_Real larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Hypr *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Hypr const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_16\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Hypr const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_17 (gp_Hypr *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Hypr *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Hypr const &)*arg1,(gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_17\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Hypr const &,gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_18 (gp_Hypr *larg1, TopoDS_Vertex *larg2, TopoDS_Vertex *larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Hypr *arg1 = 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  TopoDS_Vertex *arg3 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Hypr const &)*arg1,(TopoDS_Vertex const &)*arg2,(TopoDS_Vertex const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_18\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Hypr const &,TopoDS_Vertex const &,TopoDS_Vertex const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_19 (gp_Parab *larg1) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Parab *arg1 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Parab const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_19\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Parab const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_20 (gp_Parab *larg1, Standard_Real larg2, Standard_Real larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Parab *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Parab const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_20\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Parab const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_21 (gp_Parab *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Parab *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Parab const &)*arg1,(gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_21\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Parab const &,gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_22 (gp_Parab *larg1, TopoDS_Vertex *larg2, TopoDS_Vertex *larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  gp_Parab *arg1 = 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  TopoDS_Vertex *arg3 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((gp_Parab const &)*arg1,(TopoDS_Vertex const &)*arg2,(TopoDS_Vertex const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_22\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(gp_Parab const &,TopoDS_Vertex const &,TopoDS_Vertex const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_23 (Handle_Geom_Curve *larg1) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  Handle_Geom_Curve *arg1 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((Handle_Geom_Curve const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_23\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(Handle_Geom_Curve const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_24 (Handle_Geom_Curve *larg1, Standard_Real larg2, Standard_Real larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  Handle_Geom_Curve *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((Handle_Geom_Curve const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_24\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(Handle_Geom_Curve const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_25 (Handle_Geom_Curve *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  Handle_Geom_Curve *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((Handle_Geom_Curve const &)*arg1,(gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_25\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(Handle_Geom_Curve const &,gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_26 (Handle_Geom_Curve *larg1, TopoDS_Vertex *larg2, TopoDS_Vertex *larg3) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  Handle_Geom_Curve *arg1 = 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  TopoDS_Vertex *arg3 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((Handle_Geom_Curve const &)*arg1,(TopoDS_Vertex const &)*arg2,(TopoDS_Vertex const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_26\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(Handle_Geom_Curve const &,TopoDS_Vertex const &,TopoDS_Vertex const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_27 (Handle_Geom_Curve *larg1, gp_Pnt *larg2, gp_Pnt *larg3, Standard_Real larg4, Standard_Real larg5) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  Handle_Geom_Curve *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((Handle_Geom_Curve const &)*arg1,(gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_27\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(Handle_Geom_Curve const &,gp_Pnt const &,gp_Pnt const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_28 (Handle_Geom_Curve *larg1, TopoDS_Vertex *larg2, TopoDS_Vertex *larg3, Standard_Real larg4, Standard_Real larg5) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  Handle_Geom_Curve *arg1 = 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  TopoDS_Vertex *arg3 = 0 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((Handle_Geom_Curve const &)*arg1,(TopoDS_Vertex const &)*arg2,(TopoDS_Vertex const &)*arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_28\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(Handle_Geom_Curve const &,TopoDS_Vertex const &,TopoDS_Vertex const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_29 (Handle_Geom2d_Curve *larg1, Handle_Geom_Surface *larg2) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  Handle_Geom2d_Curve *arg1 = 0 ;
  Handle_Geom_Surface *arg2 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((Handle_Geom2d_Curve const &)*arg1,(Handle_Geom_Surface const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_29\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(Handle_Geom2d_Curve const &,Handle_Geom_Surface const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_30 (Handle_Geom2d_Curve *larg1, Handle_Geom_Surface *larg2, Standard_Real larg3, Standard_Real larg4) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  Handle_Geom2d_Curve *arg1 = 0 ;
  Handle_Geom_Surface *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((Handle_Geom2d_Curve const &)*arg1,(Handle_Geom_Surface const &)*arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_30\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(Handle_Geom2d_Curve const &,Handle_Geom_Surface const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_31 (Handle_Geom2d_Curve *larg1, Handle_Geom_Surface *larg2, TopoDS_Vertex *larg3, TopoDS_Vertex *larg4) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  Handle_Geom2d_Curve *arg1 = 0 ;
  Handle_Geom_Surface *arg2 = 0 ;
  TopoDS_Vertex *arg3 = 0 ;
  TopoDS_Vertex *arg4 = 0 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((Handle_Geom2d_Curve const &)*arg1,(Handle_Geom_Surface const &)*arg2,(TopoDS_Vertex const &)*arg3,(TopoDS_Vertex const &)*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_31\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(Handle_Geom2d_Curve const &,Handle_Geom_Surface const &,TopoDS_Vertex const &,TopoDS_Vertex const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_32 (Handle_Geom2d_Curve *larg1, Handle_Geom_Surface *larg2, gp_Pnt *larg3, gp_Pnt *larg4, Standard_Real larg5, Standard_Real larg6) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  Handle_Geom2d_Curve *arg1 = 0 ;
  Handle_Geom_Surface *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  gp_Pnt *arg4 = 0 ;
  Standard_Real arg5 ;
  Standard_Real arg6 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((Handle_Geom2d_Curve const &)*arg1,(Handle_Geom_Surface const &)*arg2,(gp_Pnt const &)*arg3,(gp_Pnt const &)*arg4,arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_32\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(Handle_Geom2d_Curve const &,Handle_Geom_Surface const &,gp_Pnt const &,gp_Pnt const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT BRepBuilderAPI_MakeEdge *_wrap_new_BRepBuilderAPI_MakeEdge__SWIG_33 (Handle_Geom2d_Curve *larg1, Handle_Geom_Surface *larg2, TopoDS_Vertex *larg3, TopoDS_Vertex *larg4, Standard_Real larg5, Standard_Real larg6) {
  BRepBuilderAPI_MakeEdge * lresult = (BRepBuilderAPI_MakeEdge *)0 ;
  Handle_Geom2d_Curve *arg1 = 0 ;
  Handle_Geom_Surface *arg2 = 0 ;
  TopoDS_Vertex *arg3 = 0 ;
  TopoDS_Vertex *arg4 = 0 ;
  Standard_Real arg5 ;
  Standard_Real arg6 ;
  BRepBuilderAPI_MakeEdge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeEdge *)new BRepBuilderAPI_MakeEdge((Handle_Geom2d_Curve const &)*arg1,(Handle_Geom_Surface const &)*arg2,(TopoDS_Vertex const &)*arg3,(TopoDS_Vertex const &)*arg4,arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeEdge__SWIG_33\n  * fulldecl: BRepBuilderAPI_MakeEdge::BRepBuilderAPI_MakeEdge(Handle_Geom2d_Curve const &,Handle_Geom_Surface const &,TopoDS_Vertex const &,TopoDS_Vertex const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeEdge *)0;
  }
}


EXPORT bool _wrap_BRepBuilderAPI_MakeEdge_IsDone (BRepBuilderAPI_MakeEdge *larg1) {
  bool lresult = (bool)0 ;
  BRepBuilderAPI_MakeEdge *arg1 = (BRepBuilderAPI_MakeEdge *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepBuilderAPI_MakeEdge const *)arg1)->IsDone();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeEdge_IsDone\n  * wrapname: _wrap_BRepBuilderAPI_MakeEdge_IsDone\n  * fulldecl: Standard_Boolean BRepBuilderAPI_MakeEdge::IsDone() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT BRepBuilderAPI_EdgeError _wrap_BRepBuilderAPI_MakeEdge_Error (BRepBuilderAPI_MakeEdge *larg1) {
  BRepBuilderAPI_EdgeError lresult = (BRepBuilderAPI_EdgeError)0 ;
  BRepBuilderAPI_MakeEdge *arg1 = (BRepBuilderAPI_MakeEdge *) 0 ;
  BRepBuilderAPI_EdgeError result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_EdgeError)((BRepBuilderAPI_MakeEdge const *)arg1)->Error();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeEdge_Error\n  * wrapname: _wrap_BRepBuilderAPI_MakeEdge_Error\n  * fulldecl: BRepBuilderAPI_EdgeError BRepBuilderAPI_MakeEdge::Error() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_EdgeError)0;
  }
}


EXPORT TopoDS_Edge *_wrap_BRepBuilderAPI_MakeEdge_Edge (BRepBuilderAPI_MakeEdge *larg1) {
  TopoDS_Edge * lresult = (TopoDS_Edge *)0 ;
  BRepBuilderAPI_MakeEdge *arg1 = (BRepBuilderAPI_MakeEdge *) 0 ;
  TopoDS_Edge *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Edge *) &((BRepBuilderAPI_MakeEdge *)arg1)->Edge();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeEdge_Edge\n  * wrapname: _wrap_BRepBuilderAPI_MakeEdge_Edge\n  * fulldecl: TopoDS_Edge const & BRepBuilderAPI_MakeEdge::Edge() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Edge *)0;
  }
}


EXPORT void _wrap_delete_BRepBuilderAPI_MakeEdge (BRepBuilderAPI_MakeEdge *larg1) {
  BRepBuilderAPI_MakeEdge *arg1 = (BRepBuilderAPI_MakeEdge *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepBuilderAPI_MakeEdge\n  * wrapname: _wrap_delete_BRepBuilderAPI_MakeEdge\n  * fulldecl: BRepBuilderAPI_MakeEdge::~BRepBuilderAPI_MakeEdge()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepBuilderAPI_MakeFace *_wrap_new_BRepBuilderAPI_MakeFace__SWIG_0 (TopoDS_Wire *larg1, bool larg2) {
  BRepBuilderAPI_MakeFace * lresult = (BRepBuilderAPI_MakeFace *)0 ;
  TopoDS_Wire *arg1 = 0 ;
  Standard_Boolean arg2 ;
  BRepBuilderAPI_MakeFace *result = 0 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeFace *)new BRepBuilderAPI_MakeFace((TopoDS_Wire const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeFace\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeFace__SWIG_0\n  * fulldecl: BRepBuilderAPI_MakeFace::BRepBuilderAPI_MakeFace(TopoDS_Wire const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeFace *)0;
  }
}


EXPORT BRepBuilderAPI_MakeFace *_wrap_new_BRepBuilderAPI_MakeFace__SWIG_1 (TopoDS_Wire *larg1) {
  BRepBuilderAPI_MakeFace * lresult = (BRepBuilderAPI_MakeFace *)0 ;
  TopoDS_Wire *arg1 = 0 ;
  BRepBuilderAPI_MakeFace *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeFace *)new BRepBuilderAPI_MakeFace((TopoDS_Wire const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeFace\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeFace__SWIG_1\n  * fulldecl: BRepBuilderAPI_MakeFace::BRepBuilderAPI_MakeFace(TopoDS_Wire const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeFace *)0;
  }
}


EXPORT BRepBuilderAPI_MakeFace *_wrap_new_BRepBuilderAPI_MakeFace__SWIG_2 (TopoDS_Face *larg1, TopoDS_Wire *larg2) {
  BRepBuilderAPI_MakeFace * lresult = (BRepBuilderAPI_MakeFace *)0 ;
  TopoDS_Face *arg1 = 0 ;
  TopoDS_Wire *arg2 = 0 ;
  BRepBuilderAPI_MakeFace *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeFace *)new BRepBuilderAPI_MakeFace((TopoDS_Face const &)*arg1,(TopoDS_Wire const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeFace\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeFace__SWIG_2\n  * fulldecl: BRepBuilderAPI_MakeFace::BRepBuilderAPI_MakeFace(TopoDS_Face const &,TopoDS_Wire const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeFace *)0;
  }
}


EXPORT BRepBuilderAPI_MakeFace *_wrap_new_BRepBuilderAPI_MakeFace__SWIG_3 (Handle_Geom_Surface *larg1, TopoDS_Wire *larg2, bool larg3) {
  BRepBuilderAPI_MakeFace * lresult = (BRepBuilderAPI_MakeFace *)0 ;
  Handle_Geom_Surface *arg1 = 0 ;
  TopoDS_Wire *arg2 = 0 ;
  Standard_Boolean arg3 ;
  BRepBuilderAPI_MakeFace *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeFace *)new BRepBuilderAPI_MakeFace((Handle_Geom_Surface const &)*arg1,(TopoDS_Wire const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeFace\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeFace__SWIG_3\n  * fulldecl: BRepBuilderAPI_MakeFace::BRepBuilderAPI_MakeFace(Handle_Geom_Surface const &,TopoDS_Wire const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeFace *)0;
  }
}


EXPORT BRepBuilderAPI_MakeFace *_wrap_new_BRepBuilderAPI_MakeFace__SWIG_4 (Handle_Geom_Surface *larg1, TopoDS_Wire *larg2) {
  BRepBuilderAPI_MakeFace * lresult = (BRepBuilderAPI_MakeFace *)0 ;
  Handle_Geom_Surface *arg1 = 0 ;
  TopoDS_Wire *arg2 = 0 ;
  BRepBuilderAPI_MakeFace *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeFace *)new BRepBuilderAPI_MakeFace((Handle_Geom_Surface const &)*arg1,(TopoDS_Wire const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeFace\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeFace__SWIG_4\n  * fulldecl: BRepBuilderAPI_MakeFace::BRepBuilderAPI_MakeFace(Handle_Geom_Surface const &,TopoDS_Wire const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeFace *)0;
  }
}


EXPORT BRepBuilderAPI_MakeFace *_wrap_new_BRepBuilderAPI_MakeFace__SWIG_5 (Handle_Geom_Surface *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5, Standard_Real larg6) {
  BRepBuilderAPI_MakeFace * lresult = (BRepBuilderAPI_MakeFace *)0 ;
  Handle_Geom_Surface *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  Standard_Real arg6 ;
  BRepBuilderAPI_MakeFace *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeFace *)new BRepBuilderAPI_MakeFace((Handle_Geom_Surface const &)*arg1,arg2,arg3,arg4,arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeFace\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeFace__SWIG_5\n  * fulldecl: BRepBuilderAPI_MakeFace::BRepBuilderAPI_MakeFace(Handle_Geom_Surface const &,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeFace *)0;
  }
}


EXPORT bool _wrap_BRepBuilderAPI_MakeFace_IsDone (BRepBuilderAPI_MakeFace *larg1) {
  bool lresult = (bool)0 ;
  BRepBuilderAPI_MakeFace *arg1 = (BRepBuilderAPI_MakeFace *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepBuilderAPI_MakeFace const *)arg1)->IsDone();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeFace_IsDone\n  * wrapname: _wrap_BRepBuilderAPI_MakeFace_IsDone\n  * fulldecl: Standard_Boolean BRepBuilderAPI_MakeFace::IsDone() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT BRepBuilderAPI_FaceError _wrap_BRepBuilderAPI_MakeFace_Error (BRepBuilderAPI_MakeFace *larg1) {
  BRepBuilderAPI_FaceError lresult = (BRepBuilderAPI_FaceError)0 ;
  BRepBuilderAPI_MakeFace *arg1 = (BRepBuilderAPI_MakeFace *) 0 ;
  BRepBuilderAPI_FaceError result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_FaceError)((BRepBuilderAPI_MakeFace const *)arg1)->Error();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeFace_Error\n  * wrapname: _wrap_BRepBuilderAPI_MakeFace_Error\n  * fulldecl: BRepBuilderAPI_FaceError BRepBuilderAPI_MakeFace::Error() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_FaceError)0;
  }
}


EXPORT TopoDS_Face *_wrap_BRepBuilderAPI_MakeFace_Face (BRepBuilderAPI_MakeFace *larg1) {
  TopoDS_Face * lresult = (TopoDS_Face *)0 ;
  BRepBuilderAPI_MakeFace *arg1 = (BRepBuilderAPI_MakeFace *) 0 ;
  TopoDS_Face *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Face *) &((BRepBuilderAPI_MakeFace const *)arg1)->Face();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeFace_Face\n  * wrapname: _wrap_BRepBuilderAPI_MakeFace_Face\n  * fulldecl: TopoDS_Face const & BRepBuilderAPI_MakeFace::Face() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Face *)0;
  }
}


EXPORT void _wrap_delete_BRepBuilderAPI_MakeFace (BRepBuilderAPI_MakeFace *larg1) {
  BRepBuilderAPI_MakeFace *arg1 = (BRepBuilderAPI_MakeFace *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepBuilderAPI_MakeFace\n  * wrapname: _wrap_delete_BRepBuilderAPI_MakeFace\n  * fulldecl: BRepBuilderAPI_MakeFace::~BRepBuilderAPI_MakeFace()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepBuilderAPI_MakeSolid *_wrap_new_BRepBuilderAPI_MakeSolid__SWIG_0 () {
  BRepBuilderAPI_MakeSolid * lresult = (BRepBuilderAPI_MakeSolid *)0 ;
  BRepBuilderAPI_MakeSolid *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeSolid *)new BRepBuilderAPI_MakeSolid();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeSolid\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeSolid__SWIG_0\n  * fulldecl: BRepBuilderAPI_MakeSolid::BRepBuilderAPI_MakeSolid()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeSolid *)0;
  }
}


EXPORT BRepBuilderAPI_MakeSolid *_wrap_new_BRepBuilderAPI_MakeSolid__SWIG_1 (TopoDS_CompSolid *larg1) {
  BRepBuilderAPI_MakeSolid * lresult = (BRepBuilderAPI_MakeSolid *)0 ;
  TopoDS_CompSolid *arg1 = 0 ;
  BRepBuilderAPI_MakeSolid *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeSolid *)new BRepBuilderAPI_MakeSolid((TopoDS_CompSolid const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeSolid\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeSolid__SWIG_1\n  * fulldecl: BRepBuilderAPI_MakeSolid::BRepBuilderAPI_MakeSolid(TopoDS_CompSolid const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeSolid *)0;
  }
}


EXPORT BRepBuilderAPI_MakeSolid *_wrap_new_BRepBuilderAPI_MakeSolid__SWIG_2 (TopoDS_Shell *larg1) {
  BRepBuilderAPI_MakeSolid * lresult = (BRepBuilderAPI_MakeSolid *)0 ;
  TopoDS_Shell *arg1 = 0 ;
  BRepBuilderAPI_MakeSolid *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeSolid *)new BRepBuilderAPI_MakeSolid((TopoDS_Shell const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeSolid\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeSolid__SWIG_2\n  * fulldecl: BRepBuilderAPI_MakeSolid::BRepBuilderAPI_MakeSolid(TopoDS_Shell const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeSolid *)0;
  }
}


EXPORT BRepBuilderAPI_MakeSolid *_wrap_new_BRepBuilderAPI_MakeSolid__SWIG_3 (TopoDS_Shell *larg1, TopoDS_Shell *larg2) {
  BRepBuilderAPI_MakeSolid * lresult = (BRepBuilderAPI_MakeSolid *)0 ;
  TopoDS_Shell *arg1 = 0 ;
  TopoDS_Shell *arg2 = 0 ;
  BRepBuilderAPI_MakeSolid *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeSolid *)new BRepBuilderAPI_MakeSolid((TopoDS_Shell const &)*arg1,(TopoDS_Shell const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeSolid\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeSolid__SWIG_3\n  * fulldecl: BRepBuilderAPI_MakeSolid::BRepBuilderAPI_MakeSolid(TopoDS_Shell const &,TopoDS_Shell const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeSolid *)0;
  }
}


EXPORT BRepBuilderAPI_MakeSolid *_wrap_new_BRepBuilderAPI_MakeSolid__SWIG_4 (TopoDS_Shell *larg1, TopoDS_Shell *larg2, TopoDS_Shell *larg3) {
  BRepBuilderAPI_MakeSolid * lresult = (BRepBuilderAPI_MakeSolid *)0 ;
  TopoDS_Shell *arg1 = 0 ;
  TopoDS_Shell *arg2 = 0 ;
  TopoDS_Shell *arg3 = 0 ;
  BRepBuilderAPI_MakeSolid *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeSolid *)new BRepBuilderAPI_MakeSolid((TopoDS_Shell const &)*arg1,(TopoDS_Shell const &)*arg2,(TopoDS_Shell const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeSolid\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeSolid__SWIG_4\n  * fulldecl: BRepBuilderAPI_MakeSolid::BRepBuilderAPI_MakeSolid(TopoDS_Shell const &,TopoDS_Shell const &,TopoDS_Shell const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeSolid *)0;
  }
}


EXPORT BRepBuilderAPI_MakeSolid *_wrap_new_BRepBuilderAPI_MakeSolid__SWIG_5 (TopoDS_Solid *larg1) {
  BRepBuilderAPI_MakeSolid * lresult = (BRepBuilderAPI_MakeSolid *)0 ;
  TopoDS_Solid *arg1 = 0 ;
  BRepBuilderAPI_MakeSolid *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeSolid *)new BRepBuilderAPI_MakeSolid((TopoDS_Solid const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeSolid\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeSolid__SWIG_5\n  * fulldecl: BRepBuilderAPI_MakeSolid::BRepBuilderAPI_MakeSolid(TopoDS_Solid const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeSolid *)0;
  }
}


EXPORT BRepBuilderAPI_MakeSolid *_wrap_new_BRepBuilderAPI_MakeSolid__SWIG_6 (TopoDS_Solid *larg1, TopoDS_Shell *larg2) {
  BRepBuilderAPI_MakeSolid * lresult = (BRepBuilderAPI_MakeSolid *)0 ;
  TopoDS_Solid *arg1 = 0 ;
  TopoDS_Shell *arg2 = 0 ;
  BRepBuilderAPI_MakeSolid *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_MakeSolid *)new BRepBuilderAPI_MakeSolid((TopoDS_Solid const &)*arg1,(TopoDS_Shell const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_MakeSolid\n  * wrapname: _wrap_new_BRepBuilderAPI_MakeSolid__SWIG_6\n  * fulldecl: BRepBuilderAPI_MakeSolid::BRepBuilderAPI_MakeSolid(TopoDS_Solid const &,TopoDS_Shell const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_MakeSolid *)0;
  }
}


EXPORT void _wrap_BRepBuilderAPI_MakeSolid_Add (BRepBuilderAPI_MakeSolid *larg1, TopoDS_Shell *larg2) {
  BRepBuilderAPI_MakeSolid *arg1 = (BRepBuilderAPI_MakeSolid *) 0 ;
  TopoDS_Shell *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Add((TopoDS_Shell const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeSolid_Add\n  * wrapname: _wrap_BRepBuilderAPI_MakeSolid_Add\n  * fulldecl: void BRepBuilderAPI_MakeSolid::Add(TopoDS_Shell const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_BRepBuilderAPI_MakeSolid_IsDone (BRepBuilderAPI_MakeSolid *larg1) {
  bool lresult = (bool)0 ;
  BRepBuilderAPI_MakeSolid *arg1 = (BRepBuilderAPI_MakeSolid *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepBuilderAPI_MakeSolid const *)arg1)->IsDone();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeSolid_IsDone\n  * wrapname: _wrap_BRepBuilderAPI_MakeSolid_IsDone\n  * fulldecl: Standard_Boolean BRepBuilderAPI_MakeSolid::IsDone() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT TopoDS_Solid *_wrap_BRepBuilderAPI_MakeSolid_Solid (BRepBuilderAPI_MakeSolid *larg1) {
  TopoDS_Solid * lresult = (TopoDS_Solid *)0 ;
  BRepBuilderAPI_MakeSolid *arg1 = (BRepBuilderAPI_MakeSolid *) 0 ;
  TopoDS_Solid *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Solid *) &(arg1)->Solid();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeSolid_Solid\n  * wrapname: _wrap_BRepBuilderAPI_MakeSolid_Solid\n  * fulldecl: TopoDS_Solid const & BRepBuilderAPI_MakeSolid::Solid()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Solid *)0;
  }
}


EXPORT bool _wrap_BRepBuilderAPI_MakeSolid_IsDeleted (BRepBuilderAPI_MakeSolid *larg1, TopoDS_Shape *larg2) {
  bool lresult = (bool)0 ;
  BRepBuilderAPI_MakeSolid *arg1 = (BRepBuilderAPI_MakeSolid *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->IsDeleted((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_MakeSolid_IsDeleted\n  * wrapname: _wrap_BRepBuilderAPI_MakeSolid_IsDeleted\n  * fulldecl: Standard_Boolean BRepBuilderAPI_MakeSolid::IsDeleted(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_delete_BRepBuilderAPI_MakeSolid (BRepBuilderAPI_MakeSolid *larg1) {
  BRepBuilderAPI_MakeSolid *arg1 = (BRepBuilderAPI_MakeSolid *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepBuilderAPI_MakeSolid\n  * wrapname: _wrap_delete_BRepBuilderAPI_MakeSolid\n  * fulldecl: BRepBuilderAPI_MakeSolid::~BRepBuilderAPI_MakeSolid()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepBuilderAPI_Sewing *_wrap_new_BRepBuilderAPI_Sewing__SWIG_0 (Standard_Real larg1, bool larg2, bool larg3, bool larg4) {
  BRepBuilderAPI_Sewing * lresult = (BRepBuilderAPI_Sewing *)0 ;
  Standard_Real arg1 ;
  Standard_Boolean arg2 ;
  Standard_Boolean arg3 ;
  Standard_Boolean arg4 ;
  BRepBuilderAPI_Sewing *result = 0 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  arg3 = (bool)larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_Sewing *)new BRepBuilderAPI_Sewing(arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_Sewing\n  * wrapname: _wrap_new_BRepBuilderAPI_Sewing__SWIG_0\n  * fulldecl: BRepBuilderAPI_Sewing::BRepBuilderAPI_Sewing(Standard_Real const,Standard_Boolean const,Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_Sewing *)0;
  }
}


EXPORT BRepBuilderAPI_Sewing *_wrap_new_BRepBuilderAPI_Sewing__SWIG_1 (Standard_Real larg1, bool larg2, bool larg3) {
  BRepBuilderAPI_Sewing * lresult = (BRepBuilderAPI_Sewing *)0 ;
  Standard_Real arg1 ;
  Standard_Boolean arg2 ;
  Standard_Boolean arg3 ;
  BRepBuilderAPI_Sewing *result = 0 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_Sewing *)new BRepBuilderAPI_Sewing(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_Sewing\n  * wrapname: _wrap_new_BRepBuilderAPI_Sewing__SWIG_1\n  * fulldecl: BRepBuilderAPI_Sewing::BRepBuilderAPI_Sewing(Standard_Real const,Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_Sewing *)0;
  }
}


EXPORT BRepBuilderAPI_Sewing *_wrap_new_BRepBuilderAPI_Sewing__SWIG_2 (Standard_Real larg1, bool larg2) {
  BRepBuilderAPI_Sewing * lresult = (BRepBuilderAPI_Sewing *)0 ;
  Standard_Real arg1 ;
  Standard_Boolean arg2 ;
  BRepBuilderAPI_Sewing *result = 0 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_Sewing *)new BRepBuilderAPI_Sewing(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_Sewing\n  * wrapname: _wrap_new_BRepBuilderAPI_Sewing__SWIG_2\n  * fulldecl: BRepBuilderAPI_Sewing::BRepBuilderAPI_Sewing(Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_Sewing *)0;
  }
}


EXPORT BRepBuilderAPI_Sewing *_wrap_new_BRepBuilderAPI_Sewing__SWIG_3 (Standard_Real larg1) {
  BRepBuilderAPI_Sewing * lresult = (BRepBuilderAPI_Sewing *)0 ;
  Standard_Real arg1 ;
  BRepBuilderAPI_Sewing *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_Sewing *)new BRepBuilderAPI_Sewing(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_Sewing\n  * wrapname: _wrap_new_BRepBuilderAPI_Sewing__SWIG_3\n  * fulldecl: BRepBuilderAPI_Sewing::BRepBuilderAPI_Sewing(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_Sewing *)0;
  }
}


EXPORT BRepBuilderAPI_Sewing *_wrap_new_BRepBuilderAPI_Sewing__SWIG_4 () {
  BRepBuilderAPI_Sewing * lresult = (BRepBuilderAPI_Sewing *)0 ;
  BRepBuilderAPI_Sewing *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_Sewing *)new BRepBuilderAPI_Sewing();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_Sewing\n  * wrapname: _wrap_new_BRepBuilderAPI_Sewing__SWIG_4\n  * fulldecl: BRepBuilderAPI_Sewing::BRepBuilderAPI_Sewing()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_Sewing *)0;
  }
}


EXPORT void _wrap_BRepBuilderAPI_Sewing_Init__SWIG_0 (BRepBuilderAPI_Sewing *larg1, Standard_Real larg2, bool larg3, bool larg4, bool larg5) {
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  Standard_Real arg2 ;
  Standard_Boolean arg3 ;
  Standard_Boolean arg4 ;
  Standard_Boolean arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  arg4 = (bool)larg4;
  arg5 = (bool)larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init(arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_Init\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_Init__SWIG_0\n  * fulldecl: void BRepBuilderAPI_Sewing::Init(Standard_Real const,Standard_Boolean const,Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepBuilderAPI_Sewing_Init__SWIG_1 (BRepBuilderAPI_Sewing *larg1, Standard_Real larg2, bool larg3, bool larg4) {
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  Standard_Real arg2 ;
  Standard_Boolean arg3 ;
  Standard_Boolean arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init(arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_Init\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_Init__SWIG_1\n  * fulldecl: void BRepBuilderAPI_Sewing::Init(Standard_Real const,Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepBuilderAPI_Sewing_Init__SWIG_2 (BRepBuilderAPI_Sewing *larg1, Standard_Real larg2, bool larg3) {
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  Standard_Real arg2 ;
  Standard_Boolean arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init(arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_Init\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_Init__SWIG_2\n  * fulldecl: void BRepBuilderAPI_Sewing::Init(Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepBuilderAPI_Sewing_Init__SWIG_3 (BRepBuilderAPI_Sewing *larg1, Standard_Real larg2) {
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_Init\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_Init__SWIG_3\n  * fulldecl: void BRepBuilderAPI_Sewing::Init(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepBuilderAPI_Sewing_Load (BRepBuilderAPI_Sewing *larg1, TopoDS_Shape *larg2) {
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Load((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_Load\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_Load\n  * fulldecl: void BRepBuilderAPI_Sewing::Load(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepBuilderAPI_Sewing_Add (BRepBuilderAPI_Sewing *larg1, TopoDS_Shape *larg2) {
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Add((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_Add\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_Add\n  * fulldecl: void BRepBuilderAPI_Sewing::Add(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepBuilderAPI_Sewing_Perform (BRepBuilderAPI_Sewing *larg1) {
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Perform();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_Perform\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_Perform\n  * fulldecl: void BRepBuilderAPI_Sewing::Perform()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopoDS_Shape *_wrap_BRepBuilderAPI_Sewing_SewedShape (BRepBuilderAPI_Sewing *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &((BRepBuilderAPI_Sewing const *)arg1)->SewedShape();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_SewedShape\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_SewedShape\n  * fulldecl: TopoDS_Shape const & BRepBuilderAPI_Sewing::SewedShape() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT Standard_Integer _wrap_BRepBuilderAPI_Sewing_NbFreeEdges (BRepBuilderAPI_Sewing *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((BRepBuilderAPI_Sewing const *)arg1)->NbFreeEdges();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_NbFreeEdges\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_NbFreeEdges\n  * fulldecl: Standard_Integer BRepBuilderAPI_Sewing::NbFreeEdges() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT TopoDS_Edge *_wrap_BRepBuilderAPI_Sewing_FreeEdge (BRepBuilderAPI_Sewing *larg1, Standard_Integer larg2) {
  TopoDS_Edge * lresult = (TopoDS_Edge *)0 ;
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  Standard_Integer arg2 ;
  TopoDS_Edge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Edge *) &((BRepBuilderAPI_Sewing const *)arg1)->FreeEdge(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_FreeEdge\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_FreeEdge\n  * fulldecl: TopoDS_Edge const & BRepBuilderAPI_Sewing::FreeEdge(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Edge *)0;
  }
}


EXPORT Standard_Integer _wrap_BRepBuilderAPI_Sewing_NbMultipleEdges (BRepBuilderAPI_Sewing *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((BRepBuilderAPI_Sewing const *)arg1)->NbMultipleEdges();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_NbMultipleEdges\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_NbMultipleEdges\n  * fulldecl: Standard_Integer BRepBuilderAPI_Sewing::NbMultipleEdges() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT TopoDS_Edge *_wrap_BRepBuilderAPI_Sewing_MultipleEdge (BRepBuilderAPI_Sewing *larg1, Standard_Integer larg2) {
  TopoDS_Edge * lresult = (TopoDS_Edge *)0 ;
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  Standard_Integer arg2 ;
  TopoDS_Edge *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Edge *) &((BRepBuilderAPI_Sewing const *)arg1)->MultipleEdge(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_MultipleEdge\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_MultipleEdge\n  * fulldecl: TopoDS_Edge const & BRepBuilderAPI_Sewing::MultipleEdge(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Edge *)0;
  }
}


EXPORT Standard_Integer _wrap_BRepBuilderAPI_Sewing_NbDegeneratedShapes (BRepBuilderAPI_Sewing *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((BRepBuilderAPI_Sewing const *)arg1)->NbDegeneratedShapes();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_NbDegeneratedShapes\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_NbDegeneratedShapes\n  * fulldecl: Standard_Integer BRepBuilderAPI_Sewing::NbDegeneratedShapes() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT TopoDS_Shape *_wrap_BRepBuilderAPI_Sewing_DegeneratedShape (BRepBuilderAPI_Sewing *larg1, Standard_Integer larg2) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  Standard_Integer arg2 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &((BRepBuilderAPI_Sewing const *)arg1)->DegeneratedShape(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_DegeneratedShape\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_DegeneratedShape\n  * fulldecl: TopoDS_Shape const & BRepBuilderAPI_Sewing::DegeneratedShape(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT Standard_Integer _wrap_BRepBuilderAPI_Sewing_NbDeletedFaces (BRepBuilderAPI_Sewing *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((BRepBuilderAPI_Sewing const *)arg1)->NbDeletedFaces();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_NbDeletedFaces\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_NbDeletedFaces\n  * fulldecl: Standard_Integer BRepBuilderAPI_Sewing::NbDeletedFaces() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT TopoDS_Face *_wrap_BRepBuilderAPI_Sewing_DeletedFace (BRepBuilderAPI_Sewing *larg1, Standard_Integer larg2) {
  TopoDS_Face * lresult = (TopoDS_Face *)0 ;
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  Standard_Integer arg2 ;
  TopoDS_Face *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Face *) &((BRepBuilderAPI_Sewing const *)arg1)->DeletedFace(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_DeletedFace\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_DeletedFace\n  * fulldecl: TopoDS_Face const & BRepBuilderAPI_Sewing::DeletedFace(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Face *)0;
  }
}


EXPORT bool _wrap_BRepBuilderAPI_Sewing_IsDegenerated (BRepBuilderAPI_Sewing *larg1, TopoDS_Shape *larg2) {
  bool lresult = (bool)0 ;
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepBuilderAPI_Sewing const *)arg1)->IsDegenerated((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_IsDegenerated\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_IsDegenerated\n  * fulldecl: Standard_Boolean BRepBuilderAPI_Sewing::IsDegenerated(TopoDS_Shape const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepBuilderAPI_Sewing_IsModified (BRepBuilderAPI_Sewing *larg1, TopoDS_Shape *larg2) {
  bool lresult = (bool)0 ;
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepBuilderAPI_Sewing const *)arg1)->IsModified((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_IsModified\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_IsModified\n  * fulldecl: Standard_Boolean BRepBuilderAPI_Sewing::IsModified(TopoDS_Shape const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT TopoDS_Shape *_wrap_BRepBuilderAPI_Sewing_Modified (BRepBuilderAPI_Sewing *larg1, TopoDS_Shape *larg2) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &((BRepBuilderAPI_Sewing const *)arg1)->Modified((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_Modified\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_Modified\n  * fulldecl: TopoDS_Shape const & BRepBuilderAPI_Sewing::Modified(TopoDS_Shape const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT void _wrap_BRepBuilderAPI_Sewing_Dump (BRepBuilderAPI_Sewing *larg1) {
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRepBuilderAPI_Sewing const *)arg1)->Dump();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_Dump\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_Dump\n  * fulldecl: void BRepBuilderAPI_Sewing::Dump() const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_BRepBuilderAPI_Sewing_IsModifiedSubShape (BRepBuilderAPI_Sewing *larg1, TopoDS_Shape *larg2) {
  bool lresult = (bool)0 ;
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepBuilderAPI_Sewing const *)arg1)->IsModifiedSubShape((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_IsModifiedSubShape\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_IsModifiedSubShape\n  * fulldecl: Standard_Boolean BRepBuilderAPI_Sewing::IsModifiedSubShape(TopoDS_Shape const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT TopoDS_Shape *_wrap_BRepBuilderAPI_Sewing_ModifiedSubShape (BRepBuilderAPI_Sewing *larg1, TopoDS_Shape *larg2) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopoDS_Shape result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((BRepBuilderAPI_Sewing const *)arg1)->ModifiedSubShape((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_Sewing_ModifiedSubShape\n  * wrapname: _wrap_BRepBuilderAPI_Sewing_ModifiedSubShape\n  * fulldecl: TopoDS_Shape BRepBuilderAPI_Sewing::ModifiedSubShape(TopoDS_Shape const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new TopoDS_Shape(result);
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT void _wrap_delete_BRepBuilderAPI_Sewing (BRepBuilderAPI_Sewing *larg1) {
  BRepBuilderAPI_Sewing *arg1 = (BRepBuilderAPI_Sewing *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepBuilderAPI_Sewing\n  * wrapname: _wrap_delete_BRepBuilderAPI_Sewing\n  * fulldecl: BRepBuilderAPI_Sewing::~BRepBuilderAPI_Sewing()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepBuilderAPI_NurbsConvert *_wrap_new_BRepBuilderAPI_NurbsConvert__SWIG_0 () {
  BRepBuilderAPI_NurbsConvert * lresult = (BRepBuilderAPI_NurbsConvert *)0 ;
  BRepBuilderAPI_NurbsConvert *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_NurbsConvert *)new BRepBuilderAPI_NurbsConvert();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_NurbsConvert\n  * wrapname: _wrap_new_BRepBuilderAPI_NurbsConvert__SWIG_0\n  * fulldecl: BRepBuilderAPI_NurbsConvert::BRepBuilderAPI_NurbsConvert()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_NurbsConvert *)0;
  }
}


EXPORT BRepBuilderAPI_NurbsConvert *_wrap_new_BRepBuilderAPI_NurbsConvert__SWIG_1 (TopoDS_Shape *larg1, bool larg2) {
  BRepBuilderAPI_NurbsConvert * lresult = (BRepBuilderAPI_NurbsConvert *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Boolean arg2 ;
  BRepBuilderAPI_NurbsConvert *result = 0 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_NurbsConvert *)new BRepBuilderAPI_NurbsConvert((TopoDS_Shape const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_NurbsConvert\n  * wrapname: _wrap_new_BRepBuilderAPI_NurbsConvert__SWIG_1\n  * fulldecl: BRepBuilderAPI_NurbsConvert::BRepBuilderAPI_NurbsConvert(TopoDS_Shape const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_NurbsConvert *)0;
  }
}


EXPORT BRepBuilderAPI_NurbsConvert *_wrap_new_BRepBuilderAPI_NurbsConvert__SWIG_2 (TopoDS_Shape *larg1) {
  BRepBuilderAPI_NurbsConvert * lresult = (BRepBuilderAPI_NurbsConvert *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  BRepBuilderAPI_NurbsConvert *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepBuilderAPI_NurbsConvert *)new BRepBuilderAPI_NurbsConvert((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepBuilderAPI_NurbsConvert\n  * wrapname: _wrap_new_BRepBuilderAPI_NurbsConvert__SWIG_2\n  * fulldecl: BRepBuilderAPI_NurbsConvert::BRepBuilderAPI_NurbsConvert(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepBuilderAPI_NurbsConvert *)0;
  }
}


EXPORT void _wrap_BRepBuilderAPI_NurbsConvert_Perform__SWIG_0 (BRepBuilderAPI_NurbsConvert *larg1, TopoDS_Shape *larg2, bool larg3) {
  BRepBuilderAPI_NurbsConvert *arg1 = (BRepBuilderAPI_NurbsConvert *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Perform((TopoDS_Shape const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_NurbsConvert_Perform\n  * wrapname: _wrap_BRepBuilderAPI_NurbsConvert_Perform__SWIG_0\n  * fulldecl: void BRepBuilderAPI_NurbsConvert::Perform(TopoDS_Shape const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepBuilderAPI_NurbsConvert_Perform__SWIG_1 (BRepBuilderAPI_NurbsConvert *larg1, TopoDS_Shape *larg2) {
  BRepBuilderAPI_NurbsConvert *arg1 = (BRepBuilderAPI_NurbsConvert *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Perform((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBuilderAPI_NurbsConvert_Perform\n  * wrapname: _wrap_BRepBuilderAPI_NurbsConvert_Perform__SWIG_1\n  * fulldecl: void BRepBuilderAPI_NurbsConvert::Perform(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_BRepBuilderAPI_NurbsConvert (BRepBuilderAPI_NurbsConvert *larg1) {
  BRepBuilderAPI_NurbsConvert *arg1 = (BRepBuilderAPI_NurbsConvert *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepBuilderAPI_NurbsConvert\n  * wrapname: _wrap_delete_BRepBuilderAPI_NurbsConvert\n  * fulldecl: BRepBuilderAPI_NurbsConvert::~BRepBuilderAPI_NurbsConvert()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <BRepOffsetAPI_NormalProjection.hxx>

EXPORT BRepOffsetAPI_NormalProjection *_wrap_new_BRepOffsetAPI_NormalProjection__SWIG_0 () {
  BRepOffsetAPI_NormalProjection * lresult = (BRepOffsetAPI_NormalProjection *)0 ;
  BRepOffsetAPI_NormalProjection *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_NormalProjection *)new BRepOffsetAPI_NormalProjection();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_NormalProjection\n  * wrapname: _wrap_new_BRepOffsetAPI_NormalProjection__SWIG_0\n  * fulldecl: BRepOffsetAPI_NormalProjection::BRepOffsetAPI_NormalProjection()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_NormalProjection *)0;
  }
}


EXPORT BRepOffsetAPI_NormalProjection *_wrap_new_BRepOffsetAPI_NormalProjection__SWIG_1 (TopoDS_Shape *larg1) {
  BRepOffsetAPI_NormalProjection * lresult = (BRepOffsetAPI_NormalProjection *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  BRepOffsetAPI_NormalProjection *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_NormalProjection *)new BRepOffsetAPI_NormalProjection((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_NormalProjection\n  * wrapname: _wrap_new_BRepOffsetAPI_NormalProjection__SWIG_1\n  * fulldecl: BRepOffsetAPI_NormalProjection::BRepOffsetAPI_NormalProjection(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_NormalProjection *)0;
  }
}


EXPORT void _wrap_BRepOffsetAPI_NormalProjection_Init (BRepOffsetAPI_NormalProjection *larg1, TopoDS_Shape *larg2) {
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_NormalProjection_Init\n  * wrapname: _wrap_BRepOffsetAPI_NormalProjection_Init\n  * fulldecl: void BRepOffsetAPI_NormalProjection::Init(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_NormalProjection_Add (BRepOffsetAPI_NormalProjection *larg1, TopoDS_Shape *larg2) {
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Add((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_NormalProjection_Add\n  * wrapname: _wrap_BRepOffsetAPI_NormalProjection_Add\n  * fulldecl: void BRepOffsetAPI_NormalProjection::Add(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_NormalProjection_SetParams (BRepOffsetAPI_NormalProjection *larg1, Standard_Real larg2, Standard_Real larg3, GeomAbs_Shape larg4, Standard_Integer larg5, Standard_Integer larg6) {
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  GeomAbs_Shape arg4 ;
  Standard_Integer arg5 ;
  Standard_Integer arg6 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetParams(arg2,arg3,arg4,arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_NormalProjection_SetParams\n  * wrapname: _wrap_BRepOffsetAPI_NormalProjection_SetParams\n  * fulldecl: void BRepOffsetAPI_NormalProjection::SetParams(Standard_Real const,Standard_Real const,GeomAbs_Shape const,Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_NormalProjection_SetMaxDistance (BRepOffsetAPI_NormalProjection *larg1, Standard_Real larg2) {
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetMaxDistance(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_NormalProjection_SetMaxDistance\n  * wrapname: _wrap_BRepOffsetAPI_NormalProjection_SetMaxDistance\n  * fulldecl: void BRepOffsetAPI_NormalProjection::SetMaxDistance(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_NormalProjection_SetLimit__SWIG_0 (BRepOffsetAPI_NormalProjection *larg1, bool larg2) {
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  Standard_Boolean arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLimit(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_NormalProjection_SetLimit\n  * wrapname: _wrap_BRepOffsetAPI_NormalProjection_SetLimit__SWIG_0\n  * fulldecl: void BRepOffsetAPI_NormalProjection::SetLimit(Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_NormalProjection_SetLimit__SWIG_1 (BRepOffsetAPI_NormalProjection *larg1) {
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLimit();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_NormalProjection_SetLimit\n  * wrapname: _wrap_BRepOffsetAPI_NormalProjection_SetLimit__SWIG_1\n  * fulldecl: void BRepOffsetAPI_NormalProjection::SetLimit()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_NormalProjection_Compute3d__SWIG_0 (BRepOffsetAPI_NormalProjection *larg1, bool larg2) {
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  Standard_Boolean arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Compute3d(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_NormalProjection_Compute3d\n  * wrapname: _wrap_BRepOffsetAPI_NormalProjection_Compute3d__SWIG_0\n  * fulldecl: void BRepOffsetAPI_NormalProjection::Compute3d(Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_NormalProjection_Compute3d__SWIG_1 (BRepOffsetAPI_NormalProjection *larg1) {
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Compute3d();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_NormalProjection_Compute3d\n  * wrapname: _wrap_BRepOffsetAPI_NormalProjection_Compute3d__SWIG_1\n  * fulldecl: void BRepOffsetAPI_NormalProjection::Compute3d()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_NormalProjection_Build (BRepOffsetAPI_NormalProjection *larg1) {
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Build();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_NormalProjection_Build\n  * wrapname: _wrap_BRepOffsetAPI_NormalProjection_Build\n  * fulldecl: void BRepOffsetAPI_NormalProjection::Build()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_BRepOffsetAPI_NormalProjection_IsDone (BRepOffsetAPI_NormalProjection *larg1) {
  bool lresult = (bool)0 ;
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepOffsetAPI_NormalProjection const *)arg1)->IsDone();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_NormalProjection_IsDone\n  * wrapname: _wrap_BRepOffsetAPI_NormalProjection_IsDone\n  * fulldecl: Standard_Boolean BRepOffsetAPI_NormalProjection::IsDone() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT TopoDS_Shape *_wrap_BRepOffsetAPI_NormalProjection_Projection (BRepOffsetAPI_NormalProjection *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &((BRepOffsetAPI_NormalProjection const *)arg1)->Projection();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_NormalProjection_Projection\n  * wrapname: _wrap_BRepOffsetAPI_NormalProjection_Projection\n  * fulldecl: TopoDS_Shape const & BRepOffsetAPI_NormalProjection::Projection() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT TopoDS_Shape *_wrap_BRepOffsetAPI_NormalProjection_Couple (BRepOffsetAPI_NormalProjection *larg1, TopoDS_Edge *larg2) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  TopoDS_Edge *arg2 = 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &((BRepOffsetAPI_NormalProjection const *)arg1)->Couple((TopoDS_Edge const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_NormalProjection_Couple\n  * wrapname: _wrap_BRepOffsetAPI_NormalProjection_Couple\n  * fulldecl: TopoDS_Shape const & BRepOffsetAPI_NormalProjection::Couple(TopoDS_Edge const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT TopTools_ListOfShape *_wrap_BRepOffsetAPI_NormalProjection_Generated (BRepOffsetAPI_NormalProjection *larg1, TopoDS_Shape *larg2) {
  TopTools_ListOfShape * lresult = (TopTools_ListOfShape *)0 ;
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopTools_ListOfShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopTools_ListOfShape *) &(arg1)->Generated((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_NormalProjection_Generated\n  * wrapname: _wrap_BRepOffsetAPI_NormalProjection_Generated\n  * fulldecl: TopTools_ListOfShape const & BRepOffsetAPI_NormalProjection::Generated(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopTools_ListOfShape *)0;
  }
}


EXPORT TopoDS_Shape *_wrap_BRepOffsetAPI_NormalProjection_Ancestor (BRepOffsetAPI_NormalProjection *larg1, TopoDS_Edge *larg2) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  TopoDS_Edge *arg2 = 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &((BRepOffsetAPI_NormalProjection const *)arg1)->Ancestor((TopoDS_Edge const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_NormalProjection_Ancestor\n  * wrapname: _wrap_BRepOffsetAPI_NormalProjection_Ancestor\n  * fulldecl: TopoDS_Shape const & BRepOffsetAPI_NormalProjection::Ancestor(TopoDS_Edge const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT bool _wrap_BRepOffsetAPI_NormalProjection_BuildWire (BRepOffsetAPI_NormalProjection *larg1, TopTools_ListOfShape *larg2) {
  bool lresult = (bool)0 ;
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  TopTools_ListOfShape *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepOffsetAPI_NormalProjection const *)arg1)->BuildWire(*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_NormalProjection_BuildWire\n  * wrapname: _wrap_BRepOffsetAPI_NormalProjection_BuildWire\n  * fulldecl: Standard_Boolean BRepOffsetAPI_NormalProjection::BuildWire(TopTools_ListOfShape &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_delete_BRepOffsetAPI_NormalProjection (BRepOffsetAPI_NormalProjection *larg1) {
  BRepOffsetAPI_NormalProjection *arg1 = (BRepOffsetAPI_NormalProjection *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepOffsetAPI_NormalProjection\n  * wrapname: _wrap_delete_BRepOffsetAPI_NormalProjection\n  * fulldecl: BRepOffsetAPI_NormalProjection::~BRepOffsetAPI_NormalProjection()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <BRepOffsetAPI_MakeOffsetShape.hxx>
  
EXPORT BRepOffsetAPI_MakeOffsetShape *_wrap_new_BRepOffsetAPI_MakeOffsetShape__SWIG_0 () {
  BRepOffsetAPI_MakeOffsetShape * lresult = (BRepOffsetAPI_MakeOffsetShape *)0 ;
  BRepOffsetAPI_MakeOffsetShape *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_MakeOffsetShape *)new BRepOffsetAPI_MakeOffsetShape();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_MakeOffsetShape\n  * wrapname: _wrap_new_BRepOffsetAPI_MakeOffsetShape__SWIG_0\n  * fulldecl: BRepOffsetAPI_MakeOffsetShape::BRepOffsetAPI_MakeOffsetShape()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_MakeOffsetShape *)0;
  }
}


EXPORT BRepOffsetAPI_MakeOffsetShape *_wrap_new_BRepOffsetAPI_MakeOffsetShape__SWIG_1 (TopoDS_Shape *larg1, Standard_Real larg2, Standard_Real larg3, BRepOffset_Mode const *larg4, bool larg5, bool larg6, GeomAbs_JoinType const *larg7, bool larg8) {
  BRepOffsetAPI_MakeOffsetShape * lresult = (BRepOffsetAPI_MakeOffsetShape *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  BRepOffset_Mode arg4 ;
  Standard_Boolean arg5 ;
  Standard_Boolean arg6 ;
  GeomAbs_JoinType arg7 ;
  Standard_Boolean arg8 ;
  BRepOffsetAPI_MakeOffsetShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = *larg4;
  arg5 = (bool)larg5;
  arg6 = (bool)larg6;
  arg7 = *larg7;
  arg8 = (bool)larg8;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_MakeOffsetShape *)new BRepOffsetAPI_MakeOffsetShape((TopoDS_Shape const &)*arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_MakeOffsetShape\n  * wrapname: _wrap_new_BRepOffsetAPI_MakeOffsetShape__SWIG_1\n  * fulldecl: BRepOffsetAPI_MakeOffsetShape::BRepOffsetAPI_MakeOffsetShape(TopoDS_Shape const &,Standard_Real const,Standard_Real const,BRepOffset_Mode const,Standard_Boolean const,Standard_Boolean const,GeomAbs_JoinType const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_MakeOffsetShape *)0;
  }
}


EXPORT BRepOffsetAPI_MakeOffsetShape *_wrap_new_BRepOffsetAPI_MakeOffsetShape__SWIG_2 (TopoDS_Shape *larg1, Standard_Real larg2, Standard_Real larg3, BRepOffset_Mode const *larg4, bool larg5, bool larg6, GeomAbs_JoinType const *larg7) {
  BRepOffsetAPI_MakeOffsetShape * lresult = (BRepOffsetAPI_MakeOffsetShape *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  BRepOffset_Mode arg4 ;
  Standard_Boolean arg5 ;
  Standard_Boolean arg6 ;
  GeomAbs_JoinType arg7 ;
  BRepOffsetAPI_MakeOffsetShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = *larg4;
  arg5 = (bool)larg5;
  arg6 = (bool)larg6;
  arg7 = *larg7;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_MakeOffsetShape *)new BRepOffsetAPI_MakeOffsetShape((TopoDS_Shape const &)*arg1,arg2,arg3,arg4,arg5,arg6,arg7);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_MakeOffsetShape\n  * wrapname: _wrap_new_BRepOffsetAPI_MakeOffsetShape__SWIG_2\n  * fulldecl: BRepOffsetAPI_MakeOffsetShape::BRepOffsetAPI_MakeOffsetShape(TopoDS_Shape const &,Standard_Real const,Standard_Real const,BRepOffset_Mode const,Standard_Boolean const,Standard_Boolean const,GeomAbs_JoinType const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_MakeOffsetShape *)0;
  }
}


EXPORT BRepOffsetAPI_MakeOffsetShape *_wrap_new_BRepOffsetAPI_MakeOffsetShape__SWIG_3 (TopoDS_Shape *larg1, Standard_Real larg2, Standard_Real larg3, BRepOffset_Mode const *larg4, bool larg5, bool larg6) {
  BRepOffsetAPI_MakeOffsetShape * lresult = (BRepOffsetAPI_MakeOffsetShape *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  BRepOffset_Mode arg4 ;
  Standard_Boolean arg5 ;
  Standard_Boolean arg6 ;
  BRepOffsetAPI_MakeOffsetShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = *larg4;
  arg5 = (bool)larg5;
  arg6 = (bool)larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_MakeOffsetShape *)new BRepOffsetAPI_MakeOffsetShape((TopoDS_Shape const &)*arg1,arg2,arg3,arg4,arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_MakeOffsetShape\n  * wrapname: _wrap_new_BRepOffsetAPI_MakeOffsetShape__SWIG_3\n  * fulldecl: BRepOffsetAPI_MakeOffsetShape::BRepOffsetAPI_MakeOffsetShape(TopoDS_Shape const &,Standard_Real const,Standard_Real const,BRepOffset_Mode const,Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_MakeOffsetShape *)0;
  }
}


EXPORT BRepOffsetAPI_MakeOffsetShape *_wrap_new_BRepOffsetAPI_MakeOffsetShape__SWIG_4 (TopoDS_Shape *larg1, Standard_Real larg2, Standard_Real larg3, BRepOffset_Mode const *larg4, bool larg5) {
  BRepOffsetAPI_MakeOffsetShape * lresult = (BRepOffsetAPI_MakeOffsetShape *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  BRepOffset_Mode arg4 ;
  Standard_Boolean arg5 ;
  BRepOffsetAPI_MakeOffsetShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = *larg4;
  arg5 = (bool)larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_MakeOffsetShape *)new BRepOffsetAPI_MakeOffsetShape((TopoDS_Shape const &)*arg1,arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_MakeOffsetShape\n  * wrapname: _wrap_new_BRepOffsetAPI_MakeOffsetShape__SWIG_4\n  * fulldecl: BRepOffsetAPI_MakeOffsetShape::BRepOffsetAPI_MakeOffsetShape(TopoDS_Shape const &,Standard_Real const,Standard_Real const,BRepOffset_Mode const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_MakeOffsetShape *)0;
  }
}


EXPORT BRepOffsetAPI_MakeOffsetShape *_wrap_new_BRepOffsetAPI_MakeOffsetShape__SWIG_5 (TopoDS_Shape *larg1, Standard_Real larg2, Standard_Real larg3, BRepOffset_Mode const *larg4) {
  BRepOffsetAPI_MakeOffsetShape * lresult = (BRepOffsetAPI_MakeOffsetShape *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  BRepOffset_Mode arg4 ;
  BRepOffsetAPI_MakeOffsetShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = *larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_MakeOffsetShape *)new BRepOffsetAPI_MakeOffsetShape((TopoDS_Shape const &)*arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_MakeOffsetShape\n  * wrapname: _wrap_new_BRepOffsetAPI_MakeOffsetShape__SWIG_5\n  * fulldecl: BRepOffsetAPI_MakeOffsetShape::BRepOffsetAPI_MakeOffsetShape(TopoDS_Shape const &,Standard_Real const,Standard_Real const,BRepOffset_Mode const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_MakeOffsetShape *)0;
  }
}


EXPORT BRepOffsetAPI_MakeOffsetShape *_wrap_new_BRepOffsetAPI_MakeOffsetShape__SWIG_6 (TopoDS_Shape *larg1, Standard_Real larg2, Standard_Real larg3) {
  BRepOffsetAPI_MakeOffsetShape * lresult = (BRepOffsetAPI_MakeOffsetShape *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  BRepOffsetAPI_MakeOffsetShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_MakeOffsetShape *)new BRepOffsetAPI_MakeOffsetShape((TopoDS_Shape const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_MakeOffsetShape\n  * wrapname: _wrap_new_BRepOffsetAPI_MakeOffsetShape__SWIG_6\n  * fulldecl: BRepOffsetAPI_MakeOffsetShape::BRepOffsetAPI_MakeOffsetShape(TopoDS_Shape const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_MakeOffsetShape *)0;
  }
}


EXPORT void _wrap_delete_BRepOffsetAPI_MakeOffsetShape (BRepOffsetAPI_MakeOffsetShape *larg1) {
  BRepOffsetAPI_MakeOffsetShape *arg1 = (BRepOffsetAPI_MakeOffsetShape *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepOffsetAPI_MakeOffsetShape\n  * wrapname: _wrap_delete_BRepOffsetAPI_MakeOffsetShape\n  * fulldecl: BRepOffsetAPI_MakeOffsetShape::~BRepOffsetAPI_MakeOffsetShape()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <BRepOffsetAPI_MakeThickSolid.hxx>
  
EXPORT BRepOffsetAPI_MakeThickSolid *_wrap_new_BRepOffsetAPI_MakeThickSolid__SWIG_0 () {
  BRepOffsetAPI_MakeThickSolid * lresult = (BRepOffsetAPI_MakeThickSolid *)0 ;
  BRepOffsetAPI_MakeThickSolid *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_MakeThickSolid *)new BRepOffsetAPI_MakeThickSolid();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_MakeThickSolid\n  * wrapname: _wrap_new_BRepOffsetAPI_MakeThickSolid__SWIG_0\n  * fulldecl: BRepOffsetAPI_MakeThickSolid::BRepOffsetAPI_MakeThickSolid()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_MakeThickSolid *)0;
  }
}


EXPORT BRepOffsetAPI_MakeThickSolid *_wrap_new_BRepOffsetAPI_MakeThickSolid__SWIG_1 (TopoDS_Shape *larg1, TopTools_ListOfShape *larg2, Standard_Real larg3, Standard_Real larg4, BRepOffset_Mode const *larg5, bool larg6, bool larg7, GeomAbs_JoinType const *larg8, bool larg9) {
  BRepOffsetAPI_MakeThickSolid * lresult = (BRepOffsetAPI_MakeThickSolid *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  TopTools_ListOfShape *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  BRepOffset_Mode arg5 ;
  Standard_Boolean arg6 ;
  Standard_Boolean arg7 ;
  GeomAbs_JoinType arg8 ;
  Standard_Boolean arg9 ;
  BRepOffsetAPI_MakeThickSolid *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = *larg5;
  arg6 = (bool)larg6;
  arg7 = (bool)larg7;
  arg8 = *larg8;
  arg9 = (bool)larg9;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_MakeThickSolid *)new BRepOffsetAPI_MakeThickSolid((TopoDS_Shape const &)*arg1,(TopTools_ListOfShape const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_MakeThickSolid\n  * wrapname: _wrap_new_BRepOffsetAPI_MakeThickSolid__SWIG_1\n  * fulldecl: BRepOffsetAPI_MakeThickSolid::BRepOffsetAPI_MakeThickSolid(TopoDS_Shape const &,TopTools_ListOfShape const &,Standard_Real const,Standard_Real const,BRepOffset_Mode const,Standard_Boolean const,Standard_Boolean const,GeomAbs_JoinType const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_MakeThickSolid *)0;
  }
}


EXPORT BRepOffsetAPI_MakeThickSolid *_wrap_new_BRepOffsetAPI_MakeThickSolid__SWIG_2 (TopoDS_Shape *larg1, TopTools_ListOfShape *larg2, Standard_Real larg3, Standard_Real larg4, BRepOffset_Mode const *larg5, bool larg6, bool larg7, GeomAbs_JoinType const *larg8) {
  BRepOffsetAPI_MakeThickSolid * lresult = (BRepOffsetAPI_MakeThickSolid *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  TopTools_ListOfShape *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  BRepOffset_Mode arg5 ;
  Standard_Boolean arg6 ;
  Standard_Boolean arg7 ;
  GeomAbs_JoinType arg8 ;
  BRepOffsetAPI_MakeThickSolid *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = *larg5;
  arg6 = (bool)larg6;
  arg7 = (bool)larg7;
  arg8 = *larg8;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_MakeThickSolid *)new BRepOffsetAPI_MakeThickSolid((TopoDS_Shape const &)*arg1,(TopTools_ListOfShape const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_MakeThickSolid\n  * wrapname: _wrap_new_BRepOffsetAPI_MakeThickSolid__SWIG_2\n  * fulldecl: BRepOffsetAPI_MakeThickSolid::BRepOffsetAPI_MakeThickSolid(TopoDS_Shape const &,TopTools_ListOfShape const &,Standard_Real const,Standard_Real const,BRepOffset_Mode const,Standard_Boolean const,Standard_Boolean const,GeomAbs_JoinType const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_MakeThickSolid *)0;
  }
}


EXPORT BRepOffsetAPI_MakeThickSolid *_wrap_new_BRepOffsetAPI_MakeThickSolid__SWIG_3 (TopoDS_Shape *larg1, TopTools_ListOfShape *larg2, Standard_Real larg3, Standard_Real larg4, BRepOffset_Mode const *larg5, bool larg6, bool larg7) {
  BRepOffsetAPI_MakeThickSolid * lresult = (BRepOffsetAPI_MakeThickSolid *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  TopTools_ListOfShape *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  BRepOffset_Mode arg5 ;
  Standard_Boolean arg6 ;
  Standard_Boolean arg7 ;
  BRepOffsetAPI_MakeThickSolid *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = *larg5;
  arg6 = (bool)larg6;
  arg7 = (bool)larg7;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_MakeThickSolid *)new BRepOffsetAPI_MakeThickSolid((TopoDS_Shape const &)*arg1,(TopTools_ListOfShape const &)*arg2,arg3,arg4,arg5,arg6,arg7);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_MakeThickSolid\n  * wrapname: _wrap_new_BRepOffsetAPI_MakeThickSolid__SWIG_3\n  * fulldecl: BRepOffsetAPI_MakeThickSolid::BRepOffsetAPI_MakeThickSolid(TopoDS_Shape const &,TopTools_ListOfShape const &,Standard_Real const,Standard_Real const,BRepOffset_Mode const,Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_MakeThickSolid *)0;
  }
}


EXPORT BRepOffsetAPI_MakeThickSolid *_wrap_new_BRepOffsetAPI_MakeThickSolid__SWIG_4 (TopoDS_Shape *larg1, TopTools_ListOfShape *larg2, Standard_Real larg3, Standard_Real larg4, BRepOffset_Mode const *larg5, bool larg6) {
  BRepOffsetAPI_MakeThickSolid * lresult = (BRepOffsetAPI_MakeThickSolid *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  TopTools_ListOfShape *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  BRepOffset_Mode arg5 ;
  Standard_Boolean arg6 ;
  BRepOffsetAPI_MakeThickSolid *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = *larg5;
  arg6 = (bool)larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_MakeThickSolid *)new BRepOffsetAPI_MakeThickSolid((TopoDS_Shape const &)*arg1,(TopTools_ListOfShape const &)*arg2,arg3,arg4,arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_MakeThickSolid\n  * wrapname: _wrap_new_BRepOffsetAPI_MakeThickSolid__SWIG_4\n  * fulldecl: BRepOffsetAPI_MakeThickSolid::BRepOffsetAPI_MakeThickSolid(TopoDS_Shape const &,TopTools_ListOfShape const &,Standard_Real const,Standard_Real const,BRepOffset_Mode const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_MakeThickSolid *)0;
  }
}


EXPORT BRepOffsetAPI_MakeThickSolid *_wrap_new_BRepOffsetAPI_MakeThickSolid__SWIG_5 (TopoDS_Shape *larg1, TopTools_ListOfShape *larg2, Standard_Real larg3, Standard_Real larg4, BRepOffset_Mode const *larg5) {
  BRepOffsetAPI_MakeThickSolid * lresult = (BRepOffsetAPI_MakeThickSolid *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  TopTools_ListOfShape *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  BRepOffset_Mode arg5 ;
  BRepOffsetAPI_MakeThickSolid *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = *larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_MakeThickSolid *)new BRepOffsetAPI_MakeThickSolid((TopoDS_Shape const &)*arg1,(TopTools_ListOfShape const &)*arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_MakeThickSolid\n  * wrapname: _wrap_new_BRepOffsetAPI_MakeThickSolid__SWIG_5\n  * fulldecl: BRepOffsetAPI_MakeThickSolid::BRepOffsetAPI_MakeThickSolid(TopoDS_Shape const &,TopTools_ListOfShape const &,Standard_Real const,Standard_Real const,BRepOffset_Mode const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_MakeThickSolid *)0;
  }
}


EXPORT BRepOffsetAPI_MakeThickSolid *_wrap_new_BRepOffsetAPI_MakeThickSolid__SWIG_6 (TopoDS_Shape *larg1, TopTools_ListOfShape *larg2, Standard_Real larg3, Standard_Real larg4) {
  BRepOffsetAPI_MakeThickSolid * lresult = (BRepOffsetAPI_MakeThickSolid *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  TopTools_ListOfShape *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  BRepOffsetAPI_MakeThickSolid *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_MakeThickSolid *)new BRepOffsetAPI_MakeThickSolid((TopoDS_Shape const &)*arg1,(TopTools_ListOfShape const &)*arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_MakeThickSolid\n  * wrapname: _wrap_new_BRepOffsetAPI_MakeThickSolid__SWIG_6\n  * fulldecl: BRepOffsetAPI_MakeThickSolid::BRepOffsetAPI_MakeThickSolid(TopoDS_Shape const &,TopTools_ListOfShape const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_MakeThickSolid *)0;
  }
}


EXPORT void _wrap_BRepOffsetAPI_MakeThickSolid_Build (BRepOffsetAPI_MakeThickSolid *larg1) {
  BRepOffsetAPI_MakeThickSolid *arg1 = (BRepOffsetAPI_MakeThickSolid *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Build();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_MakeThickSolid_Build\n  * wrapname: _wrap_BRepOffsetAPI_MakeThickSolid_Build\n  * fulldecl: void BRepOffsetAPI_MakeThickSolid::Build()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopTools_ListOfShape *_wrap_BRepOffsetAPI_MakeThickSolid_Modified (BRepOffsetAPI_MakeThickSolid *larg1, TopoDS_Shape *larg2) {
  TopTools_ListOfShape * lresult = (TopTools_ListOfShape *)0 ;
  BRepOffsetAPI_MakeThickSolid *arg1 = (BRepOffsetAPI_MakeThickSolid *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopTools_ListOfShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopTools_ListOfShape *) &(arg1)->Modified((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_MakeThickSolid_Modified\n  * wrapname: _wrap_BRepOffsetAPI_MakeThickSolid_Modified\n  * fulldecl: TopTools_ListOfShape const & BRepOffsetAPI_MakeThickSolid::Modified(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopTools_ListOfShape *)0;
  }
}


EXPORT void _wrap_delete_BRepOffsetAPI_MakeThickSolid (BRepOffsetAPI_MakeThickSolid *larg1) {
  BRepOffsetAPI_MakeThickSolid *arg1 = (BRepOffsetAPI_MakeThickSolid *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepOffsetAPI_MakeThickSolid\n  * wrapname: _wrap_delete_BRepOffsetAPI_MakeThickSolid\n  * fulldecl: BRepOffsetAPI_MakeThickSolid::~BRepOffsetAPI_MakeThickSolid()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <BRepOffsetAPI_ThruSections.hxx>
  
EXPORT BRepOffsetAPI_ThruSections *_wrap_new_BRepOffsetAPI_ThruSections__SWIG_0 (bool larg1, bool larg2, Standard_Real larg3) {
  BRepOffsetAPI_ThruSections * lresult = (BRepOffsetAPI_ThruSections *)0 ;
  Standard_Boolean arg1 ;
  Standard_Boolean arg2 ;
  Standard_Real arg3 ;
  BRepOffsetAPI_ThruSections *result = 0 ;
  
  arg1 = (bool)larg1;
  arg2 = (bool)larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_ThruSections *)new BRepOffsetAPI_ThruSections(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_ThruSections\n  * wrapname: _wrap_new_BRepOffsetAPI_ThruSections__SWIG_0\n  * fulldecl: BRepOffsetAPI_ThruSections::BRepOffsetAPI_ThruSections(Standard_Boolean const,Standard_Boolean const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_ThruSections *)0;
  }
}


EXPORT BRepOffsetAPI_ThruSections *_wrap_new_BRepOffsetAPI_ThruSections__SWIG_1 (bool larg1, bool larg2) {
  BRepOffsetAPI_ThruSections * lresult = (BRepOffsetAPI_ThruSections *)0 ;
  Standard_Boolean arg1 ;
  Standard_Boolean arg2 ;
  BRepOffsetAPI_ThruSections *result = 0 ;
  
  arg1 = (bool)larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_ThruSections *)new BRepOffsetAPI_ThruSections(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_ThruSections\n  * wrapname: _wrap_new_BRepOffsetAPI_ThruSections__SWIG_1\n  * fulldecl: BRepOffsetAPI_ThruSections::BRepOffsetAPI_ThruSections(Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_ThruSections *)0;
  }
}


EXPORT BRepOffsetAPI_ThruSections *_wrap_new_BRepOffsetAPI_ThruSections__SWIG_2 (bool larg1) {
  BRepOffsetAPI_ThruSections * lresult = (BRepOffsetAPI_ThruSections *)0 ;
  Standard_Boolean arg1 ;
  BRepOffsetAPI_ThruSections *result = 0 ;
  
  arg1 = (bool)larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_ThruSections *)new BRepOffsetAPI_ThruSections(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_ThruSections\n  * wrapname: _wrap_new_BRepOffsetAPI_ThruSections__SWIG_2\n  * fulldecl: BRepOffsetAPI_ThruSections::BRepOffsetAPI_ThruSections(Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_ThruSections *)0;
  }
}


EXPORT BRepOffsetAPI_ThruSections *_wrap_new_BRepOffsetAPI_ThruSections__SWIG_3 () {
  BRepOffsetAPI_ThruSections * lresult = (BRepOffsetAPI_ThruSections *)0 ;
  BRepOffsetAPI_ThruSections *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_ThruSections *)new BRepOffsetAPI_ThruSections();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_ThruSections\n  * wrapname: _wrap_new_BRepOffsetAPI_ThruSections__SWIG_3\n  * fulldecl: BRepOffsetAPI_ThruSections::BRepOffsetAPI_ThruSections()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_ThruSections *)0;
  }
}


EXPORT void _wrap_BRepOffsetAPI_ThruSections_Init__SWIG_0 (BRepOffsetAPI_ThruSections *larg1, bool larg2, bool larg3, Standard_Real larg4) {
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  Standard_Boolean arg2 ;
  Standard_Boolean arg3 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  arg3 = (bool)larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init(arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_Init\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_Init__SWIG_0\n  * fulldecl: void BRepOffsetAPI_ThruSections::Init(Standard_Boolean const,Standard_Boolean const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_ThruSections_Init__SWIG_1 (BRepOffsetAPI_ThruSections *larg1, bool larg2, bool larg3) {
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  Standard_Boolean arg2 ;
  Standard_Boolean arg3 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init(arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_Init\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_Init__SWIG_1\n  * fulldecl: void BRepOffsetAPI_ThruSections::Init(Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_ThruSections_Init__SWIG_2 (BRepOffsetAPI_ThruSections *larg1, bool larg2) {
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  Standard_Boolean arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_Init\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_Init__SWIG_2\n  * fulldecl: void BRepOffsetAPI_ThruSections::Init(Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_ThruSections_Init__SWIG_3 (BRepOffsetAPI_ThruSections *larg1) {
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_Init\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_Init__SWIG_3\n  * fulldecl: void BRepOffsetAPI_ThruSections::Init()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_ThruSections_AddWire (BRepOffsetAPI_ThruSections *larg1, TopoDS_Wire *larg2) {
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  TopoDS_Wire *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->AddWire((TopoDS_Wire const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_AddWire\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_AddWire\n  * fulldecl: void BRepOffsetAPI_ThruSections::AddWire(TopoDS_Wire const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_ThruSections_AddVertex (BRepOffsetAPI_ThruSections *larg1, TopoDS_Vertex *larg2) {
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->AddVertex((TopoDS_Vertex const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_AddVertex\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_AddVertex\n  * fulldecl: void BRepOffsetAPI_ThruSections::AddVertex(TopoDS_Vertex const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_ThruSections_CheckCompatibility__SWIG_0 (BRepOffsetAPI_ThruSections *larg1, bool larg2) {
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  Standard_Boolean arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->CheckCompatibility(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_CheckCompatibility\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_CheckCompatibility__SWIG_0\n  * fulldecl: void BRepOffsetAPI_ThruSections::CheckCompatibility(Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_ThruSections_CheckCompatibility__SWIG_1 (BRepOffsetAPI_ThruSections *larg1) {
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->CheckCompatibility();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_CheckCompatibility\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_CheckCompatibility__SWIG_1\n  * fulldecl: void BRepOffsetAPI_ThruSections::CheckCompatibility()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_ThruSections_SetSmoothing (BRepOffsetAPI_ThruSections *larg1, bool larg2) {
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  Standard_Boolean arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetSmoothing(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_SetSmoothing\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_SetSmoothing\n  * fulldecl: void BRepOffsetAPI_ThruSections::SetSmoothing(Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_ThruSections_SetParType (BRepOffsetAPI_ThruSections *larg1, Approx_ParametrizationType const *larg2) {
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  Approx_ParametrizationType arg2 ;
  
  arg1 = larg1;
  arg2 = *larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetParType(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_SetParType\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_SetParType\n  * fulldecl: void BRepOffsetAPI_ThruSections::SetParType(Approx_ParametrizationType const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_ThruSections_SetContinuity (BRepOffsetAPI_ThruSections *larg1, GeomAbs_Shape larg2) {
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  GeomAbs_Shape arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetContinuity(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_SetContinuity\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_SetContinuity\n  * fulldecl: void BRepOffsetAPI_ThruSections::SetContinuity(GeomAbs_Shape const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_ThruSections_SetCriteriumWeight (BRepOffsetAPI_ThruSections *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4) {
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetCriteriumWeight(arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_SetCriteriumWeight\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_SetCriteriumWeight\n  * fulldecl: void BRepOffsetAPI_ThruSections::SetCriteriumWeight(Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepOffsetAPI_ThruSections_SetMaxDegree (BRepOffsetAPI_ThruSections *larg1, Standard_Integer larg2) {
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  Standard_Integer arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetMaxDegree(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_SetMaxDegree\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_SetMaxDegree\n  * fulldecl: void BRepOffsetAPI_ThruSections::SetMaxDegree(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Approx_ParametrizationType *_wrap_BRepOffsetAPI_ThruSections_ParType (BRepOffsetAPI_ThruSections *larg1) {
  Approx_ParametrizationType * lresult = (Approx_ParametrizationType *)0 ;
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  Approx_ParametrizationType result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((BRepOffsetAPI_ThruSections const *)arg1)->ParType();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_ParType\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_ParType\n  * fulldecl: Approx_ParametrizationType BRepOffsetAPI_ThruSections::ParType() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Approx_ParametrizationType(result);
    return lresult;
  } catch (...) {
    return (Approx_ParametrizationType *)0;
  }
}


EXPORT GeomAbs_Shape _wrap_BRepOffsetAPI_ThruSections_Continuity (BRepOffsetAPI_ThruSections *larg1) {
  GeomAbs_Shape lresult = (GeomAbs_Shape)0 ;
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  GeomAbs_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAbs_Shape)((BRepOffsetAPI_ThruSections const *)arg1)->Continuity();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_Continuity\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_Continuity\n  * fulldecl: GeomAbs_Shape BRepOffsetAPI_ThruSections::Continuity() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAbs_Shape)0;
  }
}


EXPORT Standard_Integer _wrap_BRepOffsetAPI_ThruSections_MaxDegree (BRepOffsetAPI_ThruSections *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((BRepOffsetAPI_ThruSections const *)arg1)->MaxDegree();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_MaxDegree\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_MaxDegree\n  * fulldecl: Standard_Integer BRepOffsetAPI_ThruSections::MaxDegree() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT bool _wrap_BRepOffsetAPI_ThruSections_UseSmoothing (BRepOffsetAPI_ThruSections *larg1) {
  bool lresult = (bool)0 ;
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepOffsetAPI_ThruSections const *)arg1)->UseSmoothing();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_UseSmoothing\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_UseSmoothing\n  * fulldecl: Standard_Boolean BRepOffsetAPI_ThruSections::UseSmoothing() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_BRepOffsetAPI_ThruSections_CriteriumWeight (BRepOffsetAPI_ThruSections *larg1, Standard_Real *larg2, Standard_Real *larg3, Standard_Real *larg4) {
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((BRepOffsetAPI_ThruSections const *)arg1)->CriteriumWeight(*arg2,*arg3,*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_CriteriumWeight\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_CriteriumWeight\n  * fulldecl: void BRepOffsetAPI_ThruSections::CriteriumWeight(Standard_Real &,Standard_Real &,Standard_Real &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopoDS_Shape *_wrap_BRepOffsetAPI_ThruSections_FirstShape (BRepOffsetAPI_ThruSections *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &((BRepOffsetAPI_ThruSections const *)arg1)->FirstShape();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_FirstShape\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_FirstShape\n  * fulldecl: TopoDS_Shape const & BRepOffsetAPI_ThruSections::FirstShape() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT TopoDS_Shape *_wrap_BRepOffsetAPI_ThruSections_LastShape (BRepOffsetAPI_ThruSections *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &((BRepOffsetAPI_ThruSections const *)arg1)->LastShape();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_LastShape\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_LastShape\n  * fulldecl: TopoDS_Shape const & BRepOffsetAPI_ThruSections::LastShape() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT TopoDS_Shape *_wrap_BRepOffsetAPI_ThruSections_GeneratedFace (BRepOffsetAPI_ThruSections *larg1, TopoDS_Shape *larg2) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopoDS_Shape result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((BRepOffsetAPI_ThruSections const *)arg1)->GeneratedFace((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepOffsetAPI_ThruSections_GeneratedFace\n  * wrapname: _wrap_BRepOffsetAPI_ThruSections_GeneratedFace\n  * fulldecl: TopoDS_Shape BRepOffsetAPI_ThruSections::GeneratedFace(TopoDS_Shape const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new TopoDS_Shape(result);
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT void _wrap_delete_BRepOffsetAPI_ThruSections (BRepOffsetAPI_ThruSections *larg1) {
  BRepOffsetAPI_ThruSections *arg1 = (BRepOffsetAPI_ThruSections *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepOffsetAPI_ThruSections\n  * wrapname: _wrap_delete_BRepOffsetAPI_ThruSections\n  * fulldecl: BRepOffsetAPI_ThruSections::~BRepOffsetAPI_ThruSections()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <BRepPrimAPI_MakeBox.hxx>
#include <BRepPrimAPI_MakeCone.hxx>
#include <BRepPrimAPI_MakeBox.hxx>
#include <BRepPrimAPI_MakeTorus.hxx>
#include <BRepPrimAPI_MakeCylinder.hxx>
#include <BRepPrimAPI_MakeSphere.hxx>
#include <BRepPrimAPI_MakePrism.hxx>
#include <BRepPrimAPI_MakeRevol.hxx>
#include <BRepOffsetAPI_MakePipe.hxx>

EXPORT BRepPrimAPI_MakeBox *_wrap_new_BRepPrimAPI_MakeBox (gp_Pnt *larg1, gp_Pnt *larg2) {
  BRepPrimAPI_MakeBox * lresult = (BRepPrimAPI_MakeBox *)0 ;
  gp_Pnt *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  BRepPrimAPI_MakeBox *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakeBox *)new BRepPrimAPI_MakeBox((gp_Pnt const &)*arg1,(gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakeBox\n  * wrapname: _wrap_new_BRepPrimAPI_MakeBox\n  * fulldecl: BRepPrimAPI_MakeBox::BRepPrimAPI_MakeBox(gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakeBox *)0;
  }
}


EXPORT void _wrap_delete_BRepPrimAPI_MakeBox (BRepPrimAPI_MakeBox *larg1) {
  BRepPrimAPI_MakeBox *arg1 = (BRepPrimAPI_MakeBox *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepPrimAPI_MakeBox\n  * wrapname: _wrap_delete_BRepPrimAPI_MakeBox\n  * fulldecl: BRepPrimAPI_MakeBox::~BRepPrimAPI_MakeBox()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepPrimAPI_MakeCone *_wrap_new_BRepPrimAPI_MakeCone (gp_Ax2 *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5) {
  BRepPrimAPI_MakeCone * lresult = (BRepPrimAPI_MakeCone *)0 ;
  gp_Ax2 *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  BRepPrimAPI_MakeCone *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakeCone *)new BRepPrimAPI_MakeCone((gp_Ax2 const &)*arg1,arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakeCone\n  * wrapname: _wrap_new_BRepPrimAPI_MakeCone\n  * fulldecl: BRepPrimAPI_MakeCone::BRepPrimAPI_MakeCone(gp_Ax2 const &,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakeCone *)0;
  }
}


EXPORT void _wrap_delete_BRepPrimAPI_MakeCone (BRepPrimAPI_MakeCone *larg1) {
  BRepPrimAPI_MakeCone *arg1 = (BRepPrimAPI_MakeCone *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepPrimAPI_MakeCone\n  * wrapname: _wrap_delete_BRepPrimAPI_MakeCone\n  * fulldecl: BRepPrimAPI_MakeCone::~BRepPrimAPI_MakeCone()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepPrimAPI_MakeCylinder *_wrap_new_BRepPrimAPI_MakeCylinder__SWIG_0 (Standard_Real larg1, Standard_Real larg2) {
  BRepPrimAPI_MakeCylinder * lresult = (BRepPrimAPI_MakeCylinder *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  BRepPrimAPI_MakeCylinder *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakeCylinder *)new BRepPrimAPI_MakeCylinder(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakeCylinder\n  * wrapname: _wrap_new_BRepPrimAPI_MakeCylinder__SWIG_0\n  * fulldecl: BRepPrimAPI_MakeCylinder::BRepPrimAPI_MakeCylinder(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakeCylinder *)0;
  }
}


EXPORT BRepPrimAPI_MakeCylinder *_wrap_new_BRepPrimAPI_MakeCylinder__SWIG_1 (Standard_Real larg1, Standard_Real larg2, Standard_Real larg3) {
  BRepPrimAPI_MakeCylinder * lresult = (BRepPrimAPI_MakeCylinder *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  BRepPrimAPI_MakeCylinder *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakeCylinder *)new BRepPrimAPI_MakeCylinder(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakeCylinder\n  * wrapname: _wrap_new_BRepPrimAPI_MakeCylinder__SWIG_1\n  * fulldecl: BRepPrimAPI_MakeCylinder::BRepPrimAPI_MakeCylinder(Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakeCylinder *)0;
  }
}


EXPORT BRepPrimAPI_MakeCylinder *_wrap_new_BRepPrimAPI_MakeCylinder__SWIG_2 (gp_Ax2 *larg1, Standard_Real larg2, Standard_Real larg3) {
  BRepPrimAPI_MakeCylinder * lresult = (BRepPrimAPI_MakeCylinder *)0 ;
  gp_Ax2 *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  BRepPrimAPI_MakeCylinder *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakeCylinder *)new BRepPrimAPI_MakeCylinder((gp_Ax2 const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakeCylinder\n  * wrapname: _wrap_new_BRepPrimAPI_MakeCylinder__SWIG_2\n  * fulldecl: BRepPrimAPI_MakeCylinder::BRepPrimAPI_MakeCylinder(gp_Ax2 const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakeCylinder *)0;
  }
}


EXPORT BRepPrimAPI_MakeCylinder *_wrap_new_BRepPrimAPI_MakeCylinder__SWIG_3 (gp_Ax2 *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4) {
  BRepPrimAPI_MakeCylinder * lresult = (BRepPrimAPI_MakeCylinder *)0 ;
  gp_Ax2 *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  BRepPrimAPI_MakeCylinder *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakeCylinder *)new BRepPrimAPI_MakeCylinder((gp_Ax2 const &)*arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakeCylinder\n  * wrapname: _wrap_new_BRepPrimAPI_MakeCylinder__SWIG_3\n  * fulldecl: BRepPrimAPI_MakeCylinder::BRepPrimAPI_MakeCylinder(gp_Ax2 const &,Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakeCylinder *)0;
  }
}


EXPORT void _wrap_delete_BRepPrimAPI_MakeCylinder (BRepPrimAPI_MakeCylinder *larg1) {
  BRepPrimAPI_MakeCylinder *arg1 = (BRepPrimAPI_MakeCylinder *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepPrimAPI_MakeCylinder\n  * wrapname: _wrap_delete_BRepPrimAPI_MakeCylinder\n  * fulldecl: BRepPrimAPI_MakeCylinder::~BRepPrimAPI_MakeCylinder()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepPrimAPI_MakeTorus *_wrap_new_BRepPrimAPI_MakeTorus__SWIG_0 (gp_Ax2 *larg1, Standard_Real larg2, Standard_Real larg3) {
  BRepPrimAPI_MakeTorus * lresult = (BRepPrimAPI_MakeTorus *)0 ;
  gp_Ax2 *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  BRepPrimAPI_MakeTorus *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakeTorus *)new BRepPrimAPI_MakeTorus((gp_Ax2 const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakeTorus\n  * wrapname: _wrap_new_BRepPrimAPI_MakeTorus__SWIG_0\n  * fulldecl: BRepPrimAPI_MakeTorus::BRepPrimAPI_MakeTorus(gp_Ax2 const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakeTorus *)0;
  }
}


EXPORT BRepPrimAPI_MakeTorus *_wrap_new_BRepPrimAPI_MakeTorus__SWIG_1 (gp_Ax2 *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5, Standard_Real larg6) {
  BRepPrimAPI_MakeTorus * lresult = (BRepPrimAPI_MakeTorus *)0 ;
  gp_Ax2 *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  Standard_Real arg6 ;
  BRepPrimAPI_MakeTorus *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakeTorus *)new BRepPrimAPI_MakeTorus((gp_Ax2 const &)*arg1,arg2,arg3,arg4,arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakeTorus\n  * wrapname: _wrap_new_BRepPrimAPI_MakeTorus__SWIG_1\n  * fulldecl: BRepPrimAPI_MakeTorus::BRepPrimAPI_MakeTorus(gp_Ax2 const &,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakeTorus *)0;
  }
}


EXPORT void _wrap_delete_BRepPrimAPI_MakeTorus (BRepPrimAPI_MakeTorus *larg1) {
  BRepPrimAPI_MakeTorus *arg1 = (BRepPrimAPI_MakeTorus *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepPrimAPI_MakeTorus\n  * wrapname: _wrap_delete_BRepPrimAPI_MakeTorus\n  * fulldecl: BRepPrimAPI_MakeTorus::~BRepPrimAPI_MakeTorus()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepPrimAPI_MakeSphere *_wrap_new_BRepPrimAPI_MakeSphere__SWIG_0 (gp_Pnt *larg1, Standard_Real larg2) {
  BRepPrimAPI_MakeSphere * lresult = (BRepPrimAPI_MakeSphere *)0 ;
  gp_Pnt *arg1 = 0 ;
  Standard_Real arg2 ;
  BRepPrimAPI_MakeSphere *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakeSphere *)new BRepPrimAPI_MakeSphere((gp_Pnt const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakeSphere\n  * wrapname: _wrap_new_BRepPrimAPI_MakeSphere__SWIG_0\n  * fulldecl: BRepPrimAPI_MakeSphere::BRepPrimAPI_MakeSphere(gp_Pnt const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakeSphere *)0;
  }
}


EXPORT BRepPrimAPI_MakeSphere *_wrap_new_BRepPrimAPI_MakeSphere__SWIG_1 (gp_Ax2 *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5) {
  BRepPrimAPI_MakeSphere * lresult = (BRepPrimAPI_MakeSphere *)0 ;
  gp_Ax2 *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  BRepPrimAPI_MakeSphere *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakeSphere *)new BRepPrimAPI_MakeSphere((gp_Ax2 const &)*arg1,arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakeSphere\n  * wrapname: _wrap_new_BRepPrimAPI_MakeSphere__SWIG_1\n  * fulldecl: BRepPrimAPI_MakeSphere::BRepPrimAPI_MakeSphere(gp_Ax2 const &,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakeSphere *)0;
  }
}


EXPORT void _wrap_delete_BRepPrimAPI_MakeSphere (BRepPrimAPI_MakeSphere *larg1) {
  BRepPrimAPI_MakeSphere *arg1 = (BRepPrimAPI_MakeSphere *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepPrimAPI_MakeSphere\n  * wrapname: _wrap_delete_BRepPrimAPI_MakeSphere\n  * fulldecl: BRepPrimAPI_MakeSphere::~BRepPrimAPI_MakeSphere()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_BRepPrimAPI_MakeSweep (BRepPrimAPI_MakeSweep *larg1) {
  BRepPrimAPI_MakeSweep *arg1 = (BRepPrimAPI_MakeSweep *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepPrimAPI_MakeSweep\n  * wrapname: _wrap_delete_BRepPrimAPI_MakeSweep\n  * fulldecl: BRepPrimAPI_MakeSweep::~BRepPrimAPI_MakeSweep()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepPrimAPI_MakePrism *_wrap_new_BRepPrimAPI_MakePrism__SWIG_0 (TopoDS_Shape *larg1, gp_Vec *larg2, bool larg3, bool larg4) {
  BRepPrimAPI_MakePrism * lresult = (BRepPrimAPI_MakePrism *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  gp_Vec *arg2 = 0 ;
  Standard_Boolean arg3 ;
  Standard_Boolean arg4 ;
  BRepPrimAPI_MakePrism *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakePrism *)new BRepPrimAPI_MakePrism((TopoDS_Shape const &)*arg1,(gp_Vec const &)*arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakePrism\n  * wrapname: _wrap_new_BRepPrimAPI_MakePrism__SWIG_0\n  * fulldecl: BRepPrimAPI_MakePrism::BRepPrimAPI_MakePrism(TopoDS_Shape const &,gp_Vec const &,Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakePrism *)0;
  }
}


EXPORT BRepPrimAPI_MakePrism *_wrap_new_BRepPrimAPI_MakePrism__SWIG_1 (TopoDS_Shape *larg1, gp_Vec *larg2, bool larg3) {
  BRepPrimAPI_MakePrism * lresult = (BRepPrimAPI_MakePrism *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  gp_Vec *arg2 = 0 ;
  Standard_Boolean arg3 ;
  BRepPrimAPI_MakePrism *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakePrism *)new BRepPrimAPI_MakePrism((TopoDS_Shape const &)*arg1,(gp_Vec const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakePrism\n  * wrapname: _wrap_new_BRepPrimAPI_MakePrism__SWIG_1\n  * fulldecl: BRepPrimAPI_MakePrism::BRepPrimAPI_MakePrism(TopoDS_Shape const &,gp_Vec const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakePrism *)0;
  }
}


EXPORT BRepPrimAPI_MakePrism *_wrap_new_BRepPrimAPI_MakePrism__SWIG_2 (TopoDS_Shape *larg1, gp_Vec *larg2) {
  BRepPrimAPI_MakePrism * lresult = (BRepPrimAPI_MakePrism *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  gp_Vec *arg2 = 0 ;
  BRepPrimAPI_MakePrism *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakePrism *)new BRepPrimAPI_MakePrism((TopoDS_Shape const &)*arg1,(gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakePrism\n  * wrapname: _wrap_new_BRepPrimAPI_MakePrism__SWIG_2\n  * fulldecl: BRepPrimAPI_MakePrism::BRepPrimAPI_MakePrism(TopoDS_Shape const &,gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakePrism *)0;
  }
}


EXPORT void _wrap_delete_BRepPrimAPI_MakePrism (BRepPrimAPI_MakePrism *larg1) {
  BRepPrimAPI_MakePrism *arg1 = (BRepPrimAPI_MakePrism *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepPrimAPI_MakePrism\n  * wrapname: _wrap_delete_BRepPrimAPI_MakePrism\n  * fulldecl: BRepPrimAPI_MakePrism::~BRepPrimAPI_MakePrism()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepPrimAPI_MakeRevol *_wrap_new_BRepPrimAPI_MakeRevol__SWIG_0 (TopoDS_Shape *larg1, gp_Ax1 *larg2, Standard_Real larg3, bool larg4) {
  BRepPrimAPI_MakeRevol * lresult = (BRepPrimAPI_MakeRevol *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean arg4 ;
  BRepPrimAPI_MakeRevol *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakeRevol *)new BRepPrimAPI_MakeRevol((TopoDS_Shape const &)*arg1,(gp_Ax1 const &)*arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakeRevol\n  * wrapname: _wrap_new_BRepPrimAPI_MakeRevol__SWIG_0\n  * fulldecl: BRepPrimAPI_MakeRevol::BRepPrimAPI_MakeRevol(TopoDS_Shape const &,gp_Ax1 const &,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakeRevol *)0;
  }
}


EXPORT BRepPrimAPI_MakeRevol *_wrap_new_BRepPrimAPI_MakeRevol__SWIG_1 (TopoDS_Shape *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  BRepPrimAPI_MakeRevol * lresult = (BRepPrimAPI_MakeRevol *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  BRepPrimAPI_MakeRevol *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakeRevol *)new BRepPrimAPI_MakeRevol((TopoDS_Shape const &)*arg1,(gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakeRevol\n  * wrapname: _wrap_new_BRepPrimAPI_MakeRevol__SWIG_1\n  * fulldecl: BRepPrimAPI_MakeRevol::BRepPrimAPI_MakeRevol(TopoDS_Shape const &,gp_Ax1 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakeRevol *)0;
  }
}


EXPORT BRepPrimAPI_MakeRevol *_wrap_new_BRepPrimAPI_MakeRevol__SWIG_2 (TopoDS_Shape *larg1, gp_Ax1 *larg2, bool larg3) {
  BRepPrimAPI_MakeRevol * lresult = (BRepPrimAPI_MakeRevol *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Boolean arg3 ;
  BRepPrimAPI_MakeRevol *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakeRevol *)new BRepPrimAPI_MakeRevol((TopoDS_Shape const &)*arg1,(gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakeRevol\n  * wrapname: _wrap_new_BRepPrimAPI_MakeRevol__SWIG_2\n  * fulldecl: BRepPrimAPI_MakeRevol::BRepPrimAPI_MakeRevol(TopoDS_Shape const &,gp_Ax1 const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakeRevol *)0;
  }
}


EXPORT BRepPrimAPI_MakeRevol *_wrap_new_BRepPrimAPI_MakeRevol__SWIG_3 (TopoDS_Shape *larg1, gp_Ax1 *larg2) {
  BRepPrimAPI_MakeRevol * lresult = (BRepPrimAPI_MakeRevol *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  gp_Ax1 *arg2 = 0 ;
  BRepPrimAPI_MakeRevol *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepPrimAPI_MakeRevol *)new BRepPrimAPI_MakeRevol((TopoDS_Shape const &)*arg1,(gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepPrimAPI_MakeRevol\n  * wrapname: _wrap_new_BRepPrimAPI_MakeRevol__SWIG_3\n  * fulldecl: BRepPrimAPI_MakeRevol::BRepPrimAPI_MakeRevol(TopoDS_Shape const &,gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepPrimAPI_MakeRevol *)0;
  }
}


EXPORT void _wrap_delete_BRepPrimAPI_MakeRevol (BRepPrimAPI_MakeRevol *larg1) {
  BRepPrimAPI_MakeRevol *arg1 = (BRepPrimAPI_MakeRevol *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepPrimAPI_MakeRevol\n  * wrapname: _wrap_delete_BRepPrimAPI_MakeRevol\n  * fulldecl: BRepPrimAPI_MakeRevol::~BRepPrimAPI_MakeRevol()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepOffsetAPI_MakePipe *_wrap_new_BRepOffsetAPI_MakePipe (TopoDS_Wire *larg1, TopoDS_Shape *larg2) {
  BRepOffsetAPI_MakePipe * lresult = (BRepOffsetAPI_MakePipe *)0 ;
  TopoDS_Wire *arg1 = 0 ;
  TopoDS_Shape *arg2 = 0 ;
  BRepOffsetAPI_MakePipe *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepOffsetAPI_MakePipe *)new BRepOffsetAPI_MakePipe((TopoDS_Wire const &)*arg1,(TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepOffsetAPI_MakePipe\n  * wrapname: _wrap_new_BRepOffsetAPI_MakePipe\n  * fulldecl: BRepOffsetAPI_MakePipe::BRepOffsetAPI_MakePipe(TopoDS_Wire const &,TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepOffsetAPI_MakePipe *)0;
  }
}


EXPORT void _wrap_delete_BRepOffsetAPI_MakePipe (BRepOffsetAPI_MakePipe *larg1) {
  BRepOffsetAPI_MakePipe *arg1 = (BRepOffsetAPI_MakePipe *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepOffsetAPI_MakePipe\n  * wrapname: _wrap_delete_BRepOffsetAPI_MakePipe\n  * fulldecl: BRepOffsetAPI_MakePipe::~BRepOffsetAPI_MakePipe()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <BRepAlgoAPI_Algo.hxx>
#include <BRepAlgoAPI_BooleanOperation.hxx>
#include <BRepAlgoAPI_Fuse.hxx>
#include <BRepAlgoAPI_Common.hxx>
#include <BRepAlgoAPI_Cut.hxx>
#include <BRepAlgoAPI_Section.hxx>
     
EXPORT TopTools_ListOfShape *_wrap_BRepAlgoAPI_BooleanOperation_Modified (BRepAlgoAPI_BooleanOperation *larg1, TopoDS_Shape *larg2) {
  TopTools_ListOfShape * lresult = (TopTools_ListOfShape *)0 ;
  BRepAlgoAPI_BooleanOperation *arg1 = (BRepAlgoAPI_BooleanOperation *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopTools_ListOfShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopTools_ListOfShape *) &(arg1)->Modified((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepAlgoAPI_BooleanOperation_Modified\n  * wrapname: _wrap_BRepAlgoAPI_BooleanOperation_Modified\n  * fulldecl: TopTools_ListOfShape const & BRepAlgoAPI_BooleanOperation::Modified(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopTools_ListOfShape *)0;
  }
}


EXPORT bool _wrap_BRepAlgoAPI_BooleanOperation_IsDeleted (BRepAlgoAPI_BooleanOperation *larg1, TopoDS_Shape *larg2) {
  bool lresult = (bool)0 ;
  BRepAlgoAPI_BooleanOperation *arg1 = (BRepAlgoAPI_BooleanOperation *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->IsDeleted((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepAlgoAPI_BooleanOperation_IsDeleted\n  * wrapname: _wrap_BRepAlgoAPI_BooleanOperation_IsDeleted\n  * fulldecl: Standard_Boolean BRepAlgoAPI_BooleanOperation::IsDeleted(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT TopTools_ListOfShape *_wrap_BRepAlgoAPI_BooleanOperation_Generated (BRepAlgoAPI_BooleanOperation *larg1, TopoDS_Shape *larg2) {
  TopTools_ListOfShape * lresult = (TopTools_ListOfShape *)0 ;
  BRepAlgoAPI_BooleanOperation *arg1 = (BRepAlgoAPI_BooleanOperation *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopTools_ListOfShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopTools_ListOfShape *) &(arg1)->Generated((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepAlgoAPI_BooleanOperation_Generated\n  * wrapname: _wrap_BRepAlgoAPI_BooleanOperation_Generated\n  * fulldecl: TopTools_ListOfShape const & BRepAlgoAPI_BooleanOperation::Generated(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopTools_ListOfShape *)0;
  }
}


EXPORT bool _wrap_BRepAlgoAPI_BooleanOperation_HasModified (BRepAlgoAPI_BooleanOperation *larg1) {
  bool lresult = (bool)0 ;
  BRepAlgoAPI_BooleanOperation *arg1 = (BRepAlgoAPI_BooleanOperation *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepAlgoAPI_BooleanOperation const *)arg1)->HasModified();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepAlgoAPI_BooleanOperation_HasModified\n  * wrapname: _wrap_BRepAlgoAPI_BooleanOperation_HasModified\n  * fulldecl: Standard_Boolean BRepAlgoAPI_BooleanOperation::HasModified() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepAlgoAPI_BooleanOperation_HasGenerated (BRepAlgoAPI_BooleanOperation *larg1) {
  bool lresult = (bool)0 ;
  BRepAlgoAPI_BooleanOperation *arg1 = (BRepAlgoAPI_BooleanOperation *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepAlgoAPI_BooleanOperation const *)arg1)->HasGenerated();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepAlgoAPI_BooleanOperation_HasGenerated\n  * wrapname: _wrap_BRepAlgoAPI_BooleanOperation_HasGenerated\n  * fulldecl: Standard_Boolean BRepAlgoAPI_BooleanOperation::HasGenerated() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepAlgoAPI_BooleanOperation_HasDeleted (BRepAlgoAPI_BooleanOperation *larg1) {
  bool lresult = (bool)0 ;
  BRepAlgoAPI_BooleanOperation *arg1 = (BRepAlgoAPI_BooleanOperation *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepAlgoAPI_BooleanOperation const *)arg1)->HasDeleted();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepAlgoAPI_BooleanOperation_HasDeleted\n  * wrapname: _wrap_BRepAlgoAPI_BooleanOperation_HasDeleted\n  * fulldecl: Standard_Boolean BRepAlgoAPI_BooleanOperation::HasDeleted() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_delete_BRepAlgoAPI_BooleanOperation (BRepAlgoAPI_BooleanOperation *larg1) {
  BRepAlgoAPI_BooleanOperation *arg1 = (BRepAlgoAPI_BooleanOperation *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepAlgoAPI_BooleanOperation\n  * wrapname: _wrap_delete_BRepAlgoAPI_BooleanOperation\n  * fulldecl: BRepAlgoAPI_BooleanOperation::~BRepAlgoAPI_BooleanOperation()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepAlgoAPI_Fuse *_wrap_new_BRepAlgoAPI_Fuse (TopoDS_Shape *larg1, TopoDS_Shape *larg2) {
  BRepAlgoAPI_Fuse * lresult = (BRepAlgoAPI_Fuse *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  TopoDS_Shape *arg2 = 0 ;
  BRepAlgoAPI_Fuse *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepAlgoAPI_Fuse *)new BRepAlgoAPI_Fuse((TopoDS_Shape const &)*arg1,(TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepAlgoAPI_Fuse\n  * wrapname: _wrap_new_BRepAlgoAPI_Fuse\n  * fulldecl: BRepAlgoAPI_Fuse::BRepAlgoAPI_Fuse(TopoDS_Shape const &,TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepAlgoAPI_Fuse *)0;
  }
}


EXPORT void _wrap_delete_BRepAlgoAPI_Fuse (BRepAlgoAPI_Fuse *larg1) {
  BRepAlgoAPI_Fuse *arg1 = (BRepAlgoAPI_Fuse *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepAlgoAPI_Fuse\n  * wrapname: _wrap_delete_BRepAlgoAPI_Fuse\n  * fulldecl: BRepAlgoAPI_Fuse::~BRepAlgoAPI_Fuse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepAlgoAPI_Common *_wrap_new_BRepAlgoAPI_Common (TopoDS_Shape *larg1, TopoDS_Shape *larg2) {
  BRepAlgoAPI_Common * lresult = (BRepAlgoAPI_Common *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  TopoDS_Shape *arg2 = 0 ;
  BRepAlgoAPI_Common *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepAlgoAPI_Common *)new BRepAlgoAPI_Common((TopoDS_Shape const &)*arg1,(TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepAlgoAPI_Common\n  * wrapname: _wrap_new_BRepAlgoAPI_Common\n  * fulldecl: BRepAlgoAPI_Common::BRepAlgoAPI_Common(TopoDS_Shape const &,TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepAlgoAPI_Common *)0;
  }
}


EXPORT void _wrap_delete_BRepAlgoAPI_Common (BRepAlgoAPI_Common *larg1) {
  BRepAlgoAPI_Common *arg1 = (BRepAlgoAPI_Common *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepAlgoAPI_Common\n  * wrapname: _wrap_delete_BRepAlgoAPI_Common\n  * fulldecl: BRepAlgoAPI_Common::~BRepAlgoAPI_Common()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepAlgoAPI_Cut *_wrap_new_BRepAlgoAPI_Cut (TopoDS_Shape *larg1, TopoDS_Shape *larg2) {
  BRepAlgoAPI_Cut * lresult = (BRepAlgoAPI_Cut *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  TopoDS_Shape *arg2 = 0 ;
  BRepAlgoAPI_Cut *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepAlgoAPI_Cut *)new BRepAlgoAPI_Cut((TopoDS_Shape const &)*arg1,(TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepAlgoAPI_Cut\n  * wrapname: _wrap_new_BRepAlgoAPI_Cut\n  * fulldecl: BRepAlgoAPI_Cut::BRepAlgoAPI_Cut(TopoDS_Shape const &,TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepAlgoAPI_Cut *)0;
  }
}


EXPORT void _wrap_delete_BRepAlgoAPI_Cut (BRepAlgoAPI_Cut *larg1) {
  BRepAlgoAPI_Cut *arg1 = (BRepAlgoAPI_Cut *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepAlgoAPI_Cut\n  * wrapname: _wrap_delete_BRepAlgoAPI_Cut\n  * fulldecl: BRepAlgoAPI_Cut::~BRepAlgoAPI_Cut()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepAlgoAPI_Section *_wrap_new_BRepAlgoAPI_Section (TopoDS_Shape *larg1, TopoDS_Shape *larg2) {
  BRepAlgoAPI_Section * lresult = (BRepAlgoAPI_Section *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  TopoDS_Shape *arg2 = 0 ;
  BRepAlgoAPI_Section *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepAlgoAPI_Section *)new BRepAlgoAPI_Section((TopoDS_Shape const &)*arg1,(TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepAlgoAPI_Section\n  * wrapname: _wrap_new_BRepAlgoAPI_Section\n  * fulldecl: BRepAlgoAPI_Section::BRepAlgoAPI_Section(TopoDS_Shape const &,TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepAlgoAPI_Section *)0;
  }
}


EXPORT void _wrap_delete_BRepAlgoAPI_Section (BRepAlgoAPI_Section *larg1) {
  BRepAlgoAPI_Section *arg1 = (BRepAlgoAPI_Section *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepAlgoAPI_Section\n  * wrapname: _wrap_delete_BRepAlgoAPI_Section\n  * fulldecl: BRepAlgoAPI_Section::~BRepAlgoAPI_Section()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopoDS_Shape *_wrap_BRepAlgoAPI_Algo_Shape (BRepAlgoAPI_Algo *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  BRepAlgoAPI_Algo *arg1 = (BRepAlgoAPI_Algo *) 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &(arg1)->Shape();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepAlgoAPI_Algo_Shape\n  * wrapname: _wrap_BRepAlgoAPI_Algo_Shape\n  * fulldecl: TopoDS_Shape const & BRepAlgoAPI_Algo::Shape()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}



#include <Poly_Triangulation.hxx>
  
SWIGINTERN Standard_Real Handle_Poly_Triangulation_deflection__SWIG_0(Handle_Poly_Triangulation const *self){
    return (*self)->Deflection();
  }
EXPORT Standard_Real _wrap_Poly_Triangulation_deflection__SWIG_0 (Handle_Poly_Triangulation *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Poly_Triangulation *arg1 = (Handle_Poly_Triangulation *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Poly_Triangulation_deflection__SWIG_0((Handle_Poly_Triangulation const *)arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Triangulation_deflection\n  * wrapname: _wrap_Poly_Triangulation_deflection__SWIG_0\n  * fulldecl: Standard_Real Handle_Poly_Triangulation::deflection() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN void Handle_Poly_Triangulation_deflection__SWIG_1(Handle_Poly_Triangulation *self,Standard_Real const D){
    return (*self)->Deflection(D);
  }
EXPORT void _wrap_Poly_Triangulation_deflection__SWIG_1 (Handle_Poly_Triangulation *larg1, Standard_Real larg2) {
  Handle_Poly_Triangulation *arg1 = (Handle_Poly_Triangulation *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Poly_Triangulation_deflection__SWIG_1(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Triangulation_deflection\n  * wrapname: _wrap_Poly_Triangulation_deflection__SWIG_1\n  * fulldecl: void Handle_Poly_Triangulation::deflection(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Poly_Triangulation_removeUVNodes(Handle_Poly_Triangulation *self){
    return (*self)->RemoveUVNodes();
  }
EXPORT void _wrap_Poly_Triangulation_removeUVNodes (Handle_Poly_Triangulation *larg1) {
  Handle_Poly_Triangulation *arg1 = (Handle_Poly_Triangulation *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Poly_Triangulation_removeUVNodes(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Triangulation_removeUVNodes\n  * wrapname: _wrap_Poly_Triangulation_removeUVNodes\n  * fulldecl: void Handle_Poly_Triangulation::removeUVNodes()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Integer Handle_Poly_Triangulation_nbNodes(Handle_Poly_Triangulation const *self){
    return (*self)->NbNodes();
  }
EXPORT Standard_Integer _wrap_Poly_Triangulation_nbNodes (Handle_Poly_Triangulation *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Poly_Triangulation *arg1 = (Handle_Poly_Triangulation *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Poly_Triangulation_nbNodes((Handle_Poly_Triangulation const *)arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Triangulation_nbNodes\n  * wrapname: _wrap_Poly_Triangulation_nbNodes\n  * fulldecl: Standard_Integer Handle_Poly_Triangulation::nbNodes() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Poly_Triangulation_nbTriangles(Handle_Poly_Triangulation const *self){
    return (*self)->NbTriangles();
  }
EXPORT Standard_Integer _wrap_Poly_Triangulation_nbTriangles (Handle_Poly_Triangulation *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Poly_Triangulation *arg1 = (Handle_Poly_Triangulation *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Poly_Triangulation_nbTriangles((Handle_Poly_Triangulation const *)arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Triangulation_nbTriangles\n  * wrapname: _wrap_Poly_Triangulation_nbTriangles\n  * fulldecl: Standard_Integer Handle_Poly_Triangulation::nbTriangles() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Poly_Triangulation_hasUVNodes(Handle_Poly_Triangulation const *self){
    return (*self)->HasUVNodes();
  }
EXPORT bool _wrap_Poly_Triangulation_hasUVNodes (Handle_Poly_Triangulation *larg1) {
  bool lresult = (bool)0 ;
  Handle_Poly_Triangulation *arg1 = (Handle_Poly_Triangulation *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Poly_Triangulation_hasUVNodes((Handle_Poly_Triangulation const *)arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Triangulation_hasUVNodes\n  * wrapname: _wrap_Poly_Triangulation_hasUVNodes\n  * fulldecl: Standard_Boolean Handle_Poly_Triangulation::hasUVNodes() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Poly_Array1OfTriangle const &Handle_Poly_Triangulation_triangles(Handle_Poly_Triangulation const *self){
    return (*self)->Triangles();
  }
EXPORT Poly_Array1OfTriangle *_wrap_Poly_Triangulation_triangles (Handle_Poly_Triangulation *larg1) {
  Poly_Array1OfTriangle * lresult = (Poly_Array1OfTriangle *)0 ;
  Handle_Poly_Triangulation *arg1 = (Handle_Poly_Triangulation *) 0 ;
  Poly_Array1OfTriangle *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Poly_Array1OfTriangle *) &Handle_Poly_Triangulation_triangles((Handle_Poly_Triangulation const *)arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Triangulation_triangles\n  * wrapname: _wrap_Poly_Triangulation_triangles\n  * fulldecl: Poly_Array1OfTriangle const & Handle_Poly_Triangulation::triangles() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Poly_Array1OfTriangle *)0;
  }
}


SWIGINTERN TColgp_Array1OfPnt const &Handle_Poly_Triangulation_nodes(Handle_Poly_Triangulation const *self){
    return (*self)->Nodes();
  }
EXPORT TColgp_Array1OfPnt *_wrap_Poly_Triangulation_nodes (Handle_Poly_Triangulation *larg1) {
  TColgp_Array1OfPnt * lresult = (TColgp_Array1OfPnt *)0 ;
  Handle_Poly_Triangulation *arg1 = (Handle_Poly_Triangulation *) 0 ;
  TColgp_Array1OfPnt *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColgp_Array1OfPnt *) &Handle_Poly_Triangulation_nodes((Handle_Poly_Triangulation const *)arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Triangulation_nodes\n  * wrapname: _wrap_Poly_Triangulation_nodes\n  * fulldecl: TColgp_Array1OfPnt const & Handle_Poly_Triangulation::nodes() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColgp_Array1OfPnt *)0;
  }
}


SWIGINTERN TColgp_Array1OfPnt2d const &Handle_Poly_Triangulation_uVNodes(Handle_Poly_Triangulation const *self){
    return (*self)->UVNodes();
  }
EXPORT TColgp_Array1OfPnt2d *_wrap_Poly_Triangulation_uVNodes (Handle_Poly_Triangulation *larg1) {
  TColgp_Array1OfPnt2d * lresult = (TColgp_Array1OfPnt2d *)0 ;
  Handle_Poly_Triangulation *arg1 = (Handle_Poly_Triangulation *) 0 ;
  TColgp_Array1OfPnt2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColgp_Array1OfPnt2d *) &Handle_Poly_Triangulation_uVNodes((Handle_Poly_Triangulation const *)arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Triangulation_uVNodes\n  * wrapname: _wrap_Poly_Triangulation_uVNodes\n  * fulldecl: TColgp_Array1OfPnt2d const & Handle_Poly_Triangulation::uVNodes() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColgp_Array1OfPnt2d *)0;
  }
}


EXPORT void _wrap_delete_Poly_Triangulation (Handle_Poly_Triangulation *larg1) {
  Handle_Poly_Triangulation *arg1 = (Handle_Poly_Triangulation *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Poly_Triangulation\n  * wrapname: _wrap_delete_Poly_Triangulation\n  * fulldecl: Handle_Poly_Triangulation::~Handle_Poly_Triangulation()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Poly_Triangle *_wrap_new_Poly_Triangle__SWIG_0 () {
  Poly_Triangle * lresult = (Poly_Triangle *)0 ;
  Poly_Triangle *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Poly_Triangle *)new Poly_Triangle();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Poly_Triangle\n  * wrapname: _wrap_new_Poly_Triangle__SWIG_0\n  * fulldecl: Poly_Triangle::Poly_Triangle()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Poly_Triangle *)0;
  }
}


EXPORT Poly_Triangle *_wrap_new_Poly_Triangle__SWIG_1 (Standard_Integer larg1, Standard_Integer larg2, Standard_Integer larg3) {
  Poly_Triangle * lresult = (Poly_Triangle *)0 ;
  Standard_Integer arg1 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  Poly_Triangle *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Poly_Triangle *)new Poly_Triangle(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Poly_Triangle\n  * wrapname: _wrap_new_Poly_Triangle__SWIG_1\n  * fulldecl: Poly_Triangle::Poly_Triangle(Standard_Integer const,Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Poly_Triangle *)0;
  }
}


EXPORT Standard_Integer _wrap_Poly_Triangle_Value (Poly_Triangle *larg1, Standard_Integer larg2) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Poly_Triangle *arg1 = (Poly_Triangle *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((Poly_Triangle const *)arg1)->Value(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Triangle_Value\n  * wrapname: _wrap_Poly_Triangle_Value\n  * fulldecl: Standard_Integer Poly_Triangle::Value(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT void _wrap_delete_Poly_Triangle (Poly_Triangle *larg1) {
  Poly_Triangle *arg1 = (Poly_Triangle *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Poly_Triangle\n  * wrapname: _wrap_delete_Poly_Triangle\n  * fulldecl: Poly_Triangle::~Poly_Triangle()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Poly_Array1OfTriangle *_wrap_new_Poly_Array1OfTriangle__SWIG_0 (Standard_Integer larg1, Standard_Integer larg2) {
  Poly_Array1OfTriangle * lresult = (Poly_Array1OfTriangle *)0 ;
  Standard_Integer arg1 ;
  Standard_Integer arg2 ;
  Poly_Array1OfTriangle *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Poly_Array1OfTriangle *)new Poly_Array1OfTriangle(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Poly_Array1OfTriangle\n  * wrapname: _wrap_new_Poly_Array1OfTriangle__SWIG_0\n  * fulldecl: Poly_Array1OfTriangle::Poly_Array1OfTriangle(Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Poly_Array1OfTriangle *)0;
  }
}


EXPORT Poly_Array1OfTriangle *_wrap_new_Poly_Array1OfTriangle__SWIG_1 (Poly_Triangle *larg1, Standard_Integer larg2, Standard_Integer larg3) {
  Poly_Array1OfTriangle * lresult = (Poly_Array1OfTriangle *)0 ;
  Poly_Triangle *arg1 = 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  Poly_Array1OfTriangle *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Poly_Array1OfTriangle *)new Poly_Array1OfTriangle((Poly_Triangle const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Poly_Array1OfTriangle\n  * wrapname: _wrap_new_Poly_Array1OfTriangle__SWIG_1\n  * fulldecl: Poly_Array1OfTriangle::Poly_Array1OfTriangle(Poly_Triangle const &,Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Poly_Array1OfTriangle *)0;
  }
}


EXPORT Standard_Integer _wrap_Poly_Array1OfTriangle_Length (Poly_Array1OfTriangle *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Poly_Array1OfTriangle *arg1 = (Poly_Array1OfTriangle *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)(arg1)->Length();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Array1OfTriangle_Length\n  * wrapname: _wrap_Poly_Array1OfTriangle_Length\n  * fulldecl: Standard_Integer Poly_Array1OfTriangle::Length()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT Standard_Integer _wrap_Poly_Array1OfTriangle_Lower (Poly_Array1OfTriangle *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Poly_Array1OfTriangle *arg1 = (Poly_Array1OfTriangle *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)(arg1)->Lower();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Array1OfTriangle_Lower\n  * wrapname: _wrap_Poly_Array1OfTriangle_Lower\n  * fulldecl: Standard_Integer Poly_Array1OfTriangle::Lower()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT Standard_Integer _wrap_Poly_Array1OfTriangle_Upper (Poly_Array1OfTriangle *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Poly_Array1OfTriangle *arg1 = (Poly_Array1OfTriangle *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)(arg1)->Upper();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Array1OfTriangle_Upper\n  * wrapname: _wrap_Poly_Array1OfTriangle_Upper\n  * fulldecl: Standard_Integer Poly_Array1OfTriangle::Upper()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT Poly_Triangle *_wrap_Poly_Array1OfTriangle_Value (Poly_Array1OfTriangle *larg1, Standard_Integer larg2) {
  Poly_Triangle * lresult = (Poly_Triangle *)0 ;
  Poly_Array1OfTriangle *arg1 = (Poly_Array1OfTriangle *) 0 ;
  Standard_Integer arg2 ;
  Poly_Triangle *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Poly_Triangle *) &((Poly_Array1OfTriangle const *)arg1)->Value(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Array1OfTriangle_Value\n  * wrapname: _wrap_Poly_Array1OfTriangle_Value\n  * fulldecl: Poly_Triangle const & Poly_Array1OfTriangle::Value(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Poly_Triangle *)0;
  }
}


EXPORT void _wrap_delete_Poly_Array1OfTriangle (Poly_Array1OfTriangle *larg1) {
  Poly_Array1OfTriangle *arg1 = (Poly_Array1OfTriangle *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Poly_Array1OfTriangle\n  * wrapname: _wrap_delete_Poly_Array1OfTriangle\n  * fulldecl: Poly_Array1OfTriangle::~Poly_Array1OfTriangle()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Poly_Polygon3D *_wrap_new_Poly_Polygon3D__SWIG_0 (TColgp_Array1OfPnt *larg1) {
  Poly_Polygon3D * lresult = (Poly_Polygon3D *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  Poly_Polygon3D *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Poly_Polygon3D *)new Poly_Polygon3D((TColgp_Array1OfPnt const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Poly_Polygon3D\n  * wrapname: _wrap_new_Poly_Polygon3D__SWIG_0\n  * fulldecl: Poly_Polygon3D::Poly_Polygon3D(TColgp_Array1OfPnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Poly_Polygon3D *)0;
  }
}


EXPORT Poly_Polygon3D *_wrap_new_Poly_Polygon3D__SWIG_1 (TColgp_Array1OfPnt *larg1, TColStd_Array1OfReal *larg2) {
  Poly_Polygon3D * lresult = (Poly_Polygon3D *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  Poly_Polygon3D *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Poly_Polygon3D *)new Poly_Polygon3D((TColgp_Array1OfPnt const &)*arg1,(TColStd_Array1OfReal const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Poly_Polygon3D\n  * wrapname: _wrap_new_Poly_Polygon3D__SWIG_1\n  * fulldecl: Poly_Polygon3D::Poly_Polygon3D(TColgp_Array1OfPnt const &,TColStd_Array1OfReal const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Poly_Polygon3D *)0;
  }
}


EXPORT Standard_Real _wrap_Poly_Polygon3D_Deflection__SWIG_0 (Poly_Polygon3D *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Poly_Polygon3D *arg1 = (Poly_Polygon3D *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)(arg1)->Deflection();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Polygon3D_Deflection\n  * wrapname: _wrap_Poly_Polygon3D_Deflection__SWIG_0\n  * fulldecl: Standard_Real Poly_Polygon3D::Deflection()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_Poly_Polygon3D_Deflection__SWIG_1 (Poly_Polygon3D *larg1, Standard_Real larg2) {
  Poly_Polygon3D *arg1 = (Poly_Polygon3D *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Deflection(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Polygon3D_Deflection\n  * wrapname: _wrap_Poly_Polygon3D_Deflection__SWIG_1\n  * fulldecl: void Poly_Polygon3D::Deflection(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Integer _wrap_Poly_Polygon3D_NbNodes (Poly_Polygon3D *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Poly_Polygon3D *arg1 = (Poly_Polygon3D *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((Poly_Polygon3D const *)arg1)->NbNodes();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Polygon3D_NbNodes\n  * wrapname: _wrap_Poly_Polygon3D_NbNodes\n  * fulldecl: Standard_Integer Poly_Polygon3D::NbNodes() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT TColgp_Array1OfPnt *_wrap_Poly_Polygon3D_Nodes (Poly_Polygon3D *larg1) {
  TColgp_Array1OfPnt * lresult = (TColgp_Array1OfPnt *)0 ;
  Poly_Polygon3D *arg1 = (Poly_Polygon3D *) 0 ;
  TColgp_Array1OfPnt *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColgp_Array1OfPnt *) &((Poly_Polygon3D const *)arg1)->Nodes();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Polygon3D_Nodes\n  * wrapname: _wrap_Poly_Polygon3D_Nodes\n  * fulldecl: TColgp_Array1OfPnt const & Poly_Polygon3D::Nodes() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColgp_Array1OfPnt *)0;
  }
}


EXPORT bool _wrap_Poly_Polygon3D_HasParameters (Poly_Polygon3D *larg1) {
  bool lresult = (bool)0 ;
  Poly_Polygon3D *arg1 = (Poly_Polygon3D *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Poly_Polygon3D const *)arg1)->HasParameters();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Polygon3D_HasParameters\n  * wrapname: _wrap_Poly_Polygon3D_HasParameters\n  * fulldecl: Standard_Boolean Poly_Polygon3D::HasParameters() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT TColStd_Array1OfReal *_wrap_Poly_Polygon3D_Parameters (Poly_Polygon3D *larg1) {
  TColStd_Array1OfReal * lresult = (TColStd_Array1OfReal *)0 ;
  Poly_Polygon3D *arg1 = (Poly_Polygon3D *) 0 ;
  TColStd_Array1OfReal *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColStd_Array1OfReal *) &((Poly_Polygon3D const *)arg1)->Parameters();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Polygon3D_Parameters\n  * wrapname: _wrap_Poly_Polygon3D_Parameters\n  * fulldecl: TColStd_Array1OfReal const & Poly_Polygon3D::Parameters() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColStd_Array1OfReal *)0;
  }
}


EXPORT TColStd_Array1OfReal *_wrap_Poly_Polygon3D_ChangeParameters (Poly_Polygon3D *larg1) {
  TColStd_Array1OfReal * lresult = (TColStd_Array1OfReal *)0 ;
  Poly_Polygon3D *arg1 = (Poly_Polygon3D *) 0 ;
  TColStd_Array1OfReal *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColStd_Array1OfReal *) &((Poly_Polygon3D const *)arg1)->ChangeParameters();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_Polygon3D_ChangeParameters\n  * wrapname: _wrap_Poly_Polygon3D_ChangeParameters\n  * fulldecl: TColStd_Array1OfReal & Poly_Polygon3D::ChangeParameters() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColStd_Array1OfReal *)0;
  }
}


EXPORT void _wrap_delete_Poly_Polygon3D (Poly_Polygon3D *larg1) {
  Poly_Polygon3D *arg1 = (Poly_Polygon3D *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Poly_Polygon3D\n  * wrapname: _wrap_delete_Poly_Polygon3D\n  * fulldecl: Poly_Polygon3D::~Poly_Polygon3D()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



  #include <Poly_PolygonOnTriangulation.hxx>
  
EXPORT Poly_PolygonOnTriangulation *_wrap_new_Poly_PolygonOnTriangulation__SWIG_0 (TColStd_Array1OfInteger *larg1) {
  Poly_PolygonOnTriangulation * lresult = (Poly_PolygonOnTriangulation *)0 ;
  TColStd_Array1OfInteger *arg1 = 0 ;
  Poly_PolygonOnTriangulation *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Poly_PolygonOnTriangulation *)new Poly_PolygonOnTriangulation((TColStd_Array1OfInteger const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Poly_PolygonOnTriangulation\n  * wrapname: _wrap_new_Poly_PolygonOnTriangulation__SWIG_0\n  * fulldecl: Poly_PolygonOnTriangulation::Poly_PolygonOnTriangulation(TColStd_Array1OfInteger const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Poly_PolygonOnTriangulation *)0;
  }
}


EXPORT Poly_PolygonOnTriangulation *_wrap_new_Poly_PolygonOnTriangulation__SWIG_1 (TColStd_Array1OfInteger *larg1, TColStd_Array1OfReal *larg2) {
  Poly_PolygonOnTriangulation * lresult = (Poly_PolygonOnTriangulation *)0 ;
  TColStd_Array1OfInteger *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  Poly_PolygonOnTriangulation *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Poly_PolygonOnTriangulation *)new Poly_PolygonOnTriangulation((TColStd_Array1OfInteger const &)*arg1,(TColStd_Array1OfReal const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Poly_PolygonOnTriangulation\n  * wrapname: _wrap_new_Poly_PolygonOnTriangulation__SWIG_1\n  * fulldecl: Poly_PolygonOnTriangulation::Poly_PolygonOnTriangulation(TColStd_Array1OfInteger const &,TColStd_Array1OfReal const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Poly_PolygonOnTriangulation *)0;
  }
}


EXPORT Handle_Poly_PolygonOnTriangulation *_wrap_Poly_PolygonOnTriangulation_Copy (Poly_PolygonOnTriangulation *larg1) {
  Handle_Poly_PolygonOnTriangulation * lresult = (Handle_Poly_PolygonOnTriangulation *)0 ;
  Poly_PolygonOnTriangulation *arg1 = (Poly_PolygonOnTriangulation *) 0 ;
  Handle_Poly_PolygonOnTriangulation result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Poly_PolygonOnTriangulation const *)arg1)->Copy();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_PolygonOnTriangulation_Copy\n  * wrapname: _wrap_Poly_PolygonOnTriangulation_Copy\n  * fulldecl: Handle_Poly_PolygonOnTriangulation Poly_PolygonOnTriangulation::Copy() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Poly_PolygonOnTriangulation(result);
    return lresult;
  } catch (...) {
    return (Handle_Poly_PolygonOnTriangulation *)0;
  }
}


EXPORT Standard_Real _wrap_Poly_PolygonOnTriangulation_Deflection__SWIG_0 (Poly_PolygonOnTriangulation *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Poly_PolygonOnTriangulation *arg1 = (Poly_PolygonOnTriangulation *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((Poly_PolygonOnTriangulation const *)arg1)->Deflection();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_PolygonOnTriangulation_Deflection\n  * wrapname: _wrap_Poly_PolygonOnTriangulation_Deflection__SWIG_0\n  * fulldecl: Standard_Real Poly_PolygonOnTriangulation::Deflection() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_Poly_PolygonOnTriangulation_Deflection__SWIG_1 (Poly_PolygonOnTriangulation *larg1, Standard_Real larg2) {
  Poly_PolygonOnTriangulation *arg1 = (Poly_PolygonOnTriangulation *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Deflection(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_PolygonOnTriangulation_Deflection\n  * wrapname: _wrap_Poly_PolygonOnTriangulation_Deflection__SWIG_1\n  * fulldecl: void Poly_PolygonOnTriangulation::Deflection(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Integer _wrap_Poly_PolygonOnTriangulation_NbNodes (Poly_PolygonOnTriangulation *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Poly_PolygonOnTriangulation *arg1 = (Poly_PolygonOnTriangulation *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((Poly_PolygonOnTriangulation const *)arg1)->NbNodes();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_PolygonOnTriangulation_NbNodes\n  * wrapname: _wrap_Poly_PolygonOnTriangulation_NbNodes\n  * fulldecl: Standard_Integer Poly_PolygonOnTriangulation::NbNodes() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT TColStd_Array1OfInteger *_wrap_Poly_PolygonOnTriangulation_Nodes (Poly_PolygonOnTriangulation *larg1) {
  TColStd_Array1OfInteger * lresult = (TColStd_Array1OfInteger *)0 ;
  Poly_PolygonOnTriangulation *arg1 = (Poly_PolygonOnTriangulation *) 0 ;
  TColStd_Array1OfInteger *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TColStd_Array1OfInteger *) &((Poly_PolygonOnTriangulation const *)arg1)->Nodes();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_PolygonOnTriangulation_Nodes\n  * wrapname: _wrap_Poly_PolygonOnTriangulation_Nodes\n  * fulldecl: TColStd_Array1OfInteger const & Poly_PolygonOnTriangulation::Nodes() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TColStd_Array1OfInteger *)0;
  }
}


EXPORT bool _wrap_Poly_PolygonOnTriangulation_HasParameters (Poly_PolygonOnTriangulation *larg1) {
  bool lresult = (bool)0 ;
  Poly_PolygonOnTriangulation *arg1 = (Poly_PolygonOnTriangulation *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Poly_PolygonOnTriangulation const *)arg1)->HasParameters();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_PolygonOnTriangulation_HasParameters\n  * wrapname: _wrap_Poly_PolygonOnTriangulation_HasParameters\n  * fulldecl: Standard_Boolean Poly_PolygonOnTriangulation::HasParameters() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Handle_TColStd_HArray1OfReal *_wrap_Poly_PolygonOnTriangulation_Parameters (Poly_PolygonOnTriangulation *larg1) {
  Handle_TColStd_HArray1OfReal * lresult = (Handle_TColStd_HArray1OfReal *)0 ;
  Poly_PolygonOnTriangulation *arg1 = (Poly_PolygonOnTriangulation *) 0 ;
  Handle_TColStd_HArray1OfReal result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Poly_PolygonOnTriangulation const *)arg1)->Parameters();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Poly_PolygonOnTriangulation_Parameters\n  * wrapname: _wrap_Poly_PolygonOnTriangulation_Parameters\n  * fulldecl: Handle_TColStd_HArray1OfReal Poly_PolygonOnTriangulation::Parameters() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_TColStd_HArray1OfReal(result);
    return lresult;
  } catch (...) {
    return (Handle_TColStd_HArray1OfReal *)0;
  }
}


EXPORT void _wrap_delete_Poly_PolygonOnTriangulation (Poly_PolygonOnTriangulation *larg1) {
  Poly_PolygonOnTriangulation *arg1 = (Poly_PolygonOnTriangulation *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Poly_PolygonOnTriangulation\n  * wrapname: _wrap_delete_Poly_PolygonOnTriangulation\n  * fulldecl: Poly_PolygonOnTriangulation::~Poly_PolygonOnTriangulation()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <MMgt_TShared.hxx>
#include <Geom2d_Geometry.hxx>
#include <Geom2d_Point.hxx>
#include <Geom2d_CartesianPoint.hxx>
#include <Geom2d_Vector.hxx>
#include <Geom2d_VectorWithMagnitude.hxx>
#include <Geom2d_Curve.hxx>
#include <Geom2d_Line.hxx>
#include <Geom2d_OffsetCurve.hxx>
#include <Geom2d_Conic.hxx>
#include <Geom2d_Circle.hxx>
#include <Geom2d_Ellipse.hxx>
#include <Geom2d_Hyperbola.hxx>
#include <Geom2d_Parabola.hxx>
#include <Geom2d_BoundedCurve.hxx>
#include <Geom2d_BezierCurve.hxx>
#include <Geom2d_BSplineCurve.hxx>
#include <Geom2d_TrimmedCurve.hxx>
#include <Bisector_Curve.hxx>
#include <Bisector_BisecAna.hxx>
#include <Bisector_BisecCC.hxx>
#include <Bisector_BisecPC.hxx>
  
SWIGINTERN void Handle_Geom2d_Geometry_Mirror__SWIG_0(Handle_Geom2d_Geometry *self,gp_Pnt2d const &P){
    (*self)->Mirror(P);
  }
EXPORT void _wrap_Geom2d_Geometry_Mirror__SWIG_0 (Handle_Geom2d_Geometry *larg1, gp_Pnt2d *larg2) {
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Geometry_Mirror__SWIG_0(arg1,(gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Geometry_Mirror\n  * wrapname: _wrap_Geom2d_Geometry_Mirror__SWIG_0\n  * fulldecl: void Handle_Geom2d_Geometry::Mirror(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Geometry_Mirror__SWIG_1(Handle_Geom2d_Geometry *self,gp_Ax2d const &A){
    (*self)->Mirror(A);
  }
EXPORT void _wrap_Geom2d_Geometry_Mirror__SWIG_1 (Handle_Geom2d_Geometry *larg1, gp_Ax2d *larg2) {
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Geometry_Mirror__SWIG_1(arg1,(gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Geometry_Mirror\n  * wrapname: _wrap_Geom2d_Geometry_Mirror__SWIG_1\n  * fulldecl: void Handle_Geom2d_Geometry::Mirror(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Geometry_Rotate(Handle_Geom2d_Geometry *self,gp_Pnt2d const &P,Standard_Real const Ang){
    (*self)->Rotate(P, Ang);
  }
EXPORT void _wrap_Geom2d_Geometry_Rotate (Handle_Geom2d_Geometry *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Geometry_Rotate(arg1,(gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Geometry_Rotate\n  * wrapname: _wrap_Geom2d_Geometry_Rotate\n  * fulldecl: void Handle_Geom2d_Geometry::Rotate(gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Geometry_Scale(Handle_Geom2d_Geometry *self,gp_Pnt2d const &P,Standard_Real const S){
    (*self)->Scale(P, S);
  }
EXPORT void _wrap_Geom2d_Geometry_Scale (Handle_Geom2d_Geometry *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Geometry_Scale(arg1,(gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Geometry_Scale\n  * wrapname: _wrap_Geom2d_Geometry_Scale\n  * fulldecl: void Handle_Geom2d_Geometry::Scale(gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Geometry_Translate__SWIG_0(Handle_Geom2d_Geometry *self,gp_Vec2d const &V){
    (*self)->Translate(V);
  }
EXPORT void _wrap_Geom2d_Geometry_Translate__SWIG_0 (Handle_Geom2d_Geometry *larg1, gp_Vec2d *larg2) {
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Geometry_Translate__SWIG_0(arg1,(gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Geometry_Translate\n  * wrapname: _wrap_Geom2d_Geometry_Translate__SWIG_0\n  * fulldecl: void Handle_Geom2d_Geometry::Translate(gp_Vec2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Geometry_Translate__SWIG_1(Handle_Geom2d_Geometry *self,gp_Pnt2d const &P1,gp_Pnt2d const &P2){
    (*self)->Translate(P1, P2);
  }
EXPORT void _wrap_Geom2d_Geometry_Translate__SWIG_1 (Handle_Geom2d_Geometry *larg1, gp_Pnt2d *larg2, gp_Pnt2d *larg3) {
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Pnt2d *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Geometry_Translate__SWIG_1(arg1,(gp_Pnt2d const &)*arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Geometry_Translate\n  * wrapname: _wrap_Geom2d_Geometry_Translate__SWIG_1\n  * fulldecl: void Handle_Geom2d_Geometry::Translate(gp_Pnt2d const &,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_Geometry Handle_Geom2d_Geometry_Mirrored__SWIG_0(Handle_Geom2d_Geometry *self,gp_Pnt2d const &P){
    return (*self)->Mirrored(P);
  }
EXPORT Handle_Geom2d_Geometry *_wrap_Geom2d_Geometry_Mirrored__SWIG_0 (Handle_Geom2d_Geometry *larg1, gp_Pnt2d *larg2) {
  Handle_Geom2d_Geometry * lresult = (Handle_Geom2d_Geometry *)0 ;
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  SwigValueWrapper< Handle_Geom2d_Geometry > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Geometry_Mirrored__SWIG_0(arg1,(gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Geometry_Mirrored\n  * wrapname: _wrap_Geom2d_Geometry_Mirrored__SWIG_0\n  * fulldecl: Handle_Geom2d_Geometry Handle_Geom2d_Geometry::Mirrored(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Geometry *)0;
  }
}


SWIGINTERN Handle_Geom2d_Geometry Handle_Geom2d_Geometry_Mirrored__SWIG_1(Handle_Geom2d_Geometry *self,gp_Ax2d const &A){
    return (*self)->Mirrored(A);
  }
EXPORT Handle_Geom2d_Geometry *_wrap_Geom2d_Geometry_Mirrored__SWIG_1 (Handle_Geom2d_Geometry *larg1, gp_Ax2d *larg2) {
  Handle_Geom2d_Geometry * lresult = (Handle_Geom2d_Geometry *)0 ;
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  SwigValueWrapper< Handle_Geom2d_Geometry > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Geometry_Mirrored__SWIG_1(arg1,(gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Geometry_Mirrored\n  * wrapname: _wrap_Geom2d_Geometry_Mirrored__SWIG_1\n  * fulldecl: Handle_Geom2d_Geometry Handle_Geom2d_Geometry::Mirrored(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Geometry *)0;
  }
}


SWIGINTERN Handle_Geom2d_Geometry Handle_Geom2d_Geometry_Rotated(Handle_Geom2d_Geometry *self,gp_Pnt2d const &P,Standard_Real const Ang){
    return (*self)->Rotated(P, Ang);
  }
EXPORT Handle_Geom2d_Geometry *_wrap_Geom2d_Geometry_Rotated (Handle_Geom2d_Geometry *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  Handle_Geom2d_Geometry * lresult = (Handle_Geom2d_Geometry *)0 ;
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  SwigValueWrapper< Handle_Geom2d_Geometry > result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Geometry_Rotated(arg1,(gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Geometry_Rotated\n  * wrapname: _wrap_Geom2d_Geometry_Rotated\n  * fulldecl: Handle_Geom2d_Geometry Handle_Geom2d_Geometry::Rotated(gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Geometry *)0;
  }
}


SWIGINTERN Handle_Geom2d_Geometry Handle_Geom2d_Geometry_Scaled(Handle_Geom2d_Geometry *self,gp_Pnt2d const &P,Standard_Real const S){
    return (*self)->Scaled(P, S);
  }
EXPORT Handle_Geom2d_Geometry *_wrap_Geom2d_Geometry_Scaled (Handle_Geom2d_Geometry *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  Handle_Geom2d_Geometry * lresult = (Handle_Geom2d_Geometry *)0 ;
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  SwigValueWrapper< Handle_Geom2d_Geometry > result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Geometry_Scaled(arg1,(gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Geometry_Scaled\n  * wrapname: _wrap_Geom2d_Geometry_Scaled\n  * fulldecl: Handle_Geom2d_Geometry Handle_Geom2d_Geometry::Scaled(gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Geometry *)0;
  }
}


SWIGINTERN Handle_Geom2d_Geometry Handle_Geom2d_Geometry_Transformed(Handle_Geom2d_Geometry *self,gp_Trsf2d const &T){
    return (*self)->Transformed(T);
  }
EXPORT Handle_Geom2d_Geometry *_wrap_Geom2d_Geometry_Transformed (Handle_Geom2d_Geometry *larg1, gp_Trsf2d *larg2) {
  Handle_Geom2d_Geometry * lresult = (Handle_Geom2d_Geometry *)0 ;
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  SwigValueWrapper< Handle_Geom2d_Geometry > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Geometry_Transformed(arg1,(gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Geometry_Transformed\n  * wrapname: _wrap_Geom2d_Geometry_Transformed\n  * fulldecl: Handle_Geom2d_Geometry Handle_Geom2d_Geometry::Transformed(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Geometry *)0;
  }
}


SWIGINTERN Handle_Geom2d_Geometry Handle_Geom2d_Geometry_Translated__SWIG_0(Handle_Geom2d_Geometry *self,gp_Vec2d const &V){
    return (*self)->Translated(V);
  }
EXPORT Handle_Geom2d_Geometry *_wrap_Geom2d_Geometry_Translated__SWIG_0 (Handle_Geom2d_Geometry *larg1, gp_Vec2d *larg2) {
  Handle_Geom2d_Geometry * lresult = (Handle_Geom2d_Geometry *)0 ;
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  SwigValueWrapper< Handle_Geom2d_Geometry > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Geometry_Translated__SWIG_0(arg1,(gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Geometry_Translated\n  * wrapname: _wrap_Geom2d_Geometry_Translated__SWIG_0\n  * fulldecl: Handle_Geom2d_Geometry Handle_Geom2d_Geometry::Translated(gp_Vec2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Geometry *)0;
  }
}


SWIGINTERN Handle_Geom2d_Geometry Handle_Geom2d_Geometry_Translated__SWIG_1(Handle_Geom2d_Geometry *self,gp_Pnt2d const &P1,gp_Pnt2d const &P2){
    return (*self)->Translated(P1, P2);
  }
EXPORT Handle_Geom2d_Geometry *_wrap_Geom2d_Geometry_Translated__SWIG_1 (Handle_Geom2d_Geometry *larg1, gp_Pnt2d *larg2, gp_Pnt2d *larg3) {
  Handle_Geom2d_Geometry * lresult = (Handle_Geom2d_Geometry *)0 ;
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Pnt2d *arg3 = 0 ;
  SwigValueWrapper< Handle_Geom2d_Geometry > result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Geometry_Translated__SWIG_1(arg1,(gp_Pnt2d const &)*arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Geometry_Translated\n  * wrapname: _wrap_Geom2d_Geometry_Translated__SWIG_1\n  * fulldecl: Handle_Geom2d_Geometry Handle_Geom2d_Geometry::Translated(gp_Pnt2d const &,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Geometry *)0;
  }
}


SWIGINTERN void Handle_Geom2d_Geometry_Transform(Handle_Geom2d_Geometry *self,gp_Trsf2d const &T){
    (*self)->Transform(T);
  }
EXPORT void _wrap_Geom2d_Geometry_Transform (Handle_Geom2d_Geometry *larg1, gp_Trsf2d *larg2) {
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Geometry_Transform(arg1,(gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Geometry_Transform\n  * wrapname: _wrap_Geom2d_Geometry_Transform\n  * fulldecl: void Handle_Geom2d_Geometry::Transform(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_Geometry Handle_Geom2d_Geometry_Copy(Handle_Geom2d_Geometry *self){
    return (*self)->Copy();
  }
EXPORT Handle_Geom2d_Geometry *_wrap_Geom2d_Geometry_Copy (Handle_Geom2d_Geometry *larg1) {
  Handle_Geom2d_Geometry * lresult = (Handle_Geom2d_Geometry *)0 ;
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  SwigValueWrapper< Handle_Geom2d_Geometry > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Geometry_Copy(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Geometry_Copy\n  * wrapname: _wrap_Geom2d_Geometry_Copy\n  * fulldecl: Handle_Geom2d_Geometry Handle_Geom2d_Geometry::Copy()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Geometry *)0;
  }
}


EXPORT void _wrap_delete_Geom2d_Geometry (Handle_Geom2d_Geometry *larg1) {
  Handle_Geom2d_Geometry *arg1 = (Handle_Geom2d_Geometry *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom2d_Geometry\n  * wrapname: _wrap_delete_Geom2d_Geometry\n  * fulldecl: Handle_Geom2d_Geometry::~Handle_Geom2d_Geometry()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Point_Distance(Handle_Geom2d_Point *self,Handle_Geom2d_Point const &Other){
    return (*self)->Distance(Other);
  }
EXPORT Standard_Real _wrap_Geom2d_Point_Distance (Handle_Geom2d_Point *larg1, Handle_Geom2d_Point *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Point *arg1 = (Handle_Geom2d_Point *) 0 ;
  Handle_Geom2d_Point *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Point_Distance(arg1,(Handle_Geom2d_Point const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Point_Distance\n  * wrapname: _wrap_Geom2d_Point_Distance\n  * fulldecl: Standard_Real Handle_Geom2d_Point::Distance(Handle_Geom2d_Point const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Point_SquareDistance(Handle_Geom2d_Point *self,Handle_Geom2d_Point const &Other){
    return (*self)->SquareDistance(Other);
  }
EXPORT Standard_Real _wrap_Geom2d_Point_SquareDistance (Handle_Geom2d_Point *larg1, Handle_Geom2d_Point *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Point *arg1 = (Handle_Geom2d_Point *) 0 ;
  Handle_Geom2d_Point *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Point_SquareDistance(arg1,(Handle_Geom2d_Point const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Point_SquareDistance\n  * wrapname: _wrap_Geom2d_Point_SquareDistance\n  * fulldecl: Standard_Real Handle_Geom2d_Point::SquareDistance(Handle_Geom2d_Point const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN void Handle_Geom2d_Point_Coord(Handle_Geom2d_Point *self,Standard_Real &X,Standard_Real &Y){
    (*self)->Coord(X, Y);
  }
EXPORT void _wrap_Geom2d_Point_Coord (Handle_Geom2d_Point *larg1, Standard_Real *larg2, Standard_Real *larg3) {
  Handle_Geom2d_Point *arg1 = (Handle_Geom2d_Point *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Point_Coord(arg1,*arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Point_Coord\n  * wrapname: _wrap_Geom2d_Point_Coord\n  * fulldecl: void Handle_Geom2d_Point::Coord(Standard_Real &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Pnt2d Handle_Geom2d_Point_Pnt2d(Handle_Geom2d_Point *self){
    return (*self)->Pnt2d();
  }
EXPORT gp_Pnt2d *_wrap_Geom2d_Point_Pnt2d (Handle_Geom2d_Point *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Handle_Geom2d_Point *arg1 = (Handle_Geom2d_Point *) 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Point_Pnt2d(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Point_Pnt2d\n  * wrapname: _wrap_Geom2d_Point_Pnt2d\n  * fulldecl: gp_Pnt2d Handle_Geom2d_Point::Pnt2d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Point_X(Handle_Geom2d_Point *self){
    return (*self)->X();
  }
EXPORT Standard_Real _wrap_Geom2d_Point_X (Handle_Geom2d_Point *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Point *arg1 = (Handle_Geom2d_Point *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Point_X(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Point_X\n  * wrapname: _wrap_Geom2d_Point_X\n  * fulldecl: Standard_Real Handle_Geom2d_Point::X()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Point_Y(Handle_Geom2d_Point *self){
    return (*self)->Y();
  }
EXPORT Standard_Real _wrap_Geom2d_Point_Y (Handle_Geom2d_Point *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Point *arg1 = (Handle_Geom2d_Point *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Point_Y(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Point_Y\n  * wrapname: _wrap_Geom2d_Point_Y\n  * fulldecl: Standard_Real Handle_Geom2d_Point::Y()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_delete_Geom2d_Point (Handle_Geom2d_Point *larg1) {
  Handle_Geom2d_Point *arg1 = (Handle_Geom2d_Point *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom2d_Point\n  * wrapname: _wrap_delete_Geom2d_Point\n  * fulldecl: Handle_Geom2d_Point::~Handle_Geom2d_Point()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_CartesianPoint *new_Handle_Geom2d_CartesianPoint__SWIG_0(gp_Pnt2d const &P){
    return new Handle_Geom2d_CartesianPoint(new Geom2d_CartesianPoint(P));
  }
EXPORT Handle_Geom2d_CartesianPoint *_wrap_new_Geom2d_CartesianPoint__SWIG_0 (gp_Pnt2d *larg1) {
  Handle_Geom2d_CartesianPoint * lresult = (Handle_Geom2d_CartesianPoint *)0 ;
  gp_Pnt2d *arg1 = 0 ;
  Handle_Geom2d_CartesianPoint *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_CartesianPoint *)new_Handle_Geom2d_CartesianPoint__SWIG_0((gp_Pnt2d const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_CartesianPoint\n  * wrapname: _wrap_new_Geom2d_CartesianPoint__SWIG_0\n  * fulldecl: Handle_Geom2d_CartesianPoint::Handle_Geom2d_CartesianPoint(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_CartesianPoint *)0;
  }
}


SWIGINTERN Handle_Geom2d_CartesianPoint *new_Handle_Geom2d_CartesianPoint__SWIG_1(Standard_Real const X,Standard_Real const Y){
    return new Handle_Geom2d_CartesianPoint(new Geom2d_CartesianPoint(X, Y));
  }
EXPORT Handle_Geom2d_CartesianPoint *_wrap_new_Geom2d_CartesianPoint__SWIG_1 (Standard_Real larg1, Standard_Real larg2) {
  Handle_Geom2d_CartesianPoint * lresult = (Handle_Geom2d_CartesianPoint *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  Handle_Geom2d_CartesianPoint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_CartesianPoint *)new_Handle_Geom2d_CartesianPoint__SWIG_1(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_CartesianPoint\n  * wrapname: _wrap_new_Geom2d_CartesianPoint__SWIG_1\n  * fulldecl: Handle_Geom2d_CartesianPoint::Handle_Geom2d_CartesianPoint(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_CartesianPoint *)0;
  }
}


SWIGINTERN void Handle_Geom2d_CartesianPoint_SetCoord(Handle_Geom2d_CartesianPoint *self,Standard_Real const X,Standard_Real const Y){
    (*self)->SetCoord(X, Y);
  }
EXPORT void _wrap_Geom2d_CartesianPoint_SetCoord (Handle_Geom2d_CartesianPoint *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom2d_CartesianPoint *arg1 = (Handle_Geom2d_CartesianPoint *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_CartesianPoint_SetCoord(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_CartesianPoint_SetCoord\n  * wrapname: _wrap_Geom2d_CartesianPoint_SetCoord\n  * fulldecl: void Handle_Geom2d_CartesianPoint::SetCoord(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_CartesianPoint_SetPnt2d(Handle_Geom2d_CartesianPoint *self,gp_Pnt2d const &P){
    (*self)->SetPnt2d(P);
  }
EXPORT void _wrap_Geom2d_CartesianPoint_SetPnt2d (Handle_Geom2d_CartesianPoint *larg1, gp_Pnt2d *larg2) {
  Handle_Geom2d_CartesianPoint *arg1 = (Handle_Geom2d_CartesianPoint *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_CartesianPoint_SetPnt2d(arg1,(gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_CartesianPoint_SetPnt2d\n  * wrapname: _wrap_Geom2d_CartesianPoint_SetPnt2d\n  * fulldecl: void Handle_Geom2d_CartesianPoint::SetPnt2d(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_CartesianPoint_SetX(Handle_Geom2d_CartesianPoint *self,Standard_Real const X){
    (*self)->SetX(X);
  }
EXPORT void _wrap_Geom2d_CartesianPoint_SetX (Handle_Geom2d_CartesianPoint *larg1, Standard_Real larg2) {
  Handle_Geom2d_CartesianPoint *arg1 = (Handle_Geom2d_CartesianPoint *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_CartesianPoint_SetX(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_CartesianPoint_SetX\n  * wrapname: _wrap_Geom2d_CartesianPoint_SetX\n  * fulldecl: void Handle_Geom2d_CartesianPoint::SetX(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_CartesianPoint_SetY(Handle_Geom2d_CartesianPoint *self,Standard_Real const Y){
    (*self)->SetY(Y);
  }
EXPORT void _wrap_Geom2d_CartesianPoint_SetY (Handle_Geom2d_CartesianPoint *larg1, Standard_Real larg2) {
  Handle_Geom2d_CartesianPoint *arg1 = (Handle_Geom2d_CartesianPoint *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_CartesianPoint_SetY(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_CartesianPoint_SetY\n  * wrapname: _wrap_Geom2d_CartesianPoint_SetY\n  * fulldecl: void Handle_Geom2d_CartesianPoint::SetY(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_Geom2d_CartesianPoint (Handle_Geom2d_CartesianPoint *larg1) {
  Handle_Geom2d_CartesianPoint *arg1 = (Handle_Geom2d_CartesianPoint *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom2d_CartesianPoint\n  * wrapname: _wrap_delete_Geom2d_CartesianPoint\n  * fulldecl: Handle_Geom2d_CartesianPoint::~Handle_Geom2d_CartesianPoint()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Vector_Reverse(Handle_Geom2d_Vector *self){
    (*self)->Reverse();
  }
EXPORT void _wrap_Geom2d_Vector_Reverse (Handle_Geom2d_Vector *larg1) {
  Handle_Geom2d_Vector *arg1 = (Handle_Geom2d_Vector *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Vector_Reverse(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Vector_Reverse\n  * wrapname: _wrap_Geom2d_Vector_Reverse\n  * fulldecl: void Handle_Geom2d_Vector::Reverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_Vector Handle_Geom2d_Vector_Reversed(Handle_Geom2d_Vector *self){
    return (*self)->Reversed();
  }
EXPORT Handle_Geom2d_Vector *_wrap_Geom2d_Vector_Reversed (Handle_Geom2d_Vector *larg1) {
  Handle_Geom2d_Vector * lresult = (Handle_Geom2d_Vector *)0 ;
  Handle_Geom2d_Vector *arg1 = (Handle_Geom2d_Vector *) 0 ;
  SwigValueWrapper< Handle_Geom2d_Vector > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Vector_Reversed(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Vector_Reversed\n  * wrapname: _wrap_Geom2d_Vector_Reversed\n  * fulldecl: Handle_Geom2d_Vector Handle_Geom2d_Vector::Reversed()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Vector(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Vector *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Vector_Angle(Handle_Geom2d_Vector *self,Handle_Geom2d_Vector const &Other){
    return (*self)->Angle(Other);
  }
EXPORT Standard_Real _wrap_Geom2d_Vector_Angle (Handle_Geom2d_Vector *larg1, Handle_Geom2d_Vector *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Vector *arg1 = (Handle_Geom2d_Vector *) 0 ;
  Handle_Geom2d_Vector *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Vector_Angle(arg1,(Handle_Geom2d_Vector const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Vector_Angle\n  * wrapname: _wrap_Geom2d_Vector_Angle\n  * fulldecl: Standard_Real Handle_Geom2d_Vector::Angle(Handle_Geom2d_Vector const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN void Handle_Geom2d_Vector_Coord(Handle_Geom2d_Vector *self,Standard_Real &X,Standard_Real &Y){
    (*self)->Coord(X, Y);
  }
EXPORT void _wrap_Geom2d_Vector_Coord (Handle_Geom2d_Vector *larg1, Standard_Real *larg2, Standard_Real *larg3) {
  Handle_Geom2d_Vector *arg1 = (Handle_Geom2d_Vector *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Vector_Coord(arg1,*arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Vector_Coord\n  * wrapname: _wrap_Geom2d_Vector_Coord\n  * fulldecl: void Handle_Geom2d_Vector::Coord(Standard_Real &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Vector_X(Handle_Geom2d_Vector *self){
    return (*self)->X();
  }
EXPORT Standard_Real _wrap_Geom2d_Vector_X (Handle_Geom2d_Vector *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Vector *arg1 = (Handle_Geom2d_Vector *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Vector_X(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Vector_X\n  * wrapname: _wrap_Geom2d_Vector_X\n  * fulldecl: Standard_Real Handle_Geom2d_Vector::X()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Vector_Y(Handle_Geom2d_Vector *self){
    return (*self)->Y();
  }
EXPORT Standard_Real _wrap_Geom2d_Vector_Y (Handle_Geom2d_Vector *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Vector *arg1 = (Handle_Geom2d_Vector *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Vector_Y(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Vector_Y\n  * wrapname: _wrap_Geom2d_Vector_Y\n  * fulldecl: Standard_Real Handle_Geom2d_Vector::Y()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Vector_Dot(Handle_Geom2d_Vector *self,Handle_Geom2d_Vector const &Other){
    return (*self)->Dot(Other);
  }
EXPORT Standard_Real _wrap_Geom2d_Vector_Dot (Handle_Geom2d_Vector *larg1, Handle_Geom2d_Vector *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Vector *arg1 = (Handle_Geom2d_Vector *) 0 ;
  Handle_Geom2d_Vector *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Vector_Dot(arg1,(Handle_Geom2d_Vector const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Vector_Dot\n  * wrapname: _wrap_Geom2d_Vector_Dot\n  * fulldecl: Standard_Real Handle_Geom2d_Vector::Dot(Handle_Geom2d_Vector const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN gp_Vec2d Handle_Geom2d_Vector_Vec2d(Handle_Geom2d_Vector *self){
    return (*self)->Vec2d();
  }
EXPORT gp_Vec2d *_wrap_Geom2d_Vector_Vec2d (Handle_Geom2d_Vector *larg1) {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  Handle_Geom2d_Vector *arg1 = (Handle_Geom2d_Vector *) 0 ;
  gp_Vec2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Vector_Vec2d(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Vector_Vec2d\n  * wrapname: _wrap_Geom2d_Vector_Vec2d\n  * fulldecl: gp_Vec2d Handle_Geom2d_Vector::Vec2d()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec2d(result);
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


EXPORT void _wrap_delete_Geom2d_Vector (Handle_Geom2d_Vector *larg1) {
  Handle_Geom2d_Vector *arg1 = (Handle_Geom2d_Vector *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom2d_Vector\n  * wrapname: _wrap_delete_Geom2d_Vector\n  * fulldecl: Handle_Geom2d_Vector::~Handle_Geom2d_Vector()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_VectorWithMagnitude *new_Handle_Geom2d_VectorWithMagnitude__SWIG_0(gp_Vec2d const &V){
    return new Handle_Geom2d_VectorWithMagnitude(new Geom2d_VectorWithMagnitude(V));
  }
EXPORT Handle_Geom2d_VectorWithMagnitude *_wrap_new_Geom2d_VectorWithMagnitude__SWIG_0 (gp_Vec2d *larg1) {
  Handle_Geom2d_VectorWithMagnitude * lresult = (Handle_Geom2d_VectorWithMagnitude *)0 ;
  gp_Vec2d *arg1 = 0 ;
  Handle_Geom2d_VectorWithMagnitude *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_VectorWithMagnitude *)new_Handle_Geom2d_VectorWithMagnitude__SWIG_0((gp_Vec2d const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_VectorWithMagnitude\n  * wrapname: _wrap_new_Geom2d_VectorWithMagnitude__SWIG_0\n  * fulldecl: Handle_Geom2d_VectorWithMagnitude::Handle_Geom2d_VectorWithMagnitude(gp_Vec2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_VectorWithMagnitude *)0;
  }
}


SWIGINTERN Handle_Geom2d_VectorWithMagnitude *new_Handle_Geom2d_VectorWithMagnitude__SWIG_1(Standard_Real const X,Standard_Real const Y){
    return new Handle_Geom2d_VectorWithMagnitude(new Geom2d_VectorWithMagnitude(X, Y));
  }
EXPORT Handle_Geom2d_VectorWithMagnitude *_wrap_new_Geom2d_VectorWithMagnitude__SWIG_1 (Standard_Real larg1, Standard_Real larg2) {
  Handle_Geom2d_VectorWithMagnitude * lresult = (Handle_Geom2d_VectorWithMagnitude *)0 ;
  Standard_Real arg1 ;
  Standard_Real arg2 ;
  Handle_Geom2d_VectorWithMagnitude *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_VectorWithMagnitude *)new_Handle_Geom2d_VectorWithMagnitude__SWIG_1(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_VectorWithMagnitude\n  * wrapname: _wrap_new_Geom2d_VectorWithMagnitude__SWIG_1\n  * fulldecl: Handle_Geom2d_VectorWithMagnitude::Handle_Geom2d_VectorWithMagnitude(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_VectorWithMagnitude *)0;
  }
}


SWIGINTERN Handle_Geom2d_VectorWithMagnitude *new_Handle_Geom2d_VectorWithMagnitude__SWIG_2(gp_Pnt2d const &P1,gp_Pnt2d const &P2){
    return new Handle_Geom2d_VectorWithMagnitude(new Geom2d_VectorWithMagnitude(P1, P2));
  }
EXPORT Handle_Geom2d_VectorWithMagnitude *_wrap_new_Geom2d_VectorWithMagnitude__SWIG_2 (gp_Pnt2d *larg1, gp_Pnt2d *larg2) {
  Handle_Geom2d_VectorWithMagnitude * lresult = (Handle_Geom2d_VectorWithMagnitude *)0 ;
  gp_Pnt2d *arg1 = 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Handle_Geom2d_VectorWithMagnitude *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_VectorWithMagnitude *)new_Handle_Geom2d_VectorWithMagnitude__SWIG_2((gp_Pnt2d const &)*arg1,(gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_VectorWithMagnitude\n  * wrapname: _wrap_new_Geom2d_VectorWithMagnitude__SWIG_2\n  * fulldecl: Handle_Geom2d_VectorWithMagnitude::Handle_Geom2d_VectorWithMagnitude(gp_Pnt2d const &,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_VectorWithMagnitude *)0;
  }
}


SWIGINTERN void Handle_Geom2d_VectorWithMagnitude_SetCoord(Handle_Geom2d_VectorWithMagnitude *self,Standard_Real const X,Standard_Real const Y){
    return (*self)->SetCoord(X, Y);
  }
EXPORT void _wrap_Geom2d_VectorWithMagnitude_SetCoord (Handle_Geom2d_VectorWithMagnitude *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_VectorWithMagnitude_SetCoord(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_SetCoord\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_SetCoord\n  * fulldecl: void Handle_Geom2d_VectorWithMagnitude::SetCoord(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_VectorWithMagnitude_SetVec2d(Handle_Geom2d_VectorWithMagnitude *self,gp_Vec2d const &V){
    return (*self)->SetVec2d(V);
  }
EXPORT void _wrap_Geom2d_VectorWithMagnitude_SetVec2d (Handle_Geom2d_VectorWithMagnitude *larg1, gp_Vec2d *larg2) {
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  gp_Vec2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_VectorWithMagnitude_SetVec2d(arg1,(gp_Vec2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_SetVec2d\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_SetVec2d\n  * fulldecl: void Handle_Geom2d_VectorWithMagnitude::SetVec2d(gp_Vec2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_VectorWithMagnitude_SetX(Handle_Geom2d_VectorWithMagnitude *self,Standard_Real const X){
    return (*self)->SetX(X);
  }
EXPORT void _wrap_Geom2d_VectorWithMagnitude_SetX (Handle_Geom2d_VectorWithMagnitude *larg1, Standard_Real larg2) {
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_VectorWithMagnitude_SetX(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_SetX\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_SetX\n  * fulldecl: void Handle_Geom2d_VectorWithMagnitude::SetX(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_VectorWithMagnitude_SetY(Handle_Geom2d_VectorWithMagnitude *self,Standard_Real const Y){
    return (*self)->SetY(Y);
  }
EXPORT void _wrap_Geom2d_VectorWithMagnitude_SetY (Handle_Geom2d_VectorWithMagnitude *larg1, Standard_Real larg2) {
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_VectorWithMagnitude_SetY(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_SetY\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_SetY\n  * fulldecl: void Handle_Geom2d_VectorWithMagnitude::SetY(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_VectorWithMagnitude_Magnitude(Handle_Geom2d_VectorWithMagnitude *self){
    return (*self)->Magnitude();
  }
EXPORT Standard_Real _wrap_Geom2d_VectorWithMagnitude_Magnitude (Handle_Geom2d_VectorWithMagnitude *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_VectorWithMagnitude_Magnitude(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_Magnitude\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_Magnitude\n  * fulldecl: Standard_Real Handle_Geom2d_VectorWithMagnitude::Magnitude()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_VectorWithMagnitude_SquareMagnitude(Handle_Geom2d_VectorWithMagnitude *self){
    return (*self)->SquareMagnitude();
  }
EXPORT Standard_Real _wrap_Geom2d_VectorWithMagnitude_SquareMagnitude (Handle_Geom2d_VectorWithMagnitude *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_VectorWithMagnitude_SquareMagnitude(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_SquareMagnitude\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_SquareMagnitude\n  * fulldecl: Standard_Real Handle_Geom2d_VectorWithMagnitude::SquareMagnitude()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN void Handle_Geom2d_VectorWithMagnitude_Add(Handle_Geom2d_VectorWithMagnitude *self,Handle_Geom2d_Vector const &Other){
    (*self)->Add(Other);
  }
EXPORT void _wrap_Geom2d_VectorWithMagnitude_Add (Handle_Geom2d_VectorWithMagnitude *larg1, Handle_Geom2d_Vector *larg2) {
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  Handle_Geom2d_Vector *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_VectorWithMagnitude_Add(arg1,(Handle_Geom2d_Vector const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_Add\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_Add\n  * fulldecl: void Handle_Geom2d_VectorWithMagnitude::Add(Handle_Geom2d_Vector const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_VectorWithMagnitude Handle_Geom2d_VectorWithMagnitude_Added(Handle_Geom2d_VectorWithMagnitude *self,Handle_Geom2d_Vector const &Other){
    return (*self)->Added(Other);
  }
EXPORT Handle_Geom2d_VectorWithMagnitude *_wrap_Geom2d_VectorWithMagnitude_Added (Handle_Geom2d_VectorWithMagnitude *larg1, Handle_Geom2d_Vector *larg2) {
  Handle_Geom2d_VectorWithMagnitude * lresult = (Handle_Geom2d_VectorWithMagnitude *)0 ;
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  Handle_Geom2d_Vector *arg2 = 0 ;
  SwigValueWrapper< Handle_Geom2d_VectorWithMagnitude > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_VectorWithMagnitude_Added(arg1,(Handle_Geom2d_Vector const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_Added\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_Added\n  * fulldecl: Handle_Geom2d_VectorWithMagnitude Handle_Geom2d_VectorWithMagnitude::Added(Handle_Geom2d_Vector const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_VectorWithMagnitude(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_VectorWithMagnitude *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_VectorWithMagnitude_Crossed(Handle_Geom2d_VectorWithMagnitude *self,Handle_Geom2d_Vector const &Other){
    return (*self)->Crossed(Other);
  }
EXPORT Standard_Real _wrap_Geom2d_VectorWithMagnitude_Crossed (Handle_Geom2d_VectorWithMagnitude *larg1, Handle_Geom2d_Vector *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  Handle_Geom2d_Vector *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_VectorWithMagnitude_Crossed(arg1,(Handle_Geom2d_Vector const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_Crossed\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_Crossed\n  * fulldecl: Standard_Real Handle_Geom2d_VectorWithMagnitude::Crossed(Handle_Geom2d_Vector const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN void Handle_Geom2d_VectorWithMagnitude_Divide(Handle_Geom2d_VectorWithMagnitude *self,Standard_Real const Scalar){
    return (*self)->Divide(Scalar);
  }
EXPORT void _wrap_Geom2d_VectorWithMagnitude_Divide (Handle_Geom2d_VectorWithMagnitude *larg1, Standard_Real larg2) {
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_VectorWithMagnitude_Divide(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_Divide\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_Divide\n  * fulldecl: void Handle_Geom2d_VectorWithMagnitude::Divide(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_VectorWithMagnitude Handle_Geom2d_VectorWithMagnitude_Divided(Handle_Geom2d_VectorWithMagnitude *self,Standard_Real const Scalar){
    return (*self)->Divided(Scalar);
  }
EXPORT Handle_Geom2d_VectorWithMagnitude *_wrap_Geom2d_VectorWithMagnitude_Divided (Handle_Geom2d_VectorWithMagnitude *larg1, Standard_Real larg2) {
  Handle_Geom2d_VectorWithMagnitude * lresult = (Handle_Geom2d_VectorWithMagnitude *)0 ;
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  Standard_Real arg2 ;
  SwigValueWrapper< Handle_Geom2d_VectorWithMagnitude > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_VectorWithMagnitude_Divided(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_Divided\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_Divided\n  * fulldecl: Handle_Geom2d_VectorWithMagnitude Handle_Geom2d_VectorWithMagnitude::Divided(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_VectorWithMagnitude(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_VectorWithMagnitude *)0;
  }
}


SWIGINTERN Handle_Geom2d_VectorWithMagnitude Handle_Geom2d_VectorWithMagnitude_Multiplied(Handle_Geom2d_VectorWithMagnitude *self,Standard_Real const Scalar){
    return (*self)->Multiplied(Scalar);
  }
EXPORT Handle_Geom2d_VectorWithMagnitude *_wrap_Geom2d_VectorWithMagnitude_Multiplied (Handle_Geom2d_VectorWithMagnitude *larg1, Standard_Real larg2) {
  Handle_Geom2d_VectorWithMagnitude * lresult = (Handle_Geom2d_VectorWithMagnitude *)0 ;
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  Standard_Real arg2 ;
  SwigValueWrapper< Handle_Geom2d_VectorWithMagnitude > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_VectorWithMagnitude_Multiplied(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_Multiplied\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_Multiplied\n  * fulldecl: Handle_Geom2d_VectorWithMagnitude Handle_Geom2d_VectorWithMagnitude::Multiplied(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_VectorWithMagnitude(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_VectorWithMagnitude *)0;
  }
}


SWIGINTERN void Handle_Geom2d_VectorWithMagnitude_Multiply(Handle_Geom2d_VectorWithMagnitude *self,Standard_Real const Scalar){
    (*self)->Multiply(Scalar);
  }
EXPORT void _wrap_Geom2d_VectorWithMagnitude_Multiply (Handle_Geom2d_VectorWithMagnitude *larg1, Standard_Real larg2) {
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_VectorWithMagnitude_Multiply(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_Multiply\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_Multiply\n  * fulldecl: void Handle_Geom2d_VectorWithMagnitude::Multiply(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_VectorWithMagnitude_Normalize(Handle_Geom2d_VectorWithMagnitude *self){
    (*self)->Normalize();
  }
EXPORT void _wrap_Geom2d_VectorWithMagnitude_Normalize (Handle_Geom2d_VectorWithMagnitude *larg1) {
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_VectorWithMagnitude_Normalize(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_Normalize\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_Normalize\n  * fulldecl: void Handle_Geom2d_VectorWithMagnitude::Normalize()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_VectorWithMagnitude Handle_Geom2d_VectorWithMagnitude_Normalized(Handle_Geom2d_VectorWithMagnitude *self){
    return (*self)->Normalized();
  }
EXPORT Handle_Geom2d_VectorWithMagnitude *_wrap_Geom2d_VectorWithMagnitude_Normalized (Handle_Geom2d_VectorWithMagnitude *larg1) {
  Handle_Geom2d_VectorWithMagnitude * lresult = (Handle_Geom2d_VectorWithMagnitude *)0 ;
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  SwigValueWrapper< Handle_Geom2d_VectorWithMagnitude > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_VectorWithMagnitude_Normalized(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_Normalized\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_Normalized\n  * fulldecl: Handle_Geom2d_VectorWithMagnitude Handle_Geom2d_VectorWithMagnitude::Normalized()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_VectorWithMagnitude(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_VectorWithMagnitude *)0;
  }
}


SWIGINTERN Handle_Geom2d_VectorWithMagnitude Handle_Geom2d_VectorWithMagnitude_Subtracted(Handle_Geom2d_VectorWithMagnitude *self,Handle_Geom2d_Vector const &Other){
    return (*self)->Subtracted(Other);
  }
EXPORT Handle_Geom2d_VectorWithMagnitude *_wrap_Geom2d_VectorWithMagnitude_Subtracted (Handle_Geom2d_VectorWithMagnitude *larg1, Handle_Geom2d_Vector *larg2) {
  Handle_Geom2d_VectorWithMagnitude * lresult = (Handle_Geom2d_VectorWithMagnitude *)0 ;
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  Handle_Geom2d_Vector *arg2 = 0 ;
  SwigValueWrapper< Handle_Geom2d_VectorWithMagnitude > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_VectorWithMagnitude_Subtracted(arg1,(Handle_Geom2d_Vector const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_Subtracted\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_Subtracted\n  * fulldecl: Handle_Geom2d_VectorWithMagnitude Handle_Geom2d_VectorWithMagnitude::Subtracted(Handle_Geom2d_Vector const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_VectorWithMagnitude(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_VectorWithMagnitude *)0;
  }
}


SWIGINTERN void Handle_Geom2d_VectorWithMagnitude_Transform(Handle_Geom2d_VectorWithMagnitude *self,gp_Trsf2d const &T){
    return (*self)->Transform(T);
  }
EXPORT void _wrap_Geom2d_VectorWithMagnitude_Transform (Handle_Geom2d_VectorWithMagnitude *larg1, gp_Trsf2d *larg2) {
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_VectorWithMagnitude_Transform(arg1,(gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_Transform\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_Transform\n  * fulldecl: void Handle_Geom2d_VectorWithMagnitude::Transform(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_Geometry Handle_Geom2d_VectorWithMagnitude_Copy(Handle_Geom2d_VectorWithMagnitude *self){
    return (*self)->Copy();
  }
EXPORT Handle_Geom2d_Geometry *_wrap_Geom2d_VectorWithMagnitude_Copy (Handle_Geom2d_VectorWithMagnitude *larg1) {
  Handle_Geom2d_Geometry * lresult = (Handle_Geom2d_Geometry *)0 ;
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  SwigValueWrapper< Handle_Geom2d_Geometry > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_VectorWithMagnitude_Copy(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_VectorWithMagnitude_Copy\n  * wrapname: _wrap_Geom2d_VectorWithMagnitude_Copy\n  * fulldecl: Handle_Geom2d_Geometry Handle_Geom2d_VectorWithMagnitude::Copy()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Geometry *)0;
  }
}


EXPORT void _wrap_delete_Geom2d_VectorWithMagnitude (Handle_Geom2d_VectorWithMagnitude *larg1) {
  Handle_Geom2d_VectorWithMagnitude *arg1 = (Handle_Geom2d_VectorWithMagnitude *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom2d_VectorWithMagnitude\n  * wrapname: _wrap_delete_Geom2d_VectorWithMagnitude\n  * fulldecl: Handle_Geom2d_VectorWithMagnitude::~Handle_Geom2d_VectorWithMagnitude()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Curve_Reverse(Handle_Geom2d_Curve *self){
    (*self)->Reverse();
  }
EXPORT void _wrap_Geom2d_Curve_Reverse (Handle_Geom2d_Curve *larg1) {
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Curve_Reverse(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_Reverse\n  * wrapname: _wrap_Geom2d_Curve_Reverse\n  * fulldecl: void Handle_Geom2d_Curve::Reverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Curve_ReversedParameter(Handle_Geom2d_Curve *self,Standard_Real const U){
    return (*self)->ReversedParameter(U);
  }
EXPORT Standard_Real _wrap_Geom2d_Curve_ReversedParameter (Handle_Geom2d_Curve *larg1, Standard_Real larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  Standard_Real arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Curve_ReversedParameter(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_ReversedParameter\n  * wrapname: _wrap_Geom2d_Curve_ReversedParameter\n  * fulldecl: Standard_Real Handle_Geom2d_Curve::ReversedParameter(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Curve_TransformedParameter(Handle_Geom2d_Curve *self,Standard_Real const U,gp_Trsf2d const &T){
    return (*self)->TransformedParameter(U, T);
  }
EXPORT Standard_Real _wrap_Geom2d_Curve_TransformedParameter (Handle_Geom2d_Curve *larg1, Standard_Real larg2, gp_Trsf2d *larg3) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Trsf2d *arg3 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Curve_TransformedParameter(arg1,arg2,(gp_Trsf2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_TransformedParameter\n  * wrapname: _wrap_Geom2d_Curve_TransformedParameter\n  * fulldecl: Standard_Real Handle_Geom2d_Curve::TransformedParameter(Standard_Real const,gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Curve_ParametricTransformation(Handle_Geom2d_Curve *self,gp_Trsf2d const &T){
    return (*self)->ParametricTransformation(T);
  }
EXPORT Standard_Real _wrap_Geom2d_Curve_ParametricTransformation (Handle_Geom2d_Curve *larg1, gp_Trsf2d *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Curve_ParametricTransformation(arg1,(gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_ParametricTransformation\n  * wrapname: _wrap_Geom2d_Curve_ParametricTransformation\n  * fulldecl: Standard_Real Handle_Geom2d_Curve::ParametricTransformation(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Handle_Geom2d_Curve Handle_Geom2d_Curve_Reversed(Handle_Geom2d_Curve *self){
    return (*self)->Reversed();
  }
EXPORT Handle_Geom2d_Curve *_wrap_Geom2d_Curve_Reversed (Handle_Geom2d_Curve *larg1) {
  Handle_Geom2d_Curve * lresult = (Handle_Geom2d_Curve *)0 ;
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  SwigValueWrapper< Handle_Geom2d_Curve > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Curve_Reversed(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_Reversed\n  * wrapname: _wrap_Geom2d_Curve_Reversed\n  * fulldecl: Handle_Geom2d_Curve Handle_Geom2d_Curve::Reversed()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Curve(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Curve *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Curve_FirstParameter(Handle_Geom2d_Curve *self){
    return (*self)->FirstParameter();
  }
EXPORT Standard_Real _wrap_Geom2d_Curve_FirstParameter (Handle_Geom2d_Curve *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Curve_FirstParameter(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_FirstParameter\n  * wrapname: _wrap_Geom2d_Curve_FirstParameter\n  * fulldecl: Standard_Real Handle_Geom2d_Curve::FirstParameter()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Curve_LastParameter(Handle_Geom2d_Curve *self){
    return (*self)->LastParameter();
  }
EXPORT Standard_Real _wrap_Geom2d_Curve_LastParameter (Handle_Geom2d_Curve *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Curve_LastParameter(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_LastParameter\n  * wrapname: _wrap_Geom2d_Curve_LastParameter\n  * fulldecl: Standard_Real Handle_Geom2d_Curve::LastParameter()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom2d_Curve_IsClosed(Handle_Geom2d_Curve *self){
    return (*self)->IsClosed();
  }
EXPORT bool _wrap_Geom2d_Curve_IsClosed (Handle_Geom2d_Curve *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom2d_Curve_IsClosed(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_IsClosed\n  * wrapname: _wrap_Geom2d_Curve_IsClosed\n  * fulldecl: Standard_Boolean Handle_Geom2d_Curve::IsClosed()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom2d_Curve_IsPeriodic(Handle_Geom2d_Curve *self){
    return (*self)->IsPeriodic();
  }
EXPORT bool _wrap_Geom2d_Curve_IsPeriodic (Handle_Geom2d_Curve *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom2d_Curve_IsPeriodic(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_IsPeriodic\n  * wrapname: _wrap_Geom2d_Curve_IsPeriodic\n  * fulldecl: Standard_Boolean Handle_Geom2d_Curve::IsPeriodic()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Curve_Period(Handle_Geom2d_Curve *self){
    return (*self)->Period();
  }
EXPORT Standard_Real _wrap_Geom2d_Curve_Period (Handle_Geom2d_Curve *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Curve_Period(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_Period\n  * wrapname: _wrap_Geom2d_Curve_Period\n  * fulldecl: Standard_Real Handle_Geom2d_Curve::Period()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN GeomAbs_Shape Handle_Geom2d_Curve_Continuity(Handle_Geom2d_Curve *self){
    return (*self)->Continuity();
  }
EXPORT GeomAbs_Shape _wrap_Geom2d_Curve_Continuity (Handle_Geom2d_Curve *larg1) {
  GeomAbs_Shape lresult = (GeomAbs_Shape)0 ;
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  GeomAbs_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAbs_Shape)Handle_Geom2d_Curve_Continuity(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_Continuity\n  * wrapname: _wrap_Geom2d_Curve_Continuity\n  * fulldecl: GeomAbs_Shape Handle_Geom2d_Curve::Continuity()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAbs_Shape)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom2d_Curve_IsCN(Handle_Geom2d_Curve *self,Standard_Integer const N){
    return (*self)->IsCN(N);
  }
EXPORT bool _wrap_Geom2d_Curve_IsCN (Handle_Geom2d_Curve *larg1, Standard_Integer larg2) {
  bool lresult = (bool)0 ;
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom2d_Curve_IsCN(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_IsCN\n  * wrapname: _wrap_Geom2d_Curve_IsCN\n  * fulldecl: Standard_Boolean Handle_Geom2d_Curve::IsCN(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN void Handle_Geom2d_Curve_D0(Handle_Geom2d_Curve *self,Standard_Real const U,gp_Pnt2d &P){
    (*self)->D0(U, P);
  }
EXPORT void _wrap_Geom2d_Curve_D0 (Handle_Geom2d_Curve *larg1, Standard_Real larg2, gp_Pnt2d *larg3) {
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Curve_D0(arg1,arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_D0\n  * wrapname: _wrap_Geom2d_Curve_D0\n  * fulldecl: void Handle_Geom2d_Curve::D0(Standard_Real const,gp_Pnt2d &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Curve_D1(Handle_Geom2d_Curve *self,Standard_Real const U,gp_Pnt2d &P,gp_Vec2d &V1){
    (*self)->D1(U, P, V1);
  }
EXPORT void _wrap_Geom2d_Curve_D1 (Handle_Geom2d_Curve *larg1, Standard_Real larg2, gp_Pnt2d *larg3, gp_Vec2d *larg4) {
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  gp_Vec2d *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Curve_D1(arg1,arg2,*arg3,*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_D1\n  * wrapname: _wrap_Geom2d_Curve_D1\n  * fulldecl: void Handle_Geom2d_Curve::D1(Standard_Real const,gp_Pnt2d &,gp_Vec2d &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Curve_D2(Handle_Geom2d_Curve *self,Standard_Real const U,gp_Pnt2d &P,gp_Vec2d &V1,gp_Vec2d &V2){
    (*self)->D2(U, P, V1, V2);
  }
EXPORT void _wrap_Geom2d_Curve_D2 (Handle_Geom2d_Curve *larg1, Standard_Real larg2, gp_Pnt2d *larg3, gp_Vec2d *larg4, gp_Vec2d *larg5) {
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  gp_Vec2d *arg4 = 0 ;
  gp_Vec2d *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Curve_D2(arg1,arg2,*arg3,*arg4,*arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_D2\n  * wrapname: _wrap_Geom2d_Curve_D2\n  * fulldecl: void Handle_Geom2d_Curve::D2(Standard_Real const,gp_Pnt2d &,gp_Vec2d &,gp_Vec2d &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Curve_D3(Handle_Geom2d_Curve *self,Standard_Real const U,gp_Pnt2d &P,gp_Vec2d &V1,gp_Vec2d &V2,gp_Vec2d &V3){
    (*self)->D3(U, P, V1, V2, V3);
  }
EXPORT void _wrap_Geom2d_Curve_D3 (Handle_Geom2d_Curve *larg1, Standard_Real larg2, gp_Pnt2d *larg3, gp_Vec2d *larg4, gp_Vec2d *larg5, gp_Vec2d *larg6) {
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  gp_Vec2d *arg4 = 0 ;
  gp_Vec2d *arg5 = 0 ;
  gp_Vec2d *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Curve_D3(arg1,arg2,*arg3,*arg4,*arg5,*arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_D3\n  * wrapname: _wrap_Geom2d_Curve_D3\n  * fulldecl: void Handle_Geom2d_Curve::D3(Standard_Real const,gp_Pnt2d &,gp_Vec2d &,gp_Vec2d &,gp_Vec2d &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Vec2d Handle_Geom2d_Curve_DN(Handle_Geom2d_Curve *self,Standard_Real const U,Standard_Integer const N){
    return (*self)->DN(U, N);
  }
EXPORT gp_Vec2d *_wrap_Geom2d_Curve_DN (Handle_Geom2d_Curve *larg1, Standard_Real larg2, Standard_Integer larg3) {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  Standard_Real arg2 ;
  Standard_Integer arg3 ;
  gp_Vec2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Curve_DN(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_DN\n  * wrapname: _wrap_Geom2d_Curve_DN\n  * fulldecl: gp_Vec2d Handle_Geom2d_Curve::DN(Standard_Real const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec2d(result);
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


SWIGINTERN gp_Pnt2d Handle_Geom2d_Curve_Value(Handle_Geom2d_Curve *self,Standard_Real const U){
    return (*self)->Value(U);
  }
EXPORT gp_Pnt2d *_wrap_Geom2d_Curve_Value (Handle_Geom2d_Curve *larg1, Standard_Real larg2) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Curve_Value(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_Value\n  * wrapname: _wrap_Geom2d_Curve_Value\n  * fulldecl: gp_Pnt2d Handle_Geom2d_Curve::Value(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom2d_Curve_GeometryType(Handle_Geom2d_Curve *self){
    if (STANDARD_TYPE(Geom2d_Line) == (*self)->DynamicType())
      {
	return 300;
      }
    else if (STANDARD_TYPE(Geom2d_Circle) == (*self)->DynamicType())
      {
	return 301;
      }
    else if (STANDARD_TYPE(Geom2d_Ellipse) == (*self)->DynamicType())
      {
	return 302;
      }
    else if (STANDARD_TYPE(Geom2d_Hyperbola) == (*self)->DynamicType())
      {
	return 303;
      }
    else if (STANDARD_TYPE(Geom2d_Parabola) == (*self)->DynamicType())
      {
	return 304;
      }
    else if (STANDARD_TYPE(Geom2d_OffsetCurve) == (*self)->DynamicType())
      {
	return 305;
      }
    else if (STANDARD_TYPE(Geom2d_BezierCurve) == (*self)->DynamicType())
      {
	return 306;
      }
    else if (STANDARD_TYPE(Geom2d_BSplineCurve) == (*self)->DynamicType())
      {
	return 307;
      }
    else if (STANDARD_TYPE(Geom2d_TrimmedCurve) == (*self)->DynamicType())
      {
	return 308;
      }
    else if (STANDARD_TYPE(Bisector_BisecAna) == (*self)->DynamicType())
      {
	return 309;
      }
    else if (STANDARD_TYPE(Bisector_BisecCC) == (*self)->DynamicType())
      {
	return 310;
      }
    else if (STANDARD_TYPE(Bisector_BisecPC) == (*self)->DynamicType())
      {
	return 311;
      }
		
    return -1;
  }
EXPORT Standard_Integer _wrap_Geom2d_Curve_GeometryType (Handle_Geom2d_Curve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom2d_Curve_GeometryType(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Curve_GeometryType\n  * wrapname: _wrap_Geom2d_Curve_GeometryType\n  * fulldecl: Standard_Integer Handle_Geom2d_Curve::GeometryType()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT void _wrap_delete_Geom2d_Curve (Handle_Geom2d_Curve *larg1) {
  Handle_Geom2d_Curve *arg1 = (Handle_Geom2d_Curve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom2d_Curve\n  * wrapname: _wrap_delete_Geom2d_Curve\n  * fulldecl: Handle_Geom2d_Curve::~Handle_Geom2d_Curve()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Bisector_Curve_Parameter(Handle_Bisector_Curve *self,gp_Pnt2d const &P){
		return (*self)->Parameter(P);
	}
EXPORT Standard_Real _wrap_Bisector_Curve_Parameter (Handle_Bisector_Curve *larg1, gp_Pnt2d *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Bisector_Curve *arg1 = (Handle_Bisector_Curve *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Bisector_Curve_Parameter(arg1,(gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bisector_Curve_Parameter\n  * wrapname: _wrap_Bisector_Curve_Parameter\n  * fulldecl: Standard_Real Handle_Bisector_Curve::Parameter(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Bisector_Curve_IsExtendAtStart(Handle_Bisector_Curve *self){
		return (*self)->IsExtendAtStart();
	}
EXPORT bool _wrap_Bisector_Curve_IsExtendAtStart (Handle_Bisector_Curve *larg1) {
  bool lresult = (bool)0 ;
  Handle_Bisector_Curve *arg1 = (Handle_Bisector_Curve *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Bisector_Curve_IsExtendAtStart(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bisector_Curve_IsExtendAtStart\n  * wrapname: _wrap_Bisector_Curve_IsExtendAtStart\n  * fulldecl: Standard_Boolean Handle_Bisector_Curve::IsExtendAtStart()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Bisector_Curve_IsExtendAtEnd(Handle_Bisector_Curve *self){
		return (*self)->IsExtendAtEnd();
	}
EXPORT bool _wrap_Bisector_Curve_IsExtendAtEnd (Handle_Bisector_Curve *larg1) {
  bool lresult = (bool)0 ;
  Handle_Bisector_Curve *arg1 = (Handle_Bisector_Curve *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Bisector_Curve_IsExtendAtEnd(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bisector_Curve_IsExtendAtEnd\n  * wrapname: _wrap_Bisector_Curve_IsExtendAtEnd\n  * fulldecl: Standard_Boolean Handle_Bisector_Curve::IsExtendAtEnd()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Integer Handle_Bisector_Curve_NbIntervals(Handle_Bisector_Curve *self){
		return (*self)->NbIntervals();
	}
EXPORT Standard_Integer _wrap_Bisector_Curve_NbIntervals (Handle_Bisector_Curve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Bisector_Curve *arg1 = (Handle_Bisector_Curve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Bisector_Curve_NbIntervals(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bisector_Curve_NbIntervals\n  * wrapname: _wrap_Bisector_Curve_NbIntervals\n  * fulldecl: Standard_Integer Handle_Bisector_Curve::NbIntervals()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Real Handle_Bisector_Curve_IntervalFirst(Handle_Bisector_Curve *self,Standard_Integer const index){
		return (*self)->IntervalFirst(index);
	}
EXPORT Standard_Real _wrap_Bisector_Curve_IntervalFirst (Handle_Bisector_Curve *larg1, Standard_Integer larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Bisector_Curve *arg1 = (Handle_Bisector_Curve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Bisector_Curve_IntervalFirst(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bisector_Curve_IntervalFirst\n  * wrapname: _wrap_Bisector_Curve_IntervalFirst\n  * fulldecl: Standard_Real Handle_Bisector_Curve::IntervalFirst(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Bisector_Curve_IntervalLast(Handle_Bisector_Curve *self,Standard_Integer const index){
		return (*self)->IntervalLast(index);
	}
EXPORT Standard_Real _wrap_Bisector_Curve_IntervalLast (Handle_Bisector_Curve *larg1, Standard_Integer larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Bisector_Curve *arg1 = (Handle_Bisector_Curve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Bisector_Curve_IntervalLast(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bisector_Curve_IntervalLast\n  * wrapname: _wrap_Bisector_Curve_IntervalLast\n  * fulldecl: Standard_Real Handle_Bisector_Curve::IntervalLast(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_delete_Bisector_Curve (Handle_Bisector_Curve *larg1) {
  Handle_Bisector_Curve *arg1 = (Handle_Bisector_Curve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Bisector_Curve\n  * wrapname: _wrap_delete_Bisector_Curve\n  * fulldecl: Handle_Bisector_Curve::~Handle_Bisector_Curve()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_Bisector_BisecAna (Handle_Bisector_BisecAna *larg1) {
  Handle_Bisector_BisecAna *arg1 = (Handle_Bisector_BisecAna *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Bisector_BisecAna\n  * wrapname: _wrap_delete_Bisector_BisecAna\n  * fulldecl: Handle_Bisector_BisecAna::~Handle_Bisector_BisecAna()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Bisector_BisecCC *new_Handle_Bisector_BisecCC__SWIG_0(Handle_Geom2d_Curve const &Cu1,Handle_Geom2d_Curve const &Cu2,Standard_Real const Side1,Standard_Real const Side2,gp_Pnt2d const &Origin,Standard_Real const DistMax=500){
    return new Handle_Bisector_BisecCC(new Bisector_BisecCC(Cu1, Cu2, Side1, Side2, Origin, DistMax));
    }
EXPORT Handle_Bisector_BisecCC *_wrap_new_Bisector_BisecCC__SWIG_0 (Handle_Geom2d_Curve *larg1, Handle_Geom2d_Curve *larg2, Standard_Real larg3, Standard_Real larg4, gp_Pnt2d *larg5, Standard_Real larg6) {
  Handle_Bisector_BisecCC * lresult = (Handle_Bisector_BisecCC *)0 ;
  Handle_Geom2d_Curve *arg1 = 0 ;
  Handle_Geom2d_Curve *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  gp_Pnt2d *arg5 = 0 ;
  Standard_Real arg6 ;
  Handle_Bisector_BisecCC *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Bisector_BisecCC *)new_Handle_Bisector_BisecCC__SWIG_0((Handle_Geom2d_Curve const &)*arg1,(Handle_Geom2d_Curve const &)*arg2,arg3,arg4,(gp_Pnt2d const &)*arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Bisector_BisecCC\n  * wrapname: _wrap_new_Bisector_BisecCC__SWIG_0\n  * fulldecl: Handle_Bisector_BisecCC::Handle_Bisector_BisecCC(Handle_Geom2d_Curve const &,Handle_Geom2d_Curve const &,Standard_Real const,Standard_Real const,gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Bisector_BisecCC *)0;
  }
}


EXPORT Handle_Bisector_BisecCC *_wrap_new_Bisector_BisecCC__SWIG_1 (Handle_Geom2d_Curve *larg1, Handle_Geom2d_Curve *larg2, Standard_Real larg3, Standard_Real larg4, gp_Pnt2d *larg5) {
  Handle_Bisector_BisecCC * lresult = (Handle_Bisector_BisecCC *)0 ;
  Handle_Geom2d_Curve *arg1 = 0 ;
  Handle_Geom2d_Curve *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  gp_Pnt2d *arg5 = 0 ;
  Handle_Bisector_BisecCC *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Bisector_BisecCC *)new_Handle_Bisector_BisecCC__SWIG_0((Handle_Geom2d_Curve const &)*arg1,(Handle_Geom2d_Curve const &)*arg2,arg3,arg4,(gp_Pnt2d const &)*arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Bisector_BisecCC\n  * wrapname: _wrap_new_Bisector_BisecCC__SWIG_1\n  * fulldecl: Handle_Bisector_BisecCC::Handle_Bisector_BisecCC(Handle_Geom2d_Curve const &,Handle_Geom2d_Curve const &,Standard_Real const,Standard_Real const,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Bisector_BisecCC *)0;
  }
}


EXPORT void _wrap_delete_Bisector_BisecCC (Handle_Bisector_BisecCC *larg1) {
  Handle_Bisector_BisecCC *arg1 = (Handle_Bisector_BisecCC *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Bisector_BisecCC\n  * wrapname: _wrap_delete_Bisector_BisecCC\n  * fulldecl: Handle_Bisector_BisecCC::~Handle_Bisector_BisecCC()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Bisector_BisecPC *new_Handle_Bisector_BisecPC__SWIG_0(Handle_Geom2d_Curve const &Cu,gp_Pnt2d const &P,Standard_Real const Side,Standard_Real const DistMax=500){
        return new Handle_Bisector_BisecPC(new Bisector_BisecPC(Cu, P, Side, DistMax));
    }
EXPORT Handle_Bisector_BisecPC *_wrap_new_Bisector_BisecPC__SWIG_0 (Handle_Geom2d_Curve *larg1, gp_Pnt2d *larg2, Standard_Real larg3, Standard_Real larg4) {
  Handle_Bisector_BisecPC * lresult = (Handle_Bisector_BisecPC *)0 ;
  Handle_Geom2d_Curve *arg1 = 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Handle_Bisector_BisecPC *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Bisector_BisecPC *)new_Handle_Bisector_BisecPC__SWIG_0((Handle_Geom2d_Curve const &)*arg1,(gp_Pnt2d const &)*arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Bisector_BisecPC\n  * wrapname: _wrap_new_Bisector_BisecPC__SWIG_0\n  * fulldecl: Handle_Bisector_BisecPC::Handle_Bisector_BisecPC(Handle_Geom2d_Curve const &,gp_Pnt2d const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Bisector_BisecPC *)0;
  }
}


EXPORT Handle_Bisector_BisecPC *_wrap_new_Bisector_BisecPC__SWIG_1 (Handle_Geom2d_Curve *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  Handle_Bisector_BisecPC * lresult = (Handle_Bisector_BisecPC *)0 ;
  Handle_Geom2d_Curve *arg1 = 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  Handle_Bisector_BisecPC *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Bisector_BisecPC *)new_Handle_Bisector_BisecPC__SWIG_0((Handle_Geom2d_Curve const &)*arg1,(gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Bisector_BisecPC\n  * wrapname: _wrap_new_Bisector_BisecPC__SWIG_1\n  * fulldecl: Handle_Bisector_BisecPC::Handle_Bisector_BisecPC(Handle_Geom2d_Curve const &,gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Bisector_BisecPC *)0;
  }
}


EXPORT void _wrap_delete_Bisector_BisecPC (Handle_Bisector_BisecPC *larg1) {
  Handle_Bisector_BisecPC *arg1 = (Handle_Bisector_BisecPC *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Bisector_BisecPC\n  * wrapname: _wrap_delete_Bisector_BisecPC\n  * fulldecl: Handle_Bisector_BisecPC::~Handle_Bisector_BisecPC()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_Line *new_Handle_Geom2d_Line__SWIG_0(gp_Ax2d const &A){
		return new Handle_Geom2d_Line(new Geom2d_Line(A));
	}
EXPORT Handle_Geom2d_Line *_wrap_new_Geom2d_Line__SWIG_0 (gp_Ax2d *larg1) {
  Handle_Geom2d_Line * lresult = (Handle_Geom2d_Line *)0 ;
  gp_Ax2d *arg1 = 0 ;
  Handle_Geom2d_Line *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Line *)new_Handle_Geom2d_Line__SWIG_0((gp_Ax2d const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Line\n  * wrapname: _wrap_new_Geom2d_Line__SWIG_0\n  * fulldecl: Handle_Geom2d_Line::Handle_Geom2d_Line(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Line *)0;
  }
}


SWIGINTERN Handle_Geom2d_Line *new_Handle_Geom2d_Line__SWIG_1(gp_Lin2d const &L){
		return new Handle_Geom2d_Line(new Geom2d_Line(L));
	}
EXPORT Handle_Geom2d_Line *_wrap_new_Geom2d_Line__SWIG_1 (gp_Lin2d *larg1) {
  Handle_Geom2d_Line * lresult = (Handle_Geom2d_Line *)0 ;
  gp_Lin2d *arg1 = 0 ;
  Handle_Geom2d_Line *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Line *)new_Handle_Geom2d_Line__SWIG_1((gp_Lin2d const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Line\n  * wrapname: _wrap_new_Geom2d_Line__SWIG_1\n  * fulldecl: Handle_Geom2d_Line::Handle_Geom2d_Line(gp_Lin2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Line *)0;
  }
}


SWIGINTERN Handle_Geom2d_Line *new_Handle_Geom2d_Line__SWIG_2(gp_Pnt2d const &P,gp_Dir2d const &V){
		return new Handle_Geom2d_Line(new Geom2d_Line(P, V));
	}
EXPORT Handle_Geom2d_Line *_wrap_new_Geom2d_Line__SWIG_2 (gp_Pnt2d *larg1, gp_Dir2d *larg2) {
  Handle_Geom2d_Line * lresult = (Handle_Geom2d_Line *)0 ;
  gp_Pnt2d *arg1 = 0 ;
  gp_Dir2d *arg2 = 0 ;
  Handle_Geom2d_Line *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Line *)new_Handle_Geom2d_Line__SWIG_2((gp_Pnt2d const &)*arg1,(gp_Dir2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Line\n  * wrapname: _wrap_new_Geom2d_Line__SWIG_2\n  * fulldecl: Handle_Geom2d_Line::Handle_Geom2d_Line(gp_Pnt2d const &,gp_Dir2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Line *)0;
  }
}


SWIGINTERN void Handle_Geom2d_Line_SetLin2d(Handle_Geom2d_Line *self,gp_Lin2d const &L){
	  (*self)->SetLin2d(L);
	}
EXPORT void _wrap_Geom2d_Line_SetLin2d (Handle_Geom2d_Line *larg1, gp_Lin2d *larg2) {
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  gp_Lin2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Line_SetLin2d(arg1,(gp_Lin2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_SetLin2d\n  * wrapname: _wrap_Geom2d_Line_SetLin2d\n  * fulldecl: void Handle_Geom2d_Line::SetLin2d(gp_Lin2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_Line_SetDirection(Handle_Geom2d_Line *self,gp_Dir2d const &V){
	  (*self)->SetDirection(V);
	}
EXPORT void _wrap_Geom2d_Line_SetDirection (Handle_Geom2d_Line *larg1, gp_Dir2d *larg2) {
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  gp_Dir2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Line_SetDirection(arg1,(gp_Dir2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_SetDirection\n  * wrapname: _wrap_Geom2d_Line_SetDirection\n  * fulldecl: void Handle_Geom2d_Line::SetDirection(gp_Dir2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Dir2d const *Handle_Geom2d_Line_Direction(Handle_Geom2d_Line *self){
	  return (gp_Dir2d *)&(*self)->Direction();
	}
EXPORT gp_Dir2d *_wrap_Geom2d_Line_Direction (Handle_Geom2d_Line *larg1) {
  gp_Dir2d * lresult = (gp_Dir2d *)0 ;
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  gp_Dir2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Dir2d *)Handle_Geom2d_Line_Direction(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_Direction\n  * wrapname: _wrap_Geom2d_Line_Direction\n  * fulldecl: gp_Dir2d const * Handle_Geom2d_Line::Direction()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Dir2d *)0;
  }
}


SWIGINTERN void Handle_Geom2d_Line_SetLocation(Handle_Geom2d_Line *self,gp_Pnt2d const &P){
	  (*self)->SetLocation(P);
	}
EXPORT void _wrap_Geom2d_Line_SetLocation (Handle_Geom2d_Line *larg1, gp_Pnt2d *larg2) {
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Line_SetLocation(arg1,(gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_SetLocation\n  * wrapname: _wrap_Geom2d_Line_SetLocation\n  * fulldecl: void Handle_Geom2d_Line::SetLocation(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Pnt2d *Handle_Geom2d_Line_Location(Handle_Geom2d_Line *self){
	  return (gp_Pnt2d *)&(*self)->Location();
	}
EXPORT gp_Pnt2d *_wrap_Geom2d_Line_Location (Handle_Geom2d_Line *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  gp_Pnt2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Pnt2d *)Handle_Geom2d_Line_Location(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_Location\n  * wrapname: _wrap_Geom2d_Line_Location\n  * fulldecl: gp_Pnt2d * Handle_Geom2d_Line::Location()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


SWIGINTERN void Handle_Geom2d_Line_SetPosition(Handle_Geom2d_Line *self,gp_Ax2d const &A){
	  (*self)->SetPosition(A);
	}
EXPORT void _wrap_Geom2d_Line_SetPosition (Handle_Geom2d_Line *larg1, gp_Ax2d *larg2) {
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  gp_Ax2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Line_SetPosition(arg1,(gp_Ax2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_SetPosition\n  * wrapname: _wrap_Geom2d_Line_SetPosition\n  * fulldecl: void Handle_Geom2d_Line::SetPosition(gp_Ax2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Ax2d *Handle_Geom2d_Line_Position(Handle_Geom2d_Line *self){
	  return (gp_Ax2d *)&(*self)->Position();
	}
EXPORT gp_Ax2d *_wrap_Geom2d_Line_Position (Handle_Geom2d_Line *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  gp_Ax2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Ax2d *)Handle_Geom2d_Line_Position(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_Position\n  * wrapname: _wrap_Geom2d_Line_Position\n  * fulldecl: gp_Ax2d * Handle_Geom2d_Line::Position()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


SWIGINTERN void Handle_Geom2d_Line_Reverse(Handle_Geom2d_Line *self){
	  (*self)->Reverse();
	}
EXPORT void _wrap_Geom2d_Line_Reverse (Handle_Geom2d_Line *larg1) {
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Line_Reverse(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_Reverse\n  * wrapname: _wrap_Geom2d_Line_Reverse\n  * fulldecl: void Handle_Geom2d_Line::Reverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Line_ReversedParameter(Handle_Geom2d_Line *self,Standard_Real const U){
	  return (*self)->ReversedParameter(U);
	}
EXPORT Standard_Real _wrap_Geom2d_Line_ReversedParameter (Handle_Geom2d_Line *larg1, Standard_Real larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  Standard_Real arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Line_ReversedParameter(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_ReversedParameter\n  * wrapname: _wrap_Geom2d_Line_ReversedParameter\n  * fulldecl: Standard_Real Handle_Geom2d_Line::ReversedParameter(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Line_FirstParameter(Handle_Geom2d_Line *self){
	  return (*self)->FirstParameter();
	}
EXPORT Standard_Real _wrap_Geom2d_Line_FirstParameter (Handle_Geom2d_Line *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Line_FirstParameter(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_FirstParameter\n  * wrapname: _wrap_Geom2d_Line_FirstParameter\n  * fulldecl: Standard_Real Handle_Geom2d_Line::FirstParameter()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Line_LastParameter(Handle_Geom2d_Line *self){
	  return (*self)->LastParameter();
	}
EXPORT Standard_Real _wrap_Geom2d_Line_LastParameter (Handle_Geom2d_Line *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Line_LastParameter(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_LastParameter\n  * wrapname: _wrap_Geom2d_Line_LastParameter\n  * fulldecl: Standard_Real Handle_Geom2d_Line::LastParameter()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom2d_Line_IsClosed(Handle_Geom2d_Line *self){
	  return (*self)->IsClosed();
	}
EXPORT bool _wrap_Geom2d_Line_IsClosed (Handle_Geom2d_Line *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom2d_Line_IsClosed(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_IsClosed\n  * wrapname: _wrap_Geom2d_Line_IsClosed\n  * fulldecl: Standard_Boolean Handle_Geom2d_Line::IsClosed()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom2d_Line_IsPeriodic(Handle_Geom2d_Line *self){
	  return (*self)->IsPeriodic();
	}
EXPORT bool _wrap_Geom2d_Line_IsPeriodic (Handle_Geom2d_Line *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom2d_Line_IsPeriodic(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_IsPeriodic\n  * wrapname: _wrap_Geom2d_Line_IsPeriodic\n  * fulldecl: Standard_Boolean Handle_Geom2d_Line::IsPeriodic()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN GeomAbs_Shape Handle_Geom2d_Line_Continuity(Handle_Geom2d_Line *self){
	  return (*self)->Continuity();
	}
EXPORT GeomAbs_Shape _wrap_Geom2d_Line_Continuity (Handle_Geom2d_Line *larg1) {
  GeomAbs_Shape lresult = (GeomAbs_Shape)0 ;
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  GeomAbs_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAbs_Shape)Handle_Geom2d_Line_Continuity(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_Continuity\n  * wrapname: _wrap_Geom2d_Line_Continuity\n  * fulldecl: GeomAbs_Shape Handle_Geom2d_Line::Continuity()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAbs_Shape)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Line_Distance(Handle_Geom2d_Line *self,gp_Pnt2d const &P){
	  return (*self)->Distance(P);
	}
EXPORT Standard_Real _wrap_Geom2d_Line_Distance (Handle_Geom2d_Line *larg1, gp_Pnt2d *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Line_Distance(arg1,(gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_Distance\n  * wrapname: _wrap_Geom2d_Line_Distance\n  * fulldecl: Standard_Real Handle_Geom2d_Line::Distance(gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom2d_Line_IsCN(Handle_Geom2d_Line *self,Standard_Integer const N){
	  return (*self)->IsCN(N);
	}
EXPORT bool _wrap_Geom2d_Line_IsCN (Handle_Geom2d_Line *larg1, Standard_Integer larg2) {
  bool lresult = (bool)0 ;
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  Standard_Integer arg2 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom2d_Line_IsCN(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_IsCN\n  * wrapname: _wrap_Geom2d_Line_IsCN\n  * fulldecl: Standard_Boolean Handle_Geom2d_Line::IsCN(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN void Handle_Geom2d_Line_Transform(Handle_Geom2d_Line *self,gp_Trsf2d const &T){
	  (*self)->Transform(T);
	}
EXPORT void _wrap_Geom2d_Line_Transform (Handle_Geom2d_Line *larg1, gp_Trsf2d *larg2) {
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_Line_Transform(arg1,(gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_Transform\n  * wrapname: _wrap_Geom2d_Line_Transform\n  * fulldecl: void Handle_Geom2d_Line::Transform(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Line_TransformedParameter(Handle_Geom2d_Line *self,Standard_Real const U,gp_Trsf2d const &T){
	  return (*self)->TransformedParameter(U, T);
	}
EXPORT Standard_Real _wrap_Geom2d_Line_TransformedParameter (Handle_Geom2d_Line *larg1, Standard_Real larg2, gp_Trsf2d *larg3) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  Standard_Real arg2 ;
  gp_Trsf2d *arg3 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Line_TransformedParameter(arg1,arg2,(gp_Trsf2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_TransformedParameter\n  * wrapname: _wrap_Geom2d_Line_TransformedParameter\n  * fulldecl: Standard_Real Handle_Geom2d_Line::TransformedParameter(Standard_Real const,gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Line_ParametricTransformation(Handle_Geom2d_Line *self,gp_Trsf2d const &T){
	  return (*self)->ParametricTransformation(T);
	}
EXPORT Standard_Real _wrap_Geom2d_Line_ParametricTransformation (Handle_Geom2d_Line *larg1, gp_Trsf2d *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Line_ParametricTransformation(arg1,(gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Line_ParametricTransformation\n  * wrapname: _wrap_Geom2d_Line_ParametricTransformation\n  * fulldecl: Standard_Real Handle_Geom2d_Line::ParametricTransformation(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_delete_Geom2d_Line (Handle_Geom2d_Line *larg1) {
  Handle_Geom2d_Line *arg1 = (Handle_Geom2d_Line *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom2d_Line\n  * wrapname: _wrap_delete_Geom2d_Line\n  * fulldecl: Handle_Geom2d_Line::~Handle_Geom2d_Line()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_OffsetCurve *new_Handle_Geom2d_OffsetCurve(Handle_Geom2d_Curve const &C,Standard_Real const Offset){
		return new Handle_Geom2d_OffsetCurve(new Geom2d_OffsetCurve(C, Offset));
	}
EXPORT Handle_Geom2d_OffsetCurve *_wrap_new_Geom2d_OffsetCurve (Handle_Geom2d_Curve *larg1, Standard_Real larg2) {
  Handle_Geom2d_OffsetCurve * lresult = (Handle_Geom2d_OffsetCurve *)0 ;
  Handle_Geom2d_Curve *arg1 = 0 ;
  Standard_Real arg2 ;
  Handle_Geom2d_OffsetCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_OffsetCurve *)new_Handle_Geom2d_OffsetCurve((Handle_Geom2d_Curve const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_OffsetCurve\n  * wrapname: _wrap_new_Geom2d_OffsetCurve\n  * fulldecl: Handle_Geom2d_OffsetCurve::Handle_Geom2d_OffsetCurve(Handle_Geom2d_Curve const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_OffsetCurve *)0;
  }
}


SWIGINTERN Handle_Geom2d_Curve Handle_Geom2d_OffsetCurve_BasisCurve(Handle_Geom2d_OffsetCurve *self){
		return (*self)->BasisCurve();
	}
EXPORT Handle_Geom2d_Curve *_wrap_Geom2d_OffsetCurve_BasisCurve (Handle_Geom2d_OffsetCurve *larg1) {
  Handle_Geom2d_Curve * lresult = (Handle_Geom2d_Curve *)0 ;
  Handle_Geom2d_OffsetCurve *arg1 = (Handle_Geom2d_OffsetCurve *) 0 ;
  SwigValueWrapper< Handle_Geom2d_Curve > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_OffsetCurve_BasisCurve(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_OffsetCurve_BasisCurve\n  * wrapname: _wrap_Geom2d_OffsetCurve_BasisCurve\n  * fulldecl: Handle_Geom2d_Curve Handle_Geom2d_OffsetCurve::BasisCurve()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Curve(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Curve *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_OffsetCurve_Offset(Handle_Geom2d_OffsetCurve *self){
		return (*self)->Offset();
	}
EXPORT Standard_Real _wrap_Geom2d_OffsetCurve_Offset (Handle_Geom2d_OffsetCurve *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_OffsetCurve *arg1 = (Handle_Geom2d_OffsetCurve *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_OffsetCurve_Offset(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_OffsetCurve_Offset\n  * wrapname: _wrap_Geom2d_OffsetCurve_Offset\n  * fulldecl: Standard_Real Handle_Geom2d_OffsetCurve::Offset()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_delete_Geom2d_OffsetCurve (Handle_Geom2d_OffsetCurve *larg1) {
  Handle_Geom2d_OffsetCurve *arg1 = (Handle_Geom2d_OffsetCurve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom2d_OffsetCurve\n  * wrapname: _wrap_delete_Geom2d_OffsetCurve\n  * fulldecl: Handle_Geom2d_OffsetCurve::~Handle_Geom2d_OffsetCurve()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Ax2d Handle_Geom2d_Conic_XAxis(Handle_Geom2d_Conic *self){
		return (*self)->XAxis();
	}
EXPORT gp_Ax2d *_wrap_Geom2d_Conic_XAxis (Handle_Geom2d_Conic *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  Handle_Geom2d_Conic *arg1 = (Handle_Geom2d_Conic *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Conic_XAxis(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Conic_XAxis\n  * wrapname: _wrap_Geom2d_Conic_XAxis\n  * fulldecl: gp_Ax2d Handle_Geom2d_Conic::XAxis()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


SWIGINTERN gp_Ax2d Handle_Geom2d_Conic_YAxis(Handle_Geom2d_Conic *self){
		return (*self)->YAxis();
	}
EXPORT gp_Ax2d *_wrap_Geom2d_Conic_YAxis (Handle_Geom2d_Conic *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  Handle_Geom2d_Conic *arg1 = (Handle_Geom2d_Conic *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Conic_YAxis(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Conic_YAxis\n  * wrapname: _wrap_Geom2d_Conic_YAxis\n  * fulldecl: gp_Ax2d Handle_Geom2d_Conic::YAxis()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Conic_Eccentricity(Handle_Geom2d_Conic *self){
		return (*self)->Eccentricity();
	}
EXPORT Standard_Real _wrap_Geom2d_Conic_Eccentricity (Handle_Geom2d_Conic *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Conic *arg1 = (Handle_Geom2d_Conic *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Conic_Eccentricity(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Conic_Eccentricity\n  * wrapname: _wrap_Geom2d_Conic_Eccentricity\n  * fulldecl: Standard_Real Handle_Geom2d_Conic::Eccentricity()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN gp_Pnt2d Handle_Geom2d_Conic_Location(Handle_Geom2d_Conic *self){
		return (*self)->Location();
	}
EXPORT gp_Pnt2d *_wrap_Geom2d_Conic_Location (Handle_Geom2d_Conic *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Handle_Geom2d_Conic *arg1 = (Handle_Geom2d_Conic *) 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Conic_Location(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Conic_Location\n  * wrapname: _wrap_Geom2d_Conic_Location\n  * fulldecl: gp_Pnt2d Handle_Geom2d_Conic::Location()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


SWIGINTERN gp_Ax22d Handle_Geom2d_Conic_Position(Handle_Geom2d_Conic *self){
		return (*self)->Position();
	}
EXPORT gp_Ax22d *_wrap_Geom2d_Conic_Position (Handle_Geom2d_Conic *larg1) {
  gp_Ax22d * lresult = (gp_Ax22d *)0 ;
  Handle_Geom2d_Conic *arg1 = (Handle_Geom2d_Conic *) 0 ;
  gp_Ax22d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Conic_Position(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Conic_Position\n  * wrapname: _wrap_Geom2d_Conic_Position\n  * fulldecl: gp_Ax22d Handle_Geom2d_Conic::Position()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax22d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax22d *)0;
  }
}


EXPORT void _wrap_delete_Geom2d_Conic (Handle_Geom2d_Conic *larg1) {
  Handle_Geom2d_Conic *arg1 = (Handle_Geom2d_Conic *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom2d_Conic\n  * wrapname: _wrap_delete_Geom2d_Conic\n  * fulldecl: Handle_Geom2d_Conic::~Handle_Geom2d_Conic()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_Circle *new_Handle_Geom2d_Circle(gp_Ax22d const &A,Standard_Real const R){
		return new Handle_Geom2d_Circle(new Geom2d_Circle(A, R));
	}
EXPORT Handle_Geom2d_Circle *_wrap_new_Geom2d_Circle (gp_Ax22d *larg1, Standard_Real larg2) {
  Handle_Geom2d_Circle * lresult = (Handle_Geom2d_Circle *)0 ;
  gp_Ax22d *arg1 = 0 ;
  Standard_Real arg2 ;
  Handle_Geom2d_Circle *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Circle *)new_Handle_Geom2d_Circle((gp_Ax22d const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Circle\n  * wrapname: _wrap_new_Geom2d_Circle\n  * fulldecl: Handle_Geom2d_Circle::Handle_Geom2d_Circle(gp_Ax22d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Circle *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Circle_Radius(Handle_Geom2d_Circle *self){
    return (*self)->Radius();
  }
EXPORT Standard_Real _wrap_Geom2d_Circle_Radius (Handle_Geom2d_Circle *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Circle *arg1 = (Handle_Geom2d_Circle *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Circle_Radius(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Circle_Radius\n  * wrapname: _wrap_Geom2d_Circle_Radius\n  * fulldecl: Standard_Real Handle_Geom2d_Circle::Radius()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_delete_Geom2d_Circle (Handle_Geom2d_Circle *larg1) {
  Handle_Geom2d_Circle *arg1 = (Handle_Geom2d_Circle *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom2d_Circle\n  * wrapname: _wrap_delete_Geom2d_Circle\n  * fulldecl: Handle_Geom2d_Circle::~Handle_Geom2d_Circle()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_Ellipse *new_Handle_Geom2d_Ellipse__SWIG_0(gp_Ax2d const &MajorAxis,Standard_Real const MajorRadius,Standard_Real const MinorRadius,Standard_Boolean const Sense=Standard_True){
    return new Handle_Geom2d_Ellipse(new Geom2d_Ellipse(MajorAxis, MajorRadius, MinorRadius, Sense));
  }
EXPORT Handle_Geom2d_Ellipse *_wrap_new_Geom2d_Ellipse__SWIG_0 (gp_Ax2d *larg1, Standard_Real larg2, Standard_Real larg3, bool larg4) {
  Handle_Geom2d_Ellipse * lresult = (Handle_Geom2d_Ellipse *)0 ;
  gp_Ax2d *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Boolean arg4 ;
  Handle_Geom2d_Ellipse *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Ellipse *)new_Handle_Geom2d_Ellipse__SWIG_0((gp_Ax2d const &)*arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Ellipse\n  * wrapname: _wrap_new_Geom2d_Ellipse__SWIG_0\n  * fulldecl: Handle_Geom2d_Ellipse::Handle_Geom2d_Ellipse(gp_Ax2d const &,Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Ellipse *)0;
  }
}


EXPORT Handle_Geom2d_Ellipse *_wrap_new_Geom2d_Ellipse__SWIG_1 (gp_Ax2d *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom2d_Ellipse * lresult = (Handle_Geom2d_Ellipse *)0 ;
  gp_Ax2d *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Handle_Geom2d_Ellipse *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Ellipse *)new_Handle_Geom2d_Ellipse__SWIG_0((gp_Ax2d const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Ellipse\n  * wrapname: _wrap_new_Geom2d_Ellipse__SWIG_1\n  * fulldecl: Handle_Geom2d_Ellipse::Handle_Geom2d_Ellipse(gp_Ax2d const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Ellipse *)0;
  }
}


SWIGINTERN Handle_Geom2d_Ellipse *new_Handle_Geom2d_Ellipse__SWIG_2(gp_Ax22d const &Axis,Standard_Real const MajorRadius,Standard_Real const MinorRadius){
    return new Handle_Geom2d_Ellipse(new Geom2d_Ellipse(Axis, MajorRadius, MinorRadius));
  }
EXPORT Handle_Geom2d_Ellipse *_wrap_new_Geom2d_Ellipse__SWIG_2 (gp_Ax22d *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom2d_Ellipse * lresult = (Handle_Geom2d_Ellipse *)0 ;
  gp_Ax22d *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Handle_Geom2d_Ellipse *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Ellipse *)new_Handle_Geom2d_Ellipse__SWIG_2((gp_Ax22d const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Ellipse\n  * wrapname: _wrap_new_Geom2d_Ellipse__SWIG_2\n  * fulldecl: Handle_Geom2d_Ellipse::Handle_Geom2d_Ellipse(gp_Ax22d const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Ellipse *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Ellipse_MajorRadius(Handle_Geom2d_Ellipse *self){
        return (*self)->MajorRadius();
    }
EXPORT Standard_Real _wrap_Geom2d_Ellipse_MajorRadius (Handle_Geom2d_Ellipse *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Ellipse *arg1 = (Handle_Geom2d_Ellipse *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Ellipse_MajorRadius(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Ellipse_MajorRadius\n  * wrapname: _wrap_Geom2d_Ellipse_MajorRadius\n  * fulldecl: Standard_Real Handle_Geom2d_Ellipse::MajorRadius()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Ellipse_MinorRadius(Handle_Geom2d_Ellipse *self){
        return (*self)->MinorRadius();
    }
EXPORT Standard_Real _wrap_Geom2d_Ellipse_MinorRadius (Handle_Geom2d_Ellipse *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Ellipse *arg1 = (Handle_Geom2d_Ellipse *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Ellipse_MinorRadius(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Ellipse_MinorRadius\n  * wrapname: _wrap_Geom2d_Ellipse_MinorRadius\n  * fulldecl: Standard_Real Handle_Geom2d_Ellipse::MinorRadius()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN gp_Ax2d Handle_Geom2d_Ellipse_Directrix1(Handle_Geom2d_Ellipse *self){
		return (*self)->Directrix1();
	}
EXPORT gp_Ax2d *_wrap_Geom2d_Ellipse_Directrix1 (Handle_Geom2d_Ellipse *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  Handle_Geom2d_Ellipse *arg1 = (Handle_Geom2d_Ellipse *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Ellipse_Directrix1(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Ellipse_Directrix1\n  * wrapname: _wrap_Geom2d_Ellipse_Directrix1\n  * fulldecl: gp_Ax2d Handle_Geom2d_Ellipse::Directrix1()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


SWIGINTERN gp_Ax2d Handle_Geom2d_Ellipse_Directrix2(Handle_Geom2d_Ellipse *self){
		return (*self)->Directrix2();
	}
EXPORT gp_Ax2d *_wrap_Geom2d_Ellipse_Directrix2 (Handle_Geom2d_Ellipse *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  Handle_Geom2d_Ellipse *arg1 = (Handle_Geom2d_Ellipse *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Ellipse_Directrix2(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Ellipse_Directrix2\n  * wrapname: _wrap_Geom2d_Ellipse_Directrix2\n  * fulldecl: gp_Ax2d Handle_Geom2d_Ellipse::Directrix2()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Ellipse_FocalDistance(Handle_Geom2d_Ellipse *self){
		return (*self)->Focal();
	}
EXPORT Standard_Real _wrap_Geom2d_Ellipse_FocalDistance (Handle_Geom2d_Ellipse *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Ellipse *arg1 = (Handle_Geom2d_Ellipse *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Ellipse_FocalDistance(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Ellipse_FocalDistance\n  * wrapname: _wrap_Geom2d_Ellipse_FocalDistance\n  * fulldecl: Standard_Real Handle_Geom2d_Ellipse::FocalDistance()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN gp_Pnt2d Handle_Geom2d_Ellipse_Focus1(Handle_Geom2d_Ellipse *self){
		return (*self)->Focus1();
	}
EXPORT gp_Pnt2d *_wrap_Geom2d_Ellipse_Focus1 (Handle_Geom2d_Ellipse *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Handle_Geom2d_Ellipse *arg1 = (Handle_Geom2d_Ellipse *) 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Ellipse_Focus1(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Ellipse_Focus1\n  * wrapname: _wrap_Geom2d_Ellipse_Focus1\n  * fulldecl: gp_Pnt2d Handle_Geom2d_Ellipse::Focus1()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


SWIGINTERN gp_Pnt2d Handle_Geom2d_Ellipse_Focus2(Handle_Geom2d_Ellipse *self){
		return (*self)->Focus2();
	}
EXPORT gp_Pnt2d *_wrap_Geom2d_Ellipse_Focus2 (Handle_Geom2d_Ellipse *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Handle_Geom2d_Ellipse *arg1 = (Handle_Geom2d_Ellipse *) 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Ellipse_Focus2(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Ellipse_Focus2\n  * wrapname: _wrap_Geom2d_Ellipse_Focus2\n  * fulldecl: gp_Pnt2d Handle_Geom2d_Ellipse::Focus2()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT void _wrap_delete_Geom2d_Ellipse (Handle_Geom2d_Ellipse *larg1) {
  Handle_Geom2d_Ellipse *arg1 = (Handle_Geom2d_Ellipse *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom2d_Ellipse\n  * wrapname: _wrap_delete_Geom2d_Ellipse\n  * fulldecl: Handle_Geom2d_Ellipse::~Handle_Geom2d_Ellipse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_Hyperbola *new_Handle_Geom2d_Hyperbola(gp_Ax22d const &Axis,Standard_Real const MajorRadius,Standard_Real const MinorRadius){
        return new Handle_Geom2d_Hyperbola(new Geom2d_Hyperbola(Axis, MajorRadius, MinorRadius));
    }
EXPORT Handle_Geom2d_Hyperbola *_wrap_new_Geom2d_Hyperbola (gp_Ax22d *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom2d_Hyperbola * lresult = (Handle_Geom2d_Hyperbola *)0 ;
  gp_Ax22d *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Handle_Geom2d_Hyperbola *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Hyperbola *)new_Handle_Geom2d_Hyperbola((gp_Ax22d const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Hyperbola\n  * wrapname: _wrap_new_Geom2d_Hyperbola\n  * fulldecl: Handle_Geom2d_Hyperbola::Handle_Geom2d_Hyperbola(gp_Ax22d const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Hyperbola *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Hyperbola_MajorRadius(Handle_Geom2d_Hyperbola *self){
        return (*self)->MajorRadius();
    }
EXPORT Standard_Real _wrap_Geom2d_Hyperbola_MajorRadius (Handle_Geom2d_Hyperbola *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Hyperbola *arg1 = (Handle_Geom2d_Hyperbola *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Hyperbola_MajorRadius(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Hyperbola_MajorRadius\n  * wrapname: _wrap_Geom2d_Hyperbola_MajorRadius\n  * fulldecl: Standard_Real Handle_Geom2d_Hyperbola::MajorRadius()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Hyperbola_MinorRadius(Handle_Geom2d_Hyperbola *self){
        return (*self)->MinorRadius();
    }
EXPORT Standard_Real _wrap_Geom2d_Hyperbola_MinorRadius (Handle_Geom2d_Hyperbola *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Hyperbola *arg1 = (Handle_Geom2d_Hyperbola *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Hyperbola_MinorRadius(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Hyperbola_MinorRadius\n  * wrapname: _wrap_Geom2d_Hyperbola_MinorRadius\n  * fulldecl: Standard_Real Handle_Geom2d_Hyperbola::MinorRadius()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN gp_Ax2d Handle_Geom2d_Hyperbola_Directrix1(Handle_Geom2d_Hyperbola *self){
        return (*self)->Directrix1();
    }
EXPORT gp_Ax2d *_wrap_Geom2d_Hyperbola_Directrix1 (Handle_Geom2d_Hyperbola *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  Handle_Geom2d_Hyperbola *arg1 = (Handle_Geom2d_Hyperbola *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Hyperbola_Directrix1(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Hyperbola_Directrix1\n  * wrapname: _wrap_Geom2d_Hyperbola_Directrix1\n  * fulldecl: gp_Ax2d Handle_Geom2d_Hyperbola::Directrix1()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


SWIGINTERN gp_Ax2d Handle_Geom2d_Hyperbola_Directrix2(Handle_Geom2d_Hyperbola *self){
        return (*self)->Directrix2();
    }
EXPORT gp_Ax2d *_wrap_Geom2d_Hyperbola_Directrix2 (Handle_Geom2d_Hyperbola *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  Handle_Geom2d_Hyperbola *arg1 = (Handle_Geom2d_Hyperbola *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Hyperbola_Directrix2(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Hyperbola_Directrix2\n  * wrapname: _wrap_Geom2d_Hyperbola_Directrix2\n  * fulldecl: gp_Ax2d Handle_Geom2d_Hyperbola::Directrix2()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Hyperbola_FocalDistance(Handle_Geom2d_Hyperbola *self){
        return (*self)->Focal();
    }
EXPORT Standard_Real _wrap_Geom2d_Hyperbola_FocalDistance (Handle_Geom2d_Hyperbola *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Hyperbola *arg1 = (Handle_Geom2d_Hyperbola *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Hyperbola_FocalDistance(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Hyperbola_FocalDistance\n  * wrapname: _wrap_Geom2d_Hyperbola_FocalDistance\n  * fulldecl: Standard_Real Handle_Geom2d_Hyperbola::FocalDistance()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN gp_Pnt2d Handle_Geom2d_Hyperbola_Focus1(Handle_Geom2d_Hyperbola *self){
        return (*self)->Focus1();
    }
EXPORT gp_Pnt2d *_wrap_Geom2d_Hyperbola_Focus1 (Handle_Geom2d_Hyperbola *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Handle_Geom2d_Hyperbola *arg1 = (Handle_Geom2d_Hyperbola *) 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Hyperbola_Focus1(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Hyperbola_Focus1\n  * wrapname: _wrap_Geom2d_Hyperbola_Focus1\n  * fulldecl: gp_Pnt2d Handle_Geom2d_Hyperbola::Focus1()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


SWIGINTERN gp_Pnt2d Handle_Geom2d_Hyperbola_Focus2(Handle_Geom2d_Hyperbola *self){
        return (*self)->Focus2();
    }
EXPORT gp_Pnt2d *_wrap_Geom2d_Hyperbola_Focus2 (Handle_Geom2d_Hyperbola *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Handle_Geom2d_Hyperbola *arg1 = (Handle_Geom2d_Hyperbola *) 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Hyperbola_Focus2(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Hyperbola_Focus2\n  * wrapname: _wrap_Geom2d_Hyperbola_Focus2\n  * fulldecl: gp_Pnt2d Handle_Geom2d_Hyperbola::Focus2()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT void _wrap_delete_Geom2d_Hyperbola (Handle_Geom2d_Hyperbola *larg1) {
  Handle_Geom2d_Hyperbola *arg1 = (Handle_Geom2d_Hyperbola *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom2d_Hyperbola\n  * wrapname: _wrap_delete_Geom2d_Hyperbola\n  * fulldecl: Handle_Geom2d_Hyperbola::~Handle_Geom2d_Hyperbola()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_Parabola *new_Handle_Geom2d_Parabola__SWIG_0(gp_Ax22d const &Axis,Standard_Real const Focal){
        return new Handle_Geom2d_Parabola(new Geom2d_Parabola(Axis, Focal));
    }
EXPORT Handle_Geom2d_Parabola *_wrap_new_Geom2d_Parabola__SWIG_0 (gp_Ax22d *larg1, Standard_Real larg2) {
  Handle_Geom2d_Parabola * lresult = (Handle_Geom2d_Parabola *)0 ;
  gp_Ax22d *arg1 = 0 ;
  Standard_Real arg2 ;
  Handle_Geom2d_Parabola *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Parabola *)new_Handle_Geom2d_Parabola__SWIG_0((gp_Ax22d const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Parabola\n  * wrapname: _wrap_new_Geom2d_Parabola__SWIG_0\n  * fulldecl: Handle_Geom2d_Parabola::Handle_Geom2d_Parabola(gp_Ax22d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Parabola *)0;
  }
}


SWIGINTERN Handle_Geom2d_Parabola *new_Handle_Geom2d_Parabola__SWIG_1(gp_Ax2d const &D,gp_Pnt2d const &F){
        return new Handle_Geom2d_Parabola(new Geom2d_Parabola(D, F));
    }
EXPORT Handle_Geom2d_Parabola *_wrap_new_Geom2d_Parabola__SWIG_1 (gp_Ax2d *larg1, gp_Pnt2d *larg2) {
  Handle_Geom2d_Parabola * lresult = (Handle_Geom2d_Parabola *)0 ;
  gp_Ax2d *arg1 = 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Handle_Geom2d_Parabola *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Parabola *)new_Handle_Geom2d_Parabola__SWIG_1((gp_Ax2d const &)*arg1,(gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_Parabola\n  * wrapname: _wrap_new_Geom2d_Parabola__SWIG_1\n  * fulldecl: Handle_Geom2d_Parabola::Handle_Geom2d_Parabola(gp_Ax2d const &,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Parabola *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_Parabola_FocalDistance(Handle_Geom2d_Parabola *self){
        return (*self)->Focal();
    }
EXPORT Standard_Real _wrap_Geom2d_Parabola_FocalDistance (Handle_Geom2d_Parabola *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_Parabola *arg1 = (Handle_Geom2d_Parabola *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_Parabola_FocalDistance(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Parabola_FocalDistance\n  * wrapname: _wrap_Geom2d_Parabola_FocalDistance\n  * fulldecl: Standard_Real Handle_Geom2d_Parabola::FocalDistance()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN gp_Pnt2d Handle_Geom2d_Parabola_Focus(Handle_Geom2d_Parabola *self){
        return (*self)->Focus();
    }
EXPORT gp_Pnt2d *_wrap_Geom2d_Parabola_Focus (Handle_Geom2d_Parabola *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Handle_Geom2d_Parabola *arg1 = (Handle_Geom2d_Parabola *) 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Parabola_Focus(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Parabola_Focus\n  * wrapname: _wrap_Geom2d_Parabola_Focus\n  * fulldecl: gp_Pnt2d Handle_Geom2d_Parabola::Focus()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


SWIGINTERN gp_Ax2d Handle_Geom2d_Parabola_Directrix(Handle_Geom2d_Parabola *self){
        return (*self)->Directrix();
    }
EXPORT gp_Ax2d *_wrap_Geom2d_Parabola_Directrix (Handle_Geom2d_Parabola *larg1) {
  gp_Ax2d * lresult = (gp_Ax2d *)0 ;
  Handle_Geom2d_Parabola *arg1 = (Handle_Geom2d_Parabola *) 0 ;
  gp_Ax2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_Parabola_Directrix(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_Parabola_Directrix\n  * wrapname: _wrap_Geom2d_Parabola_Directrix\n  * fulldecl: gp_Ax2d Handle_Geom2d_Parabola::Directrix()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2d(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2d *)0;
  }
}


EXPORT void _wrap_delete_Geom2d_Parabola (Handle_Geom2d_Parabola *larg1) {
  Handle_Geom2d_Parabola *arg1 = (Handle_Geom2d_Parabola *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom2d_Parabola\n  * wrapname: _wrap_delete_Geom2d_Parabola\n  * fulldecl: Handle_Geom2d_Parabola::~Handle_Geom2d_Parabola()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Pnt2d Handle_Geom2d_BoundedCurve_EndPoint(Handle_Geom2d_BoundedCurve *self){
		return (*self)->EndPoint();
	}
EXPORT gp_Pnt2d *_wrap_Geom2d_BoundedCurve_EndPoint (Handle_Geom2d_BoundedCurve *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Handle_Geom2d_BoundedCurve *arg1 = (Handle_Geom2d_BoundedCurve *) 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_BoundedCurve_EndPoint(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BoundedCurve_EndPoint\n  * wrapname: _wrap_Geom2d_BoundedCurve_EndPoint\n  * fulldecl: gp_Pnt2d Handle_Geom2d_BoundedCurve::EndPoint()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


SWIGINTERN gp_Pnt2d Handle_Geom2d_BoundedCurve_StartPoint(Handle_Geom2d_BoundedCurve *self){
		return (*self)->StartPoint();
	}
EXPORT gp_Pnt2d *_wrap_Geom2d_BoundedCurve_StartPoint (Handle_Geom2d_BoundedCurve *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Handle_Geom2d_BoundedCurve *arg1 = (Handle_Geom2d_BoundedCurve *) 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_BoundedCurve_StartPoint(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BoundedCurve_StartPoint\n  * wrapname: _wrap_Geom2d_BoundedCurve_StartPoint\n  * fulldecl: gp_Pnt2d Handle_Geom2d_BoundedCurve::StartPoint()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT void _wrap_delete_Geom2d_BoundedCurve (Handle_Geom2d_BoundedCurve *larg1) {
  Handle_Geom2d_BoundedCurve *arg1 = (Handle_Geom2d_BoundedCurve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom2d_BoundedCurve\n  * wrapname: _wrap_delete_Geom2d_BoundedCurve\n  * fulldecl: Handle_Geom2d_BoundedCurve::~Handle_Geom2d_BoundedCurve()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_BezierCurve *new_Handle_Geom2d_BezierCurve(TColgp_Array1OfPnt2d const &CurvePoles,TColStd_Array1OfReal const &PoleWeights){
        return new Handle_Geom2d_BezierCurve(new Geom2d_BezierCurve(CurvePoles, PoleWeights));
    }
EXPORT Handle_Geom2d_BezierCurve *_wrap_new_Geom2d_BezierCurve (TColgp_Array1OfPnt2d *larg1, TColStd_Array1OfReal *larg2) {
  Handle_Geom2d_BezierCurve * lresult = (Handle_Geom2d_BezierCurve *)0 ;
  TColgp_Array1OfPnt2d *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  Handle_Geom2d_BezierCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_BezierCurve *)new_Handle_Geom2d_BezierCurve((TColgp_Array1OfPnt2d const &)*arg1,(TColStd_Array1OfReal const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_BezierCurve\n  * wrapname: _wrap_new_Geom2d_BezierCurve\n  * fulldecl: Handle_Geom2d_BezierCurve::Handle_Geom2d_BezierCurve(TColgp_Array1OfPnt2d const &,TColStd_Array1OfReal const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_BezierCurve *)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom2d_BezierCurve_NbPoles(Handle_Geom2d_BezierCurve *self){
        return (*self)->NbPoles();
    }
EXPORT Standard_Integer _wrap_Geom2d_BezierCurve_NbPoles (Handle_Geom2d_BezierCurve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom2d_BezierCurve *arg1 = (Handle_Geom2d_BezierCurve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom2d_BezierCurve_NbPoles(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BezierCurve_NbPoles\n  * wrapname: _wrap_Geom2d_BezierCurve_NbPoles\n  * fulldecl: Standard_Integer Handle_Geom2d_BezierCurve::NbPoles()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN gp_Pnt2d Handle_Geom2d_BezierCurve_Pole(Handle_Geom2d_BezierCurve *self,Standard_Integer const Index){
        return (*self)->Pole(Index);
    }
EXPORT gp_Pnt2d *_wrap_Geom2d_BezierCurve_Pole (Handle_Geom2d_BezierCurve *larg1, Standard_Integer larg2) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Handle_Geom2d_BezierCurve *arg1 = (Handle_Geom2d_BezierCurve *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_BezierCurve_Pole(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BezierCurve_Pole\n  * wrapname: _wrap_Geom2d_BezierCurve_Pole\n  * fulldecl: gp_Pnt2d Handle_Geom2d_BezierCurve::Pole(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_BezierCurve_Weight(Handle_Geom2d_BezierCurve *self,Standard_Integer const Index){
        return (*self)->Weight(Index);
    }
EXPORT Standard_Real _wrap_Geom2d_BezierCurve_Weight (Handle_Geom2d_BezierCurve *larg1, Standard_Integer larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_BezierCurve *arg1 = (Handle_Geom2d_BezierCurve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_BezierCurve_Weight(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BezierCurve_Weight\n  * wrapname: _wrap_Geom2d_BezierCurve_Weight\n  * fulldecl: Standard_Real Handle_Geom2d_BezierCurve::Weight(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_delete_Geom2d_BezierCurve (Handle_Geom2d_BezierCurve *larg1) {
  Handle_Geom2d_BezierCurve *arg1 = (Handle_Geom2d_BezierCurve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom2d_BezierCurve\n  * wrapname: _wrap_delete_Geom2d_BezierCurve\n  * fulldecl: Handle_Geom2d_BezierCurve::~Handle_Geom2d_BezierCurve()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_BSplineCurve *new_Handle_Geom2d_BSplineCurve__SWIG_0(TColgp_Array1OfPnt2d const &Poles,TColStd_Array1OfReal const &Knots,TColStd_Array1OfInteger const &Multiplicities,Standard_Integer const Degree,Standard_Boolean const Periodic=Standard_False){
	    return new Handle_Geom2d_BSplineCurve(new Geom2d_BSplineCurve(Poles, Knots, Multiplicities,
            Degree, Periodic));
	}
EXPORT Handle_Geom2d_BSplineCurve *_wrap_new_Geom2d_BSplineCurve__SWIG_0 (TColgp_Array1OfPnt2d *larg1, TColStd_Array1OfReal *larg2, TColStd_Array1OfInteger *larg3, Standard_Integer larg4, bool larg5) {
  Handle_Geom2d_BSplineCurve * lresult = (Handle_Geom2d_BSplineCurve *)0 ;
  TColgp_Array1OfPnt2d *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  TColStd_Array1OfInteger *arg3 = 0 ;
  Standard_Integer arg4 ;
  Standard_Boolean arg5 ;
  Handle_Geom2d_BSplineCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = (bool)larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_BSplineCurve *)new_Handle_Geom2d_BSplineCurve__SWIG_0((TColgp_Array1OfPnt2d const &)*arg1,(TColStd_Array1OfReal const &)*arg2,(TColStd_Array1OfInteger const &)*arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_BSplineCurve\n  * wrapname: _wrap_new_Geom2d_BSplineCurve__SWIG_0\n  * fulldecl: Handle_Geom2d_BSplineCurve::Handle_Geom2d_BSplineCurve(TColgp_Array1OfPnt2d const &,TColStd_Array1OfReal const &,TColStd_Array1OfInteger const &,Standard_Integer const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_BSplineCurve *)0;
  }
}


EXPORT Handle_Geom2d_BSplineCurve *_wrap_new_Geom2d_BSplineCurve__SWIG_1 (TColgp_Array1OfPnt2d *larg1, TColStd_Array1OfReal *larg2, TColStd_Array1OfInteger *larg3, Standard_Integer larg4) {
  Handle_Geom2d_BSplineCurve * lresult = (Handle_Geom2d_BSplineCurve *)0 ;
  TColgp_Array1OfPnt2d *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  TColStd_Array1OfInteger *arg3 = 0 ;
  Standard_Integer arg4 ;
  Handle_Geom2d_BSplineCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_BSplineCurve *)new_Handle_Geom2d_BSplineCurve__SWIG_0((TColgp_Array1OfPnt2d const &)*arg1,(TColStd_Array1OfReal const &)*arg2,(TColStd_Array1OfInteger const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_BSplineCurve\n  * wrapname: _wrap_new_Geom2d_BSplineCurve__SWIG_1\n  * fulldecl: Handle_Geom2d_BSplineCurve::Handle_Geom2d_BSplineCurve(TColgp_Array1OfPnt2d const &,TColStd_Array1OfReal const &,TColStd_Array1OfInteger const &,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_BSplineCurve *)0;
  }
}


SWIGINTERN Handle_Geom2d_BSplineCurve *new_Handle_Geom2d_BSplineCurve__SWIG_2(TColgp_Array1OfPnt2d const &Poles,TColStd_Array1OfReal const &Weights,TColStd_Array1OfReal const &Knots,TColStd_Array1OfInteger const &Multiplicities,Standard_Integer const Degree,Standard_Boolean const Periodic=Standard_False){
        return new Handle_Geom2d_BSplineCurve(new Geom2d_BSplineCurve(Poles, Weights, Knots, 
            Multiplicities, Degree, Periodic));
    }
EXPORT Handle_Geom2d_BSplineCurve *_wrap_new_Geom2d_BSplineCurve__SWIG_2 (TColgp_Array1OfPnt2d *larg1, TColStd_Array1OfReal *larg2, TColStd_Array1OfReal *larg3, TColStd_Array1OfInteger *larg4, Standard_Integer larg5, bool larg6) {
  Handle_Geom2d_BSplineCurve * lresult = (Handle_Geom2d_BSplineCurve *)0 ;
  TColgp_Array1OfPnt2d *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  TColStd_Array1OfReal *arg3 = 0 ;
  TColStd_Array1OfInteger *arg4 = 0 ;
  Standard_Integer arg5 ;
  Standard_Boolean arg6 ;
  Handle_Geom2d_BSplineCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = (bool)larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_BSplineCurve *)new_Handle_Geom2d_BSplineCurve__SWIG_2((TColgp_Array1OfPnt2d const &)*arg1,(TColStd_Array1OfReal const &)*arg2,(TColStd_Array1OfReal const &)*arg3,(TColStd_Array1OfInteger const &)*arg4,arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_BSplineCurve\n  * wrapname: _wrap_new_Geom2d_BSplineCurve__SWIG_2\n  * fulldecl: Handle_Geom2d_BSplineCurve::Handle_Geom2d_BSplineCurve(TColgp_Array1OfPnt2d const &,TColStd_Array1OfReal const &,TColStd_Array1OfReal const &,TColStd_Array1OfInteger const &,Standard_Integer const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_BSplineCurve *)0;
  }
}


EXPORT Handle_Geom2d_BSplineCurve *_wrap_new_Geom2d_BSplineCurve__SWIG_3 (TColgp_Array1OfPnt2d *larg1, TColStd_Array1OfReal *larg2, TColStd_Array1OfReal *larg3, TColStd_Array1OfInteger *larg4, Standard_Integer larg5) {
  Handle_Geom2d_BSplineCurve * lresult = (Handle_Geom2d_BSplineCurve *)0 ;
  TColgp_Array1OfPnt2d *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  TColStd_Array1OfReal *arg3 = 0 ;
  TColStd_Array1OfInteger *arg4 = 0 ;
  Standard_Integer arg5 ;
  Handle_Geom2d_BSplineCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_BSplineCurve *)new_Handle_Geom2d_BSplineCurve__SWIG_2((TColgp_Array1OfPnt2d const &)*arg1,(TColStd_Array1OfReal const &)*arg2,(TColStd_Array1OfReal const &)*arg3,(TColStd_Array1OfInteger const &)*arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_BSplineCurve\n  * wrapname: _wrap_new_Geom2d_BSplineCurve__SWIG_3\n  * fulldecl: Handle_Geom2d_BSplineCurve::Handle_Geom2d_BSplineCurve(TColgp_Array1OfPnt2d const &,TColStd_Array1OfReal const &,TColStd_Array1OfReal const &,TColStd_Array1OfInteger const &,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_BSplineCurve *)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom2d_BSplineCurve_Degree(Handle_Geom2d_BSplineCurve *self){
        return (*self)->Degree();
    }
EXPORT Standard_Integer _wrap_Geom2d_BSplineCurve_Degree (Handle_Geom2d_BSplineCurve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom2d_BSplineCurve_Degree(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_Degree\n  * wrapname: _wrap_Geom2d_BSplineCurve_Degree\n  * fulldecl: Standard_Integer Handle_Geom2d_BSplineCurve::Degree()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN gp_Pnt2d Handle_Geom2d_BSplineCurve_Pole(Handle_Geom2d_BSplineCurve *self,Standard_Integer const Index){
        return (*self)->Pole(Index);
    }
EXPORT gp_Pnt2d *_wrap_Geom2d_BSplineCurve_Pole (Handle_Geom2d_BSplineCurve *larg1, Standard_Integer larg2) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_BSplineCurve_Pole(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_Pole\n  * wrapname: _wrap_Geom2d_BSplineCurve_Pole\n  * fulldecl: gp_Pnt2d Handle_Geom2d_BSplineCurve::Pole(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_BSplineCurve_Weight(Handle_Geom2d_BSplineCurve *self,Standard_Integer const Index){
        return (*self)->Weight(Index);
    }
EXPORT Standard_Real _wrap_Geom2d_BSplineCurve_Weight (Handle_Geom2d_BSplineCurve *larg1, Standard_Integer larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_BSplineCurve_Weight(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_Weight\n  * wrapname: _wrap_Geom2d_BSplineCurve_Weight\n  * fulldecl: Standard_Real Handle_Geom2d_BSplineCurve::Weight(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_BSplineCurve_Knot(Handle_Geom2d_BSplineCurve *self,Standard_Integer const Index){
        return (*self)->Knot(Index);
    }
EXPORT Standard_Real _wrap_Geom2d_BSplineCurve_Knot (Handle_Geom2d_BSplineCurve *larg1, Standard_Integer larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_BSplineCurve_Knot(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_Knot\n  * wrapname: _wrap_Geom2d_BSplineCurve_Knot\n  * fulldecl: Standard_Real Handle_Geom2d_BSplineCurve::Knot(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom2d_BSplineCurve_Multiplicity(Handle_Geom2d_BSplineCurve *self,Standard_Integer const Index){
        return (*self)->Multiplicity(Index);
    }
EXPORT Standard_Integer _wrap_Geom2d_BSplineCurve_Multiplicity (Handle_Geom2d_BSplineCurve *larg1, Standard_Integer larg2) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom2d_BSplineCurve_Multiplicity(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_Multiplicity\n  * wrapname: _wrap_Geom2d_BSplineCurve_Multiplicity\n  * fulldecl: Standard_Integer Handle_Geom2d_BSplineCurve::Multiplicity(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_Knots(Handle_Geom2d_BSplineCurve *self,TColStd_Array1OfReal &K){
        return (*self)->Knots(K);
    }
EXPORT void _wrap_Geom2d_BSplineCurve_Knots (Handle_Geom2d_BSplineCurve *larg1, TColStd_Array1OfReal *larg2) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_Knots(arg1,*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_Knots\n  * wrapname: _wrap_Geom2d_BSplineCurve_Knots\n  * fulldecl: void Handle_Geom2d_BSplineCurve::Knots(TColStd_Array1OfReal &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Integer Handle_Geom2d_BSplineCurve_NbKnots(Handle_Geom2d_BSplineCurve *self){
        return(*self)->NbKnots();
    }
EXPORT Standard_Integer _wrap_Geom2d_BSplineCurve_NbKnots (Handle_Geom2d_BSplineCurve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom2d_BSplineCurve_NbKnots(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_NbKnots\n  * wrapname: _wrap_Geom2d_BSplineCurve_NbKnots\n  * fulldecl: Standard_Integer Handle_Geom2d_BSplineCurve::NbKnots()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom2d_BSplineCurve_NbPoles(Handle_Geom2d_BSplineCurve *self){
        return(*self)->NbPoles();
    }
EXPORT Standard_Integer _wrap_Geom2d_BSplineCurve_NbPoles (Handle_Geom2d_BSplineCurve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom2d_BSplineCurve_NbPoles(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_NbPoles\n  * wrapname: _wrap_Geom2d_BSplineCurve_NbPoles\n  * fulldecl: Standard_Integer Handle_Geom2d_BSplineCurve::NbPoles()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN void Handle_Geom2d_BSplineCurve_Poles(Handle_Geom2d_BSplineCurve *self,TColgp_Array1OfPnt2d &P){
      (*self)->Poles(P);
    }
EXPORT void _wrap_Geom2d_BSplineCurve_Poles (Handle_Geom2d_BSplineCurve *larg1, TColgp_Array1OfPnt2d *larg2) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  TColgp_Array1OfPnt2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_BSplineCurve_Poles(arg1,*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_BSplineCurve_Poles\n  * wrapname: _wrap_Geom2d_BSplineCurve_Poles\n  * fulldecl: void Handle_Geom2d_BSplineCurve::Poles(TColgp_Array1OfPnt2d &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_Geom2d_BSplineCurve (Handle_Geom2d_BSplineCurve *larg1) {
  Handle_Geom2d_BSplineCurve *arg1 = (Handle_Geom2d_BSplineCurve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom2d_BSplineCurve\n  * wrapname: _wrap_delete_Geom2d_BSplineCurve\n  * fulldecl: Handle_Geom2d_BSplineCurve::~Handle_Geom2d_BSplineCurve()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom2d_TrimmedCurve *new_Handle_Geom2d_TrimmedCurve__SWIG_0(Handle_Geom2d_Curve const &C,Standard_Real const U1,Standard_Real const U2,Standard_Boolean const Sense=Standard_True){
      return new Handle_Geom2d_TrimmedCurve(new Geom2d_TrimmedCurve(C, U1, U2, Sense));
    }
EXPORT Handle_Geom2d_TrimmedCurve *_wrap_new_Geom2d_TrimmedCurve__SWIG_0 (Handle_Geom2d_Curve *larg1, Standard_Real larg2, Standard_Real larg3, bool larg4) {
  Handle_Geom2d_TrimmedCurve * lresult = (Handle_Geom2d_TrimmedCurve *)0 ;
  Handle_Geom2d_Curve *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Boolean arg4 ;
  Handle_Geom2d_TrimmedCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_TrimmedCurve *)new_Handle_Geom2d_TrimmedCurve__SWIG_0((Handle_Geom2d_Curve const &)*arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_TrimmedCurve\n  * wrapname: _wrap_new_Geom2d_TrimmedCurve__SWIG_0\n  * fulldecl: Handle_Geom2d_TrimmedCurve::Handle_Geom2d_TrimmedCurve(Handle_Geom2d_Curve const &,Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_TrimmedCurve *)0;
  }
}


EXPORT Handle_Geom2d_TrimmedCurve *_wrap_new_Geom2d_TrimmedCurve__SWIG_1 (Handle_Geom2d_Curve *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom2d_TrimmedCurve * lresult = (Handle_Geom2d_TrimmedCurve *)0 ;
  Handle_Geom2d_Curve *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Handle_Geom2d_TrimmedCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_TrimmedCurve *)new_Handle_Geom2d_TrimmedCurve__SWIG_0((Handle_Geom2d_Curve const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2d_TrimmedCurve\n  * wrapname: _wrap_new_Geom2d_TrimmedCurve__SWIG_1\n  * fulldecl: Handle_Geom2d_TrimmedCurve::Handle_Geom2d_TrimmedCurve(Handle_Geom2d_Curve const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_TrimmedCurve *)0;
  }
}


SWIGINTERN Handle_Geom2d_Curve Handle_Geom2d_TrimmedCurve_BasisCurve(Handle_Geom2d_TrimmedCurve *self){
    return (*self)->BasisCurve();
  }
EXPORT Handle_Geom2d_Curve *_wrap_Geom2d_TrimmedCurve_BasisCurve (Handle_Geom2d_TrimmedCurve *larg1) {
  Handle_Geom2d_Curve * lresult = (Handle_Geom2d_Curve *)0 ;
  Handle_Geom2d_TrimmedCurve *arg1 = (Handle_Geom2d_TrimmedCurve *) 0 ;
  SwigValueWrapper< Handle_Geom2d_Curve > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_TrimmedCurve_BasisCurve(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_TrimmedCurve_BasisCurve\n  * wrapname: _wrap_Geom2d_TrimmedCurve_BasisCurve\n  * fulldecl: Handle_Geom2d_Curve Handle_Geom2d_TrimmedCurve::BasisCurve()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Curve(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Curve *)0;
  }
}


SWIGINTERN void Handle_Geom2d_TrimmedCurve_Reverse(Handle_Geom2d_TrimmedCurve *self){
    (*self)->Reverse();
  }
EXPORT void _wrap_Geom2d_TrimmedCurve_Reverse (Handle_Geom2d_TrimmedCurve *larg1) {
  Handle_Geom2d_TrimmedCurve *arg1 = (Handle_Geom2d_TrimmedCurve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_TrimmedCurve_Reverse(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_TrimmedCurve_Reverse\n  * wrapname: _wrap_Geom2d_TrimmedCurve_Reverse\n  * fulldecl: void Handle_Geom2d_TrimmedCurve::Reverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_TrimmedCurve_ReversedParameter(Handle_Geom2d_TrimmedCurve *self,Standard_Real const U){
    return (*self)->ReversedParameter(U);
  }
EXPORT Standard_Real _wrap_Geom2d_TrimmedCurve_ReversedParameter (Handle_Geom2d_TrimmedCurve *larg1, Standard_Real larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_TrimmedCurve *arg1 = (Handle_Geom2d_TrimmedCurve *) 0 ;
  Standard_Real arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_TrimmedCurve_ReversedParameter(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_TrimmedCurve_ReversedParameter\n  * wrapname: _wrap_Geom2d_TrimmedCurve_ReversedParameter\n  * fulldecl: Standard_Real Handle_Geom2d_TrimmedCurve::ReversedParameter(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN void Handle_Geom2d_TrimmedCurve_SetTrim__SWIG_0(Handle_Geom2d_TrimmedCurve *self,Standard_Real const U1,Standard_Real const U2,Standard_Boolean const Sense=Standard_True,Standard_Boolean const theAdjustPeriodic=Standard_True){
    (*self)->SetTrim(U1, U2, Sense, theAdjustPeriodic);
  }
EXPORT void _wrap_Geom2d_TrimmedCurve_SetTrim__SWIG_0 (Handle_Geom2d_TrimmedCurve *larg1, Standard_Real larg2, Standard_Real larg3, bool larg4, bool larg5) {
  Handle_Geom2d_TrimmedCurve *arg1 = (Handle_Geom2d_TrimmedCurve *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Boolean arg4 ;
  Standard_Boolean arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  arg5 = (bool)larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_TrimmedCurve_SetTrim__SWIG_0(arg1,arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_TrimmedCurve_SetTrim\n  * wrapname: _wrap_Geom2d_TrimmedCurve_SetTrim__SWIG_0\n  * fulldecl: void Handle_Geom2d_TrimmedCurve::SetTrim(Standard_Real const,Standard_Real const,Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Geom2d_TrimmedCurve_SetTrim__SWIG_1 (Handle_Geom2d_TrimmedCurve *larg1, Standard_Real larg2, Standard_Real larg3, bool larg4) {
  Handle_Geom2d_TrimmedCurve *arg1 = (Handle_Geom2d_TrimmedCurve *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Boolean arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_TrimmedCurve_SetTrim__SWIG_0(arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_TrimmedCurve_SetTrim\n  * wrapname: _wrap_Geom2d_TrimmedCurve_SetTrim__SWIG_1\n  * fulldecl: void Handle_Geom2d_TrimmedCurve::SetTrim(Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Geom2d_TrimmedCurve_SetTrim__SWIG_2 (Handle_Geom2d_TrimmedCurve *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom2d_TrimmedCurve *arg1 = (Handle_Geom2d_TrimmedCurve *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_TrimmedCurve_SetTrim__SWIG_0(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_TrimmedCurve_SetTrim\n  * wrapname: _wrap_Geom2d_TrimmedCurve_SetTrim__SWIG_2\n  * fulldecl: void Handle_Geom2d_TrimmedCurve::SetTrim(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN GeomAbs_Shape Handle_Geom2d_TrimmedCurve_Continuity(Handle_Geom2d_TrimmedCurve *self){
    return (*self)->Continuity();
  }
EXPORT GeomAbs_Shape _wrap_Geom2d_TrimmedCurve_Continuity (Handle_Geom2d_TrimmedCurve *larg1) {
  GeomAbs_Shape lresult = (GeomAbs_Shape)0 ;
  Handle_Geom2d_TrimmedCurve *arg1 = (Handle_Geom2d_TrimmedCurve *) 0 ;
  GeomAbs_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAbs_Shape)Handle_Geom2d_TrimmedCurve_Continuity(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_TrimmedCurve_Continuity\n  * wrapname: _wrap_Geom2d_TrimmedCurve_Continuity\n  * fulldecl: GeomAbs_Shape Handle_Geom2d_TrimmedCurve::Continuity()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAbs_Shape)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom2d_TrimmedCurve_IsCN(Handle_Geom2d_TrimmedCurve *self,Standard_Integer const N){
    return (*self)->IsCN(N);
  }
EXPORT bool _wrap_Geom2d_TrimmedCurve_IsCN (Handle_Geom2d_TrimmedCurve *larg1, Standard_Integer larg2) {
  bool lresult = (bool)0 ;
  Handle_Geom2d_TrimmedCurve *arg1 = (Handle_Geom2d_TrimmedCurve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom2d_TrimmedCurve_IsCN(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_TrimmedCurve_IsCN\n  * wrapname: _wrap_Geom2d_TrimmedCurve_IsCN\n  * fulldecl: Standard_Boolean Handle_Geom2d_TrimmedCurve::IsCN(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN gp_Pnt2d Handle_Geom2d_TrimmedCurve_EndPoint(Handle_Geom2d_TrimmedCurve *self){
    return (*self)->EndPoint();
  }
EXPORT gp_Pnt2d *_wrap_Geom2d_TrimmedCurve_EndPoint (Handle_Geom2d_TrimmedCurve *larg1) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Handle_Geom2d_TrimmedCurve *arg1 = (Handle_Geom2d_TrimmedCurve *) 0 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_TrimmedCurve_EndPoint(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_TrimmedCurve_EndPoint\n  * wrapname: _wrap_Geom2d_TrimmedCurve_EndPoint\n  * fulldecl: gp_Pnt2d Handle_Geom2d_TrimmedCurve::EndPoint()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_TrimmedCurve_FirstParameter(Handle_Geom2d_TrimmedCurve *self){
    return (*self)->FirstParameter();
  }
EXPORT Standard_Real _wrap_Geom2d_TrimmedCurve_FirstParameter (Handle_Geom2d_TrimmedCurve *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_TrimmedCurve *arg1 = (Handle_Geom2d_TrimmedCurve *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_TrimmedCurve_FirstParameter(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_TrimmedCurve_FirstParameter\n  * wrapname: _wrap_Geom2d_TrimmedCurve_FirstParameter\n  * fulldecl: Standard_Real Handle_Geom2d_TrimmedCurve::FirstParameter()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom2d_TrimmedCurve_IsClosed(Handle_Geom2d_TrimmedCurve *self){
    return (*self)->IsClosed();
  }
EXPORT bool _wrap_Geom2d_TrimmedCurve_IsClosed (Handle_Geom2d_TrimmedCurve *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom2d_TrimmedCurve *arg1 = (Handle_Geom2d_TrimmedCurve *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom2d_TrimmedCurve_IsClosed(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_TrimmedCurve_IsClosed\n  * wrapname: _wrap_Geom2d_TrimmedCurve_IsClosed\n  * fulldecl: Standard_Boolean Handle_Geom2d_TrimmedCurve::IsClosed()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom2d_TrimmedCurve_IsPeriodic(Handle_Geom2d_TrimmedCurve *self){
    return (*self)->IsPeriodic();
  }
EXPORT bool _wrap_Geom2d_TrimmedCurve_IsPeriodic (Handle_Geom2d_TrimmedCurve *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom2d_TrimmedCurve *arg1 = (Handle_Geom2d_TrimmedCurve *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom2d_TrimmedCurve_IsPeriodic(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_TrimmedCurve_IsPeriodic\n  * wrapname: _wrap_Geom2d_TrimmedCurve_IsPeriodic\n  * fulldecl: Standard_Boolean Handle_Geom2d_TrimmedCurve::IsPeriodic()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_TrimmedCurve_Period(Handle_Geom2d_TrimmedCurve *self){
    return (*self)->Period(); //virtual
  }
EXPORT Standard_Real _wrap_Geom2d_TrimmedCurve_Period (Handle_Geom2d_TrimmedCurve *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_TrimmedCurve *arg1 = (Handle_Geom2d_TrimmedCurve *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_TrimmedCurve_Period(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_TrimmedCurve_Period\n  * wrapname: _wrap_Geom2d_TrimmedCurve_Period\n  * fulldecl: Standard_Real Handle_Geom2d_TrimmedCurve::Period()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_TrimmedCurve_LastParameter(Handle_Geom2d_TrimmedCurve *self){
    return (*self)->LastParameter();
  }
EXPORT Standard_Real _wrap_Geom2d_TrimmedCurve_LastParameter (Handle_Geom2d_TrimmedCurve *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_TrimmedCurve *arg1 = (Handle_Geom2d_TrimmedCurve *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_TrimmedCurve_LastParameter(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_TrimmedCurve_LastParameter\n  * wrapname: _wrap_Geom2d_TrimmedCurve_LastParameter\n  * fulldecl: Standard_Real Handle_Geom2d_TrimmedCurve::LastParameter()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN void Handle_Geom2d_TrimmedCurve_D0(Handle_Geom2d_TrimmedCurve *self,Standard_Real const U,gp_Pnt2d &P){
    return (*self)->D0(U, P);
  }
EXPORT void _wrap_Geom2d_TrimmedCurve_D0 (Handle_Geom2d_TrimmedCurve *larg1, Standard_Real larg2, gp_Pnt2d *larg3) {
  Handle_Geom2d_TrimmedCurve *arg1 = (Handle_Geom2d_TrimmedCurve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_TrimmedCurve_D0(arg1,arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_TrimmedCurve_D0\n  * wrapname: _wrap_Geom2d_TrimmedCurve_D0\n  * fulldecl: void Handle_Geom2d_TrimmedCurve::D0(Standard_Real const,gp_Pnt2d &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_TrimmedCurve_D1(Handle_Geom2d_TrimmedCurve *self,Standard_Real const U,gp_Pnt2d &P,gp_Vec2d &V1){
    return (*self)->D1(U, P, V1);
  }
EXPORT void _wrap_Geom2d_TrimmedCurve_D1 (Handle_Geom2d_TrimmedCurve *larg1, Standard_Real larg2, gp_Pnt2d *larg3, gp_Vec2d *larg4) {
  Handle_Geom2d_TrimmedCurve *arg1 = (Handle_Geom2d_TrimmedCurve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  gp_Vec2d *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_TrimmedCurve_D1(arg1,arg2,*arg3,*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_TrimmedCurve_D1\n  * wrapname: _wrap_Geom2d_TrimmedCurve_D1\n  * fulldecl: void Handle_Geom2d_TrimmedCurve::D1(Standard_Real const,gp_Pnt2d &,gp_Vec2d &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_TrimmedCurve_D2(Handle_Geom2d_TrimmedCurve *self,Standard_Real const U,gp_Pnt2d &P,gp_Vec2d &V1,gp_Vec2d &V2){
    return (*self)->D2(U, P, V1, V2);
  }
EXPORT void _wrap_Geom2d_TrimmedCurve_D2 (Handle_Geom2d_TrimmedCurve *larg1, Standard_Real larg2, gp_Pnt2d *larg3, gp_Vec2d *larg4, gp_Vec2d *larg5) {
  Handle_Geom2d_TrimmedCurve *arg1 = (Handle_Geom2d_TrimmedCurve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  gp_Vec2d *arg4 = 0 ;
  gp_Vec2d *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_TrimmedCurve_D2(arg1,arg2,*arg3,*arg4,*arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_TrimmedCurve_D2\n  * wrapname: _wrap_Geom2d_TrimmedCurve_D2\n  * fulldecl: void Handle_Geom2d_TrimmedCurve::D2(Standard_Real const,gp_Pnt2d &,gp_Vec2d &,gp_Vec2d &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom2d_TrimmedCurve_D3(Handle_Geom2d_TrimmedCurve *self,Standard_Real const U,gp_Pnt2d &P,gp_Vec2d &V1,gp_Vec2d &V2,gp_Vec2d &V3){
    return (*self)->D3(U, P, V1, V2, V3);
  }
EXPORT void _wrap_Geom2d_TrimmedCurve_D3 (Handle_Geom2d_TrimmedCurve *larg1, Standard_Real larg2, gp_Pnt2d *larg3, gp_Vec2d *larg4, gp_Vec2d *larg5, gp_Vec2d *larg6) {
  Handle_Geom2d_TrimmedCurve *arg1 = (Handle_Geom2d_TrimmedCurve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  gp_Vec2d *arg4 = 0 ;
  gp_Vec2d *arg5 = 0 ;
  gp_Vec2d *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_TrimmedCurve_D3(arg1,arg2,*arg3,*arg4,*arg5,*arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_TrimmedCurve_D3\n  * wrapname: _wrap_Geom2d_TrimmedCurve_D3\n  * fulldecl: void Handle_Geom2d_TrimmedCurve::D3(Standard_Real const,gp_Pnt2d &,gp_Vec2d &,gp_Vec2d &,gp_Vec2d &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Vec2d Handle_Geom2d_TrimmedCurve_DN(Handle_Geom2d_TrimmedCurve *self,Standard_Real const U,Standard_Integer const N){
    return (*self)->DN(U, N);
  }
EXPORT gp_Vec2d *_wrap_Geom2d_TrimmedCurve_DN (Handle_Geom2d_TrimmedCurve *larg1, Standard_Real larg2, Standard_Integer larg3) {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  Handle_Geom2d_TrimmedCurve *arg1 = (Handle_Geom2d_TrimmedCurve *) 0 ;
  Standard_Real arg2 ;
  Standard_Integer arg3 ;
  gp_Vec2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_TrimmedCurve_DN(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_TrimmedCurve_DN\n  * wrapname: _wrap_Geom2d_TrimmedCurve_DN\n  * fulldecl: gp_Vec2d Handle_Geom2d_TrimmedCurve::DN(Standard_Real const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec2d(result);
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


SWIGINTERN void Handle_Geom2d_TrimmedCurve_Transform(Handle_Geom2d_TrimmedCurve *self,gp_Trsf2d const &T){
    (*self)->Transform(T);
  }
EXPORT void _wrap_Geom2d_TrimmedCurve_Transform (Handle_Geom2d_TrimmedCurve *larg1, gp_Trsf2d *larg2) {
  Handle_Geom2d_TrimmedCurve *arg1 = (Handle_Geom2d_TrimmedCurve *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom2d_TrimmedCurve_Transform(arg1,(gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_TrimmedCurve_Transform\n  * wrapname: _wrap_Geom2d_TrimmedCurve_Transform\n  * fulldecl: void Handle_Geom2d_TrimmedCurve::Transform(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_TrimmedCurve_TransformedParameter(Handle_Geom2d_TrimmedCurve *self,Standard_Real const U,gp_Trsf2d const &T){
    return (*self)->TransformedParameter(U, T);
  }
EXPORT Standard_Real _wrap_Geom2d_TrimmedCurve_TransformedParameter (Handle_Geom2d_TrimmedCurve *larg1, Standard_Real larg2, gp_Trsf2d *larg3) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_TrimmedCurve *arg1 = (Handle_Geom2d_TrimmedCurve *) 0 ;
  Standard_Real arg2 ;
  gp_Trsf2d *arg3 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_TrimmedCurve_TransformedParameter(arg1,arg2,(gp_Trsf2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_TrimmedCurve_TransformedParameter\n  * wrapname: _wrap_Geom2d_TrimmedCurve_TransformedParameter\n  * fulldecl: Standard_Real Handle_Geom2d_TrimmedCurve::TransformedParameter(Standard_Real const,gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom2d_TrimmedCurve_ParametricTransformation(Handle_Geom2d_TrimmedCurve *self,gp_Trsf2d const &T){
    return (*self)->ParametricTransformation(T);
  }
EXPORT Standard_Real _wrap_Geom2d_TrimmedCurve_ParametricTransformation (Handle_Geom2d_TrimmedCurve *larg1, gp_Trsf2d *larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom2d_TrimmedCurve *arg1 = (Handle_Geom2d_TrimmedCurve *) 0 ;
  gp_Trsf2d *arg2 = 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom2d_TrimmedCurve_ParametricTransformation(arg1,(gp_Trsf2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_TrimmedCurve_ParametricTransformation\n  * wrapname: _wrap_Geom2d_TrimmedCurve_ParametricTransformation\n  * fulldecl: Standard_Real Handle_Geom2d_TrimmedCurve::ParametricTransformation(gp_Trsf2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Handle_Geom2d_Geometry Handle_Geom2d_TrimmedCurve_Copy(Handle_Geom2d_TrimmedCurve *self){
    return (*self)->Copy();
  }
EXPORT Handle_Geom2d_Geometry *_wrap_Geom2d_TrimmedCurve_Copy (Handle_Geom2d_TrimmedCurve *larg1) {
  Handle_Geom2d_Geometry * lresult = (Handle_Geom2d_Geometry *)0 ;
  Handle_Geom2d_TrimmedCurve *arg1 = (Handle_Geom2d_TrimmedCurve *) 0 ;
  SwigValueWrapper< Handle_Geom2d_Geometry > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom2d_TrimmedCurve_Copy(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2d_TrimmedCurve_Copy\n  * wrapname: _wrap_Geom2d_TrimmedCurve_Copy\n  * fulldecl: Handle_Geom2d_Geometry Handle_Geom2d_TrimmedCurve::Copy()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Geometry *)0;
  }
}


EXPORT void _wrap_delete_Geom2d_TrimmedCurve (Handle_Geom2d_TrimmedCurve *larg1) {
  Handle_Geom2d_TrimmedCurve *arg1 = (Handle_Geom2d_TrimmedCurve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom2d_TrimmedCurve\n  * wrapname: _wrap_delete_Geom2d_TrimmedCurve\n  * fulldecl: Handle_Geom2d_TrimmedCurve::~Handle_Geom2d_TrimmedCurve()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <Geom_Curve.hxx>
#include <Geom_Surface.hxx>
#include <Geom_Geometry.hxx>
#include <Geom_BoundedCurve.hxx>
#include <Geom_BoundedSurface.hxx>
#include <Geom_BezierCurve.hxx>
#include <Geom_BezierSurface.hxx>
#include <Geom_BSplineCurve.hxx>
#include <Geom_BSplineSurface.hxx>
#include <Geom_Circle.hxx>
#include <Geom_Conic.hxx>
#include <Geom_ConicalSurface.hxx>
#include <Geom_CylindricalSurface.hxx>
#include <Geom_Ellipse.hxx>
#include <Geom_ElementarySurface.hxx>
#include <Geom_Hyperbola.hxx>
#include <Geom_Line.hxx>
#include <Geom_OffsetCurve.hxx>
#include <Geom_OffsetSurface.hxx>
#include <Geom_Parabola.hxx>
#include <Geom_Plane.hxx>
#include <Geom_RectangularTrimmedSurface.hxx>
#include <Geom_SphericalSurface.hxx>
#include <Geom_SurfaceOfLinearExtrusion.hxx>
#include <Geom_SurfaceOfRevolution.hxx>
#include <Geom_SweptSurface.hxx>
#include <Geom_ToroidalSurface.hxx>
#include <Geom_TrimmedCurve.hxx>
#include <Geom2d_Geometry.hxx>
#include <Geom2d_Curve.hxx>
#include <Geom2d_Line.hxx>
#include <Geom2d_OffsetCurve.hxx>
#include <Geom2d_Conic.hxx>
#include <Geom2d_Circle.hxx>
#include <Geom2d_Ellipse.hxx>
#include <Geom2d_Hyperbola.hxx>
#include <Geom2d_Parabola.hxx>
#include <Geom2d_BoundedCurve.hxx>
#include <Geom2d_BezierCurve.hxx>
#include <Geom2d_BSplineCurve.hxx>
#include <Geom2d_TrimmedCurve.hxx>


SWIGINTERN void Handle_Geom_Geometry_Mirror__SWIG_0(Handle_Geom_Geometry *self,gp_Pnt const &P){
    (*self)->Mirror(P);
  }
EXPORT void _wrap_Geom_Geometry_Mirror__SWIG_0 (Handle_Geom_Geometry *larg1, gp_Pnt *larg2) {
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Pnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Geometry_Mirror__SWIG_0(arg1,(gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Mirror\n  * wrapname: _wrap_Geom_Geometry_Mirror__SWIG_0\n  * fulldecl: void Handle_Geom_Geometry::Mirror(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_Geometry_Mirror__SWIG_1(Handle_Geom_Geometry *self,gp_Ax1 const &A1){
    (*self)->Mirror(A1);
  }
EXPORT void _wrap_Geom_Geometry_Mirror__SWIG_1 (Handle_Geom_Geometry *larg1, gp_Ax1 *larg2) {
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Geometry_Mirror__SWIG_1(arg1,(gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Mirror\n  * wrapname: _wrap_Geom_Geometry_Mirror__SWIG_1\n  * fulldecl: void Handle_Geom_Geometry::Mirror(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_Geometry_Mirror__SWIG_2(Handle_Geom_Geometry *self,gp_Ax2 const &A2){
    (*self)->Mirror(A2);
  }
EXPORT void _wrap_Geom_Geometry_Mirror__SWIG_2 (Handle_Geom_Geometry *larg1, gp_Ax2 *larg2) {
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Geometry_Mirror__SWIG_2(arg1,(gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Mirror\n  * wrapname: _wrap_Geom_Geometry_Mirror__SWIG_2\n  * fulldecl: void Handle_Geom_Geometry::Mirror(gp_Ax2 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_Geometry_Rotate(Handle_Geom_Geometry *self,gp_Ax1 const &A1,Standard_Real const Ang){
    (*self)->Rotate(A1, Ang);
  }
EXPORT void _wrap_Geom_Geometry_Rotate (Handle_Geom_Geometry *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Geometry_Rotate(arg1,(gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Rotate\n  * wrapname: _wrap_Geom_Geometry_Rotate\n  * fulldecl: void Handle_Geom_Geometry::Rotate(gp_Ax1 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_Geometry_Scale(Handle_Geom_Geometry *self,gp_Pnt const &P,Standard_Real const S){
    (*self)->Scale(P, S);
  }
EXPORT void _wrap_Geom_Geometry_Scale (Handle_Geom_Geometry *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Geometry_Scale(arg1,(gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Scale\n  * wrapname: _wrap_Geom_Geometry_Scale\n  * fulldecl: void Handle_Geom_Geometry::Scale(gp_Pnt const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_Geometry_Translate__SWIG_0(Handle_Geom_Geometry *self,gp_Vec const &V){
    (*self)->Translate(V);
  }
EXPORT void _wrap_Geom_Geometry_Translate__SWIG_0 (Handle_Geom_Geometry *larg1, gp_Vec *larg2) {
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Vec *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Geometry_Translate__SWIG_0(arg1,(gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Translate\n  * wrapname: _wrap_Geom_Geometry_Translate__SWIG_0\n  * fulldecl: void Handle_Geom_Geometry::Translate(gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_Geometry_Translate__SWIG_1(Handle_Geom_Geometry *self,gp_Pnt const &P1,gp_Pnt const &P2){
    (*self)->Translate(P1, P2);
  }
EXPORT void _wrap_Geom_Geometry_Translate__SWIG_1 (Handle_Geom_Geometry *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Geometry_Translate__SWIG_1(arg1,(gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Translate\n  * wrapname: _wrap_Geom_Geometry_Translate__SWIG_1\n  * fulldecl: void Handle_Geom_Geometry::Translate(gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom_Geometry Handle_Geom_Geometry_Mirrored__SWIG_0(Handle_Geom_Geometry *self,gp_Pnt const &P){
    return (*self)->Mirrored(P);
  }
EXPORT Handle_Geom_Geometry *_wrap_Geom_Geometry_Mirrored__SWIG_0 (Handle_Geom_Geometry *larg1, gp_Pnt *larg2) {
  Handle_Geom_Geometry * lresult = (Handle_Geom_Geometry *)0 ;
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Pnt *arg2 = 0 ;
  SwigValueWrapper< Handle_Geom_Geometry > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Geometry_Mirrored__SWIG_0(arg1,(gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Mirrored\n  * wrapname: _wrap_Geom_Geometry_Mirrored__SWIG_0\n  * fulldecl: Handle_Geom_Geometry Handle_Geom_Geometry::Mirrored(gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Geometry *)0;
  }
}


SWIGINTERN Handle_Geom_Geometry Handle_Geom_Geometry_Mirrored__SWIG_1(Handle_Geom_Geometry *self,gp_Ax1 const &A1){
    return (*self)->Mirrored(A1);
  }
EXPORT Handle_Geom_Geometry *_wrap_Geom_Geometry_Mirrored__SWIG_1 (Handle_Geom_Geometry *larg1, gp_Ax1 *larg2) {
  Handle_Geom_Geometry * lresult = (Handle_Geom_Geometry *)0 ;
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  SwigValueWrapper< Handle_Geom_Geometry > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Geometry_Mirrored__SWIG_1(arg1,(gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Mirrored\n  * wrapname: _wrap_Geom_Geometry_Mirrored__SWIG_1\n  * fulldecl: Handle_Geom_Geometry Handle_Geom_Geometry::Mirrored(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Geometry *)0;
  }
}


SWIGINTERN Handle_Geom_Geometry Handle_Geom_Geometry_Mirrored__SWIG_2(Handle_Geom_Geometry *self,gp_Ax2 const &A2){
    return (*self)->Mirrored(A2);
  }
EXPORT Handle_Geom_Geometry *_wrap_Geom_Geometry_Mirrored__SWIG_2 (Handle_Geom_Geometry *larg1, gp_Ax2 *larg2) {
  Handle_Geom_Geometry * lresult = (Handle_Geom_Geometry *)0 ;
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Ax2 *arg2 = 0 ;
  SwigValueWrapper< Handle_Geom_Geometry > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Geometry_Mirrored__SWIG_2(arg1,(gp_Ax2 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Mirrored\n  * wrapname: _wrap_Geom_Geometry_Mirrored__SWIG_2\n  * fulldecl: Handle_Geom_Geometry Handle_Geom_Geometry::Mirrored(gp_Ax2 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Geometry *)0;
  }
}


SWIGINTERN Handle_Geom_Geometry Handle_Geom_Geometry_Rotated(Handle_Geom_Geometry *self,gp_Ax1 const &A1,Standard_Real const Ang){
    return (*self)->Rotated(A1, Ang);
  }
EXPORT Handle_Geom_Geometry *_wrap_Geom_Geometry_Rotated (Handle_Geom_Geometry *larg1, gp_Ax1 *larg2, Standard_Real larg3) {
  Handle_Geom_Geometry * lresult = (Handle_Geom_Geometry *)0 ;
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Ax1 *arg2 = 0 ;
  Standard_Real arg3 ;
  SwigValueWrapper< Handle_Geom_Geometry > result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Geometry_Rotated(arg1,(gp_Ax1 const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Rotated\n  * wrapname: _wrap_Geom_Geometry_Rotated\n  * fulldecl: Handle_Geom_Geometry Handle_Geom_Geometry::Rotated(gp_Ax1 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Geometry *)0;
  }
}


SWIGINTERN Handle_Geom_Geometry Handle_Geom_Geometry_Scaled(Handle_Geom_Geometry *self,gp_Pnt const &P,Standard_Real const S){
    return (*self)->Scaled(P, S);
  }
EXPORT Handle_Geom_Geometry *_wrap_Geom_Geometry_Scaled (Handle_Geom_Geometry *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  Handle_Geom_Geometry * lresult = (Handle_Geom_Geometry *)0 ;
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  SwigValueWrapper< Handle_Geom_Geometry > result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Geometry_Scaled(arg1,(gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Scaled\n  * wrapname: _wrap_Geom_Geometry_Scaled\n  * fulldecl: Handle_Geom_Geometry Handle_Geom_Geometry::Scaled(gp_Pnt const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Geometry *)0;
  }
}


SWIGINTERN Handle_Geom_Geometry Handle_Geom_Geometry_Transformed(Handle_Geom_Geometry *self,gp_Trsf const &T){
    return (*self)->Transformed(T);
  }
EXPORT Handle_Geom_Geometry *_wrap_Geom_Geometry_Transformed (Handle_Geom_Geometry *larg1, gp_Trsf *larg2) {
  Handle_Geom_Geometry * lresult = (Handle_Geom_Geometry *)0 ;
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Trsf *arg2 = 0 ;
  SwigValueWrapper< Handle_Geom_Geometry > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Geometry_Transformed(arg1,(gp_Trsf const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Transformed\n  * wrapname: _wrap_Geom_Geometry_Transformed\n  * fulldecl: Handle_Geom_Geometry Handle_Geom_Geometry::Transformed(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Geometry *)0;
  }
}


SWIGINTERN Handle_Geom_Geometry Handle_Geom_Geometry_Translated__SWIG_0(Handle_Geom_Geometry *self,gp_Vec const &V){
    return (*self)->Translated(V);
  }
EXPORT Handle_Geom_Geometry *_wrap_Geom_Geometry_Translated__SWIG_0 (Handle_Geom_Geometry *larg1, gp_Vec *larg2) {
  Handle_Geom_Geometry * lresult = (Handle_Geom_Geometry *)0 ;
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Vec *arg2 = 0 ;
  SwigValueWrapper< Handle_Geom_Geometry > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Geometry_Translated__SWIG_0(arg1,(gp_Vec const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Translated\n  * wrapname: _wrap_Geom_Geometry_Translated__SWIG_0\n  * fulldecl: Handle_Geom_Geometry Handle_Geom_Geometry::Translated(gp_Vec const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Geometry *)0;
  }
}


SWIGINTERN Handle_Geom_Geometry Handle_Geom_Geometry_Translated__SWIG_1(Handle_Geom_Geometry *self,gp_Pnt const &P1,gp_Pnt const &P2){
    return (*self)->Translated(P1, P2);
  }
EXPORT Handle_Geom_Geometry *_wrap_Geom_Geometry_Translated__SWIG_1 (Handle_Geom_Geometry *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  Handle_Geom_Geometry * lresult = (Handle_Geom_Geometry *)0 ;
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  SwigValueWrapper< Handle_Geom_Geometry > result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Geometry_Translated__SWIG_1(arg1,(gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Geometry_Translated\n  * wrapname: _wrap_Geom_Geometry_Translated__SWIG_1\n  * fulldecl: Handle_Geom_Geometry Handle_Geom_Geometry::Translated(gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Geometry(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Geometry *)0;
  }
}


EXPORT void _wrap_delete_Geom_Geometry (Handle_Geom_Geometry *larg1) {
  Handle_Geom_Geometry *arg1 = (Handle_Geom_Geometry *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom_Geometry\n  * wrapname: _wrap_delete_Geom_Geometry\n  * fulldecl: Handle_Geom_Geometry::~Handle_Geom_Geometry()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Geom_Curve_FirstParameter(Handle_Geom_Curve *self){
    return (*self)->FirstParameter();
  }
EXPORT Standard_Real _wrap_Geom_Curve_FirstParameter (Handle_Geom_Curve *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Curve *arg1 = (Handle_Geom_Curve *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Curve_FirstParameter(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Curve_FirstParameter\n  * wrapname: _wrap_Geom_Curve_FirstParameter\n  * fulldecl: Standard_Real Handle_Geom_Curve::FirstParameter()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Curve_LastParameter(Handle_Geom_Curve *self){
    return (*self)->LastParameter();
  }
EXPORT Standard_Real _wrap_Geom_Curve_LastParameter (Handle_Geom_Curve *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Curve *arg1 = (Handle_Geom_Curve *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Curve_LastParameter(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Curve_LastParameter\n  * wrapname: _wrap_Geom_Curve_LastParameter\n  * fulldecl: Standard_Real Handle_Geom_Curve::LastParameter()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom_Curve_IsClosed(Handle_Geom_Curve *self){
    return (*self)->IsClosed();
  }
EXPORT bool _wrap_Geom_Curve_IsClosed (Handle_Geom_Curve *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom_Curve *arg1 = (Handle_Geom_Curve *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom_Curve_IsClosed(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Curve_IsClosed\n  * wrapname: _wrap_Geom_Curve_IsClosed\n  * fulldecl: Standard_Boolean Handle_Geom_Curve::IsClosed()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom_Curve_IsPeriodic(Handle_Geom_Curve *self){
    return (*self)->IsPeriodic();
  }
EXPORT bool _wrap_Geom_Curve_IsPeriodic (Handle_Geom_Curve *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom_Curve *arg1 = (Handle_Geom_Curve *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom_Curve_IsPeriodic(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Curve_IsPeriodic\n  * wrapname: _wrap_Geom_Curve_IsPeriodic\n  * fulldecl: Standard_Boolean Handle_Geom_Curve::IsPeriodic()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Curve_Period(Handle_Geom_Curve *self){
    return (*self)->Period();
  }
EXPORT Standard_Real _wrap_Geom_Curve_Period (Handle_Geom_Curve *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Curve *arg1 = (Handle_Geom_Curve *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Curve_Period(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Curve_Period\n  * wrapname: _wrap_Geom_Curve_Period\n  * fulldecl: Standard_Real Handle_Geom_Curve::Period()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN void Handle_Geom_Curve_Reverse(Handle_Geom_Curve *self){
    return (*self)->Reverse();
  }
EXPORT void _wrap_Geom_Curve_Reverse (Handle_Geom_Curve *larg1) {
  Handle_Geom_Curve *arg1 = (Handle_Geom_Curve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Curve_Reverse(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Curve_Reverse\n  * wrapname: _wrap_Geom_Curve_Reverse\n  * fulldecl: void Handle_Geom_Curve::Reverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Geom_Curve_ReversedParameter(Handle_Geom_Curve *self,Standard_Real const U){
    return (*self)->ReversedParameter(U);
  }
EXPORT Standard_Real _wrap_Geom_Curve_ReversedParameter (Handle_Geom_Curve *larg1, Standard_Real larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Curve *arg1 = (Handle_Geom_Curve *) 0 ;
  Standard_Real arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Curve_ReversedParameter(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Curve_ReversedParameter\n  * wrapname: _wrap_Geom_Curve_ReversedParameter\n  * fulldecl: Standard_Real Handle_Geom_Curve::ReversedParameter(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_Curve_Value(Handle_Geom_Curve *self,Standard_Real const U){
    return (*self)->Value(U);
  }
EXPORT gp_Pnt *_wrap_Geom_Curve_Value (Handle_Geom_Curve *larg1, Standard_Real larg2) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_Curve *arg1 = (Handle_Geom_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Curve_Value(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Curve_Value\n  * wrapname: _wrap_Geom_Curve_Value\n  * fulldecl: gp_Pnt Handle_Geom_Curve::Value(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_Curve_GeometryType(Handle_Geom_Curve *self){
    if (STANDARD_TYPE(Geom_BezierCurve) == (*self)->DynamicType())
      {
	return 100;
      }
    else if (STANDARD_TYPE(Geom_BSplineCurve) == (*self)->DynamicType())
      {
	return 101;
      }
    else if (STANDARD_TYPE(Geom_Circle) == (*self)->DynamicType())
      {
	return 102;
      }
    else if (STANDARD_TYPE(Geom_Ellipse) == (*self)->DynamicType())
      {
	return 103;
      }
    else if (STANDARD_TYPE(Geom_TrimmedCurve) == (*self)->DynamicType())
      {
	return 104;
      }
    else if (STANDARD_TYPE(Geom_OffsetCurve) == (*self)->DynamicType())
      {
	return 105;
      }
    else if (STANDARD_TYPE(Geom_Hyperbola) == (*self)->DynamicType())
      {
	return 106;
      }
    else if (STANDARD_TYPE(Geom_Line) == (*self)->DynamicType())
      {
	return 107;
      }
    else if (STANDARD_TYPE(Geom_Parabola) == (*self)->DynamicType())
      {
	return 108;
      }
    
    return -1;
  }
EXPORT Standard_Integer _wrap_Geom_Curve_GeometryType (Handle_Geom_Curve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_Curve *arg1 = (Handle_Geom_Curve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_Curve_GeometryType(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Curve_GeometryType\n  * wrapname: _wrap_Geom_Curve_GeometryType\n  * fulldecl: Standard_Integer Handle_Geom_Curve::GeometryType()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT void _wrap_delete_Geom_Curve (Handle_Geom_Curve *larg1) {
  Handle_Geom_Curve *arg1 = (Handle_Geom_Curve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom_Curve\n  * wrapname: _wrap_delete_Geom_Curve\n  * fulldecl: Handle_Geom_Curve::~Handle_Geom_Curve()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Pnt Handle_Geom_Surface_Value(Handle_Geom_Surface const *self,Standard_Real const U,Standard_Real const V){
    return (*self)->Value(U, V);
  }
EXPORT gp_Pnt *_wrap_Geom_Surface_Value (Handle_Geom_Surface *larg1, Standard_Real larg2, Standard_Real larg3) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  gp_Pnt result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Surface_Value((Handle_Geom_Surface const *)arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_Value\n  * wrapname: _wrap_Geom_Surface_Value\n  * fulldecl: gp_Pnt Handle_Geom_Surface::Value(Standard_Real const,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN void Handle_Geom_Surface_Bounds(Handle_Geom_Surface const *self,Standard_Real &U1,Standard_Real &U2,Standard_Real &V1,Standard_Real &V2){
    (*self)->Bounds(U1,U2,V1,V2);
  }
EXPORT void _wrap_Geom_Surface_Bounds (Handle_Geom_Surface *larg1, Standard_Real *larg2, Standard_Real *larg3, Standard_Real *larg4, Standard_Real *larg5) {
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  Standard_Real *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Surface_Bounds((Handle_Geom_Surface const *)arg1,*arg2,*arg3,*arg4,*arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_Bounds\n  * wrapname: _wrap_Geom_Surface_Bounds\n  * fulldecl: void Handle_Geom_Surface::Bounds(Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Boolean Handle_Geom_Surface_IsUClosed(Handle_Geom_Surface const *self){
    return (*self)->IsUClosed();
  }
EXPORT bool _wrap_Geom_Surface_IsUClosed (Handle_Geom_Surface *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom_Surface_IsUClosed((Handle_Geom_Surface const *)arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_IsUClosed\n  * wrapname: _wrap_Geom_Surface_IsUClosed\n  * fulldecl: Standard_Boolean Handle_Geom_Surface::IsUClosed() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom_Surface_IsVClosed(Handle_Geom_Surface const *self){
    return (*self)->IsVClosed();
  }
EXPORT bool _wrap_Geom_Surface_IsVClosed (Handle_Geom_Surface *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom_Surface_IsVClosed((Handle_Geom_Surface const *)arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_IsVClosed\n  * wrapname: _wrap_Geom_Surface_IsVClosed\n  * fulldecl: Standard_Boolean Handle_Geom_Surface::IsVClosed() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Handle_Geom_Curve Handle_Geom_Surface_UIso(Handle_Geom_Surface const *self,Standard_Real const U){
    return (*self)->UIso(U);
  }
EXPORT Handle_Geom_Curve *_wrap_Geom_Surface_UIso (Handle_Geom_Surface *larg1, Standard_Real larg2) {
  Handle_Geom_Curve * lresult = (Handle_Geom_Curve *)0 ;
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Real arg2 ;
  SwigValueWrapper< Handle_Geom_Curve > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Surface_UIso((Handle_Geom_Surface const *)arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_UIso\n  * wrapname: _wrap_Geom_Surface_UIso\n  * fulldecl: Handle_Geom_Curve Handle_Geom_Surface::UIso(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Curve(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Curve *)0;
  }
}


SWIGINTERN Handle_Geom_Curve Handle_Geom_Surface_VIso(Handle_Geom_Surface const *self,Standard_Real const V){
    return (*self)->VIso(V);
  }
EXPORT Handle_Geom_Curve *_wrap_Geom_Surface_VIso (Handle_Geom_Surface *larg1, Standard_Real larg2) {
  Handle_Geom_Curve * lresult = (Handle_Geom_Curve *)0 ;
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Real arg2 ;
  SwigValueWrapper< Handle_Geom_Curve > result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Surface_VIso((Handle_Geom_Surface const *)arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_VIso\n  * wrapname: _wrap_Geom_Surface_VIso\n  * fulldecl: Handle_Geom_Curve Handle_Geom_Surface::VIso(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Curve(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Curve *)0;
  }
}


SWIGINTERN void Handle_Geom_Surface_UReverse(Handle_Geom_Surface *self){
    return (*self)->UReverse();
  }
EXPORT void _wrap_Geom_Surface_UReverse (Handle_Geom_Surface *larg1) {
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Surface_UReverse(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_UReverse\n  * wrapname: _wrap_Geom_Surface_UReverse\n  * fulldecl: void Handle_Geom_Surface::UReverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Geom_Surface_UReversedParameter(Handle_Geom_Surface *self,Standard_Real const U){
    return (*self)->UReversedParameter(U);
  }
EXPORT Standard_Real _wrap_Geom_Surface_UReversedParameter (Handle_Geom_Surface *larg1, Standard_Real larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Real arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Surface_UReversedParameter(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_UReversedParameter\n  * wrapname: _wrap_Geom_Surface_UReversedParameter\n  * fulldecl: Standard_Real Handle_Geom_Surface::UReversedParameter(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN void Handle_Geom_Surface_VReverse(Handle_Geom_Surface *self){
    return (*self)->VReverse();
  }
EXPORT void _wrap_Geom_Surface_VReverse (Handle_Geom_Surface *larg1) {
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Surface_VReverse(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_VReverse\n  * wrapname: _wrap_Geom_Surface_VReverse\n  * fulldecl: void Handle_Geom_Surface::VReverse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Geom_Surface_VReversedParameter(Handle_Geom_Surface *self,Standard_Real const V){
    return (*self)->VReversedParameter(V);
  }
EXPORT Standard_Real _wrap_Geom_Surface_VReversedParameter (Handle_Geom_Surface *larg1, Standard_Real larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Real arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Surface_VReversedParameter(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_VReversedParameter\n  * wrapname: _wrap_Geom_Surface_VReversedParameter\n  * fulldecl: Standard_Real Handle_Geom_Surface::VReversedParameter(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom_Surface_IsUPeriodic(Handle_Geom_Surface *self){
    return (*self)->IsUPeriodic();
  }
EXPORT bool _wrap_Geom_Surface_IsUPeriodic (Handle_Geom_Surface *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom_Surface_IsUPeriodic(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_IsUPeriodic\n  * wrapname: _wrap_Geom_Surface_IsUPeriodic\n  * fulldecl: Standard_Boolean Handle_Geom_Surface::IsUPeriodic()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Surface_UPeriod(Handle_Geom_Surface *self){
    return (*self)->UPeriod();
  }
EXPORT Standard_Real _wrap_Geom_Surface_UPeriod (Handle_Geom_Surface *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Surface_UPeriod(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_UPeriod\n  * wrapname: _wrap_Geom_Surface_UPeriod\n  * fulldecl: Standard_Real Handle_Geom_Surface::UPeriod()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom_Surface_IsVPeriodic(Handle_Geom_Surface *self){
    return (*self)->IsVPeriodic();
  }
EXPORT bool _wrap_Geom_Surface_IsVPeriodic (Handle_Geom_Surface *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom_Surface_IsVPeriodic(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_IsVPeriodic\n  * wrapname: _wrap_Geom_Surface_IsVPeriodic\n  * fulldecl: Standard_Boolean Handle_Geom_Surface::IsVPeriodic()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Surface_VPeriod(Handle_Geom_Surface *self){
    return (*self)->VPeriod();
  }
EXPORT Standard_Real _wrap_Geom_Surface_VPeriod (Handle_Geom_Surface *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Surface_VPeriod(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_VPeriod\n  * wrapname: _wrap_Geom_Surface_VPeriod\n  * fulldecl: Standard_Real Handle_Geom_Surface::VPeriod()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_Surface_GeometryType(Handle_Geom_Surface *self){
    if (STANDARD_TYPE(Geom_BezierSurface) == (*self)->DynamicType())
      {
	return 200;
      }
    else if (STANDARD_TYPE(Geom_BSplineSurface) == (*self)->DynamicType())
      {
	return 201;
      }
    else if (STANDARD_TYPE(Geom_RectangularTrimmedSurface) == (*self)->DynamicType())
      {
	return 202;
      }
    else if (STANDARD_TYPE(Geom_SphericalSurface) == (*self)->DynamicType())
      {
	return 203;
      }
    else if (STANDARD_TYPE(Geom_ToroidalSurface) == (*self)->DynamicType())
      {
	return 204;
      }
    else if (STANDARD_TYPE(Geom_OffsetSurface) == (*self)->DynamicType())
      {
	return 205;
      }
    else if (STANDARD_TYPE(Geom_SurfaceOfRevolution) == (*self)->DynamicType())
      {
	return 206;
      }
    else if (STANDARD_TYPE(Geom_ConicalSurface) == (*self)->DynamicType())
      {
	return 207;
      }
    else if (STANDARD_TYPE(Geom_CylindricalSurface) == (*self)->DynamicType())
      {
	return 208;
      }
    else if (STANDARD_TYPE(Geom_SurfaceOfLinearExtrusion) == (*self)->DynamicType())
      {
	return 209;
      }
    else if (STANDARD_TYPE(Geom_Plane) == (*self)->DynamicType())
      {
	return 210;
      }
    
    return -1;
  }
EXPORT Standard_Integer _wrap_Geom_Surface_GeometryType (Handle_Geom_Surface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_Surface_GeometryType(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Surface_GeometryType\n  * wrapname: _wrap_Geom_Surface_GeometryType\n  * fulldecl: Standard_Integer Handle_Geom_Surface::GeometryType()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT void _wrap_delete_Geom_Surface (Handle_Geom_Surface *larg1) {
  Handle_Geom_Surface *arg1 = (Handle_Geom_Surface *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom_Surface\n  * wrapname: _wrap_delete_Geom_Surface\n  * fulldecl: Handle_Geom_Surface::~Handle_Geom_Surface()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Pnt Handle_Geom_BoundedCurve_EndPoint(Handle_Geom_BoundedCurve *self){
		return (*self)->EndPoint();
	}
EXPORT gp_Pnt *_wrap_Geom_BoundedCurve_EndPoint (Handle_Geom_BoundedCurve *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_BoundedCurve *arg1 = (Handle_Geom_BoundedCurve *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_BoundedCurve_EndPoint(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BoundedCurve_EndPoint\n  * wrapname: _wrap_Geom_BoundedCurve_EndPoint\n  * fulldecl: gp_Pnt Handle_Geom_BoundedCurve::EndPoint()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_BoundedCurve_StartPoint(Handle_Geom_BoundedCurve *self){
		return (*self)->StartPoint();
	}
EXPORT gp_Pnt *_wrap_Geom_BoundedCurve_StartPoint (Handle_Geom_BoundedCurve *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_BoundedCurve *arg1 = (Handle_Geom_BoundedCurve *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_BoundedCurve_StartPoint(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BoundedCurve_StartPoint\n  * wrapname: _wrap_Geom_BoundedCurve_StartPoint\n  * fulldecl: gp_Pnt Handle_Geom_BoundedCurve::StartPoint()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT void _wrap_delete_Geom_BoundedCurve (Handle_Geom_BoundedCurve *larg1) {
  Handle_Geom_BoundedCurve *arg1 = (Handle_Geom_BoundedCurve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom_BoundedCurve\n  * wrapname: _wrap_delete_Geom_BoundedCurve\n  * fulldecl: Handle_Geom_BoundedCurve::~Handle_Geom_BoundedCurve()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Ax1 Handle_Geom_Conic_Axis(Handle_Geom_Conic *self){
		return (*self)->Axis();
	}
EXPORT gp_Ax1 *_wrap_Geom_Conic_Axis (Handle_Geom_Conic *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  Handle_Geom_Conic *arg1 = (Handle_Geom_Conic *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Conic_Axis(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Conic_Axis\n  * wrapname: _wrap_Geom_Conic_Axis\n  * fulldecl: gp_Ax1 Handle_Geom_Conic::Axis()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Conic_Eccentricity(Handle_Geom_Conic *self){
		return (*self)->Eccentricity();
	}
EXPORT Standard_Real _wrap_Geom_Conic_Eccentricity (Handle_Geom_Conic *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Conic *arg1 = (Handle_Geom_Conic *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Conic_Eccentricity(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Conic_Eccentricity\n  * wrapname: _wrap_Geom_Conic_Eccentricity\n  * fulldecl: Standard_Real Handle_Geom_Conic::Eccentricity()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_Conic_Location(Handle_Geom_Conic *self){
		return (*self)->Location();
	}
EXPORT gp_Pnt *_wrap_Geom_Conic_Location (Handle_Geom_Conic *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_Conic *arg1 = (Handle_Geom_Conic *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Conic_Location(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Conic_Location\n  * wrapname: _wrap_Geom_Conic_Location\n  * fulldecl: gp_Pnt Handle_Geom_Conic::Location()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN gp_Ax2 Handle_Geom_Conic_Position(Handle_Geom_Conic *self){
		return (*self)->Position();
	}
EXPORT gp_Ax2 *_wrap_Geom_Conic_Position (Handle_Geom_Conic *larg1) {
  gp_Ax2 * lresult = (gp_Ax2 *)0 ;
  Handle_Geom_Conic *arg1 = (Handle_Geom_Conic *) 0 ;
  gp_Ax2 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Conic_Position(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Conic_Position\n  * wrapname: _wrap_Geom_Conic_Position\n  * fulldecl: gp_Ax2 Handle_Geom_Conic::Position()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2 *)0;
  }
}


SWIGINTERN gp_Ax1 Handle_Geom_Conic_XAxis(Handle_Geom_Conic *self){
		return (*self)->XAxis();
	}
EXPORT gp_Ax1 *_wrap_Geom_Conic_XAxis (Handle_Geom_Conic *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  Handle_Geom_Conic *arg1 = (Handle_Geom_Conic *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Conic_XAxis(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Conic_XAxis\n  * wrapname: _wrap_Geom_Conic_XAxis\n  * fulldecl: gp_Ax1 Handle_Geom_Conic::XAxis()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


SWIGINTERN gp_Ax1 Handle_Geom_Conic_YAxis(Handle_Geom_Conic *self){
		return (*self)->YAxis();
	}
EXPORT gp_Ax1 *_wrap_Geom_Conic_YAxis (Handle_Geom_Conic *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  Handle_Geom_Conic *arg1 = (Handle_Geom_Conic *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Conic_YAxis(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Conic_YAxis\n  * wrapname: _wrap_Geom_Conic_YAxis\n  * fulldecl: gp_Ax1 Handle_Geom_Conic::YAxis()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


EXPORT void _wrap_delete_Geom_Conic (Handle_Geom_Conic *larg1) {
  Handle_Geom_Conic *arg1 = (Handle_Geom_Conic *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom_Conic\n  * wrapname: _wrap_delete_Geom_Conic\n  * fulldecl: Handle_Geom_Conic::~Handle_Geom_Conic()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_Geom_BoundedSurface (Handle_Geom_BoundedSurface *larg1) {
  Handle_Geom_BoundedSurface *arg1 = (Handle_Geom_BoundedSurface *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom_BoundedSurface\n  * wrapname: _wrap_delete_Geom_BoundedSurface\n  * fulldecl: Handle_Geom_BoundedSurface::~Handle_Geom_BoundedSurface()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Ax1 Handle_Geom_ElementarySurface_Axis(Handle_Geom_ElementarySurface *self){
		return (*self)->Axis();
	}
EXPORT gp_Ax1 *_wrap_Geom_ElementarySurface_Axis (Handle_Geom_ElementarySurface *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  Handle_Geom_ElementarySurface *arg1 = (Handle_Geom_ElementarySurface *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_ElementarySurface_Axis(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_ElementarySurface_Axis\n  * wrapname: _wrap_Geom_ElementarySurface_Axis\n  * fulldecl: gp_Ax1 Handle_Geom_ElementarySurface::Axis()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_ElementarySurface_Location(Handle_Geom_ElementarySurface *self){
		return (*self)->Location();
	}
EXPORT gp_Pnt *_wrap_Geom_ElementarySurface_Location (Handle_Geom_ElementarySurface *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_ElementarySurface *arg1 = (Handle_Geom_ElementarySurface *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_ElementarySurface_Location(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_ElementarySurface_Location\n  * wrapname: _wrap_Geom_ElementarySurface_Location\n  * fulldecl: gp_Pnt Handle_Geom_ElementarySurface::Location()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN gp_Ax3 Handle_Geom_ElementarySurface_Position(Handle_Geom_ElementarySurface *self){
		return (*self)->Position();
	}
EXPORT gp_Ax3 *_wrap_Geom_ElementarySurface_Position (Handle_Geom_ElementarySurface *larg1) {
  gp_Ax3 * lresult = (gp_Ax3 *)0 ;
  Handle_Geom_ElementarySurface *arg1 = (Handle_Geom_ElementarySurface *) 0 ;
  gp_Ax3 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_ElementarySurface_Position(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_ElementarySurface_Position\n  * wrapname: _wrap_Geom_ElementarySurface_Position\n  * fulldecl: gp_Ax3 Handle_Geom_ElementarySurface::Position()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax3(result);
    return lresult;
  } catch (...) {
    return (gp_Ax3 *)0;
  }
}


EXPORT void _wrap_delete_Geom_ElementarySurface (Handle_Geom_ElementarySurface *larg1) {
  Handle_Geom_ElementarySurface *arg1 = (Handle_Geom_ElementarySurface *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom_ElementarySurface\n  * wrapname: _wrap_delete_Geom_ElementarySurface\n  * fulldecl: Handle_Geom_ElementarySurface::~Handle_Geom_ElementarySurface()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN gp_Dir Handle_Geom_SweptSurface_Direction(Handle_Geom_SweptSurface *self){
		return (*self)->Direction();
	}
EXPORT gp_Dir *_wrap_Geom_SweptSurface_Direction (Handle_Geom_SweptSurface *larg1) {
  gp_Dir * lresult = (gp_Dir *)0 ;
  Handle_Geom_SweptSurface *arg1 = (Handle_Geom_SweptSurface *) 0 ;
  gp_Dir result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_SweptSurface_Direction(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_SweptSurface_Direction\n  * wrapname: _wrap_Geom_SweptSurface_Direction\n  * fulldecl: gp_Dir Handle_Geom_SweptSurface::Direction()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Dir(result);
    return lresult;
  } catch (...) {
    return (gp_Dir *)0;
  }
}


SWIGINTERN Handle_Geom_Curve Handle_Geom_SweptSurface_BasisCurve(Handle_Geom_SweptSurface *self){
		return (*self)->BasisCurve();
	}
EXPORT Handle_Geom_Curve *_wrap_Geom_SweptSurface_BasisCurve (Handle_Geom_SweptSurface *larg1) {
  Handle_Geom_Curve * lresult = (Handle_Geom_Curve *)0 ;
  Handle_Geom_SweptSurface *arg1 = (Handle_Geom_SweptSurface *) 0 ;
  SwigValueWrapper< Handle_Geom_Curve > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_SweptSurface_BasisCurve(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_SweptSurface_BasisCurve\n  * wrapname: _wrap_Geom_SweptSurface_BasisCurve\n  * fulldecl: Handle_Geom_Curve Handle_Geom_SweptSurface::BasisCurve()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Curve(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Curve *)0;
  }
}


EXPORT void _wrap_delete_Geom_SweptSurface (Handle_Geom_SweptSurface *larg1) {
  Handle_Geom_SweptSurface *arg1 = (Handle_Geom_SweptSurface *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom_SweptSurface\n  * wrapname: _wrap_delete_Geom_SweptSurface\n  * fulldecl: Handle_Geom_SweptSurface::~Handle_Geom_SweptSurface()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom_BezierCurve *new_Handle_Geom_BezierCurve__SWIG_0(TColgp_Array1OfPnt const &CurvePoles,TColStd_Array1OfReal const &PoleWeights){
          return new Handle_Geom_BezierCurve(new Geom_BezierCurve(CurvePoles, PoleWeights));
    }
EXPORT Handle_Geom_BezierCurve *_wrap_new_Geom_BezierCurve__SWIG_0 (TColgp_Array1OfPnt *larg1, TColStd_Array1OfReal *larg2) {
  Handle_Geom_BezierCurve * lresult = (Handle_Geom_BezierCurve *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  Handle_Geom_BezierCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_BezierCurve *)new_Handle_Geom_BezierCurve__SWIG_0((TColgp_Array1OfPnt const &)*arg1,(TColStd_Array1OfReal const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_BezierCurve\n  * wrapname: _wrap_new_Geom_BezierCurve__SWIG_0\n  * fulldecl: Handle_Geom_BezierCurve::Handle_Geom_BezierCurve(TColgp_Array1OfPnt const &,TColStd_Array1OfReal const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_BezierCurve *)0;
  }
}


SWIGINTERN Handle_Geom_BezierCurve *new_Handle_Geom_BezierCurve__SWIG_1(TColgp_Array1OfPnt const &CurvePoles){
          return new Handle_Geom_BezierCurve(new Geom_BezierCurve(CurvePoles));
    }
EXPORT Handle_Geom_BezierCurve *_wrap_new_Geom_BezierCurve__SWIG_1 (TColgp_Array1OfPnt *larg1) {
  Handle_Geom_BezierCurve * lresult = (Handle_Geom_BezierCurve *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  Handle_Geom_BezierCurve *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_BezierCurve *)new_Handle_Geom_BezierCurve__SWIG_1((TColgp_Array1OfPnt const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_BezierCurve\n  * wrapname: _wrap_new_Geom_BezierCurve__SWIG_1\n  * fulldecl: Handle_Geom_BezierCurve::Handle_Geom_BezierCurve(TColgp_Array1OfPnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_BezierCurve *)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom_BezierCurve_IsPeriodic(Handle_Geom_BezierCurve *self){
        return (*self)->IsPeriodic();
    }
EXPORT bool _wrap_Geom_BezierCurve_IsPeriodic (Handle_Geom_BezierCurve *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom_BezierCurve *arg1 = (Handle_Geom_BezierCurve *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom_BezierCurve_IsPeriodic(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierCurve_IsPeriodic\n  * wrapname: _wrap_Geom_BezierCurve_IsPeriodic\n  * fulldecl: Standard_Boolean Handle_Geom_BezierCurve::IsPeriodic()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom_BezierCurve_IsRational(Handle_Geom_BezierCurve *self){
		return (*self)->IsRational();
	}
EXPORT bool _wrap_Geom_BezierCurve_IsRational (Handle_Geom_BezierCurve *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom_BezierCurve *arg1 = (Handle_Geom_BezierCurve *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom_BezierCurve_IsRational(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierCurve_IsRational\n  * wrapname: _wrap_Geom_BezierCurve_IsRational\n  * fulldecl: Standard_Boolean Handle_Geom_BezierCurve::IsRational()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BezierCurve_Degree(Handle_Geom_BezierCurve *self){
		return (*self)->Degree();
	}
EXPORT Standard_Integer _wrap_Geom_BezierCurve_Degree (Handle_Geom_BezierCurve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BezierCurve *arg1 = (Handle_Geom_BezierCurve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BezierCurve_Degree(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierCurve_Degree\n  * wrapname: _wrap_Geom_BezierCurve_Degree\n  * fulldecl: Standard_Integer Handle_Geom_BezierCurve::Degree()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN void Handle_Geom_BezierCurve_Resolution(Handle_Geom_BezierCurve *self,Standard_Real tolerance3d,Standard_Real &toleranceU){
        return (*self)->Resolution(tolerance3d, toleranceU);
    }
EXPORT void _wrap_Geom_BezierCurve_Resolution (Handle_Geom_BezierCurve *larg1, Standard_Real larg2, Standard_Real *larg3) {
  Handle_Geom_BezierCurve *arg1 = (Handle_Geom_BezierCurve *) 0 ;
  Standard_Real arg2 ;
  Standard_Real *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BezierCurve_Resolution(arg1,arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierCurve_Resolution\n  * wrapname: _wrap_Geom_BezierCurve_Resolution\n  * fulldecl: void Handle_Geom_BezierCurve::Resolution(Standard_Real,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BezierCurve_NbPoles(Handle_Geom_BezierCurve *self){
        return (*self)->NbPoles();
    }
EXPORT Standard_Integer _wrap_Geom_BezierCurve_NbPoles (Handle_Geom_BezierCurve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BezierCurve *arg1 = (Handle_Geom_BezierCurve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BezierCurve_NbPoles(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierCurve_NbPoles\n  * wrapname: _wrap_Geom_BezierCurve_NbPoles\n  * fulldecl: Standard_Integer Handle_Geom_BezierCurve::NbPoles()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_BezierCurve_Pole(Handle_Geom_BezierCurve *self,Standard_Integer const Index){
        return (*self)->Pole(Index);
    }
EXPORT gp_Pnt *_wrap_Geom_BezierCurve_Pole (Handle_Geom_BezierCurve *larg1, Standard_Integer larg2) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_BezierCurve *arg1 = (Handle_Geom_BezierCurve *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_BezierCurve_Pole(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierCurve_Pole\n  * wrapname: _wrap_Geom_BezierCurve_Pole\n  * fulldecl: gp_Pnt Handle_Geom_BezierCurve::Pole(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_BezierCurve_Weight(Handle_Geom_BezierCurve *self,Standard_Integer const Index){
        return (*self)->Weight(Index);
    }
EXPORT Standard_Real _wrap_Geom_BezierCurve_Weight (Handle_Geom_BezierCurve *larg1, Standard_Integer larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_BezierCurve *arg1 = (Handle_Geom_BezierCurve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_BezierCurve_Weight(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierCurve_Weight\n  * wrapname: _wrap_Geom_BezierCurve_Weight\n  * fulldecl: Standard_Real Handle_Geom_BezierCurve::Weight(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_delete_Geom_BezierCurve (Handle_Geom_BezierCurve *larg1) {
  Handle_Geom_BezierCurve *arg1 = (Handle_Geom_BezierCurve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom_BezierCurve\n  * wrapname: _wrap_delete_Geom_BezierCurve\n  * fulldecl: Handle_Geom_BezierCurve::~Handle_Geom_BezierCurve()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom_BSplineCurve *new_Handle_Geom_BSplineCurve__SWIG_0(TColgp_Array1OfPnt const &Poles,TColStd_Array1OfReal const &Weights,TColStd_Array1OfReal const &Knots,TColStd_Array1OfInteger const &Multiplicities,Standard_Integer const Degree,Standard_Boolean const Periodic=Standard_False,Standard_Boolean const CheckRational=Standard_True){
		return new Handle_Geom_BSplineCurve(new Geom_BSplineCurve(
			Poles, Weights, Knots, Multiplicities, Degree, Periodic, CheckRational));
	}
EXPORT Handle_Geom_BSplineCurve *_wrap_new_Geom_BSplineCurve__SWIG_0 (TColgp_Array1OfPnt *larg1, TColStd_Array1OfReal *larg2, TColStd_Array1OfReal *larg3, TColStd_Array1OfInteger *larg4, Standard_Integer larg5, bool larg6, bool larg7) {
  Handle_Geom_BSplineCurve * lresult = (Handle_Geom_BSplineCurve *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  TColStd_Array1OfReal *arg3 = 0 ;
  TColStd_Array1OfInteger *arg4 = 0 ;
  Standard_Integer arg5 ;
  Standard_Boolean arg6 ;
  Standard_Boolean arg7 ;
  Handle_Geom_BSplineCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = (bool)larg6;
  arg7 = (bool)larg7;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_BSplineCurve *)new_Handle_Geom_BSplineCurve__SWIG_0((TColgp_Array1OfPnt const &)*arg1,(TColStd_Array1OfReal const &)*arg2,(TColStd_Array1OfReal const &)*arg3,(TColStd_Array1OfInteger const &)*arg4,arg5,arg6,arg7);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_BSplineCurve\n  * wrapname: _wrap_new_Geom_BSplineCurve__SWIG_0\n  * fulldecl: Handle_Geom_BSplineCurve::Handle_Geom_BSplineCurve(TColgp_Array1OfPnt const &,TColStd_Array1OfReal const &,TColStd_Array1OfReal const &,TColStd_Array1OfInteger const &,Standard_Integer const,Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_BSplineCurve *)0;
  }
}


EXPORT Handle_Geom_BSplineCurve *_wrap_new_Geom_BSplineCurve__SWIG_1 (TColgp_Array1OfPnt *larg1, TColStd_Array1OfReal *larg2, TColStd_Array1OfReal *larg3, TColStd_Array1OfInteger *larg4, Standard_Integer larg5, bool larg6) {
  Handle_Geom_BSplineCurve * lresult = (Handle_Geom_BSplineCurve *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  TColStd_Array1OfReal *arg3 = 0 ;
  TColStd_Array1OfInteger *arg4 = 0 ;
  Standard_Integer arg5 ;
  Standard_Boolean arg6 ;
  Handle_Geom_BSplineCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = (bool)larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_BSplineCurve *)new_Handle_Geom_BSplineCurve__SWIG_0((TColgp_Array1OfPnt const &)*arg1,(TColStd_Array1OfReal const &)*arg2,(TColStd_Array1OfReal const &)*arg3,(TColStd_Array1OfInteger const &)*arg4,arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_BSplineCurve\n  * wrapname: _wrap_new_Geom_BSplineCurve__SWIG_1\n  * fulldecl: Handle_Geom_BSplineCurve::Handle_Geom_BSplineCurve(TColgp_Array1OfPnt const &,TColStd_Array1OfReal const &,TColStd_Array1OfReal const &,TColStd_Array1OfInteger const &,Standard_Integer const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_BSplineCurve *)0;
  }
}


EXPORT Handle_Geom_BSplineCurve *_wrap_new_Geom_BSplineCurve__SWIG_2 (TColgp_Array1OfPnt *larg1, TColStd_Array1OfReal *larg2, TColStd_Array1OfReal *larg3, TColStd_Array1OfInteger *larg4, Standard_Integer larg5) {
  Handle_Geom_BSplineCurve * lresult = (Handle_Geom_BSplineCurve *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  TColStd_Array1OfReal *arg3 = 0 ;
  TColStd_Array1OfInteger *arg4 = 0 ;
  Standard_Integer arg5 ;
  Handle_Geom_BSplineCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_BSplineCurve *)new_Handle_Geom_BSplineCurve__SWIG_0((TColgp_Array1OfPnt const &)*arg1,(TColStd_Array1OfReal const &)*arg2,(TColStd_Array1OfReal const &)*arg3,(TColStd_Array1OfInteger const &)*arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_BSplineCurve\n  * wrapname: _wrap_new_Geom_BSplineCurve__SWIG_2\n  * fulldecl: Handle_Geom_BSplineCurve::Handle_Geom_BSplineCurve(TColgp_Array1OfPnt const &,TColStd_Array1OfReal const &,TColStd_Array1OfReal const &,TColStd_Array1OfInteger const &,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_BSplineCurve *)0;
  }
}


SWIGINTERN Handle_Geom_BSplineCurve *new_Handle_Geom_BSplineCurve__SWIG_3(TColgp_Array1OfPnt const &Poles,TColStd_Array1OfReal const &Knots,TColStd_Array1OfInteger const &Multiplicities,Standard_Integer const Degree,Standard_Boolean const Periodic=Standard_False){
        return new Handle_Geom_BSplineCurve(new Geom_BSplineCurve(Poles, Knots, Multiplicities, 
            Degree, Periodic));
    }
EXPORT Handle_Geom_BSplineCurve *_wrap_new_Geom_BSplineCurve__SWIG_3 (TColgp_Array1OfPnt *larg1, TColStd_Array1OfReal *larg2, TColStd_Array1OfInteger *larg3, Standard_Integer larg4, bool larg5) {
  Handle_Geom_BSplineCurve * lresult = (Handle_Geom_BSplineCurve *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  TColStd_Array1OfInteger *arg3 = 0 ;
  Standard_Integer arg4 ;
  Standard_Boolean arg5 ;
  Handle_Geom_BSplineCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = (bool)larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_BSplineCurve *)new_Handle_Geom_BSplineCurve__SWIG_3((TColgp_Array1OfPnt const &)*arg1,(TColStd_Array1OfReal const &)*arg2,(TColStd_Array1OfInteger const &)*arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_BSplineCurve\n  * wrapname: _wrap_new_Geom_BSplineCurve__SWIG_3\n  * fulldecl: Handle_Geom_BSplineCurve::Handle_Geom_BSplineCurve(TColgp_Array1OfPnt const &,TColStd_Array1OfReal const &,TColStd_Array1OfInteger const &,Standard_Integer const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_BSplineCurve *)0;
  }
}


EXPORT Handle_Geom_BSplineCurve *_wrap_new_Geom_BSplineCurve__SWIG_4 (TColgp_Array1OfPnt *larg1, TColStd_Array1OfReal *larg2, TColStd_Array1OfInteger *larg3, Standard_Integer larg4) {
  Handle_Geom_BSplineCurve * lresult = (Handle_Geom_BSplineCurve *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  TColStd_Array1OfInteger *arg3 = 0 ;
  Standard_Integer arg4 ;
  Handle_Geom_BSplineCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_BSplineCurve *)new_Handle_Geom_BSplineCurve__SWIG_3((TColgp_Array1OfPnt const &)*arg1,(TColStd_Array1OfReal const &)*arg2,(TColStd_Array1OfInteger const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_BSplineCurve\n  * wrapname: _wrap_new_Geom_BSplineCurve__SWIG_4\n  * fulldecl: Handle_Geom_BSplineCurve::Handle_Geom_BSplineCurve(TColgp_Array1OfPnt const &,TColStd_Array1OfReal const &,TColStd_Array1OfInteger const &,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_BSplineCurve *)0;
  }
}


SWIGINTERN void Handle_Geom_BSplineCurve_SetKnot__SWIG_0(Handle_Geom_BSplineCurve *self,Standard_Integer const Index,Standard_Real const K){
    (*self)->SetKnot(Index,K);
  }
EXPORT void _wrap_Geom_BSplineCurve_SetKnot__SWIG_0 (Handle_Geom_BSplineCurve *larg1, Standard_Integer larg2, Standard_Real larg3) {
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BSplineCurve_SetKnot__SWIG_0(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_SetKnot\n  * wrapname: _wrap_Geom_BSplineCurve_SetKnot__SWIG_0\n  * fulldecl: void Handle_Geom_BSplineCurve::SetKnot(Standard_Integer const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_BSplineCurve_SetKnot__SWIG_1(Handle_Geom_BSplineCurve *self,Standard_Integer const Index,Standard_Real const K,Standard_Integer const M){
    (*self)->SetKnot(Index,K,M);
  }
EXPORT void _wrap_Geom_BSplineCurve_SetKnot__SWIG_1 (Handle_Geom_BSplineCurve *larg1, Standard_Integer larg2, Standard_Real larg3, Standard_Integer larg4) {
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real arg3 ;
  Standard_Integer arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BSplineCurve_SetKnot__SWIG_1(arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_SetKnot\n  * wrapname: _wrap_Geom_BSplineCurve_SetKnot__SWIG_1\n  * fulldecl: void Handle_Geom_BSplineCurve::SetKnot(Standard_Integer const,Standard_Real const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_BSplineCurve_SetPeriodic(Handle_Geom_BSplineCurve *self){
    (*self)->SetPeriodic();
  }
EXPORT void _wrap_Geom_BSplineCurve_SetPeriodic (Handle_Geom_BSplineCurve *larg1) {
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BSplineCurve_SetPeriodic(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_SetPeriodic\n  * wrapname: _wrap_Geom_BSplineCurve_SetPeriodic\n  * fulldecl: void Handle_Geom_BSplineCurve::SetPeriodic()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_BSplineCurve_SetNotPeriodic(Handle_Geom_BSplineCurve *self){
    (*self)->SetNotPeriodic();
  }
EXPORT void _wrap_Geom_BSplineCurve_SetNotPeriodic (Handle_Geom_BSplineCurve *larg1) {
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BSplineCurve_SetNotPeriodic(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_SetNotPeriodic\n  * wrapname: _wrap_Geom_BSplineCurve_SetNotPeriodic\n  * fulldecl: void Handle_Geom_BSplineCurve::SetNotPeriodic()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_BSplineCurve_SetOrigin__SWIG_0(Handle_Geom_BSplineCurve *self,Standard_Integer const Index){
     (*self)->SetOrigin(Index);
  }
EXPORT void _wrap_Geom_BSplineCurve_SetOrigin__SWIG_0 (Handle_Geom_BSplineCurve *larg1, Standard_Integer larg2) {
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BSplineCurve_SetOrigin__SWIG_0(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_SetOrigin\n  * wrapname: _wrap_Geom_BSplineCurve_SetOrigin__SWIG_0\n  * fulldecl: void Handle_Geom_BSplineCurve::SetOrigin(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_BSplineCurve_SetOrigin__SWIG_1(Handle_Geom_BSplineCurve *self,Standard_Real const U,Standard_Real const Tol){
     (*self)->SetOrigin(U,Tol);
  }
EXPORT void _wrap_Geom_BSplineCurve_SetOrigin__SWIG_1 (Handle_Geom_BSplineCurve *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BSplineCurve_SetOrigin__SWIG_1(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_SetOrigin\n  * wrapname: _wrap_Geom_BSplineCurve_SetOrigin__SWIG_1\n  * fulldecl: void Handle_Geom_BSplineCurve::SetOrigin(Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_BSplineCurve_SetPole__SWIG_0(Handle_Geom_BSplineCurve *self,Standard_Integer const Index,gp_Pnt const &P){
    (*self)->SetPole(Index,P);
  }
EXPORT void _wrap_Geom_BSplineCurve_SetPole__SWIG_0 (Handle_Geom_BSplineCurve *larg1, Standard_Integer larg2, gp_Pnt *larg3) {
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BSplineCurve_SetPole__SWIG_0(arg1,arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_SetPole\n  * wrapname: _wrap_Geom_BSplineCurve_SetPole__SWIG_0\n  * fulldecl: void Handle_Geom_BSplineCurve::SetPole(Standard_Integer const,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_BSplineCurve_SetPole__SWIG_1(Handle_Geom_BSplineCurve *self,Standard_Integer const Index,gp_Pnt const &P,Standard_Real const Weight){
    (*self)->SetPole(Index,P,Weight);
  }
EXPORT void _wrap_Geom_BSplineCurve_SetPole__SWIG_1 (Handle_Geom_BSplineCurve *larg1, Standard_Integer larg2, gp_Pnt *larg3, Standard_Real larg4) {
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt *arg3 = 0 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BSplineCurve_SetPole__SWIG_1(arg1,arg2,(gp_Pnt const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_SetPole\n  * wrapname: _wrap_Geom_BSplineCurve_SetPole__SWIG_1\n  * fulldecl: void Handle_Geom_BSplineCurve::SetPole(Standard_Integer const,gp_Pnt const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_BSplineCurve_MovePoint(Handle_Geom_BSplineCurve *self,Standard_Real const U,gp_Pnt const &P,Standard_Integer const Index1,Standard_Integer const Index2,Standard_Integer &FirstModifiedPole,Standard_Integer &LastModifiedPole){
    (*self)->MovePoint(U,P,Index1,Index2,FirstModifiedPole,LastModifiedPole);
  }
EXPORT void _wrap_Geom_BSplineCurve_MovePoint (Handle_Geom_BSplineCurve *larg1, Standard_Real larg2, gp_Pnt *larg3, Standard_Integer larg4, Standard_Integer larg5, Standard_Integer *larg6, Standard_Integer *larg7) {
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt *arg3 = 0 ;
  Standard_Integer arg4 ;
  Standard_Integer arg5 ;
  Standard_Integer *arg6 = 0 ;
  Standard_Integer *arg7 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BSplineCurve_MovePoint(arg1,arg2,(gp_Pnt const &)*arg3,arg4,arg5,*arg6,*arg7);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_MovePoint\n  * wrapname: _wrap_Geom_BSplineCurve_MovePoint\n  * fulldecl: void Handle_Geom_BSplineCurve::MovePoint(Standard_Real const,gp_Pnt const &,Standard_Integer const,Standard_Integer const,Standard_Integer &,Standard_Integer &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN void Handle_Geom_BSplineCurve_MovePointAndTangent(Handle_Geom_BSplineCurve *self,Standard_Real const U,gp_Pnt const &P,gp_Vec const &Tangent,Standard_Real const Tolerance,Standard_Integer const StartingCondition,Standard_Integer const EndingCondition){
    Standard_Integer ErrorStatus =0;
	(*self)->MovePointAndTangent(U,P,Tangent,Tolerance,StartingCondition,EndingCondition,ErrorStatus);
  }
EXPORT void _wrap_Geom_BSplineCurve_MovePointAndTangent (Handle_Geom_BSplineCurve *larg1, Standard_Real larg2, gp_Pnt *larg3, gp_Vec *larg4, Standard_Real larg5, Standard_Integer larg6, Standard_Integer larg7) {
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt *arg3 = 0 ;
  gp_Vec *arg4 = 0 ;
  Standard_Real arg5 ;
  Standard_Integer arg6 ;
  Standard_Integer arg7 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BSplineCurve_MovePointAndTangent(arg1,arg2,(gp_Pnt const &)*arg3,(gp_Vec const &)*arg4,arg5,arg6,arg7);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_MovePointAndTangent\n  * wrapname: _wrap_Geom_BSplineCurve_MovePointAndTangent\n  * fulldecl: void Handle_Geom_BSplineCurve::MovePointAndTangent(Standard_Real const,gp_Pnt const &,gp_Vec const &,Standard_Real const,Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Boolean Handle_Geom_BSplineCurve_IsRational(Handle_Geom_BSplineCurve const *self){
    return (*self)->IsRational();
  }
EXPORT bool _wrap_Geom_BSplineCurve_IsRational (Handle_Geom_BSplineCurve *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom_BSplineCurve_IsRational((Handle_Geom_BSplineCurve const *)arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_IsRational\n  * wrapname: _wrap_Geom_BSplineCurve_IsRational\n  * fulldecl: Standard_Boolean Handle_Geom_BSplineCurve::IsRational() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN GeomAbs_Shape Handle_Geom_BSplineCurve_Continuity(Handle_Geom_BSplineCurve const *self){
    return (*self)->Continuity();
  }
EXPORT GeomAbs_Shape _wrap_Geom_BSplineCurve_Continuity (Handle_Geom_BSplineCurve *larg1) {
  GeomAbs_Shape lresult = (GeomAbs_Shape)0 ;
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  GeomAbs_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAbs_Shape)Handle_Geom_BSplineCurve_Continuity((Handle_Geom_BSplineCurve const *)arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_Continuity\n  * wrapname: _wrap_Geom_BSplineCurve_Continuity\n  * fulldecl: GeomAbs_Shape Handle_Geom_BSplineCurve::Continuity() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAbs_Shape)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineCurve_Degree(Handle_Geom_BSplineCurve const *self){
    return (*self)->Degree();
  }
EXPORT Standard_Integer _wrap_Geom_BSplineCurve_Degree (Handle_Geom_BSplineCurve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineCurve_Degree((Handle_Geom_BSplineCurve const *)arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_Degree\n  * wrapname: _wrap_Geom_BSplineCurve_Degree\n  * fulldecl: Standard_Integer Handle_Geom_BSplineCurve::Degree() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_BSplineCurve_LocalValue(Handle_Geom_BSplineCurve const *self,Standard_Real const U,Standard_Integer const FromK1,Standard_Integer const ToK2){
    return (*self)->LocalValue(U,FromK1,ToK2);
  }
EXPORT gp_Pnt *_wrap_Geom_BSplineCurve_LocalValue (Handle_Geom_BSplineCurve *larg1, Standard_Real larg2, Standard_Integer larg3, Standard_Integer larg4) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Real arg2 ;
  Standard_Integer arg3 ;
  Standard_Integer arg4 ;
  gp_Pnt result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_BSplineCurve_LocalValue((Handle_Geom_BSplineCurve const *)arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_LocalValue\n  * wrapname: _wrap_Geom_BSplineCurve_LocalValue\n  * fulldecl: gp_Pnt Handle_Geom_BSplineCurve::LocalValue(Standard_Real const,Standard_Integer const,Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_BSplineCurve_EndPoint(Handle_Geom_BSplineCurve const *self){
    return (*self)->EndPoint();
  }
EXPORT gp_Pnt *_wrap_Geom_BSplineCurve_EndPoint (Handle_Geom_BSplineCurve *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_BSplineCurve_EndPoint((Handle_Geom_BSplineCurve const *)arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_EndPoint\n  * wrapname: _wrap_Geom_BSplineCurve_EndPoint\n  * fulldecl: gp_Pnt Handle_Geom_BSplineCurve::EndPoint() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_BSplineCurve_StartPoint(Handle_Geom_BSplineCurve const *self){
    return (*self)->StartPoint();
  }
EXPORT gp_Pnt *_wrap_Geom_BSplineCurve_StartPoint (Handle_Geom_BSplineCurve *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_BSplineCurve_StartPoint((Handle_Geom_BSplineCurve const *)arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_StartPoint\n  * wrapname: _wrap_Geom_BSplineCurve_StartPoint\n  * fulldecl: gp_Pnt Handle_Geom_BSplineCurve::StartPoint() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineCurve_NbKnots(Handle_Geom_BSplineCurve const *self){
    return (*self)->NbKnots();
  }
EXPORT Standard_Integer _wrap_Geom_BSplineCurve_NbKnots (Handle_Geom_BSplineCurve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineCurve_NbKnots((Handle_Geom_BSplineCurve const *)arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_NbKnots\n  * wrapname: _wrap_Geom_BSplineCurve_NbKnots\n  * fulldecl: Standard_Integer Handle_Geom_BSplineCurve::NbKnots() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineCurve_NbPoles(Handle_Geom_BSplineCurve const *self){
    return (*self)->NbPoles();
  }
EXPORT Standard_Integer _wrap_Geom_BSplineCurve_NbPoles (Handle_Geom_BSplineCurve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineCurve_NbPoles((Handle_Geom_BSplineCurve const *)arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_NbPoles\n  * wrapname: _wrap_Geom_BSplineCurve_NbPoles\n  * fulldecl: Standard_Integer Handle_Geom_BSplineCurve::NbPoles() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_BSplineCurve_Pole(Handle_Geom_BSplineCurve const *self,Standard_Integer const Index){
    return (*self)->Pole(Index);
  }
EXPORT gp_Pnt *_wrap_Geom_BSplineCurve_Pole (Handle_Geom_BSplineCurve *larg1, Standard_Integer larg2) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_BSplineCurve_Pole((Handle_Geom_BSplineCurve const *)arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_Pole\n  * wrapname: _wrap_Geom_BSplineCurve_Pole\n  * fulldecl: gp_Pnt Handle_Geom_BSplineCurve::Pole(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN void Handle_Geom_BSplineCurve_Poles(Handle_Geom_BSplineCurve *self,TColgp_Array1OfPnt &P){
    (*self)->Poles(P);
  }
EXPORT void _wrap_Geom_BSplineCurve_Poles (Handle_Geom_BSplineCurve *larg1, TColgp_Array1OfPnt *larg2) {
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  TColgp_Array1OfPnt *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BSplineCurve_Poles(arg1,*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_Poles\n  * wrapname: _wrap_Geom_BSplineCurve_Poles\n  * fulldecl: void Handle_Geom_BSplineCurve::Poles(TColgp_Array1OfPnt &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Geom_BSplineCurve_Weight(Handle_Geom_BSplineCurve const *self,Standard_Integer const Index){
    return (*self)->Weight(Index);
  }
EXPORT Standard_Real _wrap_Geom_BSplineCurve_Weight (Handle_Geom_BSplineCurve *larg1, Standard_Integer larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_BSplineCurve_Weight((Handle_Geom_BSplineCurve const *)arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_Weight\n  * wrapname: _wrap_Geom_BSplineCurve_Weight\n  * fulldecl: Standard_Real Handle_Geom_BSplineCurve::Weight(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_BSplineCurve_Knot(Handle_Geom_BSplineCurve const *self,Standard_Integer const Index){
    return (*self)->Knot(Index);
  }
EXPORT Standard_Real _wrap_Geom_BSplineCurve_Knot (Handle_Geom_BSplineCurve *larg1, Standard_Integer larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_BSplineCurve_Knot((Handle_Geom_BSplineCurve const *)arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_Knot\n  * wrapname: _wrap_Geom_BSplineCurve_Knot\n  * fulldecl: Standard_Real Handle_Geom_BSplineCurve::Knot(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN void Handle_Geom_BSplineCurve_Knots(Handle_Geom_BSplineCurve *self,TColStd_Array1OfReal &K){
    (*self)->Knots(K);
  }
EXPORT void _wrap_Geom_BSplineCurve_Knots (Handle_Geom_BSplineCurve *larg1, TColStd_Array1OfReal *larg2) {
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BSplineCurve_Knots(arg1,*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_Knots\n  * wrapname: _wrap_Geom_BSplineCurve_Knots\n  * fulldecl: void Handle_Geom_BSplineCurve::Knots(TColStd_Array1OfReal &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineCurve_Multiplicity(Handle_Geom_BSplineCurve const *self,Standard_Integer const Index){
    return (*self)->Multiplicity(Index);
  }
EXPORT Standard_Integer _wrap_Geom_BSplineCurve_Multiplicity (Handle_Geom_BSplineCurve *larg1, Standard_Integer larg2) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineCurve_Multiplicity((Handle_Geom_BSplineCurve const *)arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineCurve_Multiplicity\n  * wrapname: _wrap_Geom_BSplineCurve_Multiplicity\n  * fulldecl: Standard_Integer Handle_Geom_BSplineCurve::Multiplicity(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT void _wrap_delete_Geom_BSplineCurve (Handle_Geom_BSplineCurve *larg1) {
  Handle_Geom_BSplineCurve *arg1 = (Handle_Geom_BSplineCurve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom_BSplineCurve\n  * wrapname: _wrap_delete_Geom_BSplineCurve\n  * fulldecl: Handle_Geom_BSplineCurve::~Handle_Geom_BSplineCurve()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom_Circle *new_Handle_Geom_Circle(gp_Ax2 const &A2,Standard_Real const R){
		return new Handle_Geom_Circle(new Geom_Circle(A2, R));
	}
EXPORT Handle_Geom_Circle *_wrap_new_Geom_Circle (gp_Ax2 *larg1, Standard_Real larg2) {
  Handle_Geom_Circle * lresult = (Handle_Geom_Circle *)0 ;
  gp_Ax2 *arg1 = 0 ;
  Standard_Real arg2 ;
  Handle_Geom_Circle *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_Circle *)new_Handle_Geom_Circle((gp_Ax2 const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_Circle\n  * wrapname: _wrap_new_Geom_Circle\n  * fulldecl: Handle_Geom_Circle::Handle_Geom_Circle(gp_Ax2 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_Circle *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Circle_Radius(Handle_Geom_Circle *self){
    return (*self)->Radius();
  }
EXPORT Standard_Real _wrap_Geom_Circle_Radius (Handle_Geom_Circle *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Circle *arg1 = (Handle_Geom_Circle *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Circle_Radius(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Circle_Radius\n  * wrapname: _wrap_Geom_Circle_Radius\n  * fulldecl: Standard_Real Handle_Geom_Circle::Radius()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_delete_Geom_Circle (Handle_Geom_Circle *larg1) {
  Handle_Geom_Circle *arg1 = (Handle_Geom_Circle *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom_Circle\n  * wrapname: _wrap_delete_Geom_Circle\n  * fulldecl: Handle_Geom_Circle::~Handle_Geom_Circle()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom_Ellipse *new_Handle_Geom_Ellipse(gp_Ax2 const &A2,Standard_Real const majorRadius,Standard_Real const minorRadius){
		return new Handle_Geom_Ellipse(new Geom_Ellipse(A2, majorRadius, minorRadius));
	}
EXPORT Handle_Geom_Ellipse *_wrap_new_Geom_Ellipse (gp_Ax2 *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom_Ellipse * lresult = (Handle_Geom_Ellipse *)0 ;
  gp_Ax2 *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Handle_Geom_Ellipse *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_Ellipse *)new_Handle_Geom_Ellipse((gp_Ax2 const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_Ellipse\n  * wrapname: _wrap_new_Geom_Ellipse\n  * fulldecl: Handle_Geom_Ellipse::Handle_Geom_Ellipse(gp_Ax2 const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_Ellipse *)0;
  }
}


SWIGINTERN gp_Ax1 Handle_Geom_Ellipse_Directrix1(Handle_Geom_Ellipse *self){
		return (*self)->Directrix1();
	}
EXPORT gp_Ax1 *_wrap_Geom_Ellipse_Directrix1 (Handle_Geom_Ellipse *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  Handle_Geom_Ellipse *arg1 = (Handle_Geom_Ellipse *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Ellipse_Directrix1(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Ellipse_Directrix1\n  * wrapname: _wrap_Geom_Ellipse_Directrix1\n  * fulldecl: gp_Ax1 Handle_Geom_Ellipse::Directrix1()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


SWIGINTERN gp_Ax1 Handle_Geom_Ellipse_Directrix2(Handle_Geom_Ellipse *self){
		return (*self)->Directrix2();
	}
EXPORT gp_Ax1 *_wrap_Geom_Ellipse_Directrix2 (Handle_Geom_Ellipse *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  Handle_Geom_Ellipse *arg1 = (Handle_Geom_Ellipse *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Ellipse_Directrix2(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Ellipse_Directrix2\n  * wrapname: _wrap_Geom_Ellipse_Directrix2\n  * fulldecl: gp_Ax1 Handle_Geom_Ellipse::Directrix2()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Ellipse_FocalDistance(Handle_Geom_Ellipse *self){
		return (*self)->Focal();
	}
EXPORT Standard_Real _wrap_Geom_Ellipse_FocalDistance (Handle_Geom_Ellipse *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Ellipse *arg1 = (Handle_Geom_Ellipse *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Ellipse_FocalDistance(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Ellipse_FocalDistance\n  * wrapname: _wrap_Geom_Ellipse_FocalDistance\n  * fulldecl: Standard_Real Handle_Geom_Ellipse::FocalDistance()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_Ellipse_Focus1(Handle_Geom_Ellipse *self){
		return (*self)->Focus1();
	}
EXPORT gp_Pnt *_wrap_Geom_Ellipse_Focus1 (Handle_Geom_Ellipse *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_Ellipse *arg1 = (Handle_Geom_Ellipse *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Ellipse_Focus1(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Ellipse_Focus1\n  * wrapname: _wrap_Geom_Ellipse_Focus1\n  * fulldecl: gp_Pnt Handle_Geom_Ellipse::Focus1()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_Ellipse_Focus2(Handle_Geom_Ellipse *self){
    	return (*self)->Focus2();
	}
EXPORT gp_Pnt *_wrap_Geom_Ellipse_Focus2 (Handle_Geom_Ellipse *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_Ellipse *arg1 = (Handle_Geom_Ellipse *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Ellipse_Focus2(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Ellipse_Focus2\n  * wrapname: _wrap_Geom_Ellipse_Focus2\n  * fulldecl: gp_Pnt Handle_Geom_Ellipse::Focus2()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Ellipse_MajorRadius(Handle_Geom_Ellipse *self){
		return (*self)->MajorRadius();
	}
EXPORT Standard_Real _wrap_Geom_Ellipse_MajorRadius (Handle_Geom_Ellipse *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Ellipse *arg1 = (Handle_Geom_Ellipse *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Ellipse_MajorRadius(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Ellipse_MajorRadius\n  * wrapname: _wrap_Geom_Ellipse_MajorRadius\n  * fulldecl: Standard_Real Handle_Geom_Ellipse::MajorRadius()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Ellipse_MinorRadius(Handle_Geom_Ellipse *self){
		return (*self)->MinorRadius();
	}
EXPORT Standard_Real _wrap_Geom_Ellipse_MinorRadius (Handle_Geom_Ellipse *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Ellipse *arg1 = (Handle_Geom_Ellipse *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Ellipse_MinorRadius(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Ellipse_MinorRadius\n  * wrapname: _wrap_Geom_Ellipse_MinorRadius\n  * fulldecl: Standard_Real Handle_Geom_Ellipse::MinorRadius()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Ellipse_Parameter(Handle_Geom_Ellipse *self){
		return (*self)->Parameter();
	}
EXPORT Standard_Real _wrap_Geom_Ellipse_Parameter (Handle_Geom_Ellipse *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Ellipse *arg1 = (Handle_Geom_Ellipse *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Ellipse_Parameter(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Ellipse_Parameter\n  * wrapname: _wrap_Geom_Ellipse_Parameter\n  * fulldecl: Standard_Real Handle_Geom_Ellipse::Parameter()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_delete_Geom_Ellipse (Handle_Geom_Ellipse *larg1) {
  Handle_Geom_Ellipse *arg1 = (Handle_Geom_Ellipse *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom_Ellipse\n  * wrapname: _wrap_delete_Geom_Ellipse\n  * fulldecl: Handle_Geom_Ellipse::~Handle_Geom_Ellipse()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom_TrimmedCurve *new_Handle_Geom_TrimmedCurve__SWIG_0(Handle_Geom_Curve const &C,Standard_Real const U1,Standard_Real const U2,Standard_Boolean const Sense=Standard_True){
          return new Handle_Geom_TrimmedCurve(new Geom_TrimmedCurve(C, U1, U2, Sense));
    }
EXPORT Handle_Geom_TrimmedCurve *_wrap_new_Geom_TrimmedCurve__SWIG_0 (Handle_Geom_Curve *larg1, Standard_Real larg2, Standard_Real larg3, bool larg4) {
  Handle_Geom_TrimmedCurve * lresult = (Handle_Geom_TrimmedCurve *)0 ;
  Handle_Geom_Curve *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Boolean arg4 ;
  Handle_Geom_TrimmedCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_TrimmedCurve *)new_Handle_Geom_TrimmedCurve__SWIG_0((Handle_Geom_Curve const &)*arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_TrimmedCurve\n  * wrapname: _wrap_new_Geom_TrimmedCurve__SWIG_0\n  * fulldecl: Handle_Geom_TrimmedCurve::Handle_Geom_TrimmedCurve(Handle_Geom_Curve const &,Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_TrimmedCurve *)0;
  }
}


EXPORT Handle_Geom_TrimmedCurve *_wrap_new_Geom_TrimmedCurve__SWIG_1 (Handle_Geom_Curve *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom_TrimmedCurve * lresult = (Handle_Geom_TrimmedCurve *)0 ;
  Handle_Geom_Curve *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Handle_Geom_TrimmedCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_TrimmedCurve *)new_Handle_Geom_TrimmedCurve__SWIG_0((Handle_Geom_Curve const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_TrimmedCurve\n  * wrapname: _wrap_new_Geom_TrimmedCurve__SWIG_1\n  * fulldecl: Handle_Geom_TrimmedCurve::Handle_Geom_TrimmedCurve(Handle_Geom_Curve const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_TrimmedCurve *)0;
  }
}


SWIGINTERN Handle_Geom_Curve Handle_Geom_TrimmedCurve_BasisCurve(Handle_Geom_TrimmedCurve *self){
		return (*self)->BasisCurve();
	}
EXPORT Handle_Geom_Curve *_wrap_Geom_TrimmedCurve_BasisCurve (Handle_Geom_TrimmedCurve *larg1) {
  Handle_Geom_Curve * lresult = (Handle_Geom_Curve *)0 ;
  Handle_Geom_TrimmedCurve *arg1 = (Handle_Geom_TrimmedCurve *) 0 ;
  SwigValueWrapper< Handle_Geom_Curve > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_TrimmedCurve_BasisCurve(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_TrimmedCurve_BasisCurve\n  * wrapname: _wrap_Geom_TrimmedCurve_BasisCurve\n  * fulldecl: Handle_Geom_Curve Handle_Geom_TrimmedCurve::BasisCurve()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Curve(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Curve *)0;
  }
}


EXPORT void _wrap_delete_Geom_TrimmedCurve (Handle_Geom_TrimmedCurve *larg1) {
  Handle_Geom_TrimmedCurve *arg1 = (Handle_Geom_TrimmedCurve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom_TrimmedCurve\n  * wrapname: _wrap_delete_Geom_TrimmedCurve\n  * fulldecl: Handle_Geom_TrimmedCurve::~Handle_Geom_TrimmedCurve()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom_OffsetCurve *new_Handle_Geom_OffsetCurve(Handle_Geom_Curve const &C,Standard_Real const Offset,gp_Dir const &V){
          return new Handle_Geom_OffsetCurve(new Geom_OffsetCurve(C, Offset, V));
    }
EXPORT Handle_Geom_OffsetCurve *_wrap_new_Geom_OffsetCurve (Handle_Geom_Curve *larg1, Standard_Real larg2, gp_Dir *larg3) {
  Handle_Geom_OffsetCurve * lresult = (Handle_Geom_OffsetCurve *)0 ;
  Handle_Geom_Curve *arg1 = 0 ;
  Standard_Real arg2 ;
  gp_Dir *arg3 = 0 ;
  Handle_Geom_OffsetCurve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_OffsetCurve *)new_Handle_Geom_OffsetCurve((Handle_Geom_Curve const &)*arg1,arg2,(gp_Dir const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_OffsetCurve\n  * wrapname: _wrap_new_Geom_OffsetCurve\n  * fulldecl: Handle_Geom_OffsetCurve::Handle_Geom_OffsetCurve(Handle_Geom_Curve const &,Standard_Real const,gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_OffsetCurve *)0;
  }
}


SWIGINTERN gp_Dir Handle_Geom_OffsetCurve_Direction(Handle_Geom_OffsetCurve *self){
    	return (*self)->Direction();
    }
EXPORT gp_Dir *_wrap_Geom_OffsetCurve_Direction (Handle_Geom_OffsetCurve *larg1) {
  gp_Dir * lresult = (gp_Dir *)0 ;
  Handle_Geom_OffsetCurve *arg1 = (Handle_Geom_OffsetCurve *) 0 ;
  gp_Dir result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_OffsetCurve_Direction(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_OffsetCurve_Direction\n  * wrapname: _wrap_Geom_OffsetCurve_Direction\n  * fulldecl: gp_Dir Handle_Geom_OffsetCurve::Direction()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Dir(result);
    return lresult;
  } catch (...) {
    return (gp_Dir *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_OffsetCurve_Offset(Handle_Geom_OffsetCurve *self){
    	return (*self)->Offset();
    }
EXPORT Standard_Real _wrap_Geom_OffsetCurve_Offset (Handle_Geom_OffsetCurve *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_OffsetCurve *arg1 = (Handle_Geom_OffsetCurve *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_OffsetCurve_Offset(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_OffsetCurve_Offset\n  * wrapname: _wrap_Geom_OffsetCurve_Offset\n  * fulldecl: Standard_Real Handle_Geom_OffsetCurve::Offset()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Handle_Geom_Curve Handle_Geom_OffsetCurve_BasisCurve(Handle_Geom_OffsetCurve *self){
    	return (*self)->BasisCurve();
    }
EXPORT Handle_Geom_Curve *_wrap_Geom_OffsetCurve_BasisCurve (Handle_Geom_OffsetCurve *larg1) {
  Handle_Geom_Curve * lresult = (Handle_Geom_Curve *)0 ;
  Handle_Geom_OffsetCurve *arg1 = (Handle_Geom_OffsetCurve *) 0 ;
  SwigValueWrapper< Handle_Geom_Curve > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_OffsetCurve_BasisCurve(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_OffsetCurve_BasisCurve\n  * wrapname: _wrap_Geom_OffsetCurve_BasisCurve\n  * fulldecl: Handle_Geom_Curve Handle_Geom_OffsetCurve::BasisCurve()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Curve(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Curve *)0;
  }
}


EXPORT void _wrap_delete_Geom_OffsetCurve (Handle_Geom_OffsetCurve *larg1) {
  Handle_Geom_OffsetCurve *arg1 = (Handle_Geom_OffsetCurve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom_OffsetCurve\n  * wrapname: _wrap_delete_Geom_OffsetCurve\n  * fulldecl: Handle_Geom_OffsetCurve::~Handle_Geom_OffsetCurve()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom_Hyperbola *new_Handle_Geom_Hyperbola(gp_Ax2 const &A2,Standard_Real const majorRadius,Standard_Real const minorRadius){
		return new Handle_Geom_Hyperbola(new Geom_Hyperbola(A2, majorRadius, minorRadius));
	}
EXPORT Handle_Geom_Hyperbola *_wrap_new_Geom_Hyperbola (gp_Ax2 *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom_Hyperbola * lresult = (Handle_Geom_Hyperbola *)0 ;
  gp_Ax2 *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Handle_Geom_Hyperbola *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_Hyperbola *)new_Handle_Geom_Hyperbola((gp_Ax2 const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_Hyperbola\n  * wrapname: _wrap_new_Geom_Hyperbola\n  * fulldecl: Handle_Geom_Hyperbola::Handle_Geom_Hyperbola(gp_Ax2 const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_Hyperbola *)0;
  }
}


SWIGINTERN gp_Ax1 Handle_Geom_Hyperbola_Asymptote1(Handle_Geom_Hyperbola *self){
		return (*self)->Asymptote1();
	}
EXPORT gp_Ax1 *_wrap_Geom_Hyperbola_Asymptote1 (Handle_Geom_Hyperbola *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  Handle_Geom_Hyperbola *arg1 = (Handle_Geom_Hyperbola *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Hyperbola_Asymptote1(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Hyperbola_Asymptote1\n  * wrapname: _wrap_Geom_Hyperbola_Asymptote1\n  * fulldecl: gp_Ax1 Handle_Geom_Hyperbola::Asymptote1()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


SWIGINTERN gp_Ax1 Handle_Geom_Hyperbola_Asymptote2(Handle_Geom_Hyperbola *self){
		return (*self)->Asymptote2();
	}
EXPORT gp_Ax1 *_wrap_Geom_Hyperbola_Asymptote2 (Handle_Geom_Hyperbola *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  Handle_Geom_Hyperbola *arg1 = (Handle_Geom_Hyperbola *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Hyperbola_Asymptote2(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Hyperbola_Asymptote2\n  * wrapname: _wrap_Geom_Hyperbola_Asymptote2\n  * fulldecl: gp_Ax1 Handle_Geom_Hyperbola::Asymptote2()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


SWIGINTERN gp_Hypr Handle_Geom_Hyperbola_ConjugateBranch1(Handle_Geom_Hyperbola *self){
		return (*self)->ConjugateBranch1();
	}
EXPORT gp_Hypr *_wrap_Geom_Hyperbola_ConjugateBranch1 (Handle_Geom_Hyperbola *larg1) {
  gp_Hypr * lresult = (gp_Hypr *)0 ;
  Handle_Geom_Hyperbola *arg1 = (Handle_Geom_Hyperbola *) 0 ;
  SwigValueWrapper< gp_Hypr > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Hyperbola_ConjugateBranch1(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Hyperbola_ConjugateBranch1\n  * wrapname: _wrap_Geom_Hyperbola_ConjugateBranch1\n  * fulldecl: gp_Hypr Handle_Geom_Hyperbola::ConjugateBranch1()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr *)0;
  }
}


SWIGINTERN gp_Hypr Handle_Geom_Hyperbola_ConjugateBranch2(Handle_Geom_Hyperbola *self){
		return (*self)->ConjugateBranch2();
	}
EXPORT gp_Hypr *_wrap_Geom_Hyperbola_ConjugateBranch2 (Handle_Geom_Hyperbola *larg1) {
  gp_Hypr * lresult = (gp_Hypr *)0 ;
  Handle_Geom_Hyperbola *arg1 = (Handle_Geom_Hyperbola *) 0 ;
  SwigValueWrapper< gp_Hypr > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Hyperbola_ConjugateBranch2(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Hyperbola_ConjugateBranch2\n  * wrapname: _wrap_Geom_Hyperbola_ConjugateBranch2\n  * fulldecl: gp_Hypr Handle_Geom_Hyperbola::ConjugateBranch2()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr *)0;
  }
}


SWIGINTERN gp_Hypr Handle_Geom_Hyperbola_OtherBranch(Handle_Geom_Hyperbola *self){
		return (*self)->OtherBranch();
	}
EXPORT gp_Hypr *_wrap_Geom_Hyperbola_OtherBranch (Handle_Geom_Hyperbola *larg1) {
  gp_Hypr * lresult = (gp_Hypr *)0 ;
  Handle_Geom_Hyperbola *arg1 = (Handle_Geom_Hyperbola *) 0 ;
  SwigValueWrapper< gp_Hypr > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Hyperbola_OtherBranch(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Hyperbola_OtherBranch\n  * wrapname: _wrap_Geom_Hyperbola_OtherBranch\n  * fulldecl: gp_Hypr Handle_Geom_Hyperbola::OtherBranch()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr *)0;
  }
}


SWIGINTERN gp_Ax1 Handle_Geom_Hyperbola_Directrix1(Handle_Geom_Hyperbola *self){
		return (*self)->Directrix1();
	}
EXPORT gp_Ax1 *_wrap_Geom_Hyperbola_Directrix1 (Handle_Geom_Hyperbola *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  Handle_Geom_Hyperbola *arg1 = (Handle_Geom_Hyperbola *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Hyperbola_Directrix1(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Hyperbola_Directrix1\n  * wrapname: _wrap_Geom_Hyperbola_Directrix1\n  * fulldecl: gp_Ax1 Handle_Geom_Hyperbola::Directrix1()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


SWIGINTERN gp_Ax1 Handle_Geom_Hyperbola_Directrix2(Handle_Geom_Hyperbola *self){
		return (*self)->Directrix2();
	}
EXPORT gp_Ax1 *_wrap_Geom_Hyperbola_Directrix2 (Handle_Geom_Hyperbola *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  Handle_Geom_Hyperbola *arg1 = (Handle_Geom_Hyperbola *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Hyperbola_Directrix2(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Hyperbola_Directrix2\n  * wrapname: _wrap_Geom_Hyperbola_Directrix2\n  * fulldecl: gp_Ax1 Handle_Geom_Hyperbola::Directrix2()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Hyperbola_FocalDistance(Handle_Geom_Hyperbola *self){
		return (*self)->Focal();
	}
EXPORT Standard_Real _wrap_Geom_Hyperbola_FocalDistance (Handle_Geom_Hyperbola *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Hyperbola *arg1 = (Handle_Geom_Hyperbola *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Hyperbola_FocalDistance(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Hyperbola_FocalDistance\n  * wrapname: _wrap_Geom_Hyperbola_FocalDistance\n  * fulldecl: Standard_Real Handle_Geom_Hyperbola::FocalDistance()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_Hyperbola_Focus1(Handle_Geom_Hyperbola *self){
		return (*self)->Focus1();
	}
EXPORT gp_Pnt *_wrap_Geom_Hyperbola_Focus1 (Handle_Geom_Hyperbola *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_Hyperbola *arg1 = (Handle_Geom_Hyperbola *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Hyperbola_Focus1(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Hyperbola_Focus1\n  * wrapname: _wrap_Geom_Hyperbola_Focus1\n  * fulldecl: gp_Pnt Handle_Geom_Hyperbola::Focus1()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_Hyperbola_Focus2(Handle_Geom_Hyperbola *self){
		return (*self)->Focus2();
	}
EXPORT gp_Pnt *_wrap_Geom_Hyperbola_Focus2 (Handle_Geom_Hyperbola *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_Hyperbola *arg1 = (Handle_Geom_Hyperbola *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Hyperbola_Focus2(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Hyperbola_Focus2\n  * wrapname: _wrap_Geom_Hyperbola_Focus2\n  * fulldecl: gp_Pnt Handle_Geom_Hyperbola::Focus2()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Hyperbola_MajorRadius(Handle_Geom_Hyperbola *self){
		return (*self)->MajorRadius();
	}
EXPORT Standard_Real _wrap_Geom_Hyperbola_MajorRadius (Handle_Geom_Hyperbola *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Hyperbola *arg1 = (Handle_Geom_Hyperbola *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Hyperbola_MajorRadius(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Hyperbola_MajorRadius\n  * wrapname: _wrap_Geom_Hyperbola_MajorRadius\n  * fulldecl: Standard_Real Handle_Geom_Hyperbola::MajorRadius()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Hyperbola_MinorRadius(Handle_Geom_Hyperbola *self){
		return (*self)->MinorRadius();
	}
EXPORT Standard_Real _wrap_Geom_Hyperbola_MinorRadius (Handle_Geom_Hyperbola *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Hyperbola *arg1 = (Handle_Geom_Hyperbola *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Hyperbola_MinorRadius(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Hyperbola_MinorRadius\n  * wrapname: _wrap_Geom_Hyperbola_MinorRadius\n  * fulldecl: Standard_Real Handle_Geom_Hyperbola::MinorRadius()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Hyperbola_Parameter(Handle_Geom_Hyperbola *self){
		return (*self)->Parameter();
	}
EXPORT Standard_Real _wrap_Geom_Hyperbola_Parameter (Handle_Geom_Hyperbola *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Hyperbola *arg1 = (Handle_Geom_Hyperbola *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Hyperbola_Parameter(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Hyperbola_Parameter\n  * wrapname: _wrap_Geom_Hyperbola_Parameter\n  * fulldecl: Standard_Real Handle_Geom_Hyperbola::Parameter()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_delete_Geom_Hyperbola (Handle_Geom_Hyperbola *larg1) {
  Handle_Geom_Hyperbola *arg1 = (Handle_Geom_Hyperbola *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom_Hyperbola\n  * wrapname: _wrap_delete_Geom_Hyperbola\n  * fulldecl: Handle_Geom_Hyperbola::~Handle_Geom_Hyperbola()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom_Line *new_Handle_Geom_Line__SWIG_0(gp_Ax1 const &A1){
		return new Handle_Geom_Line(new Geom_Line(A1));
	}
EXPORT Handle_Geom_Line *_wrap_new_Geom_Line__SWIG_0 (gp_Ax1 *larg1) {
  Handle_Geom_Line * lresult = (Handle_Geom_Line *)0 ;
  gp_Ax1 *arg1 = 0 ;
  Handle_Geom_Line *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_Line *)new_Handle_Geom_Line__SWIG_0((gp_Ax1 const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_Line\n  * wrapname: _wrap_new_Geom_Line__SWIG_0\n  * fulldecl: Handle_Geom_Line::Handle_Geom_Line(gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_Line *)0;
  }
}


SWIGINTERN Handle_Geom_Line *new_Handle_Geom_Line__SWIG_1(gp_Pnt const &P,gp_Dir const &V){
		return new Handle_Geom_Line(new Geom_Line(P, V));
	}
EXPORT Handle_Geom_Line *_wrap_new_Geom_Line__SWIG_1 (gp_Pnt *larg1, gp_Dir *larg2) {
  Handle_Geom_Line * lresult = (Handle_Geom_Line *)0 ;
  gp_Pnt *arg1 = 0 ;
  gp_Dir *arg2 = 0 ;
  Handle_Geom_Line *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_Line *)new_Handle_Geom_Line__SWIG_1((gp_Pnt const &)*arg1,(gp_Dir const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_Line\n  * wrapname: _wrap_new_Geom_Line__SWIG_1\n  * fulldecl: Handle_Geom_Line::Handle_Geom_Line(gp_Pnt const &,gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_Line *)0;
  }
}


SWIGINTERN gp_Ax1 Handle_Geom_Line_Position(Handle_Geom_Line *self){
		return (*self)->Position();
	}
EXPORT gp_Ax1 *_wrap_Geom_Line_Position (Handle_Geom_Line *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  Handle_Geom_Line *arg1 = (Handle_Geom_Line *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Line_Position(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Line_Position\n  * wrapname: _wrap_Geom_Line_Position\n  * fulldecl: gp_Ax1 Handle_Geom_Line::Position()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


SWIGINTERN gp_Lin Handle_Geom_Line_Lin(Handle_Geom_Line *self){
		return (*self)->Lin();
	}
EXPORT gp_Lin *_wrap_Geom_Line_Lin (Handle_Geom_Line *larg1) {
  gp_Lin * lresult = (gp_Lin *)0 ;
  Handle_Geom_Line *arg1 = (Handle_Geom_Line *) 0 ;
  gp_Lin result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Line_Lin(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Line_Lin\n  * wrapname: _wrap_Geom_Line_Lin\n  * fulldecl: gp_Lin Handle_Geom_Line::Lin()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Lin(result);
    return lresult;
  } catch (...) {
    return (gp_Lin *)0;
  }
}


EXPORT void _wrap_delete_Geom_Line (Handle_Geom_Line *larg1) {
  Handle_Geom_Line *arg1 = (Handle_Geom_Line *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom_Line\n  * wrapname: _wrap_delete_Geom_Line\n  * fulldecl: Handle_Geom_Line::~Handle_Geom_Line()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom_Parabola *new_Handle_Geom_Parabola(gp_Ax2 const &A2,Standard_Real const Focal){
		return new Handle_Geom_Parabola(new Geom_Parabola(A2, Focal));
	}
EXPORT Handle_Geom_Parabola *_wrap_new_Geom_Parabola (gp_Ax2 *larg1, Standard_Real larg2) {
  Handle_Geom_Parabola * lresult = (Handle_Geom_Parabola *)0 ;
  gp_Ax2 *arg1 = 0 ;
  Standard_Real arg2 ;
  Handle_Geom_Parabola *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_Parabola *)new_Handle_Geom_Parabola((gp_Ax2 const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_Parabola\n  * wrapname: _wrap_new_Geom_Parabola\n  * fulldecl: Handle_Geom_Parabola::Handle_Geom_Parabola(gp_Ax2 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_Parabola *)0;
  }
}


SWIGINTERN gp_Ax1 Handle_Geom_Parabola_Directrix(Handle_Geom_Parabola *self){
		return (*self)->Directrix();
	}
EXPORT gp_Ax1 *_wrap_Geom_Parabola_Directrix (Handle_Geom_Parabola *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  Handle_Geom_Parabola *arg1 = (Handle_Geom_Parabola *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Parabola_Directrix(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Parabola_Directrix\n  * wrapname: _wrap_Geom_Parabola_Directrix\n  * fulldecl: gp_Ax1 Handle_Geom_Parabola::Directrix()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Parabola_FocalDistance(Handle_Geom_Parabola *self){
		return (*self)->Focal();
	}
EXPORT Standard_Real _wrap_Geom_Parabola_FocalDistance (Handle_Geom_Parabola *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Parabola *arg1 = (Handle_Geom_Parabola *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Parabola_FocalDistance(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Parabola_FocalDistance\n  * wrapname: _wrap_Geom_Parabola_FocalDistance\n  * fulldecl: Standard_Real Handle_Geom_Parabola::FocalDistance()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_Parabola_Focus(Handle_Geom_Parabola *self){
		return (*self)->Focus();
	}
EXPORT gp_Pnt *_wrap_Geom_Parabola_Focus (Handle_Geom_Parabola *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_Parabola *arg1 = (Handle_Geom_Parabola *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Parabola_Focus(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Parabola_Focus\n  * wrapname: _wrap_Geom_Parabola_Focus\n  * fulldecl: gp_Pnt Handle_Geom_Parabola::Focus()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_Parabola_Parameter(Handle_Geom_Parabola *self){
		return (*self)->Parameter();
	}
EXPORT Standard_Real _wrap_Geom_Parabola_Parameter (Handle_Geom_Parabola *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_Parabola *arg1 = (Handle_Geom_Parabola *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_Parabola_Parameter(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Parabola_Parameter\n  * wrapname: _wrap_Geom_Parabola_Parameter\n  * fulldecl: Standard_Real Handle_Geom_Parabola::Parameter()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_delete_Geom_Parabola (Handle_Geom_Parabola *larg1) {
  Handle_Geom_Parabola *arg1 = (Handle_Geom_Parabola *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom_Parabola\n  * wrapname: _wrap_delete_Geom_Parabola\n  * fulldecl: Handle_Geom_Parabola::~Handle_Geom_Parabola()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom_BezierSurface *new_Handle_Geom_BezierSurface(TColgp_Array2OfPnt const &SurfacePoles,TColStd_Array2OfReal const &PoleWeights){
		return new Handle_Geom_BezierSurface(new Geom_BezierSurface(SurfacePoles, PoleWeights));
	}
EXPORT Handle_Geom_BezierSurface *_wrap_new_Geom_BezierSurface (TColgp_Array2OfPnt *larg1, TColStd_Array2OfReal *larg2) {
  Handle_Geom_BezierSurface * lresult = (Handle_Geom_BezierSurface *)0 ;
  TColgp_Array2OfPnt *arg1 = 0 ;
  TColStd_Array2OfReal *arg2 = 0 ;
  Handle_Geom_BezierSurface *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_BezierSurface *)new_Handle_Geom_BezierSurface((TColgp_Array2OfPnt const &)*arg1,(TColStd_Array2OfReal const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_BezierSurface\n  * wrapname: _wrap_new_Geom_BezierSurface\n  * fulldecl: Handle_Geom_BezierSurface::Handle_Geom_BezierSurface(TColgp_Array2OfPnt const &,TColStd_Array2OfReal const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_BezierSurface *)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BezierSurface_NbUPoles(Handle_Geom_BezierSurface *self){
        return (*self)->NbUPoles();
    }
EXPORT Standard_Integer _wrap_Geom_BezierSurface_NbUPoles (Handle_Geom_BezierSurface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BezierSurface *arg1 = (Handle_Geom_BezierSurface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BezierSurface_NbUPoles(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierSurface_NbUPoles\n  * wrapname: _wrap_Geom_BezierSurface_NbUPoles\n  * fulldecl: Standard_Integer Handle_Geom_BezierSurface::NbUPoles()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BezierSurface_NbVPoles(Handle_Geom_BezierSurface *self){
        return (*self)->NbVPoles();
    }
EXPORT Standard_Integer _wrap_Geom_BezierSurface_NbVPoles (Handle_Geom_BezierSurface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BezierSurface *arg1 = (Handle_Geom_BezierSurface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BezierSurface_NbVPoles(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierSurface_NbVPoles\n  * wrapname: _wrap_Geom_BezierSurface_NbVPoles\n  * fulldecl: Standard_Integer Handle_Geom_BezierSurface::NbVPoles()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BezierSurface_UDegree(Handle_Geom_BezierSurface *self){
        return (*self)->UDegree();
    }
EXPORT Standard_Integer _wrap_Geom_BezierSurface_UDegree (Handle_Geom_BezierSurface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BezierSurface *arg1 = (Handle_Geom_BezierSurface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BezierSurface_UDegree(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierSurface_UDegree\n  * wrapname: _wrap_Geom_BezierSurface_UDegree\n  * fulldecl: Standard_Integer Handle_Geom_BezierSurface::UDegree()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BezierSurface_VDegree(Handle_Geom_BezierSurface *self){
        return (*self)->VDegree();
    }
EXPORT Standard_Integer _wrap_Geom_BezierSurface_VDegree (Handle_Geom_BezierSurface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BezierSurface *arg1 = (Handle_Geom_BezierSurface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BezierSurface_VDegree(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierSurface_VDegree\n  * wrapname: _wrap_Geom_BezierSurface_VDegree\n  * fulldecl: Standard_Integer Handle_Geom_BezierSurface::VDegree()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_BezierSurface_Pole(Handle_Geom_BezierSurface *self,Standard_Integer const indexU,Standard_Integer const indexV){
        return (*self)->Pole(indexU, indexV);
    }
EXPORT gp_Pnt *_wrap_Geom_BezierSurface_Pole (Handle_Geom_BezierSurface *larg1, Standard_Integer larg2, Standard_Integer larg3) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_BezierSurface *arg1 = (Handle_Geom_BezierSurface *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  gp_Pnt result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_BezierSurface_Pole(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierSurface_Pole\n  * wrapname: _wrap_Geom_BezierSurface_Pole\n  * fulldecl: gp_Pnt Handle_Geom_BezierSurface::Pole(Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_BezierSurface_Weight(Handle_Geom_BezierSurface *self,Standard_Integer const indexU,Standard_Integer const indexV){
        return (*self)->Weight(indexU, indexV);
    }
EXPORT Standard_Real _wrap_Geom_BezierSurface_Weight (Handle_Geom_BezierSurface *larg1, Standard_Integer larg2, Standard_Integer larg3) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_BezierSurface *arg1 = (Handle_Geom_BezierSurface *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_BezierSurface_Weight(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierSurface_Weight\n  * wrapname: _wrap_Geom_BezierSurface_Weight\n  * fulldecl: Standard_Real Handle_Geom_BezierSurface::Weight(Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom_BezierSurface_IsURational(Handle_Geom_BezierSurface *self){
        return (*self)->IsURational();
    }
EXPORT bool _wrap_Geom_BezierSurface_IsURational (Handle_Geom_BezierSurface *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom_BezierSurface *arg1 = (Handle_Geom_BezierSurface *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom_BezierSurface_IsURational(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierSurface_IsURational\n  * wrapname: _wrap_Geom_BezierSurface_IsURational\n  * fulldecl: Standard_Boolean Handle_Geom_BezierSurface::IsURational()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom_BezierSurface_IsVRational(Handle_Geom_BezierSurface *self){
        return (*self)->IsVRational();
    }
EXPORT bool _wrap_Geom_BezierSurface_IsVRational (Handle_Geom_BezierSurface *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom_BezierSurface *arg1 = (Handle_Geom_BezierSurface *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom_BezierSurface_IsVRational(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierSurface_IsVRational\n  * wrapname: _wrap_Geom_BezierSurface_IsVRational\n  * fulldecl: Standard_Boolean Handle_Geom_BezierSurface::IsVRational()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BezierSurface_MaxDegree(Handle_Geom_BezierSurface *self){
        return (*self)->MaxDegree();
    }
EXPORT Standard_Integer _wrap_Geom_BezierSurface_MaxDegree (Handle_Geom_BezierSurface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BezierSurface *arg1 = (Handle_Geom_BezierSurface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BezierSurface_MaxDegree(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierSurface_MaxDegree\n  * wrapname: _wrap_Geom_BezierSurface_MaxDegree\n  * fulldecl: Standard_Integer Handle_Geom_BezierSurface::MaxDegree()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN void Handle_Geom_BezierSurface_Resolution(Handle_Geom_BezierSurface *self,Standard_Real tolerance3d,Standard_Real &toleranceU,Standard_Real &toleranceV){
        return (*self)->Resolution(tolerance3d, toleranceU, toleranceV);
    }
EXPORT void _wrap_Geom_BezierSurface_Resolution (Handle_Geom_BezierSurface *larg1, Standard_Real larg2, Standard_Real *larg3, Standard_Real *larg4) {
  Handle_Geom_BezierSurface *arg1 = (Handle_Geom_BezierSurface *) 0 ;
  Standard_Real arg2 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BezierSurface_Resolution(arg1,arg2,*arg3,*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BezierSurface_Resolution\n  * wrapname: _wrap_Geom_BezierSurface_Resolution\n  * fulldecl: void Handle_Geom_BezierSurface::Resolution(Standard_Real,Standard_Real &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_Geom_BezierSurface (Handle_Geom_BezierSurface *larg1) {
  Handle_Geom_BezierSurface *arg1 = (Handle_Geom_BezierSurface *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom_BezierSurface\n  * wrapname: _wrap_delete_Geom_BezierSurface\n  * fulldecl: Handle_Geom_BezierSurface::~Handle_Geom_BezierSurface()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom_BSplineSurface *new_Handle_Geom_BSplineSurface__SWIG_0(TColgp_Array2OfPnt const &Poles,TColStd_Array2OfReal const &Weights,TColStd_Array1OfReal const &UKnots,TColStd_Array1OfReal const &VKnots,TColStd_Array1OfInteger const &UMults,TColStd_Array1OfInteger const &VMults,Standard_Integer const UDegree,Standard_Integer const VDegree,Standard_Boolean const UPeriodic=Standard_False,Standard_Boolean const VPeriodic=Standard_False){
        return new Handle_Geom_BSplineSurface(new Geom_BSplineSurface(Poles, Weights, UKnots, VKnots, UMults, VMults,
            UDegree, VDegree, UPeriodic, VPeriodic));
    }
EXPORT Handle_Geom_BSplineSurface *_wrap_new_Geom_BSplineSurface__SWIG_0 (TColgp_Array2OfPnt *larg1, TColStd_Array2OfReal *larg2, TColStd_Array1OfReal *larg3, TColStd_Array1OfReal *larg4, TColStd_Array1OfInteger *larg5, TColStd_Array1OfInteger *larg6, Standard_Integer larg7, Standard_Integer larg8, bool larg9, bool larg10) {
  Handle_Geom_BSplineSurface * lresult = (Handle_Geom_BSplineSurface *)0 ;
  TColgp_Array2OfPnt *arg1 = 0 ;
  TColStd_Array2OfReal *arg2 = 0 ;
  TColStd_Array1OfReal *arg3 = 0 ;
  TColStd_Array1OfReal *arg4 = 0 ;
  TColStd_Array1OfInteger *arg5 = 0 ;
  TColStd_Array1OfInteger *arg6 = 0 ;
  Standard_Integer arg7 ;
  Standard_Integer arg8 ;
  Standard_Boolean arg9 ;
  Standard_Boolean arg10 ;
  Handle_Geom_BSplineSurface *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = (bool)larg9;
  arg10 = (bool)larg10;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_BSplineSurface *)new_Handle_Geom_BSplineSurface__SWIG_0((TColgp_Array2OfPnt const &)*arg1,(TColStd_Array2OfReal const &)*arg2,(TColStd_Array1OfReal const &)*arg3,(TColStd_Array1OfReal const &)*arg4,(TColStd_Array1OfInteger const &)*arg5,(TColStd_Array1OfInteger const &)*arg6,arg7,arg8,arg9,arg10);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_BSplineSurface\n  * wrapname: _wrap_new_Geom_BSplineSurface__SWIG_0\n  * fulldecl: Handle_Geom_BSplineSurface::Handle_Geom_BSplineSurface(TColgp_Array2OfPnt const &,TColStd_Array2OfReal const &,TColStd_Array1OfReal const &,TColStd_Array1OfReal const &,TColStd_Array1OfInteger const &,TColStd_Array1OfInteger const &,Standard_Integer const,Standard_Integer const,Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_BSplineSurface *)0;
  }
}


EXPORT Handle_Geom_BSplineSurface *_wrap_new_Geom_BSplineSurface__SWIG_1 (TColgp_Array2OfPnt *larg1, TColStd_Array2OfReal *larg2, TColStd_Array1OfReal *larg3, TColStd_Array1OfReal *larg4, TColStd_Array1OfInteger *larg5, TColStd_Array1OfInteger *larg6, Standard_Integer larg7, Standard_Integer larg8, bool larg9) {
  Handle_Geom_BSplineSurface * lresult = (Handle_Geom_BSplineSurface *)0 ;
  TColgp_Array2OfPnt *arg1 = 0 ;
  TColStd_Array2OfReal *arg2 = 0 ;
  TColStd_Array1OfReal *arg3 = 0 ;
  TColStd_Array1OfReal *arg4 = 0 ;
  TColStd_Array1OfInteger *arg5 = 0 ;
  TColStd_Array1OfInteger *arg6 = 0 ;
  Standard_Integer arg7 ;
  Standard_Integer arg8 ;
  Standard_Boolean arg9 ;
  Handle_Geom_BSplineSurface *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = (bool)larg9;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_BSplineSurface *)new_Handle_Geom_BSplineSurface__SWIG_0((TColgp_Array2OfPnt const &)*arg1,(TColStd_Array2OfReal const &)*arg2,(TColStd_Array1OfReal const &)*arg3,(TColStd_Array1OfReal const &)*arg4,(TColStd_Array1OfInteger const &)*arg5,(TColStd_Array1OfInteger const &)*arg6,arg7,arg8,arg9);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_BSplineSurface\n  * wrapname: _wrap_new_Geom_BSplineSurface__SWIG_1\n  * fulldecl: Handle_Geom_BSplineSurface::Handle_Geom_BSplineSurface(TColgp_Array2OfPnt const &,TColStd_Array2OfReal const &,TColStd_Array1OfReal const &,TColStd_Array1OfReal const &,TColStd_Array1OfInteger const &,TColStd_Array1OfInteger const &,Standard_Integer const,Standard_Integer const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_BSplineSurface *)0;
  }
}


EXPORT Handle_Geom_BSplineSurface *_wrap_new_Geom_BSplineSurface__SWIG_2 (TColgp_Array2OfPnt *larg1, TColStd_Array2OfReal *larg2, TColStd_Array1OfReal *larg3, TColStd_Array1OfReal *larg4, TColStd_Array1OfInteger *larg5, TColStd_Array1OfInteger *larg6, Standard_Integer larg7, Standard_Integer larg8) {
  Handle_Geom_BSplineSurface * lresult = (Handle_Geom_BSplineSurface *)0 ;
  TColgp_Array2OfPnt *arg1 = 0 ;
  TColStd_Array2OfReal *arg2 = 0 ;
  TColStd_Array1OfReal *arg3 = 0 ;
  TColStd_Array1OfReal *arg4 = 0 ;
  TColStd_Array1OfInteger *arg5 = 0 ;
  TColStd_Array1OfInteger *arg6 = 0 ;
  Standard_Integer arg7 ;
  Standard_Integer arg8 ;
  Handle_Geom_BSplineSurface *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_BSplineSurface *)new_Handle_Geom_BSplineSurface__SWIG_0((TColgp_Array2OfPnt const &)*arg1,(TColStd_Array2OfReal const &)*arg2,(TColStd_Array1OfReal const &)*arg3,(TColStd_Array1OfReal const &)*arg4,(TColStd_Array1OfInteger const &)*arg5,(TColStd_Array1OfInteger const &)*arg6,arg7,arg8);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_BSplineSurface\n  * wrapname: _wrap_new_Geom_BSplineSurface__SWIG_2\n  * fulldecl: Handle_Geom_BSplineSurface::Handle_Geom_BSplineSurface(TColgp_Array2OfPnt const &,TColStd_Array2OfReal const &,TColStd_Array1OfReal const &,TColStd_Array1OfReal const &,TColStd_Array1OfInteger const &,TColStd_Array1OfInteger const &,Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_BSplineSurface *)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom_BSplineSurface_IsURational(Handle_Geom_BSplineSurface *self){
        return (*self)->IsURational();
    }
EXPORT bool _wrap_Geom_BSplineSurface_IsURational (Handle_Geom_BSplineSurface *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom_BSplineSurface_IsURational(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_IsURational\n  * wrapname: _wrap_Geom_BSplineSurface_IsURational\n  * fulldecl: Standard_Boolean Handle_Geom_BSplineSurface::IsURational()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Boolean Handle_Geom_BSplineSurface_IsVRational(Handle_Geom_BSplineSurface *self){
        return (*self)->IsVRational();
    }
EXPORT bool _wrap_Geom_BSplineSurface_IsVRational (Handle_Geom_BSplineSurface *larg1) {
  bool lresult = (bool)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)Handle_Geom_BSplineSurface_IsVRational(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_IsVRational\n  * wrapname: _wrap_Geom_BSplineSurface_IsVRational\n  * fulldecl: Standard_Boolean Handle_Geom_BSplineSurface::IsVRational()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineSurface_FirstUKnotIndex(Handle_Geom_BSplineSurface *self){
        return (*self)->FirstUKnotIndex();
    }
EXPORT Standard_Integer _wrap_Geom_BSplineSurface_FirstUKnotIndex (Handle_Geom_BSplineSurface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineSurface_FirstUKnotIndex(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_FirstUKnotIndex\n  * wrapname: _wrap_Geom_BSplineSurface_FirstUKnotIndex\n  * fulldecl: Standard_Integer Handle_Geom_BSplineSurface::FirstUKnotIndex()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineSurface_FirstVKnotIndex(Handle_Geom_BSplineSurface *self){
        return (*self)->FirstVKnotIndex();
    }
EXPORT Standard_Integer _wrap_Geom_BSplineSurface_FirstVKnotIndex (Handle_Geom_BSplineSurface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineSurface_FirstVKnotIndex(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_FirstVKnotIndex\n  * wrapname: _wrap_Geom_BSplineSurface_FirstVKnotIndex\n  * fulldecl: Standard_Integer Handle_Geom_BSplineSurface::FirstVKnotIndex()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineSurface_LastUKnotIndex(Handle_Geom_BSplineSurface *self){
        return (*self)->LastUKnotIndex();
    }
EXPORT Standard_Integer _wrap_Geom_BSplineSurface_LastUKnotIndex (Handle_Geom_BSplineSurface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineSurface_LastUKnotIndex(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_LastUKnotIndex\n  * wrapname: _wrap_Geom_BSplineSurface_LastUKnotIndex\n  * fulldecl: Standard_Integer Handle_Geom_BSplineSurface::LastUKnotIndex()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineSurface_LastVKnotIndex(Handle_Geom_BSplineSurface *self){
        return (*self)->LastVKnotIndex();
    }
EXPORT Standard_Integer _wrap_Geom_BSplineSurface_LastVKnotIndex (Handle_Geom_BSplineSurface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineSurface_LastVKnotIndex(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_LastVKnotIndex\n  * wrapname: _wrap_Geom_BSplineSurface_LastVKnotIndex\n  * fulldecl: Standard_Integer Handle_Geom_BSplineSurface::LastVKnotIndex()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineSurface_NbUPoles(Handle_Geom_BSplineSurface *self){
        return (*self)->NbUPoles();
    }
EXPORT Standard_Integer _wrap_Geom_BSplineSurface_NbUPoles (Handle_Geom_BSplineSurface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineSurface_NbUPoles(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_NbUPoles\n  * wrapname: _wrap_Geom_BSplineSurface_NbUPoles\n  * fulldecl: Standard_Integer Handle_Geom_BSplineSurface::NbUPoles()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineSurface_NbVPoles(Handle_Geom_BSplineSurface *self){
        return (*self)->NbVPoles();
    }
EXPORT Standard_Integer _wrap_Geom_BSplineSurface_NbVPoles (Handle_Geom_BSplineSurface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineSurface_NbVPoles(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_NbVPoles\n  * wrapname: _wrap_Geom_BSplineSurface_NbVPoles\n  * fulldecl: Standard_Integer Handle_Geom_BSplineSurface::NbVPoles()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineSurface_NbUKnots(Handle_Geom_BSplineSurface *self){
        return (*self)->NbUKnots();
    }
EXPORT Standard_Integer _wrap_Geom_BSplineSurface_NbUKnots (Handle_Geom_BSplineSurface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineSurface_NbUKnots(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_NbUKnots\n  * wrapname: _wrap_Geom_BSplineSurface_NbUKnots\n  * fulldecl: Standard_Integer Handle_Geom_BSplineSurface::NbUKnots()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineSurface_NbVKnots(Handle_Geom_BSplineSurface *self){
        return (*self)->NbVKnots();
    }
EXPORT Standard_Integer _wrap_Geom_BSplineSurface_NbVKnots (Handle_Geom_BSplineSurface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineSurface_NbVKnots(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_NbVKnots\n  * wrapname: _wrap_Geom_BSplineSurface_NbVKnots\n  * fulldecl: Standard_Integer Handle_Geom_BSplineSurface::NbVKnots()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_BSplineSurface_Pole(Handle_Geom_BSplineSurface *self,Standard_Integer const indexU,Standard_Integer const indexV){
        return (*self)->Pole(indexU, indexV);
    }
EXPORT gp_Pnt *_wrap_Geom_BSplineSurface_Pole (Handle_Geom_BSplineSurface *larg1, Standard_Integer larg2, Standard_Integer larg3) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  gp_Pnt result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_BSplineSurface_Pole(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_Pole\n  * wrapname: _wrap_Geom_BSplineSurface_Pole\n  * fulldecl: gp_Pnt Handle_Geom_BSplineSurface::Pole(Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineSurface_UDegree(Handle_Geom_BSplineSurface *self){
        return (*self)->UDegree();
    }
EXPORT Standard_Integer _wrap_Geom_BSplineSurface_UDegree (Handle_Geom_BSplineSurface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineSurface_UDegree(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_UDegree\n  * wrapname: _wrap_Geom_BSplineSurface_UDegree\n  * fulldecl: Standard_Integer Handle_Geom_BSplineSurface::UDegree()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineSurface_VDegree(Handle_Geom_BSplineSurface *self){
        return (*self)->VDegree();
    }
EXPORT Standard_Integer _wrap_Geom_BSplineSurface_VDegree (Handle_Geom_BSplineSurface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineSurface_VDegree(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_VDegree\n  * wrapname: _wrap_Geom_BSplineSurface_VDegree\n  * fulldecl: Standard_Integer Handle_Geom_BSplineSurface::VDegree()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_BSplineSurface_UKnot(Handle_Geom_BSplineSurface *self,Standard_Integer const indexUKnot){
        return (*self)->UKnot(indexUKnot);
    }
EXPORT Standard_Real _wrap_Geom_BSplineSurface_UKnot (Handle_Geom_BSplineSurface *larg1, Standard_Integer larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_BSplineSurface_UKnot(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_UKnot\n  * wrapname: _wrap_Geom_BSplineSurface_UKnot\n  * fulldecl: Standard_Real Handle_Geom_BSplineSurface::UKnot(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_BSplineSurface_VKnot(Handle_Geom_BSplineSurface *self,Standard_Integer const indexVKnot){
        return (*self)->VKnot(indexVKnot);
    }
EXPORT Standard_Real _wrap_Geom_BSplineSurface_VKnot (Handle_Geom_BSplineSurface *larg1, Standard_Integer larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_BSplineSurface_VKnot(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_VKnot\n  * wrapname: _wrap_Geom_BSplineSurface_VKnot\n  * fulldecl: Standard_Real Handle_Geom_BSplineSurface::VKnot(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineSurface_UMultiplicity(Handle_Geom_BSplineSurface *self,Standard_Integer const indexUKnot){
		return (*self)->UMultiplicity(indexUKnot);
    }
EXPORT Standard_Integer _wrap_Geom_BSplineSurface_UMultiplicity (Handle_Geom_BSplineSurface *larg1, Standard_Integer larg2) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineSurface_UMultiplicity(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_UMultiplicity\n  * wrapname: _wrap_Geom_BSplineSurface_UMultiplicity\n  * fulldecl: Standard_Integer Handle_Geom_BSplineSurface::UMultiplicity(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineSurface_VMultiplicity(Handle_Geom_BSplineSurface *self,Standard_Integer const indexVKnot){
		return (*self)->VMultiplicity(indexVKnot);
    }
EXPORT Standard_Integer _wrap_Geom_BSplineSurface_VMultiplicity (Handle_Geom_BSplineSurface *larg1, Standard_Integer larg2) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineSurface_VMultiplicity(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_VMultiplicity\n  * wrapname: _wrap_Geom_BSplineSurface_VMultiplicity\n  * fulldecl: Standard_Integer Handle_Geom_BSplineSurface::VMultiplicity(Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_BSplineSurface_Weight(Handle_Geom_BSplineSurface *self,Standard_Integer const indexU,Standard_Integer const indexV){
        return (*self)->Weight(indexU, indexV);
    }
EXPORT Standard_Real _wrap_Geom_BSplineSurface_Weight (Handle_Geom_BSplineSurface *larg1, Standard_Integer larg2, Standard_Integer larg3) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_BSplineSurface_Weight(arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_Weight\n  * wrapname: _wrap_Geom_BSplineSurface_Weight\n  * fulldecl: Standard_Real Handle_Geom_BSplineSurface::Weight(Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Integer Handle_Geom_BSplineSurface_getMaxDegree(Handle_Geom_BSplineSurface *self){
        return (*self)->MaxDegree();
    }
EXPORT Standard_Integer _wrap_Geom_BSplineSurface_getMaxDegree (Handle_Geom_BSplineSurface *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)Handle_Geom_BSplineSurface_getMaxDegree(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_getMaxDegree\n  * wrapname: _wrap_Geom_BSplineSurface_getMaxDegree\n  * fulldecl: Standard_Integer Handle_Geom_BSplineSurface::getMaxDegree()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


SWIGINTERN void Handle_Geom_BSplineSurface_Resolution(Handle_Geom_BSplineSurface *self,Standard_Real tolerance3d,Standard_Real &toleranceU,Standard_Real &toleranceV){
      (*self)->Resolution(tolerance3d, toleranceU, toleranceV);
    }
EXPORT void _wrap_Geom_BSplineSurface_Resolution (Handle_Geom_BSplineSurface *larg1, Standard_Real larg2, Standard_Real *larg3, Standard_Real *larg4) {
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  Standard_Real arg2 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_BSplineSurface_Resolution(arg1,arg2,*arg3,*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_BSplineSurface_Resolution\n  * wrapname: _wrap_Geom_BSplineSurface_Resolution\n  * fulldecl: void Handle_Geom_BSplineSurface::Resolution(Standard_Real,Standard_Real &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_Geom_BSplineSurface (Handle_Geom_BSplineSurface *larg1) {
  Handle_Geom_BSplineSurface *arg1 = (Handle_Geom_BSplineSurface *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom_BSplineSurface\n  * wrapname: _wrap_delete_Geom_BSplineSurface\n  * fulldecl: Handle_Geom_BSplineSurface::~Handle_Geom_BSplineSurface()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom_RectangularTrimmedSurface *new_Handle_Geom_RectangularTrimmedSurface__SWIG_0(Handle_Geom_Surface const &S,Standard_Real const U1,Standard_Real const U2,Standard_Real const V1,Standard_Real const V2,Standard_Boolean const USense=Standard_True,Standard_Boolean const VSense=Standard_True){
        return new Handle_Geom_RectangularTrimmedSurface(new Geom_RectangularTrimmedSurface(S, U1, U2, V1, V2, USense, VSense));
     }
EXPORT Handle_Geom_RectangularTrimmedSurface *_wrap_new_Geom_RectangularTrimmedSurface__SWIG_0 (Handle_Geom_Surface *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5, bool larg6, bool larg7) {
  Handle_Geom_RectangularTrimmedSurface * lresult = (Handle_Geom_RectangularTrimmedSurface *)0 ;
  Handle_Geom_Surface *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  Standard_Boolean arg6 ;
  Standard_Boolean arg7 ;
  Handle_Geom_RectangularTrimmedSurface *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = (bool)larg6;
  arg7 = (bool)larg7;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_RectangularTrimmedSurface *)new_Handle_Geom_RectangularTrimmedSurface__SWIG_0((Handle_Geom_Surface const &)*arg1,arg2,arg3,arg4,arg5,arg6,arg7);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_RectangularTrimmedSurface\n  * wrapname: _wrap_new_Geom_RectangularTrimmedSurface__SWIG_0\n  * fulldecl: Handle_Geom_RectangularTrimmedSurface::Handle_Geom_RectangularTrimmedSurface(Handle_Geom_Surface const &,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_RectangularTrimmedSurface *)0;
  }
}


EXPORT Handle_Geom_RectangularTrimmedSurface *_wrap_new_Geom_RectangularTrimmedSurface__SWIG_1 (Handle_Geom_Surface *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5, bool larg6) {
  Handle_Geom_RectangularTrimmedSurface * lresult = (Handle_Geom_RectangularTrimmedSurface *)0 ;
  Handle_Geom_Surface *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  Standard_Boolean arg6 ;
  Handle_Geom_RectangularTrimmedSurface *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = (bool)larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_RectangularTrimmedSurface *)new_Handle_Geom_RectangularTrimmedSurface__SWIG_0((Handle_Geom_Surface const &)*arg1,arg2,arg3,arg4,arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_RectangularTrimmedSurface\n  * wrapname: _wrap_new_Geom_RectangularTrimmedSurface__SWIG_1\n  * fulldecl: Handle_Geom_RectangularTrimmedSurface::Handle_Geom_RectangularTrimmedSurface(Handle_Geom_Surface const &,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_RectangularTrimmedSurface *)0;
  }
}


EXPORT Handle_Geom_RectangularTrimmedSurface *_wrap_new_Geom_RectangularTrimmedSurface__SWIG_2 (Handle_Geom_Surface *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5) {
  Handle_Geom_RectangularTrimmedSurface * lresult = (Handle_Geom_RectangularTrimmedSurface *)0 ;
  Handle_Geom_Surface *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  Handle_Geom_RectangularTrimmedSurface *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_RectangularTrimmedSurface *)new_Handle_Geom_RectangularTrimmedSurface__SWIG_0((Handle_Geom_Surface const &)*arg1,arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_RectangularTrimmedSurface\n  * wrapname: _wrap_new_Geom_RectangularTrimmedSurface__SWIG_2\n  * fulldecl: Handle_Geom_RectangularTrimmedSurface::Handle_Geom_RectangularTrimmedSurface(Handle_Geom_Surface const &,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_RectangularTrimmedSurface *)0;
  }
}


SWIGINTERN Handle_Geom_Surface Handle_Geom_RectangularTrimmedSurface_BasisSurface(Handle_Geom_RectangularTrimmedSurface *self){
        return (*self)->BasisSurface();	
	}
EXPORT Handle_Geom_Surface *_wrap_Geom_RectangularTrimmedSurface_BasisSurface (Handle_Geom_RectangularTrimmedSurface *larg1) {
  Handle_Geom_Surface * lresult = (Handle_Geom_Surface *)0 ;
  Handle_Geom_RectangularTrimmedSurface *arg1 = (Handle_Geom_RectangularTrimmedSurface *) 0 ;
  SwigValueWrapper< Handle_Geom_Surface > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_RectangularTrimmedSurface_BasisSurface(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_RectangularTrimmedSurface_BasisSurface\n  * wrapname: _wrap_Geom_RectangularTrimmedSurface_BasisSurface\n  * fulldecl: Handle_Geom_Surface Handle_Geom_RectangularTrimmedSurface::BasisSurface()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Surface(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Surface *)0;
  }
}


SWIGINTERN void Handle_Geom_RectangularTrimmedSurface_Bounds(Handle_Geom_RectangularTrimmedSurface *self,Standard_Real &u1,Standard_Real &u2,Standard_Real &v1,Standard_Real &v2){
        (*self)->Bounds(u1, u2, v1, v2);
    }
EXPORT void _wrap_Geom_RectangularTrimmedSurface_Bounds (Handle_Geom_RectangularTrimmedSurface *larg1, Standard_Real *larg2, Standard_Real *larg3, Standard_Real *larg4, Standard_Real *larg5) {
  Handle_Geom_RectangularTrimmedSurface *arg1 = (Handle_Geom_RectangularTrimmedSurface *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  Standard_Real *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_RectangularTrimmedSurface_Bounds(arg1,*arg2,*arg3,*arg4,*arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_RectangularTrimmedSurface_Bounds\n  * wrapname: _wrap_Geom_RectangularTrimmedSurface_Bounds\n  * fulldecl: void Handle_Geom_RectangularTrimmedSurface::Bounds(Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_Geom_RectangularTrimmedSurface (Handle_Geom_RectangularTrimmedSurface *larg1) {
  Handle_Geom_RectangularTrimmedSurface *arg1 = (Handle_Geom_RectangularTrimmedSurface *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom_RectangularTrimmedSurface\n  * wrapname: _wrap_delete_Geom_RectangularTrimmedSurface\n  * fulldecl: Handle_Geom_RectangularTrimmedSurface::~Handle_Geom_RectangularTrimmedSurface()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom_SphericalSurface *new_Handle_Geom_SphericalSurface(gp_Ax3 const &A3,Standard_Real const Radius){
        return new Handle_Geom_SphericalSurface(new Geom_SphericalSurface(A3, Radius));
    }
EXPORT Handle_Geom_SphericalSurface *_wrap_new_Geom_SphericalSurface (gp_Ax3 *larg1, Standard_Real larg2) {
  Handle_Geom_SphericalSurface * lresult = (Handle_Geom_SphericalSurface *)0 ;
  gp_Ax3 *arg1 = 0 ;
  Standard_Real arg2 ;
  Handle_Geom_SphericalSurface *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_SphericalSurface *)new_Handle_Geom_SphericalSurface((gp_Ax3 const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_SphericalSurface\n  * wrapname: _wrap_new_Geom_SphericalSurface\n  * fulldecl: Handle_Geom_SphericalSurface::Handle_Geom_SphericalSurface(gp_Ax3 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_SphericalSurface *)0;
  }
}


SWIGINTERN gp_Sphere Handle_Geom_SphericalSurface_Sphere(Handle_Geom_SphericalSurface *self){
	    return (*self)->Sphere();	
	}
EXPORT gp_Sphere *_wrap_Geom_SphericalSurface_Sphere (Handle_Geom_SphericalSurface *larg1) {
  gp_Sphere * lresult = (gp_Sphere *)0 ;
  Handle_Geom_SphericalSurface *arg1 = (Handle_Geom_SphericalSurface *) 0 ;
  SwigValueWrapper< gp_Sphere > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_SphericalSurface_Sphere(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_SphericalSurface_Sphere\n  * wrapname: _wrap_Geom_SphericalSurface_Sphere\n  * fulldecl: gp_Sphere Handle_Geom_SphericalSurface::Sphere()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Sphere(result);
    return lresult;
  } catch (...) {
    return (gp_Sphere *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_SphericalSurface_Area(Handle_Geom_SphericalSurface *self){
	    return (*self)->Area();	
	}
EXPORT Standard_Real _wrap_Geom_SphericalSurface_Area (Handle_Geom_SphericalSurface *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_SphericalSurface *arg1 = (Handle_Geom_SphericalSurface *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_SphericalSurface_Area(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_SphericalSurface_Area\n  * wrapname: _wrap_Geom_SphericalSurface_Area\n  * fulldecl: Standard_Real Handle_Geom_SphericalSurface::Area()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN void Handle_Geom_SphericalSurface_Coefficients(Handle_Geom_SphericalSurface *self,Standard_Real &outA1,Standard_Real &outA2,Standard_Real &outA3,Standard_Real &outB1,Standard_Real &outB2,Standard_Real &outB3,Standard_Real &outC1,Standard_Real &outC2,Standard_Real &outC3,Standard_Real &outD){
		return (*self)->Coefficients(outA1, outA2, outA3, outB1, outB2, outB3, outC1, outC2, outC3, outD);
	}
EXPORT void _wrap_Geom_SphericalSurface_Coefficients (Handle_Geom_SphericalSurface *larg1, Standard_Real *larg2, Standard_Real *larg3, Standard_Real *larg4, Standard_Real *larg5, Standard_Real *larg6, Standard_Real *larg7, Standard_Real *larg8, Standard_Real *larg9, Standard_Real *larg10, Standard_Real *larg11) {
  Handle_Geom_SphericalSurface *arg1 = (Handle_Geom_SphericalSurface *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  Standard_Real *arg5 = 0 ;
  Standard_Real *arg6 = 0 ;
  Standard_Real *arg7 = 0 ;
  Standard_Real *arg8 = 0 ;
  Standard_Real *arg9 = 0 ;
  Standard_Real *arg10 = 0 ;
  Standard_Real *arg11 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  arg11 = larg11;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_SphericalSurface_Coefficients(arg1,*arg2,*arg3,*arg4,*arg5,*arg6,*arg7,*arg8,*arg9,*arg10,*arg11);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_SphericalSurface_Coefficients\n  * wrapname: _wrap_Geom_SphericalSurface_Coefficients\n  * fulldecl: void Handle_Geom_SphericalSurface::Coefficients(Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Geom_SphericalSurface_Radius(Handle_Geom_SphericalSurface *self){   
		return (*self)->Radius();	
	}
EXPORT Standard_Real _wrap_Geom_SphericalSurface_Radius (Handle_Geom_SphericalSurface *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_SphericalSurface *arg1 = (Handle_Geom_SphericalSurface *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_SphericalSurface_Radius(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_SphericalSurface_Radius\n  * wrapname: _wrap_Geom_SphericalSurface_Radius\n  * fulldecl: Standard_Real Handle_Geom_SphericalSurface::Radius()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_SphericalSurface_Volume(Handle_Geom_SphericalSurface *self){   
		return (*self)->Volume();	
	}
EXPORT Standard_Real _wrap_Geom_SphericalSurface_Volume (Handle_Geom_SphericalSurface *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_SphericalSurface *arg1 = (Handle_Geom_SphericalSurface *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_SphericalSurface_Volume(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_SphericalSurface_Volume\n  * wrapname: _wrap_Geom_SphericalSurface_Volume\n  * fulldecl: Standard_Real Handle_Geom_SphericalSurface::Volume()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_delete_Geom_SphericalSurface (Handle_Geom_SphericalSurface *larg1) {
  Handle_Geom_SphericalSurface *arg1 = (Handle_Geom_SphericalSurface *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom_SphericalSurface\n  * wrapname: _wrap_delete_Geom_SphericalSurface\n  * fulldecl: Handle_Geom_SphericalSurface::~Handle_Geom_SphericalSurface()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom_ToroidalSurface *new_Handle_Geom_ToroidalSurface(gp_Ax3 const &A3,Standard_Real const MajorRadius,Standard_Real const MinorRadius){
        return new Handle_Geom_ToroidalSurface(new Geom_ToroidalSurface(A3, MajorRadius, MinorRadius));
    }
EXPORT Handle_Geom_ToroidalSurface *_wrap_new_Geom_ToroidalSurface (gp_Ax3 *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom_ToroidalSurface * lresult = (Handle_Geom_ToroidalSurface *)0 ;
  gp_Ax3 *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Handle_Geom_ToroidalSurface *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_ToroidalSurface *)new_Handle_Geom_ToroidalSurface((gp_Ax3 const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_ToroidalSurface\n  * wrapname: _wrap_new_Geom_ToroidalSurface\n  * fulldecl: Handle_Geom_ToroidalSurface::Handle_Geom_ToroidalSurface(gp_Ax3 const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_ToroidalSurface *)0;
  }
}


SWIGINTERN gp_Torus Handle_Geom_ToroidalSurface_Torus(Handle_Geom_ToroidalSurface *self){
	    return (*self)->Torus();	
	}
EXPORT gp_Torus *_wrap_Geom_ToroidalSurface_Torus (Handle_Geom_ToroidalSurface *larg1) {
  gp_Torus * lresult = (gp_Torus *)0 ;
  Handle_Geom_ToroidalSurface *arg1 = (Handle_Geom_ToroidalSurface *) 0 ;
  SwigValueWrapper< gp_Torus > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_ToroidalSurface_Torus(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_ToroidalSurface_Torus\n  * wrapname: _wrap_Geom_ToroidalSurface_Torus\n  * fulldecl: gp_Torus Handle_Geom_ToroidalSurface::Torus()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Torus(result);
    return lresult;
  } catch (...) {
    return (gp_Torus *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_ToroidalSurface_Area(Handle_Geom_ToroidalSurface *self){
	    return (*self)->Area();	
	}
EXPORT Standard_Real _wrap_Geom_ToroidalSurface_Area (Handle_Geom_ToroidalSurface *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_ToroidalSurface *arg1 = (Handle_Geom_ToroidalSurface *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_ToroidalSurface_Area(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_ToroidalSurface_Area\n  * wrapname: _wrap_Geom_ToroidalSurface_Area\n  * fulldecl: Standard_Real Handle_Geom_ToroidalSurface::Area()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_ToroidalSurface_MajorRadius(Handle_Geom_ToroidalSurface *self){
		return (*self)->MajorRadius();
	}
EXPORT Standard_Real _wrap_Geom_ToroidalSurface_MajorRadius (Handle_Geom_ToroidalSurface *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_ToroidalSurface *arg1 = (Handle_Geom_ToroidalSurface *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_ToroidalSurface_MajorRadius(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_ToroidalSurface_MajorRadius\n  * wrapname: _wrap_Geom_ToroidalSurface_MajorRadius\n  * fulldecl: Standard_Real Handle_Geom_ToroidalSurface::MajorRadius()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_ToroidalSurface_MinorRadius(Handle_Geom_ToroidalSurface *self){
		return (*self)->MinorRadius();
	}
EXPORT Standard_Real _wrap_Geom_ToroidalSurface_MinorRadius (Handle_Geom_ToroidalSurface *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_ToroidalSurface *arg1 = (Handle_Geom_ToroidalSurface *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_ToroidalSurface_MinorRadius(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_ToroidalSurface_MinorRadius\n  * wrapname: _wrap_Geom_ToroidalSurface_MinorRadius\n  * fulldecl: Standard_Real Handle_Geom_ToroidalSurface::MinorRadius()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_ToroidalSurface_Volume(Handle_Geom_ToroidalSurface *self){   
		return (*self)->Volume();	
	}
EXPORT Standard_Real _wrap_Geom_ToroidalSurface_Volume (Handle_Geom_ToroidalSurface *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_ToroidalSurface *arg1 = (Handle_Geom_ToroidalSurface *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_ToroidalSurface_Volume(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_ToroidalSurface_Volume\n  * wrapname: _wrap_Geom_ToroidalSurface_Volume\n  * fulldecl: Standard_Real Handle_Geom_ToroidalSurface::Volume()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_delete_Geom_ToroidalSurface (Handle_Geom_ToroidalSurface *larg1) {
  Handle_Geom_ToroidalSurface *arg1 = (Handle_Geom_ToroidalSurface *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom_ToroidalSurface\n  * wrapname: _wrap_delete_Geom_ToroidalSurface\n  * fulldecl: Handle_Geom_ToroidalSurface::~Handle_Geom_ToroidalSurface()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom_OffsetSurface *new_Handle_Geom_OffsetSurface(Handle_Geom_Surface const &S,Standard_Real const Offset){
        return new Handle_Geom_OffsetSurface(new Geom_OffsetSurface(S, Offset)); 
    }
EXPORT Handle_Geom_OffsetSurface *_wrap_new_Geom_OffsetSurface (Handle_Geom_Surface *larg1, Standard_Real larg2) {
  Handle_Geom_OffsetSurface * lresult = (Handle_Geom_OffsetSurface *)0 ;
  Handle_Geom_Surface *arg1 = 0 ;
  Standard_Real arg2 ;
  Handle_Geom_OffsetSurface *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_OffsetSurface *)new_Handle_Geom_OffsetSurface((Handle_Geom_Surface const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_OffsetSurface\n  * wrapname: _wrap_new_Geom_OffsetSurface\n  * fulldecl: Handle_Geom_OffsetSurface::Handle_Geom_OffsetSurface(Handle_Geom_Surface const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_OffsetSurface *)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_OffsetSurface_Offset(Handle_Geom_OffsetSurface *self){
		return (*self)->Offset();	
	}
EXPORT Standard_Real _wrap_Geom_OffsetSurface_Offset (Handle_Geom_OffsetSurface *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_OffsetSurface *arg1 = (Handle_Geom_OffsetSurface *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_OffsetSurface_Offset(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_OffsetSurface_Offset\n  * wrapname: _wrap_Geom_OffsetSurface_Offset\n  * fulldecl: Standard_Real Handle_Geom_OffsetSurface::Offset()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Handle_Geom_Surface Handle_Geom_OffsetSurface_BasisSurface(Handle_Geom_OffsetSurface *self){
        return (*self)->BasisSurface();	
	}
EXPORT Handle_Geom_Surface *_wrap_Geom_OffsetSurface_BasisSurface (Handle_Geom_OffsetSurface *larg1) {
  Handle_Geom_Surface * lresult = (Handle_Geom_Surface *)0 ;
  Handle_Geom_OffsetSurface *arg1 = (Handle_Geom_OffsetSurface *) 0 ;
  SwigValueWrapper< Handle_Geom_Surface > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_OffsetSurface_BasisSurface(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_OffsetSurface_BasisSurface\n  * wrapname: _wrap_Geom_OffsetSurface_BasisSurface\n  * fulldecl: Handle_Geom_Surface Handle_Geom_OffsetSurface::BasisSurface()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom_Surface(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom_Surface *)0;
  }
}


EXPORT void _wrap_delete_Geom_OffsetSurface (Handle_Geom_OffsetSurface *larg1) {
  Handle_Geom_OffsetSurface *arg1 = (Handle_Geom_OffsetSurface *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom_OffsetSurface\n  * wrapname: _wrap_delete_Geom_OffsetSurface\n  * fulldecl: Handle_Geom_OffsetSurface::~Handle_Geom_OffsetSurface()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom_SurfaceOfRevolution *new_Handle_Geom_SurfaceOfRevolution(Handle_Geom_Curve const &C,gp_Ax1 const &A1){
        return new Handle_Geom_SurfaceOfRevolution(new Geom_SurfaceOfRevolution(C, A1));
    }
EXPORT Handle_Geom_SurfaceOfRevolution *_wrap_new_Geom_SurfaceOfRevolution (Handle_Geom_Curve *larg1, gp_Ax1 *larg2) {
  Handle_Geom_SurfaceOfRevolution * lresult = (Handle_Geom_SurfaceOfRevolution *)0 ;
  Handle_Geom_Curve *arg1 = 0 ;
  gp_Ax1 *arg2 = 0 ;
  Handle_Geom_SurfaceOfRevolution *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_SurfaceOfRevolution *)new_Handle_Geom_SurfaceOfRevolution((Handle_Geom_Curve const &)*arg1,(gp_Ax1 const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_SurfaceOfRevolution\n  * wrapname: _wrap_new_Geom_SurfaceOfRevolution\n  * fulldecl: Handle_Geom_SurfaceOfRevolution::Handle_Geom_SurfaceOfRevolution(Handle_Geom_Curve const &,gp_Ax1 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_SurfaceOfRevolution *)0;
  }
}


SWIGINTERN gp_Ax1 Handle_Geom_SurfaceOfRevolution_Axis(Handle_Geom_SurfaceOfRevolution *self){
		return (*self)->Axis();	
	}
EXPORT gp_Ax1 *_wrap_Geom_SurfaceOfRevolution_Axis (Handle_Geom_SurfaceOfRevolution *larg1) {
  gp_Ax1 * lresult = (gp_Ax1 *)0 ;
  Handle_Geom_SurfaceOfRevolution *arg1 = (Handle_Geom_SurfaceOfRevolution *) 0 ;
  gp_Ax1 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_SurfaceOfRevolution_Axis(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_SurfaceOfRevolution_Axis\n  * wrapname: _wrap_Geom_SurfaceOfRevolution_Axis\n  * fulldecl: gp_Ax1 Handle_Geom_SurfaceOfRevolution::Axis()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax1(result);
    return lresult;
  } catch (...) {
    return (gp_Ax1 *)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_SurfaceOfRevolution_Location(Handle_Geom_SurfaceOfRevolution *self){
		return (*self)->Location();	
	}
EXPORT gp_Pnt *_wrap_Geom_SurfaceOfRevolution_Location (Handle_Geom_SurfaceOfRevolution *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_SurfaceOfRevolution *arg1 = (Handle_Geom_SurfaceOfRevolution *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_SurfaceOfRevolution_Location(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_SurfaceOfRevolution_Location\n  * wrapname: _wrap_Geom_SurfaceOfRevolution_Location\n  * fulldecl: gp_Pnt Handle_Geom_SurfaceOfRevolution::Location()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN gp_Ax2 Handle_Geom_SurfaceOfRevolution_ReferencePlane(Handle_Geom_SurfaceOfRevolution *self){
		return (*self)->ReferencePlane();	
	}
EXPORT gp_Ax2 *_wrap_Geom_SurfaceOfRevolution_ReferencePlane (Handle_Geom_SurfaceOfRevolution *larg1) {
  gp_Ax2 * lresult = (gp_Ax2 *)0 ;
  Handle_Geom_SurfaceOfRevolution *arg1 = (Handle_Geom_SurfaceOfRevolution *) 0 ;
  gp_Ax2 result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_SurfaceOfRevolution_ReferencePlane(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_SurfaceOfRevolution_ReferencePlane\n  * wrapname: _wrap_Geom_SurfaceOfRevolution_ReferencePlane\n  * fulldecl: gp_Ax2 Handle_Geom_SurfaceOfRevolution::ReferencePlane()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Ax2(result);
    return lresult;
  } catch (...) {
    return (gp_Ax2 *)0;
  }
}


EXPORT void _wrap_delete_Geom_SurfaceOfRevolution (Handle_Geom_SurfaceOfRevolution *larg1) {
  Handle_Geom_SurfaceOfRevolution *arg1 = (Handle_Geom_SurfaceOfRevolution *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom_SurfaceOfRevolution\n  * wrapname: _wrap_delete_Geom_SurfaceOfRevolution\n  * fulldecl: Handle_Geom_SurfaceOfRevolution::~Handle_Geom_SurfaceOfRevolution()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom_ConicalSurface *new_Handle_Geom_ConicalSurface(gp_Ax3 const &A3,Standard_Real const Ang,Standard_Real const Radius){
		return new Handle_Geom_ConicalSurface(new Geom_ConicalSurface(A3, Ang, Radius));
	}
EXPORT Handle_Geom_ConicalSurface *_wrap_new_Geom_ConicalSurface (gp_Ax3 *larg1, Standard_Real larg2, Standard_Real larg3) {
  Handle_Geom_ConicalSurface * lresult = (Handle_Geom_ConicalSurface *)0 ;
  gp_Ax3 *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Handle_Geom_ConicalSurface *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_ConicalSurface *)new_Handle_Geom_ConicalSurface((gp_Ax3 const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_ConicalSurface\n  * wrapname: _wrap_new_Geom_ConicalSurface\n  * fulldecl: Handle_Geom_ConicalSurface::Handle_Geom_ConicalSurface(gp_Ax3 const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_ConicalSurface *)0;
  }
}


SWIGINTERN gp_Cone Handle_Geom_ConicalSurface_Cone(Handle_Geom_ConicalSurface *self){
		return (*self)->Cone();	
	}
EXPORT gp_Cone *_wrap_Geom_ConicalSurface_Cone (Handle_Geom_ConicalSurface *larg1) {
  gp_Cone * lresult = (gp_Cone *)0 ;
  Handle_Geom_ConicalSurface *arg1 = (Handle_Geom_ConicalSurface *) 0 ;
  SwigValueWrapper< gp_Cone > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_ConicalSurface_Cone(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_ConicalSurface_Cone\n  * wrapname: _wrap_Geom_ConicalSurface_Cone\n  * fulldecl: gp_Cone Handle_Geom_ConicalSurface::Cone()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Cone(result);
    return lresult;
  } catch (...) {
    return (gp_Cone *)0;
  }
}


SWIGINTERN gp_Pnt Handle_Geom_ConicalSurface_Apex(Handle_Geom_ConicalSurface *self){
		return (*self)->Apex();	
	}
EXPORT gp_Pnt *_wrap_Geom_ConicalSurface_Apex (Handle_Geom_ConicalSurface *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  Handle_Geom_ConicalSurface *arg1 = (Handle_Geom_ConicalSurface *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_ConicalSurface_Apex(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_ConicalSurface_Apex\n  * wrapname: _wrap_Geom_ConicalSurface_Apex\n  * fulldecl: gp_Pnt Handle_Geom_ConicalSurface::Apex()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


SWIGINTERN void Handle_Geom_ConicalSurface_Coefficients(Handle_Geom_ConicalSurface *self,Standard_Real &outA1,Standard_Real &outA2,Standard_Real &outA3,Standard_Real &outB1,Standard_Real &outB2,Standard_Real &outB3,Standard_Real &outC1,Standard_Real &outC2,Standard_Real &outC3,Standard_Real &outD){
    	(*self)->Coefficients(outA1, outA2, outA3, outB1, outB2, outB3, outC1, outC2, outC3, outD);
    }
EXPORT void _wrap_Geom_ConicalSurface_Coefficients (Handle_Geom_ConicalSurface *larg1, Standard_Real *larg2, Standard_Real *larg3, Standard_Real *larg4, Standard_Real *larg5, Standard_Real *larg6, Standard_Real *larg7, Standard_Real *larg8, Standard_Real *larg9, Standard_Real *larg10, Standard_Real *larg11) {
  Handle_Geom_ConicalSurface *arg1 = (Handle_Geom_ConicalSurface *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  Standard_Real *arg5 = 0 ;
  Standard_Real *arg6 = 0 ;
  Standard_Real *arg7 = 0 ;
  Standard_Real *arg8 = 0 ;
  Standard_Real *arg9 = 0 ;
  Standard_Real *arg10 = 0 ;
  Standard_Real *arg11 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  arg11 = larg11;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_ConicalSurface_Coefficients(arg1,*arg2,*arg3,*arg4,*arg5,*arg6,*arg7,*arg8,*arg9,*arg10,*arg11);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_ConicalSurface_Coefficients\n  * wrapname: _wrap_Geom_ConicalSurface_Coefficients\n  * fulldecl: void Handle_Geom_ConicalSurface::Coefficients(Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Geom_ConicalSurface_ReferenceRadius(Handle_Geom_ConicalSurface *self){   
		return (*self)->RefRadius();	
	}
EXPORT Standard_Real _wrap_Geom_ConicalSurface_ReferenceRadius (Handle_Geom_ConicalSurface *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_ConicalSurface *arg1 = (Handle_Geom_ConicalSurface *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_ConicalSurface_ReferenceRadius(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_ConicalSurface_ReferenceRadius\n  * wrapname: _wrap_Geom_ConicalSurface_ReferenceRadius\n  * fulldecl: Standard_Real Handle_Geom_ConicalSurface::ReferenceRadius()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


SWIGINTERN Standard_Real Handle_Geom_ConicalSurface_SemiAngle(Handle_Geom_ConicalSurface *self){   
		return (*self)->SemiAngle();	
	}
EXPORT Standard_Real _wrap_Geom_ConicalSurface_SemiAngle (Handle_Geom_ConicalSurface *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_ConicalSurface *arg1 = (Handle_Geom_ConicalSurface *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_ConicalSurface_SemiAngle(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_ConicalSurface_SemiAngle\n  * wrapname: _wrap_Geom_ConicalSurface_SemiAngle\n  * fulldecl: Standard_Real Handle_Geom_ConicalSurface::SemiAngle()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_delete_Geom_ConicalSurface (Handle_Geom_ConicalSurface *larg1) {
  Handle_Geom_ConicalSurface *arg1 = (Handle_Geom_ConicalSurface *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom_ConicalSurface\n  * wrapname: _wrap_delete_Geom_ConicalSurface\n  * fulldecl: Handle_Geom_ConicalSurface::~Handle_Geom_ConicalSurface()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom_CylindricalSurface *new_Handle_Geom_CylindricalSurface__SWIG_0(gp_Ax3 const &A3,Standard_Real const Radius){
		return new Handle_Geom_CylindricalSurface(new Geom_CylindricalSurface(A3, Radius));
	}
EXPORT Handle_Geom_CylindricalSurface *_wrap_new_Geom_CylindricalSurface__SWIG_0 (gp_Ax3 *larg1, Standard_Real larg2) {
  Handle_Geom_CylindricalSurface * lresult = (Handle_Geom_CylindricalSurface *)0 ;
  gp_Ax3 *arg1 = 0 ;
  Standard_Real arg2 ;
  Handle_Geom_CylindricalSurface *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_CylindricalSurface *)new_Handle_Geom_CylindricalSurface__SWIG_0((gp_Ax3 const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_CylindricalSurface\n  * wrapname: _wrap_new_Geom_CylindricalSurface__SWIG_0\n  * fulldecl: Handle_Geom_CylindricalSurface::Handle_Geom_CylindricalSurface(gp_Ax3 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_CylindricalSurface *)0;
  }
}


SWIGINTERN Handle_Geom_CylindricalSurface *new_Handle_Geom_CylindricalSurface__SWIG_1(gp_Ax2 const &A2,Standard_Real const Radius){
		return new Handle_Geom_CylindricalSurface(new Geom_CylindricalSurface(A2, Radius));
	}
EXPORT Handle_Geom_CylindricalSurface *_wrap_new_Geom_CylindricalSurface__SWIG_1 (gp_Ax2 *larg1, Standard_Real larg2) {
  Handle_Geom_CylindricalSurface * lresult = (Handle_Geom_CylindricalSurface *)0 ;
  gp_Ax2 *arg1 = 0 ;
  Standard_Real arg2 ;
  Handle_Geom_CylindricalSurface *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_CylindricalSurface *)new_Handle_Geom_CylindricalSurface__SWIG_1((gp_Ax2 const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_CylindricalSurface\n  * wrapname: _wrap_new_Geom_CylindricalSurface__SWIG_1\n  * fulldecl: Handle_Geom_CylindricalSurface::Handle_Geom_CylindricalSurface(gp_Ax2 const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_CylindricalSurface *)0;
  }
}


SWIGINTERN gp_Cylinder Handle_Geom_CylindricalSurface_Cylinder(Handle_Geom_CylindricalSurface *self){
		return (*self)->Cylinder();	
	}
EXPORT gp_Cylinder *_wrap_Geom_CylindricalSurface_Cylinder (Handle_Geom_CylindricalSurface *larg1) {
  gp_Cylinder * lresult = (gp_Cylinder *)0 ;
  Handle_Geom_CylindricalSurface *arg1 = (Handle_Geom_CylindricalSurface *) 0 ;
  SwigValueWrapper< gp_Cylinder > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_CylindricalSurface_Cylinder(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_CylindricalSurface_Cylinder\n  * wrapname: _wrap_Geom_CylindricalSurface_Cylinder\n  * fulldecl: gp_Cylinder Handle_Geom_CylindricalSurface::Cylinder()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Cylinder(result);
    return lresult;
  } catch (...) {
    return (gp_Cylinder *)0;
  }
}


SWIGINTERN void Handle_Geom_CylindricalSurface_Coefficients(Handle_Geom_CylindricalSurface *self,Standard_Real &outA1,Standard_Real &outA2,Standard_Real &outA3,Standard_Real &outB1,Standard_Real &outB2,Standard_Real &outB3,Standard_Real &outC1,Standard_Real &outC2,Standard_Real &outC3,Standard_Real &outD){
		return (*self)->Coefficients(outA1, outA2, outA3, outB1, outB2, outB3, outC1, outC2, outC3, outD);
	}
EXPORT void _wrap_Geom_CylindricalSurface_Coefficients (Handle_Geom_CylindricalSurface *larg1, Standard_Real *larg2, Standard_Real *larg3, Standard_Real *larg4, Standard_Real *larg5, Standard_Real *larg6, Standard_Real *larg7, Standard_Real *larg8, Standard_Real *larg9, Standard_Real *larg10, Standard_Real *larg11) {
  Handle_Geom_CylindricalSurface *arg1 = (Handle_Geom_CylindricalSurface *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  Standard_Real *arg5 = 0 ;
  Standard_Real *arg6 = 0 ;
  Standard_Real *arg7 = 0 ;
  Standard_Real *arg8 = 0 ;
  Standard_Real *arg9 = 0 ;
  Standard_Real *arg10 = 0 ;
  Standard_Real *arg11 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  arg11 = larg11;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_CylindricalSurface_Coefficients(arg1,*arg2,*arg3,*arg4,*arg5,*arg6,*arg7,*arg8,*arg9,*arg10,*arg11);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_CylindricalSurface_Coefficients\n  * wrapname: _wrap_Geom_CylindricalSurface_Coefficients\n  * fulldecl: void Handle_Geom_CylindricalSurface::Coefficients(Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Real Handle_Geom_CylindricalSurface_Radius(Handle_Geom_CylindricalSurface *self){   
		return (*self)->Radius();	
	}
EXPORT Standard_Real _wrap_Geom_CylindricalSurface_Radius (Handle_Geom_CylindricalSurface *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Handle_Geom_CylindricalSurface *arg1 = (Handle_Geom_CylindricalSurface *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)Handle_Geom_CylindricalSurface_Radius(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_CylindricalSurface_Radius\n  * wrapname: _wrap_Geom_CylindricalSurface_Radius\n  * fulldecl: Standard_Real Handle_Geom_CylindricalSurface::Radius()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_delete_Geom_CylindricalSurface (Handle_Geom_CylindricalSurface *larg1) {
  Handle_Geom_CylindricalSurface *arg1 = (Handle_Geom_CylindricalSurface *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom_CylindricalSurface\n  * wrapname: _wrap_delete_Geom_CylindricalSurface\n  * fulldecl: Handle_Geom_CylindricalSurface::~Handle_Geom_CylindricalSurface()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom_SurfaceOfLinearExtrusion *new_Handle_Geom_SurfaceOfLinearExtrusion(Handle_Geom_Curve const &C,gp_Dir const &V){
        return new Handle_Geom_SurfaceOfLinearExtrusion(new Geom_SurfaceOfLinearExtrusion(C, V));
    }
EXPORT Handle_Geom_SurfaceOfLinearExtrusion *_wrap_new_Geom_SurfaceOfLinearExtrusion (Handle_Geom_Curve *larg1, gp_Dir *larg2) {
  Handle_Geom_SurfaceOfLinearExtrusion * lresult = (Handle_Geom_SurfaceOfLinearExtrusion *)0 ;
  Handle_Geom_Curve *arg1 = 0 ;
  gp_Dir *arg2 = 0 ;
  Handle_Geom_SurfaceOfLinearExtrusion *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_SurfaceOfLinearExtrusion *)new_Handle_Geom_SurfaceOfLinearExtrusion((Handle_Geom_Curve const &)*arg1,(gp_Dir const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_SurfaceOfLinearExtrusion\n  * wrapname: _wrap_new_Geom_SurfaceOfLinearExtrusion\n  * fulldecl: Handle_Geom_SurfaceOfLinearExtrusion::Handle_Geom_SurfaceOfLinearExtrusion(Handle_Geom_Curve const &,gp_Dir const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_SurfaceOfLinearExtrusion *)0;
  }
}


EXPORT void _wrap_delete_Geom_SurfaceOfLinearExtrusion (Handle_Geom_SurfaceOfLinearExtrusion *larg1) {
  Handle_Geom_SurfaceOfLinearExtrusion *arg1 = (Handle_Geom_SurfaceOfLinearExtrusion *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom_SurfaceOfLinearExtrusion\n  * wrapname: _wrap_delete_Geom_SurfaceOfLinearExtrusion\n  * fulldecl: Handle_Geom_SurfaceOfLinearExtrusion::~Handle_Geom_SurfaceOfLinearExtrusion()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_Geom_Plane *new_Handle_Geom_Plane(gp_Ax3 const &A3){
		return new Handle_Geom_Plane(new Geom_Plane(A3));
	}
EXPORT Handle_Geom_Plane *_wrap_new_Geom_Plane (gp_Ax3 *larg1) {
  Handle_Geom_Plane * lresult = (Handle_Geom_Plane *)0 ;
  gp_Ax3 *arg1 = 0 ;
  Handle_Geom_Plane *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_Plane *)new_Handle_Geom_Plane((gp_Ax3 const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom_Plane\n  * wrapname: _wrap_new_Geom_Plane\n  * fulldecl: Handle_Geom_Plane::Handle_Geom_Plane(gp_Ax3 const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_Plane *)0;
  }
}


SWIGINTERN gp_Pln Handle_Geom_Plane_Plane(Handle_Geom_Plane *self){
		return (*self)->Pln();	
	}
EXPORT gp_Pln *_wrap_Geom_Plane_Plane (Handle_Geom_Plane *larg1) {
  gp_Pln * lresult = (gp_Pln *)0 ;
  Handle_Geom_Plane *arg1 = (Handle_Geom_Plane *) 0 ;
  SwigValueWrapper< gp_Pln > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = Handle_Geom_Plane_Plane(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Plane_Plane\n  * wrapname: _wrap_Geom_Plane_Plane\n  * fulldecl: gp_Pln Handle_Geom_Plane::Plane()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pln(result);
    return lresult;
  } catch (...) {
    return (gp_Pln *)0;
  }
}


SWIGINTERN void Handle_Geom_Plane_Coefficients(Handle_Geom_Plane *self,Standard_Real &outA,Standard_Real &outB,Standard_Real &outC,Standard_Real &outD){
		return (*self)->Coefficients(outA, outB, outC, outD);
	}
EXPORT void _wrap_Geom_Plane_Coefficients (Handle_Geom_Plane *larg1, Standard_Real *larg2, Standard_Real *larg3, Standard_Real *larg4, Standard_Real *larg5) {
  Handle_Geom_Plane *arg1 = (Handle_Geom_Plane *) 0 ;
  Standard_Real *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  Standard_Real *arg4 = 0 ;
  Standard_Real *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Handle_Geom_Plane_Coefficients(arg1,*arg2,*arg3,*arg4,*arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom_Plane_Coefficients\n  * wrapname: _wrap_Geom_Plane_Coefficients\n  * fulldecl: void Handle_Geom_Plane::Coefficients(Standard_Real &,Standard_Real &,Standard_Real &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_Geom_Plane (Handle_Geom_Plane *larg1) {
  Handle_Geom_Plane *arg1 = (Handle_Geom_Plane *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom_Plane\n  * wrapname: _wrap_delete_Geom_Plane\n  * fulldecl: Handle_Geom_Plane::~Handle_Geom_Plane()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <BRepLib.hxx>

EXPORT void _wrap_BRepLib_Precision__SWIG_0 (Standard_Real larg1) {
  Standard_Real arg1 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::Precision(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_Precision\n  * wrapname: _wrap_BRepLib_Precision__SWIG_0\n  * fulldecl: void BRepLib::Precision(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Real _wrap_BRepLib_Precision__SWIG_1 () {
  Standard_Real lresult = (Standard_Real)0 ;
  Standard_Real result;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)BRepLib::Precision();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_Precision\n  * wrapname: _wrap_BRepLib_Precision__SWIG_1\n  * fulldecl: Standard_Real BRepLib::Precision()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_BRepLib_Plane__SWIG_0 (Handle_Geom_Plane *larg1) {
  Handle_Geom_Plane *arg1 = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::Plane((Handle_Geom_Plane const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_Plane\n  * wrapname: _wrap_BRepLib_Plane__SWIG_0\n  * fulldecl: void BRepLib::Plane(Handle_Geom_Plane const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Handle_Geom_Plane *_wrap_BRepLib_Plane__SWIG_1 () {
  Handle_Geom_Plane * lresult = (Handle_Geom_Plane *)0 ;
  Handle_Geom_Plane *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_Plane *) &BRepLib::Plane();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_Plane\n  * wrapname: _wrap_BRepLib_Plane__SWIG_1\n  * fulldecl: Handle_Geom_Plane const & BRepLib::Plane()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_Plane *)0;
  }
}


EXPORT bool _wrap_BRepLib_CheckSameRange__SWIG_0 (TopoDS_Edge *larg1, Standard_Real larg2) {
  bool lresult = (bool)0 ;
  TopoDS_Edge *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::CheckSameRange((TopoDS_Edge const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_CheckSameRange\n  * wrapname: _wrap_BRepLib_CheckSameRange__SWIG_0\n  * fulldecl: Standard_Boolean BRepLib::CheckSameRange(TopoDS_Edge const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepLib_CheckSameRange__SWIG_1 (TopoDS_Edge *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Edge *arg1 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::CheckSameRange((TopoDS_Edge const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_CheckSameRange\n  * wrapname: _wrap_BRepLib_CheckSameRange__SWIG_1\n  * fulldecl: Standard_Boolean BRepLib::CheckSameRange(TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_BRepLib_SameRange__SWIG_0 (TopoDS_Edge *larg1, Standard_Real larg2) {
  TopoDS_Edge *arg1 = 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::SameRange((TopoDS_Edge const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_SameRange\n  * wrapname: _wrap_BRepLib_SameRange__SWIG_0\n  * fulldecl: void BRepLib::SameRange(TopoDS_Edge const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepLib_SameRange__SWIG_1 (TopoDS_Edge *larg1) {
  TopoDS_Edge *arg1 = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::SameRange((TopoDS_Edge const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_SameRange\n  * wrapname: _wrap_BRepLib_SameRange__SWIG_1\n  * fulldecl: void BRepLib::SameRange(TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_BRepLib_BuildCurve3d__SWIG_0 (TopoDS_Edge *larg1, Standard_Real larg2, GeomAbs_Shape larg3, Standard_Integer larg4, Standard_Integer larg5) {
  bool lresult = (bool)0 ;
  TopoDS_Edge *arg1 = 0 ;
  Standard_Real arg2 ;
  GeomAbs_Shape arg3 ;
  Standard_Integer arg4 ;
  Standard_Integer arg5 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::BuildCurve3d((TopoDS_Edge const &)*arg1,arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_BuildCurve3d\n  * wrapname: _wrap_BRepLib_BuildCurve3d__SWIG_0\n  * fulldecl: Standard_Boolean BRepLib::BuildCurve3d(TopoDS_Edge const &,Standard_Real const,GeomAbs_Shape const,Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepLib_BuildCurve3d__SWIG_1 (TopoDS_Edge *larg1, Standard_Real larg2, GeomAbs_Shape larg3, Standard_Integer larg4) {
  bool lresult = (bool)0 ;
  TopoDS_Edge *arg1 = 0 ;
  Standard_Real arg2 ;
  GeomAbs_Shape arg3 ;
  Standard_Integer arg4 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::BuildCurve3d((TopoDS_Edge const &)*arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_BuildCurve3d\n  * wrapname: _wrap_BRepLib_BuildCurve3d__SWIG_1\n  * fulldecl: Standard_Boolean BRepLib::BuildCurve3d(TopoDS_Edge const &,Standard_Real const,GeomAbs_Shape const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepLib_BuildCurve3d__SWIG_2 (TopoDS_Edge *larg1, Standard_Real larg2, GeomAbs_Shape larg3) {
  bool lresult = (bool)0 ;
  TopoDS_Edge *arg1 = 0 ;
  Standard_Real arg2 ;
  GeomAbs_Shape arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::BuildCurve3d((TopoDS_Edge const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_BuildCurve3d\n  * wrapname: _wrap_BRepLib_BuildCurve3d__SWIG_2\n  * fulldecl: Standard_Boolean BRepLib::BuildCurve3d(TopoDS_Edge const &,Standard_Real const,GeomAbs_Shape const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepLib_BuildCurve3d__SWIG_3 (TopoDS_Edge *larg1, Standard_Real larg2) {
  bool lresult = (bool)0 ;
  TopoDS_Edge *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::BuildCurve3d((TopoDS_Edge const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_BuildCurve3d\n  * wrapname: _wrap_BRepLib_BuildCurve3d__SWIG_3\n  * fulldecl: Standard_Boolean BRepLib::BuildCurve3d(TopoDS_Edge const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepLib_BuildCurve3d__SWIG_4 (TopoDS_Edge *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Edge *arg1 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::BuildCurve3d((TopoDS_Edge const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_BuildCurve3d\n  * wrapname: _wrap_BRepLib_BuildCurve3d__SWIG_4\n  * fulldecl: Standard_Boolean BRepLib::BuildCurve3d(TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepLib_BuildCurves3d__SWIG_0 (TopoDS_Shape *larg1, Standard_Real larg2, GeomAbs_Shape larg3, Standard_Integer larg4, Standard_Integer larg5) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  GeomAbs_Shape arg3 ;
  Standard_Integer arg4 ;
  Standard_Integer arg5 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::BuildCurves3d((TopoDS_Shape const &)*arg1,arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_BuildCurves3d\n  * wrapname: _wrap_BRepLib_BuildCurves3d__SWIG_0\n  * fulldecl: Standard_Boolean BRepLib::BuildCurves3d(TopoDS_Shape const &,Standard_Real const,GeomAbs_Shape const,Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepLib_BuildCurves3d__SWIG_1 (TopoDS_Shape *larg1, Standard_Real larg2, GeomAbs_Shape larg3, Standard_Integer larg4) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  GeomAbs_Shape arg3 ;
  Standard_Integer arg4 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::BuildCurves3d((TopoDS_Shape const &)*arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_BuildCurves3d\n  * wrapname: _wrap_BRepLib_BuildCurves3d__SWIG_1\n  * fulldecl: Standard_Boolean BRepLib::BuildCurves3d(TopoDS_Shape const &,Standard_Real const,GeomAbs_Shape const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepLib_BuildCurves3d__SWIG_2 (TopoDS_Shape *larg1, Standard_Real larg2, GeomAbs_Shape larg3) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  GeomAbs_Shape arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::BuildCurves3d((TopoDS_Shape const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_BuildCurves3d\n  * wrapname: _wrap_BRepLib_BuildCurves3d__SWIG_2\n  * fulldecl: Standard_Boolean BRepLib::BuildCurves3d(TopoDS_Shape const &,Standard_Real const,GeomAbs_Shape const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepLib_BuildCurves3d__SWIG_3 (TopoDS_Shape *larg1, Standard_Real larg2) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::BuildCurves3d((TopoDS_Shape const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_BuildCurves3d\n  * wrapname: _wrap_BRepLib_BuildCurves3d__SWIG_3\n  * fulldecl: Standard_Boolean BRepLib::BuildCurves3d(TopoDS_Shape const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepLib_BuildCurves3d__SWIG_4 (TopoDS_Shape *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::BuildCurves3d((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_BuildCurves3d\n  * wrapname: _wrap_BRepLib_BuildCurves3d__SWIG_4\n  * fulldecl: Standard_Boolean BRepLib::BuildCurves3d(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepLib_UpdateEdgeTol (TopoDS_Edge *larg1, Standard_Real larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  TopoDS_Edge *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::UpdateEdgeTol((TopoDS_Edge const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_UpdateEdgeTol\n  * wrapname: _wrap_BRepLib_UpdateEdgeTol\n  * fulldecl: Standard_Boolean BRepLib::UpdateEdgeTol(TopoDS_Edge const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepLib_UpdateEdgeTolerance (TopoDS_Shape *larg1, Standard_Real larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::UpdateEdgeTolerance((TopoDS_Shape const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_UpdateEdgeTolerance\n  * wrapname: _wrap_BRepLib_UpdateEdgeTolerance\n  * fulldecl: Standard_Boolean BRepLib::UpdateEdgeTolerance(TopoDS_Shape const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_BRepLib_SameParameter__SWIG_0 (TopoDS_Edge *larg1, Standard_Real larg2) {
  TopoDS_Edge *arg1 = 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::SameParameter((TopoDS_Edge const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_SameParameter\n  * wrapname: _wrap_BRepLib_SameParameter__SWIG_0\n  * fulldecl: void BRepLib::SameParameter(TopoDS_Edge const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepLib_SameParameter__SWIG_1 (TopoDS_Edge *larg1) {
  TopoDS_Edge *arg1 = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::SameParameter((TopoDS_Edge const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_SameParameter\n  * wrapname: _wrap_BRepLib_SameParameter__SWIG_1\n  * fulldecl: void BRepLib::SameParameter(TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepLib_SameParameter__SWIG_2 (TopoDS_Shape *larg1, Standard_Real larg2, bool larg3) {
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Boolean arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::SameParameter((TopoDS_Shape const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_SameParameter\n  * wrapname: _wrap_BRepLib_SameParameter__SWIG_2\n  * fulldecl: void BRepLib::SameParameter(TopoDS_Shape const &,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepLib_SameParameter__SWIG_3 (TopoDS_Shape *larg1, Standard_Real larg2) {
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::SameParameter((TopoDS_Shape const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_SameParameter\n  * wrapname: _wrap_BRepLib_SameParameter__SWIG_3\n  * fulldecl: void BRepLib::SameParameter(TopoDS_Shape const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepLib_SameParameter__SWIG_4 (TopoDS_Shape *larg1) {
  TopoDS_Shape *arg1 = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::SameParameter((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_SameParameter\n  * wrapname: _wrap_BRepLib_SameParameter__SWIG_4\n  * fulldecl: void BRepLib::SameParameter(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepLib_UpdateTolerances__SWIG_0 (TopoDS_Shape *larg1, bool larg2) {
  TopoDS_Shape *arg1 = 0 ;
  Standard_Boolean arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::UpdateTolerances((TopoDS_Shape const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_UpdateTolerances\n  * wrapname: _wrap_BRepLib_UpdateTolerances__SWIG_0\n  * fulldecl: void BRepLib::UpdateTolerances(TopoDS_Shape const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepLib_UpdateTolerances__SWIG_1 (TopoDS_Shape *larg1) {
  TopoDS_Shape *arg1 = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::UpdateTolerances((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_UpdateTolerances\n  * wrapname: _wrap_BRepLib_UpdateTolerances__SWIG_1\n  * fulldecl: void BRepLib::UpdateTolerances(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepLib_UpdateInnerTolerances (TopoDS_Shape *larg1) {
  TopoDS_Shape *arg1 = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::UpdateInnerTolerances((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_UpdateInnerTolerances\n  * wrapname: _wrap_BRepLib_UpdateInnerTolerances\n  * fulldecl: void BRepLib::UpdateInnerTolerances(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_BRepLib_OrientClosedSolid (TopoDS_Solid *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Solid *arg1 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::OrientClosedSolid(*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_OrientClosedSolid\n  * wrapname: _wrap_BRepLib_OrientClosedSolid\n  * fulldecl: Standard_Boolean BRepLib::OrientClosedSolid(TopoDS_Solid &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_BRepLib_EncodeRegularity__SWIG_0 (TopoDS_Shape *larg1, Standard_Real larg2) {
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::EncodeRegularity((TopoDS_Shape const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_EncodeRegularity\n  * wrapname: _wrap_BRepLib_EncodeRegularity__SWIG_0\n  * fulldecl: void BRepLib::EncodeRegularity(TopoDS_Shape const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepLib_EncodeRegularity__SWIG_1 (TopoDS_Shape *larg1) {
  TopoDS_Shape *arg1 = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::EncodeRegularity((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_EncodeRegularity\n  * wrapname: _wrap_BRepLib_EncodeRegularity__SWIG_1\n  * fulldecl: void BRepLib::EncodeRegularity(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepLib_EncodeRegularity__SWIG_2 (TopoDS_Edge *larg1, TopoDS_Face *larg2, TopoDS_Face *larg3, Standard_Real larg4) {
  TopoDS_Edge *arg1 = 0 ;
  TopoDS_Face *arg2 = 0 ;
  TopoDS_Face *arg3 = 0 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::EncodeRegularity(*arg1,(TopoDS_Face const &)*arg2,(TopoDS_Face const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_EncodeRegularity\n  * wrapname: _wrap_BRepLib_EncodeRegularity__SWIG_2\n  * fulldecl: void BRepLib::EncodeRegularity(TopoDS_Edge &,TopoDS_Face const &,TopoDS_Face const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepLib_EncodeRegularity__SWIG_3 (TopoDS_Edge *larg1, TopoDS_Face *larg2, TopoDS_Face *larg3) {
  TopoDS_Edge *arg1 = 0 ;
  TopoDS_Face *arg2 = 0 ;
  TopoDS_Face *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::EncodeRegularity(*arg1,(TopoDS_Face const &)*arg2,(TopoDS_Face const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_EncodeRegularity\n  * wrapname: _wrap_BRepLib_EncodeRegularity__SWIG_3\n  * fulldecl: void BRepLib::EncodeRegularity(TopoDS_Edge &,TopoDS_Face const &,TopoDS_Face const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepLib_SortFaces (TopoDS_Shape *larg1, TopTools_ListOfShape *larg2) {
  TopoDS_Shape *arg1 = 0 ;
  TopTools_ListOfShape *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::SortFaces((TopoDS_Shape const &)*arg1,*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_SortFaces\n  * wrapname: _wrap_BRepLib_SortFaces\n  * fulldecl: void BRepLib::SortFaces(TopoDS_Shape const &,TopTools_ListOfShape &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepLib_ReverseSortFaces (TopoDS_Shape *larg1, TopTools_ListOfShape *larg2) {
  TopoDS_Shape *arg1 = 0 ;
  TopTools_ListOfShape *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::ReverseSortFaces((TopoDS_Shape const &)*arg1,*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_ReverseSortFaces\n  * wrapname: _wrap_BRepLib_ReverseSortFaces\n  * fulldecl: void BRepLib::ReverseSortFaces(TopoDS_Shape const &,TopTools_ListOfShape &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_BRepLib_EnsureNormalConsistency__SWIG_0 (TopoDS_Shape *larg1, Standard_Real larg2, bool larg3) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Boolean arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::EnsureNormalConsistency((TopoDS_Shape const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_EnsureNormalConsistency\n  * wrapname: _wrap_BRepLib_EnsureNormalConsistency__SWIG_0\n  * fulldecl: Standard_Boolean BRepLib::EnsureNormalConsistency(TopoDS_Shape const &,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepLib_EnsureNormalConsistency__SWIG_1 (TopoDS_Shape *larg1, Standard_Real larg2) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::EnsureNormalConsistency((TopoDS_Shape const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_EnsureNormalConsistency\n  * wrapname: _wrap_BRepLib_EnsureNormalConsistency__SWIG_1\n  * fulldecl: Standard_Boolean BRepLib::EnsureNormalConsistency(TopoDS_Shape const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepLib_EnsureNormalConsistency__SWIG_2 (TopoDS_Shape *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepLib::EnsureNormalConsistency((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_EnsureNormalConsistency\n  * wrapname: _wrap_BRepLib_EnsureNormalConsistency__SWIG_2\n  * fulldecl: Standard_Boolean BRepLib::EnsureNormalConsistency(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_BRepLib_BoundingVertex (NCollection_List< TopoDS_Shape > *larg1, gp_Pnt *larg2, Standard_Real *larg3) {
  NCollection_List< TopoDS_Shape > *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepLib::BoundingVertex((NCollection_List< TopoDS_Shape > const &)*arg1,*arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepLib_BoundingVertex\n  * wrapname: _wrap_BRepLib_BoundingVertex\n  * fulldecl: void BRepLib::BoundingVertex(NCollection_List< TopoDS_Shape > const &,gp_Pnt &,Standard_Real &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_BRepLib (BRepLib *larg1) {
  BRepLib *arg1 = (BRepLib *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepLib\n  * wrapname: _wrap_delete_BRepLib\n  * fulldecl: BRepLib::~BRepLib()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <BRepFilletAPI_MakeFillet.hxx>
#include <BRepFilletAPI_MakeChamfer.hxx>
  
EXPORT void _wrap_delete_BRepFilletAPI_LocalOperation (BRepFilletAPI_LocalOperation *larg1) {
  BRepFilletAPI_LocalOperation *arg1 = (BRepFilletAPI_LocalOperation *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepFilletAPI_LocalOperation\n  * wrapname: _wrap_delete_BRepFilletAPI_LocalOperation\n  * fulldecl: BRepFilletAPI_LocalOperation::~BRepFilletAPI_LocalOperation()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepFilletAPI_MakeFillet *_wrap_new_BRepFilletAPI_MakeFillet__SWIG_0 (TopoDS_Shape *larg1, ChFi3d_FilletShape larg2) {
  BRepFilletAPI_MakeFillet * lresult = (BRepFilletAPI_MakeFillet *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  ChFi3d_FilletShape arg2 ;
  BRepFilletAPI_MakeFillet *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepFilletAPI_MakeFillet *)new BRepFilletAPI_MakeFillet((TopoDS_Shape const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepFilletAPI_MakeFillet\n  * wrapname: _wrap_new_BRepFilletAPI_MakeFillet__SWIG_0\n  * fulldecl: BRepFilletAPI_MakeFillet::BRepFilletAPI_MakeFillet(TopoDS_Shape const &,ChFi3d_FilletShape const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepFilletAPI_MakeFillet *)0;
  }
}


EXPORT BRepFilletAPI_MakeFillet *_wrap_new_BRepFilletAPI_MakeFillet__SWIG_1 (TopoDS_Shape *larg1) {
  BRepFilletAPI_MakeFillet * lresult = (BRepFilletAPI_MakeFillet *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  BRepFilletAPI_MakeFillet *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepFilletAPI_MakeFillet *)new BRepFilletAPI_MakeFillet((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepFilletAPI_MakeFillet\n  * wrapname: _wrap_new_BRepFilletAPI_MakeFillet__SWIG_1\n  * fulldecl: BRepFilletAPI_MakeFillet::BRepFilletAPI_MakeFillet(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepFilletAPI_MakeFillet *)0;
  }
}


EXPORT void _wrap_BRepFilletAPI_MakeFillet_Add (BRepFilletAPI_MakeFillet *larg1, Standard_Real larg2, TopoDS_Edge *larg3) {
  BRepFilletAPI_MakeFillet *arg1 = (BRepFilletAPI_MakeFillet *) 0 ;
  Standard_Real arg2 ;
  TopoDS_Edge *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Add(arg2,(TopoDS_Edge const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepFilletAPI_MakeFillet_Add\n  * wrapname: _wrap_BRepFilletAPI_MakeFillet_Add\n  * fulldecl: void BRepFilletAPI_MakeFillet::Add(Standard_Real const,TopoDS_Edge const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_BRepFilletAPI_MakeFillet (BRepFilletAPI_MakeFillet *larg1) {
  BRepFilletAPI_MakeFillet *arg1 = (BRepFilletAPI_MakeFillet *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepFilletAPI_MakeFillet\n  * wrapname: _wrap_delete_BRepFilletAPI_MakeFillet\n  * fulldecl: BRepFilletAPI_MakeFillet::~BRepFilletAPI_MakeFillet()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT BRepFilletAPI_MakeChamfer *_wrap_new_BRepFilletAPI_MakeChamfer (TopoDS_Shape *larg1) {
  BRepFilletAPI_MakeChamfer * lresult = (BRepFilletAPI_MakeChamfer *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  BRepFilletAPI_MakeChamfer *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepFilletAPI_MakeChamfer *)new BRepFilletAPI_MakeChamfer((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepFilletAPI_MakeChamfer\n  * wrapname: _wrap_new_BRepFilletAPI_MakeChamfer\n  * fulldecl: BRepFilletAPI_MakeChamfer::BRepFilletAPI_MakeChamfer(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepFilletAPI_MakeChamfer *)0;
  }
}


EXPORT void _wrap_BRepFilletAPI_MakeChamfer_Add (BRepFilletAPI_MakeChamfer *larg1, Standard_Real larg2, TopoDS_Edge *larg3, TopoDS_Face *larg4) {
  BRepFilletAPI_MakeChamfer *arg1 = (BRepFilletAPI_MakeChamfer *) 0 ;
  Standard_Real arg2 ;
  TopoDS_Edge *arg3 = 0 ;
  TopoDS_Face *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Add(arg2,(TopoDS_Edge const &)*arg3,(TopoDS_Face const &)*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepFilletAPI_MakeChamfer_Add\n  * wrapname: _wrap_BRepFilletAPI_MakeChamfer_Add\n  * fulldecl: void BRepFilletAPI_MakeChamfer::Add(Standard_Real const,TopoDS_Edge const &,TopoDS_Face const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_BRepFilletAPI_MakeChamfer (BRepFilletAPI_MakeChamfer *larg1) {
  BRepFilletAPI_MakeChamfer *arg1 = (BRepFilletAPI_MakeChamfer *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepFilletAPI_MakeChamfer\n  * wrapname: _wrap_delete_BRepFilletAPI_MakeChamfer\n  * fulldecl: BRepFilletAPI_MakeChamfer::~BRepFilletAPI_MakeChamfer()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include <BRepCheck_Analyzer.hxx>
EXPORT BRepCheck_Analyzer *_wrap_new_BRepCheck_Analyzer__SWIG_0 (TopoDS_Shape *larg1, bool larg2) {
  BRepCheck_Analyzer * lresult = (BRepCheck_Analyzer *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Boolean arg2 ;
  BRepCheck_Analyzer *result = 0 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepCheck_Analyzer *)new BRepCheck_Analyzer((TopoDS_Shape const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepCheck_Analyzer\n  * wrapname: _wrap_new_BRepCheck_Analyzer__SWIG_0\n  * fulldecl: BRepCheck_Analyzer::BRepCheck_Analyzer(TopoDS_Shape const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepCheck_Analyzer *)0;
  }
}


EXPORT BRepCheck_Analyzer *_wrap_new_BRepCheck_Analyzer__SWIG_1 (TopoDS_Shape *larg1) {
  BRepCheck_Analyzer * lresult = (BRepCheck_Analyzer *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  BRepCheck_Analyzer *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepCheck_Analyzer *)new BRepCheck_Analyzer((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepCheck_Analyzer\n  * wrapname: _wrap_new_BRepCheck_Analyzer__SWIG_1\n  * fulldecl: BRepCheck_Analyzer::BRepCheck_Analyzer(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepCheck_Analyzer *)0;
  }
}


EXPORT void _wrap_BRepCheck_Analyzer_Init__SWIG_0 (BRepCheck_Analyzer *larg1, TopoDS_Shape *larg2, bool larg3) {
  BRepCheck_Analyzer *arg1 = (BRepCheck_Analyzer *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init((TopoDS_Shape const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepCheck_Analyzer_Init\n  * wrapname: _wrap_BRepCheck_Analyzer_Init__SWIG_0\n  * fulldecl: void BRepCheck_Analyzer::Init(TopoDS_Shape const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepCheck_Analyzer_Init__SWIG_1 (BRepCheck_Analyzer *larg1, TopoDS_Shape *larg2) {
  BRepCheck_Analyzer *arg1 = (BRepCheck_Analyzer *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepCheck_Analyzer_Init\n  * wrapname: _wrap_BRepCheck_Analyzer_Init__SWIG_1\n  * fulldecl: void BRepCheck_Analyzer::Init(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_BRepCheck_Analyzer_IsValid (BRepCheck_Analyzer *larg1) {
  bool lresult = (bool)0 ;
  BRepCheck_Analyzer *arg1 = (BRepCheck_Analyzer *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepCheck_Analyzer const *)arg1)->IsValid();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepCheck_Analyzer_IsValid\n  * wrapname: _wrap_BRepCheck_Analyzer_IsValid\n  * fulldecl: Standard_Boolean BRepCheck_Analyzer::IsValid() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_delete_BRepCheck_Analyzer (BRepCheck_Analyzer *larg1) {
  BRepCheck_Analyzer *arg1 = (BRepCheck_Analyzer *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepCheck_Analyzer\n  * wrapname: _wrap_delete_BRepCheck_Analyzer\n  * fulldecl: BRepCheck_Analyzer::~BRepCheck_Analyzer()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include <ShapeBuild_ReShape.hxx>
EXPORT ShapeBuild_ReShape *_wrap_new_ShapeBuild_ReShape () {
  ShapeBuild_ReShape * lresult = (ShapeBuild_ReShape *)0 ;
  ShapeBuild_ReShape *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (ShapeBuild_ReShape *)new ShapeBuild_ReShape();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_ShapeBuild_ReShape\n  * wrapname: _wrap_new_ShapeBuild_ReShape\n  * fulldecl: ShapeBuild_ReShape::ShapeBuild_ReShape()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (ShapeBuild_ReShape *)0;
  }
}


EXPORT void _wrap_ShapeBuild_ReShape_Replace__SWIG_0 (ShapeBuild_ReShape *larg1, TopoDS_Shape *larg2, TopoDS_Shape *larg3, bool larg4) {
  ShapeBuild_ReShape *arg1 = (ShapeBuild_ReShape *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopoDS_Shape *arg3 = 0 ;
  Standard_Boolean arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Replace((TopoDS_Shape const &)*arg2,(TopoDS_Shape const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeBuild_ReShape_Replace\n  * wrapname: _wrap_ShapeBuild_ReShape_Replace__SWIG_0\n  * fulldecl: void ShapeBuild_ReShape::Replace(TopoDS_Shape const &,TopoDS_Shape const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_ShapeBuild_ReShape_Replace__SWIG_1 (ShapeBuild_ReShape *larg1, TopoDS_Shape *larg2, TopoDS_Shape *larg3) {
  ShapeBuild_ReShape *arg1 = (ShapeBuild_ReShape *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopoDS_Shape *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Replace((TopoDS_Shape const &)*arg2,(TopoDS_Shape const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeBuild_ReShape_Replace\n  * wrapname: _wrap_ShapeBuild_ReShape_Replace__SWIG_1\n  * fulldecl: void ShapeBuild_ReShape::Replace(TopoDS_Shape const &,TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopoDS_Shape *_wrap_ShapeBuild_ReShape_Apply__SWIG_0 (ShapeBuild_ReShape *larg1, TopoDS_Shape *larg2, TopAbs_ShapeEnum larg3) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  ShapeBuild_ReShape *arg1 = (ShapeBuild_ReShape *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopAbs_ShapeEnum arg3 ;
  TopoDS_Shape result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (arg1)->Apply((TopoDS_Shape const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeBuild_ReShape_Apply\n  * wrapname: _wrap_ShapeBuild_ReShape_Apply__SWIG_0\n  * fulldecl: TopoDS_Shape ShapeBuild_ReShape::Apply(TopoDS_Shape const &,TopAbs_ShapeEnum const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new TopoDS_Shape(result);
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT TopoDS_Shape *_wrap_ShapeBuild_ReShape_Apply__SWIG_1 (ShapeBuild_ReShape *larg1, TopoDS_Shape *larg2) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  ShapeBuild_ReShape *arg1 = (ShapeBuild_ReShape *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopoDS_Shape result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (arg1)->Apply((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeBuild_ReShape_Apply\n  * wrapname: _wrap_ShapeBuild_ReShape_Apply__SWIG_1\n  * fulldecl: TopoDS_Shape ShapeBuild_ReShape::Apply(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new TopoDS_Shape(result);
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT void _wrap_delete_ShapeBuild_ReShape (ShapeBuild_ReShape *larg1) {
  ShapeBuild_ReShape *arg1 = (ShapeBuild_ReShape *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_ShapeBuild_ReShape\n  * wrapname: _wrap_delete_ShapeBuild_ReShape\n  * fulldecl: ShapeBuild_ReShape::~ShapeBuild_ReShape()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <STEPControl_Reader.hxx>
#include <IGESControl_Reader.hxx>
#include <XSControl_WorkSession.hxx>
#include <XSControl_TransferReader.hxx>
#include <StepRepr_RepresentationItem.hxx>
#include <TCollection_HAsciiString.hxx>
#include <IGESData_IGESEntity.hxx>
#include <TransferBRep.hxx>
#include <Transfer_Binder.hxx>
#include <Transfer_TransientProcess.hxx>
#include <Interface_InterfaceModel.hxx>
#include <iostream>
 
EXPORT IFSelect_ReturnStatus _wrap_XSControl_Reader_ReadFile (XSControl_Reader *larg1, Standard_CString larg2) {
  IFSelect_ReturnStatus lresult = (IFSelect_ReturnStatus)0 ;
  XSControl_Reader *arg1 = (XSControl_Reader *) 0 ;
  Standard_CString arg2 = (Standard_CString) (Standard_CString)0 ;
  IFSelect_ReturnStatus result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (IFSelect_ReturnStatus)(arg1)->ReadFile(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: XSControl_Reader_ReadFile\n  * wrapname: _wrap_XSControl_Reader_ReadFile\n  * fulldecl: IFSelect_ReturnStatus XSControl_Reader::ReadFile(Standard_CString const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (IFSelect_ReturnStatus)0;
  }
}


EXPORT Standard_Integer _wrap_XSControl_Reader_TransferRoots (XSControl_Reader *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  XSControl_Reader *arg1 = (XSControl_Reader *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)(arg1)->TransferRoots();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: XSControl_Reader_TransferRoots\n  * wrapname: _wrap_XSControl_Reader_TransferRoots\n  * fulldecl: Standard_Integer XSControl_Reader::TransferRoots()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT void _wrap_XSControl_Reader_ClearShapes (XSControl_Reader *larg1) {
  XSControl_Reader *arg1 = (XSControl_Reader *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->ClearShapes();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: XSControl_Reader_ClearShapes\n  * wrapname: _wrap_XSControl_Reader_ClearShapes\n  * fulldecl: void XSControl_Reader::ClearShapes()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Integer _wrap_XSControl_Reader_NbRootsForTransfer (XSControl_Reader *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  XSControl_Reader *arg1 = (XSControl_Reader *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)(arg1)->NbRootsForTransfer();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: XSControl_Reader_NbRootsForTransfer\n  * wrapname: _wrap_XSControl_Reader_NbRootsForTransfer\n  * fulldecl: Standard_Integer XSControl_Reader::NbRootsForTransfer()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT TopoDS_Shape *_wrap_XSControl_Reader_OneShape (XSControl_Reader *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  XSControl_Reader *arg1 = (XSControl_Reader *) 0 ;
  TopoDS_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((XSControl_Reader const *)arg1)->OneShape();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: XSControl_Reader_OneShape\n  * wrapname: _wrap_XSControl_Reader_OneShape\n  * fulldecl: TopoDS_Shape XSControl_Reader::OneShape() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new TopoDS_Shape(result);
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT void _wrap_delete_XSControl_Reader (XSControl_Reader *larg1) {
  XSControl_Reader *arg1 = (XSControl_Reader *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_XSControl_Reader\n  * wrapname: _wrap_delete_XSControl_Reader\n  * fulldecl: XSControl_Reader::~XSControl_Reader()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT STEPControl_Reader *_wrap_new_STEPControl_Reader () {
  STEPControl_Reader * lresult = (STEPControl_Reader *)0 ;
  STEPControl_Reader *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (STEPControl_Reader *)new STEPControl_Reader();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_STEPControl_Reader\n  * wrapname: _wrap_new_STEPControl_Reader\n  * fulldecl: STEPControl_Reader::STEPControl_Reader()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (STEPControl_Reader *)0;
  }
}


SWIGINTERN char const *STEPControl_Reader_getLabel(STEPControl_Reader *self,TopoDS_Shape *theShape){
		const Handle(XSControl_WorkSession)& theSession = self->WS();
		const Handle(XSControl_TransferReader)& aReader = theSession->TransferReader();
		Handle(Standard_Transient) anEntity = aReader->EntityFromShapeResult(*theShape, 1);
		if (anEntity.IsNull()) {
			// as just mapped
			anEntity = aReader->EntityFromShapeResult (*theShape,-1);
		}

		if (anEntity.IsNull()) {
			// as anything
			anEntity = aReader->EntityFromShapeResult (*theShape,4);
		}

		if (anEntity.IsNull()) {
			cout<<"Warning: XSInterface_STEPReader::ReadAttributes() entity not found"<<endl;
			return NULL;
		}
		else 
		{
			Handle(StepRepr_RepresentationItem) aReprItem;
			aReprItem = Handle(StepRepr_RepresentationItem)::DownCast(anEntity);

			if (aReprItem.IsNull()) {
				cout<<"Error: STEPReader::ReadAttributes(): StepRepr_RepresentationItem Is NULL"<<endl;
				return NULL;
			}
			else 
				return aReprItem->Name()->ToCString();
		}
	}
EXPORT char *_wrap_STEPControl_Reader_getLabel (STEPControl_Reader *larg1, TopoDS_Shape *larg2) {
  char * lresult = (char *)0 ;
  STEPControl_Reader *arg1 = (STEPControl_Reader *) 0 ;
  TopoDS_Shape *arg2 = (TopoDS_Shape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (char *)STEPControl_Reader_getLabel(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: STEPControl_Reader_getLabel\n  * wrapname: _wrap_STEPControl_Reader_getLabel\n  * fulldecl: char const * STEPControl_Reader::getLabel(TopoDS_Shape *)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_STEPControl_Reader (STEPControl_Reader *larg1) {
  STEPControl_Reader *arg1 = (STEPControl_Reader *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_STEPControl_Reader\n  * wrapname: _wrap_delete_STEPControl_Reader\n  * fulldecl: STEPControl_Reader::~STEPControl_Reader()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT IGESControl_Reader *_wrap_new_IGESControl_Reader () {
  IGESControl_Reader * lresult = (IGESControl_Reader *)0 ;
  IGESControl_Reader *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (IGESControl_Reader *)new IGESControl_Reader();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_IGESControl_Reader\n  * wrapname: _wrap_new_IGESControl_Reader\n  * fulldecl: IGESControl_Reader::IGESControl_Reader()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (IGESControl_Reader *)0;
  }
}


SWIGINTERN char const *IGESControl_Reader_getLabel(IGESControl_Reader *self,TopoDS_Shape theShape){
		const Handle(XSControl_WorkSession)& theSession = self->WS();
		const Handle(Interface_InterfaceModel)& theModel = theSession->Model();
		const Handle(XSControl_TransferReader)& aReader = theSession->TransferReader();
		const Handle(Transfer_TransientProcess)& tp = aReader->TransientProcess();
		Standard_Integer nb = theModel->NbEntities(); 
		for(Standard_Integer i=1; i<=nb; i++) 
		{
			Handle(IGESData_IGESEntity) ent = Handle(IGESData_IGESEntity)::DownCast(theModel->Value(i));

			if (ent.IsNull())
				continue;

			Handle(Transfer_Binder) binder = tp->Find(ent); 

			if (binder.IsNull())
				continue;
			TopoDS_Shape oneShape = TransferBRep::ShapeResult(binder);
			if (oneShape.IsNull())
				continue;
			if (oneShape.IsEqual(theShape))
			{
				if (ent->HasName())
					return ent->NameValue()->String().ToCString();
				else
					return NULL; 
			}
		}
		return NULL; 
	}
EXPORT char *_wrap_IGESControl_Reader_getLabel (IGESControl_Reader *larg1, TopoDS_Shape *larg2) {
  char * lresult = (char *)0 ;
  IGESControl_Reader *arg1 = (IGESControl_Reader *) 0 ;
  TopoDS_Shape arg2 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = *larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (char *)IGESControl_Reader_getLabel(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: IGESControl_Reader_getLabel\n  * wrapname: _wrap_IGESControl_Reader_getLabel\n  * fulldecl: char const * IGESControl_Reader::getLabel(TopoDS_Shape)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


SWIGINTERN TopoDS_Shape IGESControl_Reader_getShape(IGESControl_Reader *self,char *shapeName){
		const TCollection_AsciiString ascShapeName(shapeName);
		const Handle(XSControl_WorkSession)& theSession = self->WS();
		const Handle(Interface_InterfaceModel)& theModel = theSession->Model();
		const Handle(XSControl_TransferReader)& aReader = theSession->TransferReader();
		const Handle(Transfer_TransientProcess)& tp = aReader->TransientProcess();
		Standard_Integer nb = theModel->NbEntities();
		TopoDS_Shape retShape; 
		for(Standard_Integer i=1; i<=nb; i++)
		{
			Handle(IGESData_IGESEntity) ent = Handle(IGESData_IGESEntity)::DownCast(theModel->Value(i));

			if (ent.IsNull())
				continue;
			Handle(Transfer_Binder) binder = tp->Find(ent);

			if (binder.IsNull())
				continue;
			TopoDS_Shape oneShape = TransferBRep::ShapeResult(binder);

			if (oneShape.IsNull())
				continue;

			if (ent->HasName() && ent->NameValue()->String().IsEqual(ascShapeName))
				retShape = oneShape;
		}
		return retShape; 
	}
EXPORT TopoDS_Shape *_wrap_IGESControl_Reader_getShape (IGESControl_Reader *larg1, char *larg2) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  IGESControl_Reader *arg1 = (IGESControl_Reader *) 0 ;
  char *arg2 = (char *) 0 ;
  TopoDS_Shape result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = IGESControl_Reader_getShape(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: IGESControl_Reader_getShape\n  * wrapname: _wrap_IGESControl_Reader_getShape\n  * fulldecl: TopoDS_Shape IGESControl_Reader::getShape(char *)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new TopoDS_Shape(result);
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


SWIGINTERN void IGESControl_Reader_dumpLabels(IGESControl_Reader *self){
		const Handle(XSControl_WorkSession)& theSession = self->WS();
		const Handle(Interface_InterfaceModel)& theModel = theSession->Model();
		Standard_Integer nb = theModel->NbEntities();
		for(Standard_Integer i=1; i<=nb; i++)
		{
			Handle(IGESData_IGESEntity) ent = Handle(IGESData_IGESEntity)::DownCast(theModel->Value(i));
			if (ent.IsNull()) continue;
			if (ent->HasName())
			{
				std::cout << ent->NameValue()->String().ToCString() << std::endl;
			}
		}
	}
EXPORT void _wrap_IGESControl_Reader_dumpLabels (IGESControl_Reader *larg1) {
  IGESControl_Reader *arg1 = (IGESControl_Reader *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        IGESControl_Reader_dumpLabels(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: IGESControl_Reader_dumpLabels\n  * wrapname: _wrap_IGESControl_Reader_dumpLabels\n  * fulldecl: void IGESControl_Reader::dumpLabels()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_IGESControl_Reader (IGESControl_Reader *larg1) {
  IGESControl_Reader *arg1 = (IGESControl_Reader *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_IGESControl_Reader\n  * wrapname: _wrap_delete_IGESControl_Reader\n  * fulldecl: IGESControl_Reader::~IGESControl_Reader()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <STEPControl_Writer.hxx>
 
EXPORT STEPControl_Writer *_wrap_new_STEPControl_Writer () {
  STEPControl_Writer * lresult = (STEPControl_Writer *)0 ;
  STEPControl_Writer *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (STEPControl_Writer *)new STEPControl_Writer();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_STEPControl_Writer\n  * wrapname: _wrap_new_STEPControl_Writer\n  * fulldecl: STEPControl_Writer::STEPControl_Writer()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (STEPControl_Writer *)0;
  }
}


EXPORT IFSelect_ReturnStatus _wrap_STEPControl_Writer_Write (STEPControl_Writer *larg1, Standard_CString larg2) {
  IFSelect_ReturnStatus lresult = (IFSelect_ReturnStatus)0 ;
  STEPControl_Writer *arg1 = (STEPControl_Writer *) 0 ;
  Standard_CString arg2 = (Standard_CString) (Standard_CString)0 ;
  IFSelect_ReturnStatus result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (IFSelect_ReturnStatus)(arg1)->Write(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: STEPControl_Writer_Write\n  * wrapname: _wrap_STEPControl_Writer_Write\n  * fulldecl: IFSelect_ReturnStatus STEPControl_Writer::Write(Standard_CString const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (IFSelect_ReturnStatus)0;
  }
}


EXPORT IFSelect_ReturnStatus _wrap_STEPControl_Writer_Transfer (STEPControl_Writer *larg1, TopoDS_Shape *larg2, STEPControl_StepModelType larg3) {
  IFSelect_ReturnStatus lresult = (IFSelect_ReturnStatus)0 ;
  STEPControl_Writer *arg1 = (STEPControl_Writer *) 0 ;
  TopoDS_Shape arg2 ;
  STEPControl_StepModelType arg3 ;
  IFSelect_ReturnStatus result;
  
  arg1 = larg1;
  arg2 = *larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (IFSelect_ReturnStatus)(arg1)->Transfer(arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: STEPControl_Writer_Transfer\n  * wrapname: _wrap_STEPControl_Writer_Transfer\n  * fulldecl: IFSelect_ReturnStatus STEPControl_Writer::Transfer(TopoDS_Shape,STEPControl_StepModelType)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (IFSelect_ReturnStatus)0;
  }
}


EXPORT void _wrap_delete_STEPControl_Writer (STEPControl_Writer *larg1) {
  STEPControl_Writer *arg1 = (STEPControl_Writer *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_STEPControl_Writer\n  * wrapname: _wrap_delete_STEPControl_Writer\n  * fulldecl: STEPControl_Writer::~STEPControl_Writer()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <IGESControl_Writer.hxx>
 
EXPORT IGESControl_Writer *_wrap_new_IGESControl_Writer__SWIG_0 () {
  IGESControl_Writer * lresult = (IGESControl_Writer *)0 ;
  IGESControl_Writer *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (IGESControl_Writer *)new IGESControl_Writer();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_IGESControl_Writer\n  * wrapname: _wrap_new_IGESControl_Writer__SWIG_0\n  * fulldecl: IGESControl_Writer::IGESControl_Writer()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (IGESControl_Writer *)0;
  }
}


EXPORT IGESControl_Writer *_wrap_new_IGESControl_Writer__SWIG_1 (Standard_CString larg1, Standard_Integer larg2) {
  IGESControl_Writer * lresult = (IGESControl_Writer *)0 ;
  Standard_CString arg1 = (Standard_CString) (Standard_CString)0 ;
  Standard_Integer arg2 ;
  IGESControl_Writer *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (IGESControl_Writer *)new IGESControl_Writer(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_IGESControl_Writer\n  * wrapname: _wrap_new_IGESControl_Writer__SWIG_1\n  * fulldecl: IGESControl_Writer::IGESControl_Writer(Standard_CString const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (IGESControl_Writer *)0;
  }
}


EXPORT IGESControl_Writer *_wrap_new_IGESControl_Writer__SWIG_2 (Standard_CString larg1) {
  IGESControl_Writer * lresult = (IGESControl_Writer *)0 ;
  Standard_CString arg1 = (Standard_CString) (Standard_CString)0 ;
  IGESControl_Writer *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (IGESControl_Writer *)new IGESControl_Writer(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_IGESControl_Writer\n  * wrapname: _wrap_new_IGESControl_Writer__SWIG_2\n  * fulldecl: IGESControl_Writer::IGESControl_Writer(Standard_CString const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (IGESControl_Writer *)0;
  }
}


EXPORT bool _wrap_IGESControl_Writer_Write (IGESControl_Writer *larg1, Standard_CString larg2) {
  bool lresult = (bool)0 ;
  IGESControl_Writer *arg1 = (IGESControl_Writer *) 0 ;
  Standard_CString arg2 = (Standard_CString) (Standard_CString)0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->Write(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: IGESControl_Writer_Write\n  * wrapname: _wrap_IGESControl_Writer_Write\n  * fulldecl: Standard_Boolean IGESControl_Writer::Write(Standard_CString const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_IGESControl_Writer_AddShape (IGESControl_Writer *larg1, TopoDS_Shape *larg2) {
  bool lresult = (bool)0 ;
  IGESControl_Writer *arg1 = (IGESControl_Writer *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->AddShape((TopoDS_Shape const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: IGESControl_Writer_AddShape\n  * wrapname: _wrap_IGESControl_Writer_AddShape\n  * fulldecl: Standard_Boolean IGESControl_Writer::AddShape(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_IGESControl_Writer_ComputeModel (IGESControl_Writer *larg1) {
  IGESControl_Writer *arg1 = (IGESControl_Writer *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->ComputeModel();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: IGESControl_Writer_ComputeModel\n  * wrapname: _wrap_IGESControl_Writer_ComputeModel\n  * fulldecl: void IGESControl_Writer::ComputeModel()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_IGESControl_Writer (IGESControl_Writer *larg1) {
  IGESControl_Writer *arg1 = (IGESControl_Writer *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_IGESControl_Writer\n  * wrapname: _wrap_delete_IGESControl_Writer\n  * fulldecl: IGESControl_Writer::~IGESControl_Writer()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <IGESControl_Controller.hxx>
 
EXPORT IGESControl_Controller *_wrap_new_IGESControl_Controller () {
  IGESControl_Controller * lresult = (IGESControl_Controller *)0 ;
  IGESControl_Controller *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (IGESControl_Controller *)new IGESControl_Controller();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_IGESControl_Controller\n  * wrapname: _wrap_new_IGESControl_Controller\n  * fulldecl: IGESControl_Controller::IGESControl_Controller()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (IGESControl_Controller *)0;
  }
}


EXPORT void _wrap_IGESControl_Controller_Init (IGESControl_Controller *larg1) {
  IGESControl_Controller *arg1 = (IGESControl_Controller *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: IGESControl_Controller_Init\n  * wrapname: _wrap_IGESControl_Controller_Init\n  * fulldecl: void IGESControl_Controller::Init()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_IGESControl_Controller (IGESControl_Controller *larg1) {
  IGESControl_Controller *arg1 = (IGESControl_Controller *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_IGESControl_Controller\n  * wrapname: _wrap_delete_IGESControl_Controller\n  * fulldecl: IGESControl_Controller::~IGESControl_Controller()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <ShapeFix_Wireframe.hxx>
#include <ShapeFix_Root.hxx>
#include <ShapeBuild_ReShape.hxx>
#include <Message_ProgressIndicator.hxx>
#include <ShapeFix_Shape.hxx>
#include <ShapeFix_Solid.hxx>
#include <ShapeFix_Shell.hxx>
#include <ShapeFix_Face.hxx>
#include <ShapeFix_Wire.hxx>
#include <ShapeFix_Edge.hxx>

EXPORT void _wrap_ShapeFix_Root_SetPrecision (ShapeFix_Root *larg1, Standard_Real larg2) {
  ShapeFix_Root *arg1 = (ShapeFix_Root *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetPrecision(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Root_SetPrecision\n  * wrapname: _wrap_ShapeFix_Root_SetPrecision\n  * fulldecl: void ShapeFix_Root::SetPrecision(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Real _wrap_ShapeFix_Root_Precision (ShapeFix_Root *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  ShapeFix_Root *arg1 = (ShapeFix_Root *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((ShapeFix_Root const *)arg1)->Precision();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Root_Precision\n  * wrapname: _wrap_ShapeFix_Root_Precision\n  * fulldecl: Standard_Real ShapeFix_Root::Precision() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_ShapeFix_Root_SetContext (ShapeFix_Root *larg1, ShapeBuild_ReShape *larg2) {
  ShapeFix_Root *arg1 = (ShapeFix_Root *) 0 ;
  ShapeBuild_ReShape *arg2 = (ShapeBuild_ReShape *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetContext((ShapeBuild_ReShape const *)arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Root_SetContext\n  * wrapname: _wrap_ShapeFix_Root_SetContext\n  * fulldecl: void ShapeFix_Root::SetContext(ShapeBuild_ReShape const *)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Handle_ShapeBuild_ReShape ShapeFix_Root_getContext(ShapeFix_Root *self){
        Handle_ShapeBuild_ReShape p = self->Context();
        return p;
    }
EXPORT Handle_ShapeBuild_ReShape *_wrap_ShapeFix_Root_getContext (ShapeFix_Root *larg1) {
  Handle_ShapeBuild_ReShape * lresult = (Handle_ShapeBuild_ReShape *)0 ;
  ShapeFix_Root *arg1 = (ShapeFix_Root *) 0 ;
  Handle_ShapeBuild_ReShape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ShapeFix_Root_getContext(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Root_getContext\n  * wrapname: _wrap_ShapeFix_Root_getContext\n  * fulldecl: Handle_ShapeBuild_ReShape ShapeFix_Root::getContext()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_ShapeBuild_ReShape(result);
    return lresult;
  } catch (...) {
    return (Handle_ShapeBuild_ReShape *)0;
  }
}


EXPORT void _wrap_delete_ShapeFix_Root (ShapeFix_Root *larg1) {
  ShapeFix_Root *arg1 = (ShapeFix_Root *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_ShapeFix_Root\n  * wrapname: _wrap_delete_ShapeFix_Root\n  * fulldecl: ShapeFix_Root::~ShapeFix_Root()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT ShapeFix_Wireframe *_wrap_new_ShapeFix_Wireframe (TopoDS_Shape *larg1) {
  ShapeFix_Wireframe * lresult = (ShapeFix_Wireframe *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  ShapeFix_Wireframe *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (ShapeFix_Wireframe *)new ShapeFix_Wireframe((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_ShapeFix_Wireframe\n  * wrapname: _wrap_new_ShapeFix_Wireframe\n  * fulldecl: ShapeFix_Wireframe::ShapeFix_Wireframe(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (ShapeFix_Wireframe *)0;
  }
}


EXPORT bool _wrap_ShapeFix_Wireframe_FixWireGaps (ShapeFix_Wireframe *larg1) {
  bool lresult = (bool)0 ;
  ShapeFix_Wireframe *arg1 = (ShapeFix_Wireframe *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->FixWireGaps();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Wireframe_FixWireGaps\n  * wrapname: _wrap_ShapeFix_Wireframe_FixWireGaps\n  * fulldecl: Standard_Boolean ShapeFix_Wireframe::FixWireGaps()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_ShapeFix_Wireframe_FixSmallEdges (ShapeFix_Wireframe *larg1) {
  bool lresult = (bool)0 ;
  ShapeFix_Wireframe *arg1 = (ShapeFix_Wireframe *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->FixSmallEdges();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Wireframe_FixSmallEdges\n  * wrapname: _wrap_ShapeFix_Wireframe_FixSmallEdges\n  * fulldecl: Standard_Boolean ShapeFix_Wireframe::FixSmallEdges()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_ShapeFix_Wireframe_SetLimitAngle (ShapeFix_Wireframe *larg1, Standard_Real larg2) {
  ShapeFix_Wireframe *arg1 = (ShapeFix_Wireframe *) 0 ;
  Standard_Real arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetLimitAngle(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Wireframe_SetLimitAngle\n  * wrapname: _wrap_ShapeFix_Wireframe_SetLimitAngle\n  * fulldecl: void ShapeFix_Wireframe::SetLimitAngle(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Real _wrap_ShapeFix_Wireframe_LimitAngle (ShapeFix_Wireframe *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  ShapeFix_Wireframe *arg1 = (ShapeFix_Wireframe *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((ShapeFix_Wireframe const *)arg1)->LimitAngle();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Wireframe_LimitAngle\n  * wrapname: _wrap_ShapeFix_Wireframe_LimitAngle\n  * fulldecl: Standard_Real ShapeFix_Wireframe::LimitAngle() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT TopoDS_Shape *_wrap_ShapeFix_Wireframe_Shape (ShapeFix_Wireframe *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  ShapeFix_Wireframe *arg1 = (ShapeFix_Wireframe *) 0 ;
  TopoDS_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (arg1)->Shape();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Wireframe_Shape\n  * wrapname: _wrap_ShapeFix_Wireframe_Shape\n  * fulldecl: TopoDS_Shape ShapeFix_Wireframe::Shape()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new TopoDS_Shape(result);
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


SWIGINTERN void ShapeFix_Wireframe_setDropSmallEdges(ShapeFix_Wireframe *self,bool b){
		self->ModeDropSmallEdges()=b;
	}
EXPORT void _wrap_ShapeFix_Wireframe_setDropSmallEdges (ShapeFix_Wireframe *larg1, bool larg2) {
  ShapeFix_Wireframe *arg1 = (ShapeFix_Wireframe *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ShapeFix_Wireframe_setDropSmallEdges(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Wireframe_setDropSmallEdges\n  * wrapname: _wrap_ShapeFix_Wireframe_setDropSmallEdges\n  * fulldecl: void ShapeFix_Wireframe::setDropSmallEdges(bool)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN bool ShapeFix_Wireframe_getDropSmallEdges(ShapeFix_Wireframe *self){
        return self->ModeDropSmallEdges()!=0;
	}
EXPORT bool _wrap_ShapeFix_Wireframe_getDropSmallEdges (ShapeFix_Wireframe *larg1) {
  bool lresult = (bool)0 ;
  ShapeFix_Wireframe *arg1 = (ShapeFix_Wireframe *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (bool)ShapeFix_Wireframe_getDropSmallEdges(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Wireframe_getDropSmallEdges\n  * wrapname: _wrap_ShapeFix_Wireframe_getDropSmallEdges\n  * fulldecl: bool ShapeFix_Wireframe::getDropSmallEdges()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_delete_ShapeFix_Wireframe (ShapeFix_Wireframe *larg1) {
  ShapeFix_Wireframe *arg1 = (ShapeFix_Wireframe *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_ShapeFix_Wireframe\n  * wrapname: _wrap_delete_ShapeFix_Wireframe\n  * fulldecl: ShapeFix_Wireframe::~ShapeFix_Wireframe()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT ShapeFix_Shape *_wrap_new_ShapeFix_Shape (TopoDS_Shape *larg1) {
  ShapeFix_Shape * lresult = (ShapeFix_Shape *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  ShapeFix_Shape *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (ShapeFix_Shape *)new ShapeFix_Shape((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_ShapeFix_Shape\n  * wrapname: _wrap_new_ShapeFix_Shape\n  * fulldecl: ShapeFix_Shape::ShapeFix_Shape(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (ShapeFix_Shape *)0;
  }
}


EXPORT TopoDS_Shape *_wrap_ShapeFix_Shape_Shape (ShapeFix_Shape *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  ShapeFix_Shape *arg1 = (ShapeFix_Shape *) 0 ;
  TopoDS_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((ShapeFix_Shape const *)arg1)->Shape();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Shape_Shape\n  * wrapname: _wrap_ShapeFix_Shape_Shape\n  * fulldecl: TopoDS_Shape ShapeFix_Shape::Shape() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new TopoDS_Shape(result);
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT bool _wrap_ShapeFix_Shape_Perform__SWIG_0 (ShapeFix_Shape *larg1, Handle_Message_ProgressIndicator *larg2) {
  bool lresult = (bool)0 ;
  ShapeFix_Shape *arg1 = (ShapeFix_Shape *) 0 ;
  Handle_Message_ProgressIndicator *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->Perform((Handle_Message_ProgressIndicator const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Shape_Perform\n  * wrapname: _wrap_ShapeFix_Shape_Perform__SWIG_0\n  * fulldecl: Standard_Boolean ShapeFix_Shape::Perform(Handle_Message_ProgressIndicator const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_ShapeFix_Shape_Perform__SWIG_1 (ShapeFix_Shape *larg1) {
  bool lresult = (bool)0 ;
  ShapeFix_Shape *arg1 = (ShapeFix_Shape *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->Perform();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Shape_Perform\n  * wrapname: _wrap_ShapeFix_Shape_Perform__SWIG_1\n  * fulldecl: Standard_Boolean ShapeFix_Shape::Perform()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Handle_ShapeFix_Solid *_wrap_ShapeFix_Shape_FixSolidTool (ShapeFix_Shape *larg1) {
  Handle_ShapeFix_Solid * lresult = (Handle_ShapeFix_Solid *)0 ;
  ShapeFix_Shape *arg1 = (ShapeFix_Shape *) 0 ;
  Handle_ShapeFix_Solid result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((ShapeFix_Shape const *)arg1)->FixSolidTool();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Shape_FixSolidTool\n  * wrapname: _wrap_ShapeFix_Shape_FixSolidTool\n  * fulldecl: Handle_ShapeFix_Solid ShapeFix_Shape::FixSolidTool() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_ShapeFix_Solid(result);
    return lresult;
  } catch (...) {
    return (Handle_ShapeFix_Solid *)0;
  }
}


EXPORT Handle_ShapeFix_Shell *_wrap_ShapeFix_Shape_FixShellTool (ShapeFix_Shape *larg1) {
  Handle_ShapeFix_Shell * lresult = (Handle_ShapeFix_Shell *)0 ;
  ShapeFix_Shape *arg1 = (ShapeFix_Shape *) 0 ;
  Handle_ShapeFix_Shell result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((ShapeFix_Shape const *)arg1)->FixShellTool();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Shape_FixShellTool\n  * wrapname: _wrap_ShapeFix_Shape_FixShellTool\n  * fulldecl: Handle_ShapeFix_Shell ShapeFix_Shape::FixShellTool() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_ShapeFix_Shell(result);
    return lresult;
  } catch (...) {
    return (Handle_ShapeFix_Shell *)0;
  }
}


EXPORT Handle_ShapeFix_Face *_wrap_ShapeFix_Shape_FixFaceTool (ShapeFix_Shape *larg1) {
  Handle_ShapeFix_Face * lresult = (Handle_ShapeFix_Face *)0 ;
  ShapeFix_Shape *arg1 = (ShapeFix_Shape *) 0 ;
  Handle_ShapeFix_Face result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((ShapeFix_Shape const *)arg1)->FixFaceTool();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Shape_FixFaceTool\n  * wrapname: _wrap_ShapeFix_Shape_FixFaceTool\n  * fulldecl: Handle_ShapeFix_Face ShapeFix_Shape::FixFaceTool() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_ShapeFix_Face(result);
    return lresult;
  } catch (...) {
    return (Handle_ShapeFix_Face *)0;
  }
}


EXPORT Handle_ShapeFix_Wire *_wrap_ShapeFix_Shape_FixWireTool (ShapeFix_Shape *larg1) {
  Handle_ShapeFix_Wire * lresult = (Handle_ShapeFix_Wire *)0 ;
  ShapeFix_Shape *arg1 = (ShapeFix_Shape *) 0 ;
  Handle_ShapeFix_Wire result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((ShapeFix_Shape const *)arg1)->FixWireTool();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Shape_FixWireTool\n  * wrapname: _wrap_ShapeFix_Shape_FixWireTool\n  * fulldecl: Handle_ShapeFix_Wire ShapeFix_Shape::FixWireTool() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_ShapeFix_Wire(result);
    return lresult;
  } catch (...) {
    return (Handle_ShapeFix_Wire *)0;
  }
}


EXPORT Handle_ShapeFix_Edge *_wrap_ShapeFix_Shape_FixEdgeTool (ShapeFix_Shape *larg1) {
  Handle_ShapeFix_Edge * lresult = (Handle_ShapeFix_Edge *)0 ;
  ShapeFix_Shape *arg1 = (ShapeFix_Shape *) 0 ;
  Handle_ShapeFix_Edge result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((ShapeFix_Shape const *)arg1)->FixEdgeTool();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeFix_Shape_FixEdgeTool\n  * wrapname: _wrap_ShapeFix_Shape_FixEdgeTool\n  * fulldecl: Handle_ShapeFix_Edge ShapeFix_Shape::FixEdgeTool() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_ShapeFix_Edge(result);
    return lresult;
  } catch (...) {
    return (Handle_ShapeFix_Edge *)0;
  }
}


EXPORT void _wrap_delete_ShapeFix_Shape (ShapeFix_Shape *larg1) {
  ShapeFix_Shape *arg1 = (ShapeFix_Shape *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_ShapeFix_Shape\n  * wrapname: _wrap_delete_ShapeFix_Shape\n  * fulldecl: ShapeFix_Shape::~ShapeFix_Shape()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_Message_ProgressIndicator (Handle_Message_ProgressIndicator *larg1) {
  Handle_Message_ProgressIndicator *arg1 = (Handle_Message_ProgressIndicator *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Message_ProgressIndicator\n  * wrapname: _wrap_delete_Message_ProgressIndicator\n  * fulldecl: Handle_Message_ProgressIndicator::~Handle_Message_ProgressIndicator()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <ShapeAnalysis_Edge.hxx>
#include <ShapeAnalysis_Surface.hxx>

EXPORT ShapeAnalysis_Edge *_wrap_new_ShapeAnalysis_Edge () {
  ShapeAnalysis_Edge * lresult = (ShapeAnalysis_Edge *)0 ;
  ShapeAnalysis_Edge *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (ShapeAnalysis_Edge *)new ShapeAnalysis_Edge();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_ShapeAnalysis_Edge\n  * wrapname: _wrap_new_ShapeAnalysis_Edge\n  * fulldecl: ShapeAnalysis_Edge::ShapeAnalysis_Edge()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (ShapeAnalysis_Edge *)0;
  }
}


EXPORT bool _wrap_ShapeAnalysis_Edge_IsClosed3d (ShapeAnalysis_Edge *larg1, TopoDS_Edge *larg2) {
  bool lresult = (bool)0 ;
  ShapeAnalysis_Edge *arg1 = (ShapeAnalysis_Edge *) 0 ;
  TopoDS_Edge *arg2 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((ShapeAnalysis_Edge const *)arg1)->IsClosed3d((TopoDS_Edge const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeAnalysis_Edge_IsClosed3d\n  * wrapname: _wrap_ShapeAnalysis_Edge_IsClosed3d\n  * fulldecl: Standard_Boolean ShapeAnalysis_Edge::IsClosed3d(TopoDS_Edge const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_ShapeAnalysis_Edge_HasPCurve (ShapeAnalysis_Edge *larg1, TopoDS_Edge *larg2, TopoDS_Face *larg3) {
  bool lresult = (bool)0 ;
  ShapeAnalysis_Edge *arg1 = (ShapeAnalysis_Edge *) 0 ;
  TopoDS_Edge *arg2 = 0 ;
  TopoDS_Face *arg3 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((ShapeAnalysis_Edge const *)arg1)->HasPCurve((TopoDS_Edge const &)*arg2,(TopoDS_Face const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeAnalysis_Edge_HasPCurve\n  * wrapname: _wrap_ShapeAnalysis_Edge_HasPCurve\n  * fulldecl: Standard_Boolean ShapeAnalysis_Edge::HasPCurve(TopoDS_Edge const &,TopoDS_Face const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_ShapeAnalysis_Edge_IsSeam (ShapeAnalysis_Edge *larg1, TopoDS_Edge *larg2, TopoDS_Face *larg3) {
  bool lresult = (bool)0 ;
  ShapeAnalysis_Edge *arg1 = (ShapeAnalysis_Edge *) 0 ;
  TopoDS_Edge *arg2 = 0 ;
  TopoDS_Face *arg3 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((ShapeAnalysis_Edge const *)arg1)->IsSeam((TopoDS_Edge const &)*arg2,(TopoDS_Face const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeAnalysis_Edge_IsSeam\n  * wrapname: _wrap_ShapeAnalysis_Edge_IsSeam\n  * fulldecl: Standard_Boolean ShapeAnalysis_Edge::IsSeam(TopoDS_Edge const &,TopoDS_Face const &) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_delete_ShapeAnalysis_Edge (ShapeAnalysis_Edge *larg1) {
  ShapeAnalysis_Edge *arg1 = (ShapeAnalysis_Edge *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_ShapeAnalysis_Edge\n  * wrapname: _wrap_delete_ShapeAnalysis_Edge\n  * fulldecl: ShapeAnalysis_Edge::~ShapeAnalysis_Edge()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT ShapeAnalysis_Surface *_wrap_new_ShapeAnalysis_Surface (Handle_Geom_Surface *larg1) {
  ShapeAnalysis_Surface * lresult = (ShapeAnalysis_Surface *)0 ;
  Handle_Geom_Surface *arg1 = 0 ;
  ShapeAnalysis_Surface *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (ShapeAnalysis_Surface *)new ShapeAnalysis_Surface((Handle_Geom_Surface const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_ShapeAnalysis_Surface\n  * wrapname: _wrap_new_ShapeAnalysis_Surface\n  * fulldecl: ShapeAnalysis_Surface::ShapeAnalysis_Surface(Handle_Geom_Surface const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (ShapeAnalysis_Surface *)0;
  }
}


EXPORT bool _wrap_ShapeAnalysis_Surface_HasSingularities (ShapeAnalysis_Surface *larg1, Standard_Real larg2) {
  bool lresult = (bool)0 ;
  ShapeAnalysis_Surface *arg1 = (ShapeAnalysis_Surface *) 0 ;
  Standard_Real arg2 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->HasSingularities(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeAnalysis_Surface_HasSingularities\n  * wrapname: _wrap_ShapeAnalysis_Surface_HasSingularities\n  * fulldecl: Standard_Boolean ShapeAnalysis_Surface::HasSingularities(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Standard_Integer _wrap_ShapeAnalysis_Surface_NbSingularities (ShapeAnalysis_Surface *larg1, Standard_Real larg2) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  ShapeAnalysis_Surface *arg1 = (ShapeAnalysis_Surface *) 0 ;
  Standard_Real arg2 ;
  Standard_Integer result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)(arg1)->NbSingularities(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeAnalysis_Surface_NbSingularities\n  * wrapname: _wrap_ShapeAnalysis_Surface_NbSingularities\n  * fulldecl: Standard_Integer ShapeAnalysis_Surface::NbSingularities(Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT bool _wrap_ShapeAnalysis_Surface_IsDegenerated (ShapeAnalysis_Surface *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  bool lresult = (bool)0 ;
  ShapeAnalysis_Surface *arg1 = (ShapeAnalysis_Surface *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->IsDegenerated((gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeAnalysis_Surface_IsDegenerated\n  * wrapname: _wrap_ShapeAnalysis_Surface_IsDegenerated\n  * fulldecl: Standard_Boolean ShapeAnalysis_Surface::IsDegenerated(gp_Pnt const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_delete_ShapeAnalysis_Surface (ShapeAnalysis_Surface *larg1) {
  ShapeAnalysis_Surface *arg1 = (ShapeAnalysis_Surface *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_ShapeAnalysis_Surface\n  * wrapname: _wrap_delete_ShapeAnalysis_Surface\n  * fulldecl: ShapeAnalysis_Surface::~ShapeAnalysis_Surface()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <APIHeaderSection_MakeHeader.hxx>
#include <StepData_StepModel.hxx>

EXPORT APIHeaderSection_MakeHeader *_wrap_new_APIHeaderSection_MakeHeader (Handle_StepData_StepModel *larg1) {
  APIHeaderSection_MakeHeader * lresult = (APIHeaderSection_MakeHeader *)0 ;
  Handle_StepData_StepModel *arg1 = 0 ;
  APIHeaderSection_MakeHeader *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (APIHeaderSection_MakeHeader *)new APIHeaderSection_MakeHeader((Handle_StepData_StepModel const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_APIHeaderSection_MakeHeader\n  * wrapname: _wrap_new_APIHeaderSection_MakeHeader\n  * fulldecl: APIHeaderSection_MakeHeader::APIHeaderSection_MakeHeader(Handle_StepData_StepModel const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (APIHeaderSection_MakeHeader *)0;
  }
}


EXPORT void _wrap_APIHeaderSection_MakeHeader_SetName (APIHeaderSection_MakeHeader *larg1, Handle_TCollection_HAsciiString *larg2) {
  APIHeaderSection_MakeHeader *arg1 = (APIHeaderSection_MakeHeader *) 0 ;
  Handle_TCollection_HAsciiString *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetName((Handle_TCollection_HAsciiString const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: APIHeaderSection_MakeHeader_SetName\n  * wrapname: _wrap_APIHeaderSection_MakeHeader_SetName\n  * fulldecl: void APIHeaderSection_MakeHeader::SetName(Handle_TCollection_HAsciiString const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_APIHeaderSection_MakeHeader_SetAuthorValue (APIHeaderSection_MakeHeader *larg1, Standard_Integer larg2, Handle_TCollection_HAsciiString *larg3) {
  APIHeaderSection_MakeHeader *arg1 = (APIHeaderSection_MakeHeader *) 0 ;
  Standard_Integer arg2 ;
  Handle_TCollection_HAsciiString *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetAuthorValue(arg2,(Handle_TCollection_HAsciiString const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: APIHeaderSection_MakeHeader_SetAuthorValue\n  * wrapname: _wrap_APIHeaderSection_MakeHeader_SetAuthorValue\n  * fulldecl: void APIHeaderSection_MakeHeader::SetAuthorValue(Standard_Integer const,Handle_TCollection_HAsciiString const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_APIHeaderSection_MakeHeader_SetOrganizationValue (APIHeaderSection_MakeHeader *larg1, Standard_Integer larg2, Handle_TCollection_HAsciiString *larg3) {
  APIHeaderSection_MakeHeader *arg1 = (APIHeaderSection_MakeHeader *) 0 ;
  Standard_Integer arg2 ;
  Handle_TCollection_HAsciiString *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetOrganizationValue(arg2,(Handle_TCollection_HAsciiString const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: APIHeaderSection_MakeHeader_SetOrganizationValue\n  * wrapname: _wrap_APIHeaderSection_MakeHeader_SetOrganizationValue\n  * fulldecl: void APIHeaderSection_MakeHeader::SetOrganizationValue(Standard_Integer const,Handle_TCollection_HAsciiString const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_APIHeaderSection_MakeHeader_SetOriginatingSystem (APIHeaderSection_MakeHeader *larg1, Handle_TCollection_HAsciiString *larg2) {
  APIHeaderSection_MakeHeader *arg1 = (APIHeaderSection_MakeHeader *) 0 ;
  Handle_TCollection_HAsciiString *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetOriginatingSystem((Handle_TCollection_HAsciiString const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: APIHeaderSection_MakeHeader_SetOriginatingSystem\n  * wrapname: _wrap_APIHeaderSection_MakeHeader_SetOriginatingSystem\n  * fulldecl: void APIHeaderSection_MakeHeader::SetOriginatingSystem(Handle_TCollection_HAsciiString const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_APIHeaderSection_MakeHeader_SetDescriptionValue (APIHeaderSection_MakeHeader *larg1, Standard_Integer larg2, Handle_TCollection_HAsciiString *larg3) {
  APIHeaderSection_MakeHeader *arg1 = (APIHeaderSection_MakeHeader *) 0 ;
  Standard_Integer arg2 ;
  Handle_TCollection_HAsciiString *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->SetDescriptionValue(arg2,(Handle_TCollection_HAsciiString const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: APIHeaderSection_MakeHeader_SetDescriptionValue\n  * wrapname: _wrap_APIHeaderSection_MakeHeader_SetDescriptionValue\n  * fulldecl: void APIHeaderSection_MakeHeader::SetDescriptionValue(Standard_Integer const,Handle_TCollection_HAsciiString const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_APIHeaderSection_MakeHeader (APIHeaderSection_MakeHeader *larg1) {
  APIHeaderSection_MakeHeader *arg1 = (APIHeaderSection_MakeHeader *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_APIHeaderSection_MakeHeader\n  * wrapname: _wrap_delete_APIHeaderSection_MakeHeader\n  * fulldecl: APIHeaderSection_MakeHeader::~APIHeaderSection_MakeHeader()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


 #include <ShapeUpgrade_RemoveInternalWires.hxx> 
 #include <ShapeUpgrade_Tool.hxx> 
 #include <ShapeUpgrade_ShapeDivideArea.hxx> 
EXPORT void _wrap_delete_ShapeUpgrade_Tool (ShapeUpgrade_Tool *larg1) {
  ShapeUpgrade_Tool *arg1 = (ShapeUpgrade_Tool *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_ShapeUpgrade_Tool\n  * wrapname: _wrap_delete_ShapeUpgrade_Tool\n  * fulldecl: ShapeUpgrade_Tool::~ShapeUpgrade_Tool()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT ShapeUpgrade_RemoveInternalWires *_wrap_new_ShapeUpgrade_RemoveInternalWires (TopoDS_Shape *larg1) {
  ShapeUpgrade_RemoveInternalWires * lresult = (ShapeUpgrade_RemoveInternalWires *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  ShapeUpgrade_RemoveInternalWires *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (ShapeUpgrade_RemoveInternalWires *)new ShapeUpgrade_RemoveInternalWires((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_ShapeUpgrade_RemoveInternalWires\n  * wrapname: _wrap_new_ShapeUpgrade_RemoveInternalWires\n  * fulldecl: ShapeUpgrade_RemoveInternalWires::ShapeUpgrade_RemoveInternalWires(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (ShapeUpgrade_RemoveInternalWires *)0;
  }
}


EXPORT bool _wrap_ShapeUpgrade_RemoveInternalWires_Perform (ShapeUpgrade_RemoveInternalWires *larg1) {
  bool lresult = (bool)0 ;
  ShapeUpgrade_RemoveInternalWires *arg1 = (ShapeUpgrade_RemoveInternalWires *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->Perform();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeUpgrade_RemoveInternalWires_Perform\n  * wrapname: _wrap_ShapeUpgrade_RemoveInternalWires_Perform\n  * fulldecl: Standard_Boolean ShapeUpgrade_RemoveInternalWires::Perform()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT TopoDS_Shape *_wrap_ShapeUpgrade_RemoveInternalWires_GetResult (ShapeUpgrade_RemoveInternalWires *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  ShapeUpgrade_RemoveInternalWires *arg1 = (ShapeUpgrade_RemoveInternalWires *) 0 ;
  TopoDS_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((ShapeUpgrade_RemoveInternalWires const *)arg1)->GetResult();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeUpgrade_RemoveInternalWires_GetResult\n  * wrapname: _wrap_ShapeUpgrade_RemoveInternalWires_GetResult\n  * fulldecl: TopoDS_Shape ShapeUpgrade_RemoveInternalWires::GetResult() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new TopoDS_Shape(result);
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


SWIGINTERN void ShapeUpgrade_RemoveInternalWires_setMinArea(ShapeUpgrade_RemoveInternalWires *self,double d){
		self->MinArea()=d;
	}
EXPORT void _wrap_ShapeUpgrade_RemoveInternalWires_setMinArea (ShapeUpgrade_RemoveInternalWires *larg1, double larg2) {
  ShapeUpgrade_RemoveInternalWires *arg1 = (ShapeUpgrade_RemoveInternalWires *) 0 ;
  double arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ShapeUpgrade_RemoveInternalWires_setMinArea(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeUpgrade_RemoveInternalWires_setMinArea\n  * wrapname: _wrap_ShapeUpgrade_RemoveInternalWires_setMinArea\n  * fulldecl: void ShapeUpgrade_RemoveInternalWires::setMinArea(double)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN double ShapeUpgrade_RemoveInternalWires_getMinArea(ShapeUpgrade_RemoveInternalWires *self){
		return self->MinArea();
	}
EXPORT double _wrap_ShapeUpgrade_RemoveInternalWires_getMinArea (ShapeUpgrade_RemoveInternalWires *larg1) {
  double lresult = (double)0 ;
  ShapeUpgrade_RemoveInternalWires *arg1 = (ShapeUpgrade_RemoveInternalWires *) 0 ;
  double result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (double)ShapeUpgrade_RemoveInternalWires_getMinArea(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeUpgrade_RemoveInternalWires_getMinArea\n  * wrapname: _wrap_ShapeUpgrade_RemoveInternalWires_getMinArea\n  * fulldecl: double ShapeUpgrade_RemoveInternalWires::getMinArea()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (double)0;
  }
}


SWIGINTERN void ShapeUpgrade_RemoveInternalWires_setRemoveFaceMode(ShapeUpgrade_RemoveInternalWires *self,Standard_Boolean b){
		self->RemoveFaceMode()=b;
	}
EXPORT void _wrap_ShapeUpgrade_RemoveInternalWires_setRemoveFaceMode (ShapeUpgrade_RemoveInternalWires *larg1, bool larg2) {
  ShapeUpgrade_RemoveInternalWires *arg1 = (ShapeUpgrade_RemoveInternalWires *) 0 ;
  Standard_Boolean arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ShapeUpgrade_RemoveInternalWires_setRemoveFaceMode(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeUpgrade_RemoveInternalWires_setRemoveFaceMode\n  * wrapname: _wrap_ShapeUpgrade_RemoveInternalWires_setRemoveFaceMode\n  * fulldecl: void ShapeUpgrade_RemoveInternalWires::setRemoveFaceMode(Standard_Boolean)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN Standard_Boolean ShapeUpgrade_RemoveInternalWires_getRemoveFaceMode(ShapeUpgrade_RemoveInternalWires *self){
		return self->RemoveFaceMode();
	}
EXPORT bool _wrap_ShapeUpgrade_RemoveInternalWires_getRemoveFaceMode (ShapeUpgrade_RemoveInternalWires *larg1) {
  bool lresult = (bool)0 ;
  ShapeUpgrade_RemoveInternalWires *arg1 = (ShapeUpgrade_RemoveInternalWires *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)ShapeUpgrade_RemoveInternalWires_getRemoveFaceMode(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeUpgrade_RemoveInternalWires_getRemoveFaceMode\n  * wrapname: _wrap_ShapeUpgrade_RemoveInternalWires_getRemoveFaceMode\n  * fulldecl: Standard_Boolean ShapeUpgrade_RemoveInternalWires::getRemoveFaceMode()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_delete_ShapeUpgrade_RemoveInternalWires (ShapeUpgrade_RemoveInternalWires *larg1) {
  ShapeUpgrade_RemoveInternalWires *arg1 = (ShapeUpgrade_RemoveInternalWires *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_ShapeUpgrade_RemoveInternalWires\n  * wrapname: _wrap_delete_ShapeUpgrade_RemoveInternalWires\n  * fulldecl: ShapeUpgrade_RemoveInternalWires::~ShapeUpgrade_RemoveInternalWires()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopoDS_Shape *_wrap_ShapeUpgrade_ShapeDivide_Result (ShapeUpgrade_ShapeDivide *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  ShapeUpgrade_ShapeDivide *arg1 = (ShapeUpgrade_ShapeDivide *) 0 ;
  TopoDS_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((ShapeUpgrade_ShapeDivide const *)arg1)->Result();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeUpgrade_ShapeDivide_Result\n  * wrapname: _wrap_ShapeUpgrade_ShapeDivide_Result\n  * fulldecl: TopoDS_Shape ShapeUpgrade_ShapeDivide::Result() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new TopoDS_Shape(result);
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT bool _wrap_ShapeUpgrade_ShapeDivide_Perform__SWIG_0 (ShapeUpgrade_ShapeDivide *larg1, bool larg2) {
  bool lresult = (bool)0 ;
  ShapeUpgrade_ShapeDivide *arg1 = (ShapeUpgrade_ShapeDivide *) 0 ;
  Standard_Boolean arg2 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->Perform(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeUpgrade_ShapeDivide_Perform\n  * wrapname: _wrap_ShapeUpgrade_ShapeDivide_Perform__SWIG_0\n  * fulldecl: Standard_Boolean ShapeUpgrade_ShapeDivide::Perform(Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_ShapeUpgrade_ShapeDivide_Perform__SWIG_1 (ShapeUpgrade_ShapeDivide *larg1) {
  bool lresult = (bool)0 ;
  ShapeUpgrade_ShapeDivide *arg1 = (ShapeUpgrade_ShapeDivide *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->Perform();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeUpgrade_ShapeDivide_Perform\n  * wrapname: _wrap_ShapeUpgrade_ShapeDivide_Perform__SWIG_1\n  * fulldecl: Standard_Boolean ShapeUpgrade_ShapeDivide::Perform()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_delete_ShapeUpgrade_ShapeDivide (ShapeUpgrade_ShapeDivide *larg1) {
  ShapeUpgrade_ShapeDivide *arg1 = (ShapeUpgrade_ShapeDivide *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_ShapeUpgrade_ShapeDivide\n  * wrapname: _wrap_delete_ShapeUpgrade_ShapeDivide\n  * fulldecl: ShapeUpgrade_ShapeDivide::~ShapeUpgrade_ShapeDivide()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT ShapeUpgrade_ShapeDivideArea *_wrap_new_ShapeUpgrade_ShapeDivideArea (TopoDS_Shape *larg1) {
  ShapeUpgrade_ShapeDivideArea * lresult = (ShapeUpgrade_ShapeDivideArea *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  ShapeUpgrade_ShapeDivideArea *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (ShapeUpgrade_ShapeDivideArea *)new ShapeUpgrade_ShapeDivideArea((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_ShapeUpgrade_ShapeDivideArea\n  * wrapname: _wrap_new_ShapeUpgrade_ShapeDivideArea\n  * fulldecl: ShapeUpgrade_ShapeDivideArea::ShapeUpgrade_ShapeDivideArea(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (ShapeUpgrade_ShapeDivideArea *)0;
  }
}


SWIGINTERN void ShapeUpgrade_ShapeDivideArea_setMaxArea(ShapeUpgrade_ShapeDivideArea *self,double d){
		self->MaxArea()=d;
	}
EXPORT void _wrap_ShapeUpgrade_ShapeDivideArea_setMaxArea (ShapeUpgrade_ShapeDivideArea *larg1, double larg2) {
  ShapeUpgrade_ShapeDivideArea *arg1 = (ShapeUpgrade_ShapeDivideArea *) 0 ;
  double arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ShapeUpgrade_ShapeDivideArea_setMaxArea(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeUpgrade_ShapeDivideArea_setMaxArea\n  * wrapname: _wrap_ShapeUpgrade_ShapeDivideArea_setMaxArea\n  * fulldecl: void ShapeUpgrade_ShapeDivideArea::setMaxArea(double)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


SWIGINTERN double ShapeUpgrade_ShapeDivideArea_getMaxArea(ShapeUpgrade_ShapeDivideArea *self){
		return self->MaxArea();
	}
EXPORT double _wrap_ShapeUpgrade_ShapeDivideArea_getMaxArea (ShapeUpgrade_ShapeDivideArea *larg1) {
  double lresult = (double)0 ;
  ShapeUpgrade_ShapeDivideArea *arg1 = (ShapeUpgrade_ShapeDivideArea *) 0 ;
  double result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (double)ShapeUpgrade_ShapeDivideArea_getMaxArea(arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeUpgrade_ShapeDivideArea_getMaxArea\n  * wrapname: _wrap_ShapeUpgrade_ShapeDivideArea_getMaxArea\n  * fulldecl: double ShapeUpgrade_ShapeDivideArea::getMaxArea()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (double)0;
  }
}


EXPORT void _wrap_delete_ShapeUpgrade_ShapeDivideArea (ShapeUpgrade_ShapeDivideArea *larg1) {
  ShapeUpgrade_ShapeDivideArea *arg1 = (ShapeUpgrade_ShapeDivideArea *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_ShapeUpgrade_ShapeDivideArea\n  * wrapname: _wrap_delete_ShapeUpgrade_ShapeDivideArea\n  * fulldecl: ShapeUpgrade_ShapeDivideArea::~ShapeUpgrade_ShapeDivideArea()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include <GeomAPI_PointsToBSpline.hxx>
#include <GeomAPI_Interpolate.hxx>
EXPORT GeomAPI_PointsToBSpline *_wrap_new_GeomAPI_PointsToBSpline__SWIG_0 () {
  GeomAPI_PointsToBSpline * lresult = (GeomAPI_PointsToBSpline *)0 ;
  GeomAPI_PointsToBSpline *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAPI_PointsToBSpline *)new GeomAPI_PointsToBSpline();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GeomAPI_PointsToBSpline\n  * wrapname: _wrap_new_GeomAPI_PointsToBSpline__SWIG_0\n  * fulldecl: GeomAPI_PointsToBSpline::GeomAPI_PointsToBSpline()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAPI_PointsToBSpline *)0;
  }
}


EXPORT GeomAPI_PointsToBSpline *_wrap_new_GeomAPI_PointsToBSpline__SWIG_1 (TColgp_Array1OfPnt *larg1, Standard_Integer larg2, Standard_Integer larg3, GeomAbs_Shape larg4, Standard_Real larg5) {
  GeomAPI_PointsToBSpline * lresult = (GeomAPI_PointsToBSpline *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  GeomAbs_Shape arg4 ;
  Standard_Real arg5 ;
  GeomAPI_PointsToBSpline *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAPI_PointsToBSpline *)new GeomAPI_PointsToBSpline((TColgp_Array1OfPnt const &)*arg1,arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GeomAPI_PointsToBSpline\n  * wrapname: _wrap_new_GeomAPI_PointsToBSpline__SWIG_1\n  * fulldecl: GeomAPI_PointsToBSpline::GeomAPI_PointsToBSpline(TColgp_Array1OfPnt const &,Standard_Integer const,Standard_Integer const,GeomAbs_Shape const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAPI_PointsToBSpline *)0;
  }
}


EXPORT GeomAPI_PointsToBSpline *_wrap_new_GeomAPI_PointsToBSpline__SWIG_2 (TColgp_Array1OfPnt *larg1, Standard_Integer larg2, Standard_Integer larg3, GeomAbs_Shape larg4) {
  GeomAPI_PointsToBSpline * lresult = (GeomAPI_PointsToBSpline *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  GeomAbs_Shape arg4 ;
  GeomAPI_PointsToBSpline *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAPI_PointsToBSpline *)new GeomAPI_PointsToBSpline((TColgp_Array1OfPnt const &)*arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GeomAPI_PointsToBSpline\n  * wrapname: _wrap_new_GeomAPI_PointsToBSpline__SWIG_2\n  * fulldecl: GeomAPI_PointsToBSpline::GeomAPI_PointsToBSpline(TColgp_Array1OfPnt const &,Standard_Integer const,Standard_Integer const,GeomAbs_Shape const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAPI_PointsToBSpline *)0;
  }
}


EXPORT GeomAPI_PointsToBSpline *_wrap_new_GeomAPI_PointsToBSpline__SWIG_3 (TColgp_Array1OfPnt *larg1, Standard_Integer larg2, Standard_Integer larg3) {
  GeomAPI_PointsToBSpline * lresult = (GeomAPI_PointsToBSpline *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  Standard_Integer arg2 ;
  Standard_Integer arg3 ;
  GeomAPI_PointsToBSpline *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAPI_PointsToBSpline *)new GeomAPI_PointsToBSpline((TColgp_Array1OfPnt const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GeomAPI_PointsToBSpline\n  * wrapname: _wrap_new_GeomAPI_PointsToBSpline__SWIG_3\n  * fulldecl: GeomAPI_PointsToBSpline::GeomAPI_PointsToBSpline(TColgp_Array1OfPnt const &,Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAPI_PointsToBSpline *)0;
  }
}


EXPORT GeomAPI_PointsToBSpline *_wrap_new_GeomAPI_PointsToBSpline__SWIG_4 (TColgp_Array1OfPnt *larg1, Standard_Integer larg2) {
  GeomAPI_PointsToBSpline * lresult = (GeomAPI_PointsToBSpline *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  Standard_Integer arg2 ;
  GeomAPI_PointsToBSpline *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAPI_PointsToBSpline *)new GeomAPI_PointsToBSpline((TColgp_Array1OfPnt const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GeomAPI_PointsToBSpline\n  * wrapname: _wrap_new_GeomAPI_PointsToBSpline__SWIG_4\n  * fulldecl: GeomAPI_PointsToBSpline::GeomAPI_PointsToBSpline(TColgp_Array1OfPnt const &,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAPI_PointsToBSpline *)0;
  }
}


EXPORT GeomAPI_PointsToBSpline *_wrap_new_GeomAPI_PointsToBSpline__SWIG_5 (TColgp_Array1OfPnt *larg1) {
  GeomAPI_PointsToBSpline * lresult = (GeomAPI_PointsToBSpline *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  GeomAPI_PointsToBSpline *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAPI_PointsToBSpline *)new GeomAPI_PointsToBSpline((TColgp_Array1OfPnt const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GeomAPI_PointsToBSpline\n  * wrapname: _wrap_new_GeomAPI_PointsToBSpline__SWIG_5\n  * fulldecl: GeomAPI_PointsToBSpline::GeomAPI_PointsToBSpline(TColgp_Array1OfPnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAPI_PointsToBSpline *)0;
  }
}


EXPORT GeomAPI_PointsToBSpline *_wrap_new_GeomAPI_PointsToBSpline__SWIG_6 (TColgp_Array1OfPnt *larg1, TColStd_Array1OfReal *larg2, Standard_Integer larg3, Standard_Integer larg4, GeomAbs_Shape larg5, Standard_Real larg6) {
  GeomAPI_PointsToBSpline * lresult = (GeomAPI_PointsToBSpline *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  Standard_Integer arg3 ;
  Standard_Integer arg4 ;
  GeomAbs_Shape arg5 ;
  Standard_Real arg6 ;
  GeomAPI_PointsToBSpline *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAPI_PointsToBSpline *)new GeomAPI_PointsToBSpline((TColgp_Array1OfPnt const &)*arg1,(TColStd_Array1OfReal const &)*arg2,arg3,arg4,arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GeomAPI_PointsToBSpline\n  * wrapname: _wrap_new_GeomAPI_PointsToBSpline__SWIG_6\n  * fulldecl: GeomAPI_PointsToBSpline::GeomAPI_PointsToBSpline(TColgp_Array1OfPnt const &,TColStd_Array1OfReal const &,Standard_Integer const,Standard_Integer const,GeomAbs_Shape const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAPI_PointsToBSpline *)0;
  }
}


EXPORT GeomAPI_PointsToBSpline *_wrap_new_GeomAPI_PointsToBSpline__SWIG_7 (TColgp_Array1OfPnt *larg1, TColStd_Array1OfReal *larg2, Standard_Integer larg3, Standard_Integer larg4, GeomAbs_Shape larg5) {
  GeomAPI_PointsToBSpline * lresult = (GeomAPI_PointsToBSpline *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  Standard_Integer arg3 ;
  Standard_Integer arg4 ;
  GeomAbs_Shape arg5 ;
  GeomAPI_PointsToBSpline *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAPI_PointsToBSpline *)new GeomAPI_PointsToBSpline((TColgp_Array1OfPnt const &)*arg1,(TColStd_Array1OfReal const &)*arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GeomAPI_PointsToBSpline\n  * wrapname: _wrap_new_GeomAPI_PointsToBSpline__SWIG_7\n  * fulldecl: GeomAPI_PointsToBSpline::GeomAPI_PointsToBSpline(TColgp_Array1OfPnt const &,TColStd_Array1OfReal const &,Standard_Integer const,Standard_Integer const,GeomAbs_Shape const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAPI_PointsToBSpline *)0;
  }
}


EXPORT GeomAPI_PointsToBSpline *_wrap_new_GeomAPI_PointsToBSpline__SWIG_8 (TColgp_Array1OfPnt *larg1, TColStd_Array1OfReal *larg2, Standard_Integer larg3, Standard_Integer larg4) {
  GeomAPI_PointsToBSpline * lresult = (GeomAPI_PointsToBSpline *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  Standard_Integer arg3 ;
  Standard_Integer arg4 ;
  GeomAPI_PointsToBSpline *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAPI_PointsToBSpline *)new GeomAPI_PointsToBSpline((TColgp_Array1OfPnt const &)*arg1,(TColStd_Array1OfReal const &)*arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GeomAPI_PointsToBSpline\n  * wrapname: _wrap_new_GeomAPI_PointsToBSpline__SWIG_8\n  * fulldecl: GeomAPI_PointsToBSpline::GeomAPI_PointsToBSpline(TColgp_Array1OfPnt const &,TColStd_Array1OfReal const &,Standard_Integer const,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAPI_PointsToBSpline *)0;
  }
}


EXPORT GeomAPI_PointsToBSpline *_wrap_new_GeomAPI_PointsToBSpline__SWIG_9 (TColgp_Array1OfPnt *larg1, TColStd_Array1OfReal *larg2, Standard_Integer larg3) {
  GeomAPI_PointsToBSpline * lresult = (GeomAPI_PointsToBSpline *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  Standard_Integer arg3 ;
  GeomAPI_PointsToBSpline *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAPI_PointsToBSpline *)new GeomAPI_PointsToBSpline((TColgp_Array1OfPnt const &)*arg1,(TColStd_Array1OfReal const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GeomAPI_PointsToBSpline\n  * wrapname: _wrap_new_GeomAPI_PointsToBSpline__SWIG_9\n  * fulldecl: GeomAPI_PointsToBSpline::GeomAPI_PointsToBSpline(TColgp_Array1OfPnt const &,TColStd_Array1OfReal const &,Standard_Integer const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAPI_PointsToBSpline *)0;
  }
}


EXPORT GeomAPI_PointsToBSpline *_wrap_new_GeomAPI_PointsToBSpline__SWIG_10 (TColgp_Array1OfPnt *larg1, TColStd_Array1OfReal *larg2) {
  GeomAPI_PointsToBSpline * lresult = (GeomAPI_PointsToBSpline *)0 ;
  TColgp_Array1OfPnt *arg1 = 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  GeomAPI_PointsToBSpline *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAPI_PointsToBSpline *)new GeomAPI_PointsToBSpline((TColgp_Array1OfPnt const &)*arg1,(TColStd_Array1OfReal const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GeomAPI_PointsToBSpline\n  * wrapname: _wrap_new_GeomAPI_PointsToBSpline__SWIG_10\n  * fulldecl: GeomAPI_PointsToBSpline::GeomAPI_PointsToBSpline(TColgp_Array1OfPnt const &,TColStd_Array1OfReal const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAPI_PointsToBSpline *)0;
  }
}


EXPORT Handle_Geom_BSplineCurve *_wrap_GeomAPI_PointsToBSpline_Curve (GeomAPI_PointsToBSpline *larg1) {
  Handle_Geom_BSplineCurve * lresult = (Handle_Geom_BSplineCurve *)0 ;
  GeomAPI_PointsToBSpline *arg1 = (GeomAPI_PointsToBSpline *) 0 ;
  Handle_Geom_BSplineCurve *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_BSplineCurve *) &((GeomAPI_PointsToBSpline const *)arg1)->Curve();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAPI_PointsToBSpline_Curve\n  * wrapname: _wrap_GeomAPI_PointsToBSpline_Curve\n  * fulldecl: Handle_Geom_BSplineCurve const & GeomAPI_PointsToBSpline::Curve() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_BSplineCurve *)0;
  }
}


EXPORT void _wrap_delete_GeomAPI_PointsToBSpline (GeomAPI_PointsToBSpline *larg1) {
  GeomAPI_PointsToBSpline *arg1 = (GeomAPI_PointsToBSpline *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_GeomAPI_PointsToBSpline\n  * wrapname: _wrap_delete_GeomAPI_PointsToBSpline\n  * fulldecl: GeomAPI_PointsToBSpline::~GeomAPI_PointsToBSpline()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT GeomAPI_Interpolate *_wrap_new_GeomAPI_Interpolate (Handle_TColgp_HArray1OfPnt *larg1, bool larg2, Standard_Real larg3) {
  GeomAPI_Interpolate * lresult = (GeomAPI_Interpolate *)0 ;
  Handle_TColgp_HArray1OfPnt *arg1 = 0 ;
  Standard_Boolean arg2 ;
  Standard_Real arg3 ;
  GeomAPI_Interpolate *result = 0 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAPI_Interpolate *)new GeomAPI_Interpolate((Handle_TColgp_HArray1OfPnt const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GeomAPI_Interpolate\n  * wrapname: _wrap_new_GeomAPI_Interpolate\n  * fulldecl: GeomAPI_Interpolate::GeomAPI_Interpolate(Handle_TColgp_HArray1OfPnt const &,Standard_Boolean const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAPI_Interpolate *)0;
  }
}


EXPORT void _wrap_GeomAPI_Interpolate_Load__SWIG_0 (GeomAPI_Interpolate *larg1, TColgp_Array1OfVec *larg2, Handle_TColStd_HArray1OfBoolean *larg3, bool larg4) {
  GeomAPI_Interpolate *arg1 = (GeomAPI_Interpolate *) 0 ;
  TColgp_Array1OfVec *arg2 = 0 ;
  Handle_TColStd_HArray1OfBoolean *arg3 = 0 ;
  Standard_Boolean arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Load((TColgp_Array1OfVec const &)*arg2,(Handle_TColStd_HArray1OfBoolean const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAPI_Interpolate_Load\n  * wrapname: _wrap_GeomAPI_Interpolate_Load__SWIG_0\n  * fulldecl: void GeomAPI_Interpolate::Load(TColgp_Array1OfVec const &,Handle_TColStd_HArray1OfBoolean const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_GeomAPI_Interpolate_Load__SWIG_1 (GeomAPI_Interpolate *larg1, TColgp_Array1OfVec *larg2, Handle_TColStd_HArray1OfBoolean *larg3) {
  GeomAPI_Interpolate *arg1 = (GeomAPI_Interpolate *) 0 ;
  TColgp_Array1OfVec *arg2 = 0 ;
  Handle_TColStd_HArray1OfBoolean *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Load((TColgp_Array1OfVec const &)*arg2,(Handle_TColStd_HArray1OfBoolean const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAPI_Interpolate_Load\n  * wrapname: _wrap_GeomAPI_Interpolate_Load__SWIG_1\n  * fulldecl: void GeomAPI_Interpolate::Load(TColgp_Array1OfVec const &,Handle_TColStd_HArray1OfBoolean const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_GeomAPI_Interpolate_Perform (GeomAPI_Interpolate *larg1) {
  GeomAPI_Interpolate *arg1 = (GeomAPI_Interpolate *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Perform();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAPI_Interpolate_Perform\n  * wrapname: _wrap_GeomAPI_Interpolate_Perform\n  * fulldecl: void GeomAPI_Interpolate::Perform()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Handle_Geom_BSplineCurve *_wrap_GeomAPI_Interpolate_Curve (GeomAPI_Interpolate *larg1) {
  Handle_Geom_BSplineCurve * lresult = (Handle_Geom_BSplineCurve *)0 ;
  GeomAPI_Interpolate *arg1 = (GeomAPI_Interpolate *) 0 ;
  Handle_Geom_BSplineCurve *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_BSplineCurve *) &((GeomAPI_Interpolate const *)arg1)->Curve();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAPI_Interpolate_Curve\n  * wrapname: _wrap_GeomAPI_Interpolate_Curve\n  * fulldecl: Handle_Geom_BSplineCurve const & GeomAPI_Interpolate::Curve() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_BSplineCurve *)0;
  }
}


EXPORT void _wrap_delete_GeomAPI_Interpolate (GeomAPI_Interpolate *larg1) {
  GeomAPI_Interpolate *arg1 = (GeomAPI_Interpolate *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_GeomAPI_Interpolate\n  * wrapname: _wrap_delete_GeomAPI_Interpolate\n  * fulldecl: GeomAPI_Interpolate::~GeomAPI_Interpolate()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include <GC_Root.hxx>
EXPORT bool _wrap_GC_Root_IsDone (GC_Root *larg1) {
  bool lresult = (bool)0 ;
  GC_Root *arg1 = (GC_Root *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((GC_Root const *)arg1)->IsDone();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GC_Root_IsDone\n  * wrapname: _wrap_GC_Root_IsDone\n  * fulldecl: Standard_Boolean GC_Root::IsDone() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT int _wrap_GC_Root_Status (GC_Root *larg1) {
  int lresult = (int)0 ;
  GC_Root *arg1 = (GC_Root *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (int)((GC_Root const *)arg1)->Status();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GC_Root_Status\n  * wrapname: _wrap_GC_Root_Status\n  * fulldecl: int GC_Root::Status() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_delete_GC_Root (GC_Root *larg1) {
  GC_Root *arg1 = (GC_Root *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_GC_Root\n  * wrapname: _wrap_delete_GC_Root\n  * fulldecl: GC_Root::~GC_Root()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include <GC_MakeArcOfCircle.hxx>
EXPORT GC_MakeArcOfCircle *_wrap_new_GC_MakeArcOfCircle__SWIG_0 (gp_Pnt *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  GC_MakeArcOfCircle * lresult = (GC_MakeArcOfCircle *)0 ;
  gp_Pnt *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  GC_MakeArcOfCircle *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GC_MakeArcOfCircle *)new GC_MakeArcOfCircle((gp_Pnt const &)*arg1,(gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GC_MakeArcOfCircle\n  * wrapname: _wrap_new_GC_MakeArcOfCircle__SWIG_0\n  * fulldecl: GC_MakeArcOfCircle::GC_MakeArcOfCircle(gp_Pnt const &,gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GC_MakeArcOfCircle *)0;
  }
}


EXPORT GC_MakeArcOfCircle *_wrap_new_GC_MakeArcOfCircle__SWIG_1 (gp_Circ *larg1, gp_Pnt *larg2, gp_Pnt *larg3, bool larg4) {
  GC_MakeArcOfCircle * lresult = (GC_MakeArcOfCircle *)0 ;
  gp_Circ *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  Standard_Boolean arg4 ;
  GC_MakeArcOfCircle *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GC_MakeArcOfCircle *)new GC_MakeArcOfCircle((gp_Circ const &)*arg1,(gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GC_MakeArcOfCircle\n  * wrapname: _wrap_new_GC_MakeArcOfCircle__SWIG_1\n  * fulldecl: GC_MakeArcOfCircle::GC_MakeArcOfCircle(gp_Circ const &,gp_Pnt const &,gp_Pnt const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GC_MakeArcOfCircle *)0;
  }
}


EXPORT Handle_Geom_TrimmedCurve *_wrap_GC_MakeArcOfCircle_Value (GC_MakeArcOfCircle *larg1) {
  Handle_Geom_TrimmedCurve * lresult = (Handle_Geom_TrimmedCurve *)0 ;
  GC_MakeArcOfCircle *arg1 = (GC_MakeArcOfCircle *) 0 ;
  Handle_Geom_TrimmedCurve *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_TrimmedCurve *) &((GC_MakeArcOfCircle const *)arg1)->Value();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GC_MakeArcOfCircle_Value\n  * wrapname: _wrap_GC_MakeArcOfCircle_Value\n  * fulldecl: Handle_Geom_TrimmedCurve const & GC_MakeArcOfCircle::Value() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_TrimmedCurve *)0;
  }
}


EXPORT void _wrap_delete_GC_MakeArcOfCircle (GC_MakeArcOfCircle *larg1) {
  GC_MakeArcOfCircle *arg1 = (GC_MakeArcOfCircle *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_GC_MakeArcOfCircle\n  * wrapname: _wrap_delete_GC_MakeArcOfCircle\n  * fulldecl: GC_MakeArcOfCircle::~GC_MakeArcOfCircle()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include <GC_MakeSegment.hxx>
EXPORT GC_MakeSegment *_wrap_new_GC_MakeSegment__SWIG_0 (gp_Pnt *larg1, gp_Pnt *larg2) {
  GC_MakeSegment * lresult = (GC_MakeSegment *)0 ;
  gp_Pnt *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  GC_MakeSegment *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GC_MakeSegment *)new GC_MakeSegment((gp_Pnt const &)*arg1,(gp_Pnt const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GC_MakeSegment\n  * wrapname: _wrap_new_GC_MakeSegment__SWIG_0\n  * fulldecl: GC_MakeSegment::GC_MakeSegment(gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GC_MakeSegment *)0;
  }
}


EXPORT GC_MakeSegment *_wrap_new_GC_MakeSegment__SWIG_1 (gp_Lin *larg1, Standard_Real larg2, Standard_Real larg3) {
  GC_MakeSegment * lresult = (GC_MakeSegment *)0 ;
  gp_Lin *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  GC_MakeSegment *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GC_MakeSegment *)new GC_MakeSegment((gp_Lin const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GC_MakeSegment\n  * wrapname: _wrap_new_GC_MakeSegment__SWIG_1\n  * fulldecl: GC_MakeSegment::GC_MakeSegment(gp_Lin const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GC_MakeSegment *)0;
  }
}


EXPORT GC_MakeSegment *_wrap_new_GC_MakeSegment__SWIG_2 (gp_Lin *larg1, gp_Pnt *larg2, Standard_Real larg3) {
  GC_MakeSegment * lresult = (GC_MakeSegment *)0 ;
  gp_Lin *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  Standard_Real arg3 ;
  GC_MakeSegment *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GC_MakeSegment *)new GC_MakeSegment((gp_Lin const &)*arg1,(gp_Pnt const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GC_MakeSegment\n  * wrapname: _wrap_new_GC_MakeSegment__SWIG_2\n  * fulldecl: GC_MakeSegment::GC_MakeSegment(gp_Lin const &,gp_Pnt const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GC_MakeSegment *)0;
  }
}


EXPORT GC_MakeSegment *_wrap_new_GC_MakeSegment__SWIG_3 (gp_Lin *larg1, gp_Pnt *larg2, gp_Pnt *larg3) {
  GC_MakeSegment * lresult = (GC_MakeSegment *)0 ;
  gp_Lin *arg1 = 0 ;
  gp_Pnt *arg2 = 0 ;
  gp_Pnt *arg3 = 0 ;
  GC_MakeSegment *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GC_MakeSegment *)new GC_MakeSegment((gp_Lin const &)*arg1,(gp_Pnt const &)*arg2,(gp_Pnt const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GC_MakeSegment\n  * wrapname: _wrap_new_GC_MakeSegment__SWIG_3\n  * fulldecl: GC_MakeSegment::GC_MakeSegment(gp_Lin const &,gp_Pnt const &,gp_Pnt const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GC_MakeSegment *)0;
  }
}


EXPORT Handle_Geom_TrimmedCurve *_wrap_GC_MakeSegment_Value (GC_MakeSegment *larg1) {
  Handle_Geom_TrimmedCurve * lresult = (Handle_Geom_TrimmedCurve *)0 ;
  GC_MakeSegment *arg1 = (GC_MakeSegment *) 0 ;
  Handle_Geom_TrimmedCurve *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom_TrimmedCurve *) &((GC_MakeSegment const *)arg1)->Value();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GC_MakeSegment_Value\n  * wrapname: _wrap_GC_MakeSegment_Value\n  * fulldecl: Handle_Geom_TrimmedCurve const & GC_MakeSegment::Value() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom_TrimmedCurve *)0;
  }
}


EXPORT void _wrap_delete_GC_MakeSegment (GC_MakeSegment *larg1) {
  GC_MakeSegment *arg1 = (GC_MakeSegment *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_GC_MakeSegment\n  * wrapname: _wrap_delete_GC_MakeSegment\n  * fulldecl: GC_MakeSegment::~GC_MakeSegment()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include <GCE2d_Root.hxx>
EXPORT bool _wrap_GCE2d_Root_IsDone (GCE2d_Root *larg1) {
  bool lresult = (bool)0 ;
  GCE2d_Root *arg1 = (GCE2d_Root *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((GCE2d_Root const *)arg1)->IsDone();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GCE2d_Root_IsDone\n  * wrapname: _wrap_GCE2d_Root_IsDone\n  * fulldecl: Standard_Boolean GCE2d_Root::IsDone() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT gce_ErrorType *_wrap_GCE2d_Root_Status (GCE2d_Root *larg1) {
  gce_ErrorType * lresult = (gce_ErrorType *)0 ;
  GCE2d_Root *arg1 = (GCE2d_Root *) 0 ;
  gce_ErrorType result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((GCE2d_Root const *)arg1)->Status();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GCE2d_Root_Status\n  * wrapname: _wrap_GCE2d_Root_Status\n  * fulldecl: gce_ErrorType GCE2d_Root::Status() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gce_ErrorType(result);
    return lresult;
  } catch (...) {
    return (gce_ErrorType *)0;
  }
}


EXPORT void _wrap_delete_GCE2d_Root (GCE2d_Root *larg1) {
  GCE2d_Root *arg1 = (GCE2d_Root *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_GCE2d_Root\n  * wrapname: _wrap_delete_GCE2d_Root\n  * fulldecl: GCE2d_Root::~GCE2d_Root()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include <GCE2d_MakeSegment.hxx>
EXPORT GCE2d_MakeSegment *_wrap_new_GCE2d_MakeSegment__SWIG_0 (gp_Pnt2d *larg1, gp_Pnt2d *larg2) {
  GCE2d_MakeSegment * lresult = (GCE2d_MakeSegment *)0 ;
  gp_Pnt2d *arg1 = 0 ;
  gp_Pnt2d *arg2 = 0 ;
  GCE2d_MakeSegment *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GCE2d_MakeSegment *)new GCE2d_MakeSegment((gp_Pnt2d const &)*arg1,(gp_Pnt2d const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GCE2d_MakeSegment\n  * wrapname: _wrap_new_GCE2d_MakeSegment__SWIG_0\n  * fulldecl: GCE2d_MakeSegment::GCE2d_MakeSegment(gp_Pnt2d const &,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GCE2d_MakeSegment *)0;
  }
}


EXPORT GCE2d_MakeSegment *_wrap_new_GCE2d_MakeSegment__SWIG_1 (gp_Pnt2d *larg1, gp_Dir2d *larg2, gp_Pnt2d *larg3) {
  GCE2d_MakeSegment * lresult = (GCE2d_MakeSegment *)0 ;
  gp_Pnt2d *arg1 = 0 ;
  gp_Dir2d *arg2 = 0 ;
  gp_Pnt2d *arg3 = 0 ;
  GCE2d_MakeSegment *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GCE2d_MakeSegment *)new GCE2d_MakeSegment((gp_Pnt2d const &)*arg1,(gp_Dir2d const &)*arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GCE2d_MakeSegment\n  * wrapname: _wrap_new_GCE2d_MakeSegment__SWIG_1\n  * fulldecl: GCE2d_MakeSegment::GCE2d_MakeSegment(gp_Pnt2d const &,gp_Dir2d const &,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GCE2d_MakeSegment *)0;
  }
}


EXPORT GCE2d_MakeSegment *_wrap_new_GCE2d_MakeSegment__SWIG_2 (gp_Lin2d *larg1, Standard_Real larg2, Standard_Real larg3) {
  GCE2d_MakeSegment * lresult = (GCE2d_MakeSegment *)0 ;
  gp_Lin2d *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  GCE2d_MakeSegment *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GCE2d_MakeSegment *)new GCE2d_MakeSegment((gp_Lin2d const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GCE2d_MakeSegment\n  * wrapname: _wrap_new_GCE2d_MakeSegment__SWIG_2\n  * fulldecl: GCE2d_MakeSegment::GCE2d_MakeSegment(gp_Lin2d const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GCE2d_MakeSegment *)0;
  }
}


EXPORT GCE2d_MakeSegment *_wrap_new_GCE2d_MakeSegment__SWIG_3 (gp_Lin2d *larg1, gp_Pnt2d *larg2, Standard_Real larg3) {
  GCE2d_MakeSegment * lresult = (GCE2d_MakeSegment *)0 ;
  gp_Lin2d *arg1 = 0 ;
  gp_Pnt2d *arg2 = 0 ;
  Standard_Real arg3 ;
  GCE2d_MakeSegment *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GCE2d_MakeSegment *)new GCE2d_MakeSegment((gp_Lin2d const &)*arg1,(gp_Pnt2d const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GCE2d_MakeSegment\n  * wrapname: _wrap_new_GCE2d_MakeSegment__SWIG_3\n  * fulldecl: GCE2d_MakeSegment::GCE2d_MakeSegment(gp_Lin2d const &,gp_Pnt2d const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GCE2d_MakeSegment *)0;
  }
}


EXPORT GCE2d_MakeSegment *_wrap_new_GCE2d_MakeSegment__SWIG_4 (gp_Lin2d *larg1, gp_Pnt2d *larg2, gp_Pnt2d *larg3) {
  GCE2d_MakeSegment * lresult = (GCE2d_MakeSegment *)0 ;
  gp_Lin2d *arg1 = 0 ;
  gp_Pnt2d *arg2 = 0 ;
  gp_Pnt2d *arg3 = 0 ;
  GCE2d_MakeSegment *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GCE2d_MakeSegment *)new GCE2d_MakeSegment((gp_Lin2d const &)*arg1,(gp_Pnt2d const &)*arg2,(gp_Pnt2d const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GCE2d_MakeSegment\n  * wrapname: _wrap_new_GCE2d_MakeSegment__SWIG_4\n  * fulldecl: GCE2d_MakeSegment::GCE2d_MakeSegment(gp_Lin2d const &,gp_Pnt2d const &,gp_Pnt2d const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GCE2d_MakeSegment *)0;
  }
}


EXPORT Handle_Geom2d_TrimmedCurve *_wrap_GCE2d_MakeSegment_Value (GCE2d_MakeSegment *larg1) {
  Handle_Geom2d_TrimmedCurve * lresult = (Handle_Geom2d_TrimmedCurve *)0 ;
  GCE2d_MakeSegment *arg1 = (GCE2d_MakeSegment *) 0 ;
  Handle_Geom2d_TrimmedCurve *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_TrimmedCurve *) &((GCE2d_MakeSegment const *)arg1)->Value();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GCE2d_MakeSegment_Value\n  * wrapname: _wrap_GCE2d_MakeSegment_Value\n  * fulldecl: Handle_Geom2d_TrimmedCurve const & GCE2d_MakeSegment::Value() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_TrimmedCurve *)0;
  }
}


EXPORT void _wrap_delete_GCE2d_MakeSegment (GCE2d_MakeSegment *larg1) {
  GCE2d_MakeSegment *arg1 = (GCE2d_MakeSegment *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_GCE2d_MakeSegment\n  * wrapname: _wrap_delete_GCE2d_MakeSegment\n  * fulldecl: GCE2d_MakeSegment::~GCE2d_MakeSegment()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



  #include <Adaptor2d_Curve2d.hxx>
  #include <Geom2dAdaptor_Curve.hxx>
  #include <Adaptor2d_HCurve2d.hxx>
 
EXPORT gp_Pnt2d *_wrap_Adaptor2d_Curve2d_Value (Adaptor2d_Curve2d *larg1, Standard_Real larg2) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Adaptor2d_Curve2d *arg1 = (Adaptor2d_Curve2d *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Adaptor2d_Curve2d const *)arg1)->Value(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_Curve2d_Value\n  * wrapname: _wrap_Adaptor2d_Curve2d_Value\n  * fulldecl: gp_Pnt2d Adaptor2d_Curve2d::Value(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT void _wrap_delete_Adaptor2d_Curve2d (Adaptor2d_Curve2d *larg1) {
  Adaptor2d_Curve2d *arg1 = (Adaptor2d_Curve2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Adaptor2d_Curve2d\n  * wrapname: _wrap_delete_Adaptor2d_Curve2d\n  * fulldecl: Adaptor2d_Curve2d::~Adaptor2d_Curve2d()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Geom2dAdaptor_Curve *_wrap_new_Geom2dAdaptor_Curve__SWIG_0 () {
  Geom2dAdaptor_Curve * lresult = (Geom2dAdaptor_Curve *)0 ;
  Geom2dAdaptor_Curve *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Geom2dAdaptor_Curve *)new Geom2dAdaptor_Curve();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2dAdaptor_Curve\n  * wrapname: _wrap_new_Geom2dAdaptor_Curve__SWIG_0\n  * fulldecl: Geom2dAdaptor_Curve::Geom2dAdaptor_Curve()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Geom2dAdaptor_Curve *)0;
  }
}


EXPORT Geom2dAdaptor_Curve *_wrap_new_Geom2dAdaptor_Curve__SWIG_1 (Handle_Geom2d_Curve *larg1) {
  Geom2dAdaptor_Curve * lresult = (Geom2dAdaptor_Curve *)0 ;
  Handle_Geom2d_Curve *arg1 = 0 ;
  Geom2dAdaptor_Curve *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Geom2dAdaptor_Curve *)new Geom2dAdaptor_Curve((Handle_Geom2d_Curve const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2dAdaptor_Curve\n  * wrapname: _wrap_new_Geom2dAdaptor_Curve__SWIG_1\n  * fulldecl: Geom2dAdaptor_Curve::Geom2dAdaptor_Curve(Handle_Geom2d_Curve const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Geom2dAdaptor_Curve *)0;
  }
}


EXPORT Geom2dAdaptor_Curve *_wrap_new_Geom2dAdaptor_Curve__SWIG_2 (Handle_Geom2d_Curve *larg1, Standard_Real larg2, Standard_Real larg3) {
  Geom2dAdaptor_Curve * lresult = (Geom2dAdaptor_Curve *)0 ;
  Handle_Geom2d_Curve *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Geom2dAdaptor_Curve *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Geom2dAdaptor_Curve *)new Geom2dAdaptor_Curve((Handle_Geom2d_Curve const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Geom2dAdaptor_Curve\n  * wrapname: _wrap_new_Geom2dAdaptor_Curve__SWIG_2\n  * fulldecl: Geom2dAdaptor_Curve::Geom2dAdaptor_Curve(Handle_Geom2d_Curve const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Geom2dAdaptor_Curve *)0;
  }
}


EXPORT void _wrap_Geom2dAdaptor_Curve_Load__SWIG_0 (Geom2dAdaptor_Curve *larg1, Handle_Geom2d_Curve *larg2) {
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Handle_Geom2d_Curve *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Load((Handle_Geom2d_Curve const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Load\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Load__SWIG_0\n  * fulldecl: void Geom2dAdaptor_Curve::Load(Handle_Geom2d_Curve const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Geom2dAdaptor_Curve_Load__SWIG_1 (Geom2dAdaptor_Curve *larg1, Handle_Geom2d_Curve *larg2, Standard_Real larg3, Standard_Real larg4) {
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Handle_Geom2d_Curve *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Load((Handle_Geom2d_Curve const &)*arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Load\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Load__SWIG_1\n  * fulldecl: void Geom2dAdaptor_Curve::Load(Handle_Geom2d_Curve const &,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Handle_Geom2d_Curve *_wrap_Geom2dAdaptor_Curve_Curve (Geom2dAdaptor_Curve *larg1) {
  Handle_Geom2d_Curve * lresult = (Handle_Geom2d_Curve *)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Handle_Geom2d_Curve *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Handle_Geom2d_Curve *) &((Geom2dAdaptor_Curve const *)arg1)->Curve();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Curve\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Curve\n  * fulldecl: Handle_Geom2d_Curve const & Geom2dAdaptor_Curve::Curve() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_Curve *)0;
  }
}


EXPORT Standard_Real _wrap_Geom2dAdaptor_Curve_FirstParameter (Geom2dAdaptor_Curve *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((Geom2dAdaptor_Curve const *)arg1)->FirstParameter();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_FirstParameter\n  * wrapname: _wrap_Geom2dAdaptor_Curve_FirstParameter\n  * fulldecl: Standard_Real Geom2dAdaptor_Curve::FirstParameter() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_Geom2dAdaptor_Curve_LastParameter (Geom2dAdaptor_Curve *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((Geom2dAdaptor_Curve const *)arg1)->LastParameter();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_LastParameter\n  * wrapname: _wrap_Geom2dAdaptor_Curve_LastParameter\n  * fulldecl: Standard_Real Geom2dAdaptor_Curve::LastParameter() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT GeomAbs_Shape _wrap_Geom2dAdaptor_Curve_Continuity (Geom2dAdaptor_Curve *larg1) {
  GeomAbs_Shape lresult = (GeomAbs_Shape)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  GeomAbs_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAbs_Shape)((Geom2dAdaptor_Curve const *)arg1)->Continuity();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Continuity\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Continuity\n  * fulldecl: GeomAbs_Shape Geom2dAdaptor_Curve::Continuity() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAbs_Shape)0;
  }
}


EXPORT Standard_Integer _wrap_Geom2dAdaptor_Curve_NbIntervals (Geom2dAdaptor_Curve *larg1, GeomAbs_Shape larg2) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  GeomAbs_Shape arg2 ;
  Standard_Integer result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((Geom2dAdaptor_Curve const *)arg1)->NbIntervals(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_NbIntervals\n  * wrapname: _wrap_Geom2dAdaptor_Curve_NbIntervals\n  * fulldecl: Standard_Integer Geom2dAdaptor_Curve::NbIntervals(GeomAbs_Shape const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT void _wrap_Geom2dAdaptor_Curve_Intervals (Geom2dAdaptor_Curve *larg1, TColStd_Array1OfReal *larg2, GeomAbs_Shape larg3) {
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  GeomAbs_Shape arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((Geom2dAdaptor_Curve const *)arg1)->Intervals(*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Intervals\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Intervals\n  * fulldecl: void Geom2dAdaptor_Curve::Intervals(TColStd_Array1OfReal &,GeomAbs_Shape const) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Handle_Adaptor2d_HCurve2d *_wrap_Geom2dAdaptor_Curve_Trim (Geom2dAdaptor_Curve *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4) {
  Handle_Adaptor2d_HCurve2d * lresult = (Handle_Adaptor2d_HCurve2d *)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Handle_Adaptor2d_HCurve2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Geom2dAdaptor_Curve const *)arg1)->Trim(arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Trim\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Trim\n  * fulldecl: Handle_Adaptor2d_HCurve2d Geom2dAdaptor_Curve::Trim(Standard_Real const,Standard_Real const,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Adaptor2d_HCurve2d(result);
    return lresult;
  } catch (...) {
    return (Handle_Adaptor2d_HCurve2d *)0;
  }
}


EXPORT bool _wrap_Geom2dAdaptor_Curve_IsClosed (Geom2dAdaptor_Curve *larg1) {
  bool lresult = (bool)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Geom2dAdaptor_Curve const *)arg1)->IsClosed();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_IsClosed\n  * wrapname: _wrap_Geom2dAdaptor_Curve_IsClosed\n  * fulldecl: Standard_Boolean Geom2dAdaptor_Curve::IsClosed() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_Geom2dAdaptor_Curve_IsPeriodic (Geom2dAdaptor_Curve *larg1) {
  bool lresult = (bool)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Geom2dAdaptor_Curve const *)arg1)->IsPeriodic();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_IsPeriodic\n  * wrapname: _wrap_Geom2dAdaptor_Curve_IsPeriodic\n  * fulldecl: Standard_Boolean Geom2dAdaptor_Curve::IsPeriodic() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Standard_Real _wrap_Geom2dAdaptor_Curve_Period (Geom2dAdaptor_Curve *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((Geom2dAdaptor_Curve const *)arg1)->Period();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Period\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Period\n  * fulldecl: Standard_Real Geom2dAdaptor_Curve::Period() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Pnt2d *_wrap_Geom2dAdaptor_Curve_Value (Geom2dAdaptor_Curve *larg1, Standard_Real larg2) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Geom2dAdaptor_Curve const *)arg1)->Value(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Value\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Value\n  * fulldecl: gp_Pnt2d Geom2dAdaptor_Curve::Value(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT void _wrap_Geom2dAdaptor_Curve_D0 (Geom2dAdaptor_Curve *larg1, Standard_Real larg2, gp_Pnt2d *larg3) {
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((Geom2dAdaptor_Curve const *)arg1)->D0(arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_D0\n  * wrapname: _wrap_Geom2dAdaptor_Curve_D0\n  * fulldecl: void Geom2dAdaptor_Curve::D0(Standard_Real const,gp_Pnt2d &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Geom2dAdaptor_Curve_D1 (Geom2dAdaptor_Curve *larg1, Standard_Real larg2, gp_Pnt2d *larg3, gp_Vec2d *larg4) {
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  gp_Vec2d *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((Geom2dAdaptor_Curve const *)arg1)->D1(arg2,*arg3,*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_D1\n  * wrapname: _wrap_Geom2dAdaptor_Curve_D1\n  * fulldecl: void Geom2dAdaptor_Curve::D1(Standard_Real const,gp_Pnt2d &,gp_Vec2d &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Geom2dAdaptor_Curve_D2 (Geom2dAdaptor_Curve *larg1, Standard_Real larg2, gp_Pnt2d *larg3, gp_Vec2d *larg4, gp_Vec2d *larg5) {
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  gp_Vec2d *arg4 = 0 ;
  gp_Vec2d *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((Geom2dAdaptor_Curve const *)arg1)->D2(arg2,*arg3,*arg4,*arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_D2\n  * wrapname: _wrap_Geom2dAdaptor_Curve_D2\n  * fulldecl: void Geom2dAdaptor_Curve::D2(Standard_Real const,gp_Pnt2d &,gp_Vec2d &,gp_Vec2d &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Geom2dAdaptor_Curve_D3 (Geom2dAdaptor_Curve *larg1, Standard_Real larg2, gp_Pnt2d *larg3, gp_Vec2d *larg4, gp_Vec2d *larg5, gp_Vec2d *larg6) {
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  gp_Vec2d *arg4 = 0 ;
  gp_Vec2d *arg5 = 0 ;
  gp_Vec2d *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((Geom2dAdaptor_Curve const *)arg1)->D3(arg2,*arg3,*arg4,*arg5,*arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_D3\n  * wrapname: _wrap_Geom2dAdaptor_Curve_D3\n  * fulldecl: void Geom2dAdaptor_Curve::D3(Standard_Real const,gp_Pnt2d &,gp_Vec2d &,gp_Vec2d &,gp_Vec2d &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec2d *_wrap_Geom2dAdaptor_Curve_DN (Geom2dAdaptor_Curve *larg1, Standard_Real larg2, Standard_Integer larg3) {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Real arg2 ;
  Standard_Integer arg3 ;
  gp_Vec2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Geom2dAdaptor_Curve const *)arg1)->DN(arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_DN\n  * wrapname: _wrap_Geom2dAdaptor_Curve_DN\n  * fulldecl: gp_Vec2d Geom2dAdaptor_Curve::DN(Standard_Real const,Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec2d(result);
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


EXPORT Standard_Real _wrap_Geom2dAdaptor_Curve_Resolution (Geom2dAdaptor_Curve *larg1, Standard_Real larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Real arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((Geom2dAdaptor_Curve const *)arg1)->Resolution(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Resolution\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Resolution\n  * fulldecl: Standard_Real Geom2dAdaptor_Curve::Resolution(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT GeomAbs_CurveType *_wrap_Geom2dAdaptor_Curve_GetType (Geom2dAdaptor_Curve *larg1) {
  GeomAbs_CurveType * lresult = (GeomAbs_CurveType *)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  GeomAbs_CurveType result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Geom2dAdaptor_Curve const *)arg1)->GetType();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_GetType\n  * wrapname: _wrap_Geom2dAdaptor_Curve_GetType\n  * fulldecl: GeomAbs_CurveType Geom2dAdaptor_Curve::GetType() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new GeomAbs_CurveType(result);
    return lresult;
  } catch (...) {
    return (GeomAbs_CurveType *)0;
  }
}


EXPORT gp_Lin2d *_wrap_Geom2dAdaptor_Curve_Line (Geom2dAdaptor_Curve *larg1) {
  gp_Lin2d * lresult = (gp_Lin2d *)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  gp_Lin2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Geom2dAdaptor_Curve const *)arg1)->Line();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Line\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Line\n  * fulldecl: gp_Lin2d Geom2dAdaptor_Curve::Line() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Lin2d(result);
    return lresult;
  } catch (...) {
    return (gp_Lin2d *)0;
  }
}


EXPORT gp_Circ2d *_wrap_Geom2dAdaptor_Curve_Circle (Geom2dAdaptor_Curve *larg1) {
  gp_Circ2d * lresult = (gp_Circ2d *)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  gp_Circ2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Geom2dAdaptor_Curve const *)arg1)->Circle();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Circle\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Circle\n  * fulldecl: gp_Circ2d Geom2dAdaptor_Curve::Circle() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Circ2d(result);
    return lresult;
  } catch (...) {
    return (gp_Circ2d *)0;
  }
}


EXPORT gp_Elips2d *_wrap_Geom2dAdaptor_Curve_Ellipse (Geom2dAdaptor_Curve *larg1) {
  gp_Elips2d * lresult = (gp_Elips2d *)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  gp_Elips2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Geom2dAdaptor_Curve const *)arg1)->Ellipse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Ellipse\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Ellipse\n  * fulldecl: gp_Elips2d Geom2dAdaptor_Curve::Ellipse() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Elips2d(result);
    return lresult;
  } catch (...) {
    return (gp_Elips2d *)0;
  }
}


EXPORT gp_Hypr2d *_wrap_Geom2dAdaptor_Curve_Hyperbola (Geom2dAdaptor_Curve *larg1) {
  gp_Hypr2d * lresult = (gp_Hypr2d *)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  gp_Hypr2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Geom2dAdaptor_Curve const *)arg1)->Hyperbola();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Hyperbola\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Hyperbola\n  * fulldecl: gp_Hypr2d Geom2dAdaptor_Curve::Hyperbola() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr2d(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr2d *)0;
  }
}


EXPORT gp_Parab2d *_wrap_Geom2dAdaptor_Curve_Parabola (Geom2dAdaptor_Curve *larg1) {
  gp_Parab2d * lresult = (gp_Parab2d *)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  gp_Parab2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Geom2dAdaptor_Curve const *)arg1)->Parabola();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Parabola\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Parabola\n  * fulldecl: gp_Parab2d Geom2dAdaptor_Curve::Parabola() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Parab2d(result);
    return lresult;
  } catch (...) {
    return (gp_Parab2d *)0;
  }
}


EXPORT Standard_Integer _wrap_Geom2dAdaptor_Curve_Degree (Geom2dAdaptor_Curve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((Geom2dAdaptor_Curve const *)arg1)->Degree();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Degree\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Degree\n  * fulldecl: Standard_Integer Geom2dAdaptor_Curve::Degree() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT bool _wrap_Geom2dAdaptor_Curve_IsRational (Geom2dAdaptor_Curve *larg1) {
  bool lresult = (bool)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Geom2dAdaptor_Curve const *)arg1)->IsRational();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_IsRational\n  * wrapname: _wrap_Geom2dAdaptor_Curve_IsRational\n  * fulldecl: Standard_Boolean Geom2dAdaptor_Curve::IsRational() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Standard_Integer _wrap_Geom2dAdaptor_Curve_NbPoles (Geom2dAdaptor_Curve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((Geom2dAdaptor_Curve const *)arg1)->NbPoles();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_NbPoles\n  * wrapname: _wrap_Geom2dAdaptor_Curve_NbPoles\n  * fulldecl: Standard_Integer Geom2dAdaptor_Curve::NbPoles() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT Standard_Integer _wrap_Geom2dAdaptor_Curve_NbKnots (Geom2dAdaptor_Curve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((Geom2dAdaptor_Curve const *)arg1)->NbKnots();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_NbKnots\n  * wrapname: _wrap_Geom2dAdaptor_Curve_NbKnots\n  * fulldecl: Standard_Integer Geom2dAdaptor_Curve::NbKnots() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT Standard_Integer _wrap_Geom2dAdaptor_Curve_NbSamples (Geom2dAdaptor_Curve *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((Geom2dAdaptor_Curve const *)arg1)->NbSamples();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_NbSamples\n  * wrapname: _wrap_Geom2dAdaptor_Curve_NbSamples\n  * fulldecl: Standard_Integer Geom2dAdaptor_Curve::NbSamples() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT Handle_Geom2d_BezierCurve *_wrap_Geom2dAdaptor_Curve_Bezier (Geom2dAdaptor_Curve *larg1) {
  Handle_Geom2d_BezierCurve * lresult = (Handle_Geom2d_BezierCurve *)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  SwigValueWrapper< Handle_Geom2d_BezierCurve > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Geom2dAdaptor_Curve const *)arg1)->Bezier();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_Bezier\n  * wrapname: _wrap_Geom2dAdaptor_Curve_Bezier\n  * fulldecl: Handle_Geom2d_BezierCurve Geom2dAdaptor_Curve::Bezier() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_BezierCurve(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_BezierCurve *)0;
  }
}


EXPORT Handle_Geom2d_BSplineCurve *_wrap_Geom2dAdaptor_Curve_BSpline (Geom2dAdaptor_Curve *larg1) {
  Handle_Geom2d_BSplineCurve * lresult = (Handle_Geom2d_BSplineCurve *)0 ;
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  SwigValueWrapper< Handle_Geom2d_BSplineCurve > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Geom2dAdaptor_Curve const *)arg1)->BSpline();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Geom2dAdaptor_Curve_BSpline\n  * wrapname: _wrap_Geom2dAdaptor_Curve_BSpline\n  * fulldecl: Handle_Geom2d_BSplineCurve Geom2dAdaptor_Curve::BSpline() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_BSplineCurve(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_BSplineCurve *)0;
  }
}


EXPORT void _wrap_delete_Geom2dAdaptor_Curve (Geom2dAdaptor_Curve *larg1) {
  Geom2dAdaptor_Curve *arg1 = (Geom2dAdaptor_Curve *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Geom2dAdaptor_Curve\n  * wrapname: _wrap_delete_Geom2dAdaptor_Curve\n  * fulldecl: Geom2dAdaptor_Curve::~Geom2dAdaptor_Curve()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Adaptor2d_Curve2d *_wrap_Adaptor2d_HCurve2d_Curve2d (Adaptor2d_HCurve2d *larg1) {
  Adaptor2d_Curve2d * lresult = (Adaptor2d_Curve2d *)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Adaptor2d_Curve2d *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Adaptor2d_Curve2d *) &((Adaptor2d_HCurve2d const *)arg1)->Curve2d();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_Curve2d\n  * wrapname: _wrap_Adaptor2d_HCurve2d_Curve2d\n  * fulldecl: Adaptor2d_Curve2d const & Adaptor2d_HCurve2d::Curve2d() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Adaptor2d_Curve2d *)0;
  }
}


EXPORT Standard_Real _wrap_Adaptor2d_HCurve2d_FirstParameter (Adaptor2d_HCurve2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((Adaptor2d_HCurve2d const *)arg1)->FirstParameter();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_FirstParameter\n  * wrapname: _wrap_Adaptor2d_HCurve2d_FirstParameter\n  * fulldecl: Standard_Real Adaptor2d_HCurve2d::FirstParameter() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_Adaptor2d_HCurve2d_LastParameter (Adaptor2d_HCurve2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((Adaptor2d_HCurve2d const *)arg1)->LastParameter();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_LastParameter\n  * wrapname: _wrap_Adaptor2d_HCurve2d_LastParameter\n  * fulldecl: Standard_Real Adaptor2d_HCurve2d::LastParameter() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT GeomAbs_Shape _wrap_Adaptor2d_HCurve2d_Continuity (Adaptor2d_HCurve2d *larg1) {
  GeomAbs_Shape lresult = (GeomAbs_Shape)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  GeomAbs_Shape result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAbs_Shape)((Adaptor2d_HCurve2d const *)arg1)->Continuity();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_Continuity\n  * wrapname: _wrap_Adaptor2d_HCurve2d_Continuity\n  * fulldecl: GeomAbs_Shape Adaptor2d_HCurve2d::Continuity() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAbs_Shape)0;
  }
}


EXPORT Standard_Integer _wrap_Adaptor2d_HCurve2d_NbIntervals (Adaptor2d_HCurve2d *larg1, GeomAbs_Shape larg2) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  GeomAbs_Shape arg2 ;
  Standard_Integer result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((Adaptor2d_HCurve2d const *)arg1)->NbIntervals(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_NbIntervals\n  * wrapname: _wrap_Adaptor2d_HCurve2d_NbIntervals\n  * fulldecl: Standard_Integer Adaptor2d_HCurve2d::NbIntervals(GeomAbs_Shape const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT void _wrap_Adaptor2d_HCurve2d_Intervals (Adaptor2d_HCurve2d *larg1, TColStd_Array1OfReal *larg2, GeomAbs_Shape larg3) {
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  TColStd_Array1OfReal *arg2 = 0 ;
  GeomAbs_Shape arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((Adaptor2d_HCurve2d const *)arg1)->Intervals(*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_Intervals\n  * wrapname: _wrap_Adaptor2d_HCurve2d_Intervals\n  * fulldecl: void Adaptor2d_HCurve2d::Intervals(TColStd_Array1OfReal &,GeomAbs_Shape const) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Handle_Adaptor2d_HCurve2d *_wrap_Adaptor2d_HCurve2d_Trim (Adaptor2d_HCurve2d *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4) {
  Handle_Adaptor2d_HCurve2d * lresult = (Handle_Adaptor2d_HCurve2d *)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Handle_Adaptor2d_HCurve2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Adaptor2d_HCurve2d const *)arg1)->Trim(arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_Trim\n  * wrapname: _wrap_Adaptor2d_HCurve2d_Trim\n  * fulldecl: Handle_Adaptor2d_HCurve2d Adaptor2d_HCurve2d::Trim(Standard_Real const,Standard_Real const,Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Adaptor2d_HCurve2d(result);
    return lresult;
  } catch (...) {
    return (Handle_Adaptor2d_HCurve2d *)0;
  }
}


EXPORT bool _wrap_Adaptor2d_HCurve2d_IsClosed (Adaptor2d_HCurve2d *larg1) {
  bool lresult = (bool)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Adaptor2d_HCurve2d const *)arg1)->IsClosed();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_IsClosed\n  * wrapname: _wrap_Adaptor2d_HCurve2d_IsClosed\n  * fulldecl: Standard_Boolean Adaptor2d_HCurve2d::IsClosed() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_Adaptor2d_HCurve2d_IsPeriodic (Adaptor2d_HCurve2d *larg1) {
  bool lresult = (bool)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Adaptor2d_HCurve2d const *)arg1)->IsPeriodic();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_IsPeriodic\n  * wrapname: _wrap_Adaptor2d_HCurve2d_IsPeriodic\n  * fulldecl: Standard_Boolean Adaptor2d_HCurve2d::IsPeriodic() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Standard_Real _wrap_Adaptor2d_HCurve2d_Period (Adaptor2d_HCurve2d *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((Adaptor2d_HCurve2d const *)arg1)->Period();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_Period\n  * wrapname: _wrap_Adaptor2d_HCurve2d_Period\n  * fulldecl: Standard_Real Adaptor2d_HCurve2d::Period() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Pnt2d *_wrap_Adaptor2d_HCurve2d_Value (Adaptor2d_HCurve2d *larg1, Standard_Real larg2) {
  gp_Pnt2d * lresult = (gp_Pnt2d *)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Adaptor2d_HCurve2d const *)arg1)->Value(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_Value\n  * wrapname: _wrap_Adaptor2d_HCurve2d_Value\n  * fulldecl: gp_Pnt2d Adaptor2d_HCurve2d::Value(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt2d(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt2d *)0;
  }
}


EXPORT void _wrap_Adaptor2d_HCurve2d_D0 (Adaptor2d_HCurve2d *larg1, Standard_Real larg2, gp_Pnt2d *larg3) {
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((Adaptor2d_HCurve2d const *)arg1)->D0(arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_D0\n  * wrapname: _wrap_Adaptor2d_HCurve2d_D0\n  * fulldecl: void Adaptor2d_HCurve2d::D0(Standard_Real const,gp_Pnt2d &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Adaptor2d_HCurve2d_D1 (Adaptor2d_HCurve2d *larg1, Standard_Real larg2, gp_Pnt2d *larg3, gp_Vec2d *larg4) {
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  gp_Vec2d *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((Adaptor2d_HCurve2d const *)arg1)->D1(arg2,*arg3,*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_D1\n  * wrapname: _wrap_Adaptor2d_HCurve2d_D1\n  * fulldecl: void Adaptor2d_HCurve2d::D1(Standard_Real const,gp_Pnt2d &,gp_Vec2d &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Adaptor2d_HCurve2d_D2 (Adaptor2d_HCurve2d *larg1, Standard_Real larg2, gp_Pnt2d *larg3, gp_Vec2d *larg4, gp_Vec2d *larg5) {
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  gp_Vec2d *arg4 = 0 ;
  gp_Vec2d *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((Adaptor2d_HCurve2d const *)arg1)->D2(arg2,*arg3,*arg4,*arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_D2\n  * wrapname: _wrap_Adaptor2d_HCurve2d_D2\n  * fulldecl: void Adaptor2d_HCurve2d::D2(Standard_Real const,gp_Pnt2d &,gp_Vec2d &,gp_Vec2d &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_Adaptor2d_HCurve2d_D3 (Adaptor2d_HCurve2d *larg1, Standard_Real larg2, gp_Pnt2d *larg3, gp_Vec2d *larg4, gp_Vec2d *larg5, gp_Vec2d *larg6) {
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Real arg2 ;
  gp_Pnt2d *arg3 = 0 ;
  gp_Vec2d *arg4 = 0 ;
  gp_Vec2d *arg5 = 0 ;
  gp_Vec2d *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((Adaptor2d_HCurve2d const *)arg1)->D3(arg2,*arg3,*arg4,*arg5,*arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_D3\n  * wrapname: _wrap_Adaptor2d_HCurve2d_D3\n  * fulldecl: void Adaptor2d_HCurve2d::D3(Standard_Real const,gp_Pnt2d &,gp_Vec2d &,gp_Vec2d &,gp_Vec2d &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Vec2d *_wrap_Adaptor2d_HCurve2d_DN (Adaptor2d_HCurve2d *larg1, Standard_Real larg2, Standard_Integer larg3) {
  gp_Vec2d * lresult = (gp_Vec2d *)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Real arg2 ;
  Standard_Integer arg3 ;
  gp_Vec2d result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Adaptor2d_HCurve2d const *)arg1)->DN(arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_DN\n  * wrapname: _wrap_Adaptor2d_HCurve2d_DN\n  * fulldecl: gp_Vec2d Adaptor2d_HCurve2d::DN(Standard_Real const,Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Vec2d(result);
    return lresult;
  } catch (...) {
    return (gp_Vec2d *)0;
  }
}


EXPORT Standard_Real _wrap_Adaptor2d_HCurve2d_Resolution (Adaptor2d_HCurve2d *larg1, Standard_Real larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Real arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((Adaptor2d_HCurve2d const *)arg1)->Resolution(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_Resolution\n  * wrapname: _wrap_Adaptor2d_HCurve2d_Resolution\n  * fulldecl: Standard_Real Adaptor2d_HCurve2d::Resolution(Standard_Real const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT GeomAbs_CurveType *_wrap_Adaptor2d_HCurve2d_GetType (Adaptor2d_HCurve2d *larg1) {
  GeomAbs_CurveType * lresult = (GeomAbs_CurveType *)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  GeomAbs_CurveType result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Adaptor2d_HCurve2d const *)arg1)->GetType();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_GetType\n  * wrapname: _wrap_Adaptor2d_HCurve2d_GetType\n  * fulldecl: GeomAbs_CurveType Adaptor2d_HCurve2d::GetType() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new GeomAbs_CurveType(result);
    return lresult;
  } catch (...) {
    return (GeomAbs_CurveType *)0;
  }
}


EXPORT gp_Lin2d *_wrap_Adaptor2d_HCurve2d_Line (Adaptor2d_HCurve2d *larg1) {
  gp_Lin2d * lresult = (gp_Lin2d *)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  gp_Lin2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Adaptor2d_HCurve2d const *)arg1)->Line();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_Line\n  * wrapname: _wrap_Adaptor2d_HCurve2d_Line\n  * fulldecl: gp_Lin2d Adaptor2d_HCurve2d::Line() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Lin2d(result);
    return lresult;
  } catch (...) {
    return (gp_Lin2d *)0;
  }
}


EXPORT gp_Circ2d *_wrap_Adaptor2d_HCurve2d_Circle (Adaptor2d_HCurve2d *larg1) {
  gp_Circ2d * lresult = (gp_Circ2d *)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  gp_Circ2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Adaptor2d_HCurve2d const *)arg1)->Circle();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_Circle\n  * wrapname: _wrap_Adaptor2d_HCurve2d_Circle\n  * fulldecl: gp_Circ2d Adaptor2d_HCurve2d::Circle() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Circ2d(result);
    return lresult;
  } catch (...) {
    return (gp_Circ2d *)0;
  }
}


EXPORT gp_Elips2d *_wrap_Adaptor2d_HCurve2d_Ellipse (Adaptor2d_HCurve2d *larg1) {
  gp_Elips2d * lresult = (gp_Elips2d *)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  gp_Elips2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Adaptor2d_HCurve2d const *)arg1)->Ellipse();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_Ellipse\n  * wrapname: _wrap_Adaptor2d_HCurve2d_Ellipse\n  * fulldecl: gp_Elips2d Adaptor2d_HCurve2d::Ellipse() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Elips2d(result);
    return lresult;
  } catch (...) {
    return (gp_Elips2d *)0;
  }
}


EXPORT gp_Hypr2d *_wrap_Adaptor2d_HCurve2d_Hyperbola (Adaptor2d_HCurve2d *larg1) {
  gp_Hypr2d * lresult = (gp_Hypr2d *)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  gp_Hypr2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Adaptor2d_HCurve2d const *)arg1)->Hyperbola();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_Hyperbola\n  * wrapname: _wrap_Adaptor2d_HCurve2d_Hyperbola\n  * fulldecl: gp_Hypr2d Adaptor2d_HCurve2d::Hyperbola() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Hypr2d(result);
    return lresult;
  } catch (...) {
    return (gp_Hypr2d *)0;
  }
}


EXPORT gp_Parab2d *_wrap_Adaptor2d_HCurve2d_Parabola (Adaptor2d_HCurve2d *larg1) {
  gp_Parab2d * lresult = (gp_Parab2d *)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  gp_Parab2d result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Adaptor2d_HCurve2d const *)arg1)->Parabola();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_Parabola\n  * wrapname: _wrap_Adaptor2d_HCurve2d_Parabola\n  * fulldecl: gp_Parab2d Adaptor2d_HCurve2d::Parabola() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Parab2d(result);
    return lresult;
  } catch (...) {
    return (gp_Parab2d *)0;
  }
}


EXPORT Standard_Integer _wrap_Adaptor2d_HCurve2d_Degree (Adaptor2d_HCurve2d *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((Adaptor2d_HCurve2d const *)arg1)->Degree();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_Degree\n  * wrapname: _wrap_Adaptor2d_HCurve2d_Degree\n  * fulldecl: Standard_Integer Adaptor2d_HCurve2d::Degree() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT bool _wrap_Adaptor2d_HCurve2d_IsRational (Adaptor2d_HCurve2d *larg1) {
  bool lresult = (bool)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Adaptor2d_HCurve2d const *)arg1)->IsRational();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_IsRational\n  * wrapname: _wrap_Adaptor2d_HCurve2d_IsRational\n  * fulldecl: Standard_Boolean Adaptor2d_HCurve2d::IsRational() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Standard_Integer _wrap_Adaptor2d_HCurve2d_NbPoles (Adaptor2d_HCurve2d *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((Adaptor2d_HCurve2d const *)arg1)->NbPoles();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_NbPoles\n  * wrapname: _wrap_Adaptor2d_HCurve2d_NbPoles\n  * fulldecl: Standard_Integer Adaptor2d_HCurve2d::NbPoles() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT Standard_Integer _wrap_Adaptor2d_HCurve2d_NbKnots (Adaptor2d_HCurve2d *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((Adaptor2d_HCurve2d const *)arg1)->NbKnots();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_NbKnots\n  * wrapname: _wrap_Adaptor2d_HCurve2d_NbKnots\n  * fulldecl: Standard_Integer Adaptor2d_HCurve2d::NbKnots() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT Handle_Geom2d_BezierCurve *_wrap_Adaptor2d_HCurve2d_Bezier (Adaptor2d_HCurve2d *larg1) {
  Handle_Geom2d_BezierCurve * lresult = (Handle_Geom2d_BezierCurve *)0 ;
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  SwigValueWrapper< Handle_Geom2d_BezierCurve > result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((Adaptor2d_HCurve2d const *)arg1)->Bezier();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Adaptor2d_HCurve2d_Bezier\n  * wrapname: _wrap_Adaptor2d_HCurve2d_Bezier\n  * fulldecl: Handle_Geom2d_BezierCurve Adaptor2d_HCurve2d::Bezier() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new Handle_Geom2d_BezierCurve(result);
    return lresult;
  } catch (...) {
    return (Handle_Geom2d_BezierCurve *)0;
  }
}


EXPORT void _wrap_delete_Adaptor2d_HCurve2d (Adaptor2d_HCurve2d *larg1) {
  Adaptor2d_HCurve2d *arg1 = (Adaptor2d_HCurve2d *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Adaptor2d_HCurve2d\n  * wrapname: _wrap_delete_Adaptor2d_HCurve2d\n  * fulldecl: Adaptor2d_HCurve2d::~Adaptor2d_HCurve2d()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



  #include <Adaptor3d_Curve.hxx>
  #include <Adaptor2d_Curve2d.hxx>
  #include <CPnts_UniformDeflection.hxx>
  
EXPORT CPnts_UniformDeflection *_wrap_new_CPnts_UniformDeflection__SWIG_0 () {
  CPnts_UniformDeflection * lresult = (CPnts_UniformDeflection *)0 ;
  CPnts_UniformDeflection *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (CPnts_UniformDeflection *)new CPnts_UniformDeflection();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_CPnts_UniformDeflection\n  * wrapname: _wrap_new_CPnts_UniformDeflection__SWIG_0\n  * fulldecl: CPnts_UniformDeflection::CPnts_UniformDeflection()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (CPnts_UniformDeflection *)0;
  }
}


EXPORT CPnts_UniformDeflection *_wrap_new_CPnts_UniformDeflection__SWIG_1 (Adaptor3d_Curve *larg1, Standard_Real larg2, Standard_Real larg3, bool larg4) {
  CPnts_UniformDeflection * lresult = (CPnts_UniformDeflection *)0 ;
  Adaptor3d_Curve *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Boolean arg4 ;
  CPnts_UniformDeflection *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (CPnts_UniformDeflection *)new CPnts_UniformDeflection((Adaptor3d_Curve const &)*arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_CPnts_UniformDeflection\n  * wrapname: _wrap_new_CPnts_UniformDeflection__SWIG_1\n  * fulldecl: CPnts_UniformDeflection::CPnts_UniformDeflection(Adaptor3d_Curve const &,Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (CPnts_UniformDeflection *)0;
  }
}


EXPORT CPnts_UniformDeflection *_wrap_new_CPnts_UniformDeflection__SWIG_2 (Adaptor2d_Curve2d *larg1, Standard_Real larg2, Standard_Real larg3, bool larg4) {
  CPnts_UniformDeflection * lresult = (CPnts_UniformDeflection *)0 ;
  Adaptor2d_Curve2d *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Boolean arg4 ;
  CPnts_UniformDeflection *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (CPnts_UniformDeflection *)new CPnts_UniformDeflection((Adaptor2d_Curve2d const &)*arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_CPnts_UniformDeflection\n  * wrapname: _wrap_new_CPnts_UniformDeflection__SWIG_2\n  * fulldecl: CPnts_UniformDeflection::CPnts_UniformDeflection(Adaptor2d_Curve2d const &,Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (CPnts_UniformDeflection *)0;
  }
}


EXPORT CPnts_UniformDeflection *_wrap_new_CPnts_UniformDeflection__SWIG_3 (Adaptor3d_Curve *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5, bool larg6) {
  CPnts_UniformDeflection * lresult = (CPnts_UniformDeflection *)0 ;
  Adaptor3d_Curve *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  Standard_Boolean arg6 ;
  CPnts_UniformDeflection *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = (bool)larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (CPnts_UniformDeflection *)new CPnts_UniformDeflection((Adaptor3d_Curve const &)*arg1,arg2,arg3,arg4,arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_CPnts_UniformDeflection\n  * wrapname: _wrap_new_CPnts_UniformDeflection__SWIG_3\n  * fulldecl: CPnts_UniformDeflection::CPnts_UniformDeflection(Adaptor3d_Curve const &,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (CPnts_UniformDeflection *)0;
  }
}


EXPORT CPnts_UniformDeflection *_wrap_new_CPnts_UniformDeflection__SWIG_4 (Adaptor2d_Curve2d *larg1, Standard_Real larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5, bool larg6) {
  CPnts_UniformDeflection * lresult = (CPnts_UniformDeflection *)0 ;
  Adaptor2d_Curve2d *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  Standard_Boolean arg6 ;
  CPnts_UniformDeflection *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = (bool)larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (CPnts_UniformDeflection *)new CPnts_UniformDeflection((Adaptor2d_Curve2d const &)*arg1,arg2,arg3,arg4,arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_CPnts_UniformDeflection\n  * wrapname: _wrap_new_CPnts_UniformDeflection__SWIG_4\n  * fulldecl: CPnts_UniformDeflection::CPnts_UniformDeflection(Adaptor2d_Curve2d const &,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (CPnts_UniformDeflection *)0;
  }
}


EXPORT void _wrap_CPnts_UniformDeflection_Initialize__SWIG_0 (CPnts_UniformDeflection *larg1, Adaptor3d_Curve *larg2, Standard_Real larg3, Standard_Real larg4, bool larg5) {
  CPnts_UniformDeflection *arg1 = (CPnts_UniformDeflection *) 0 ;
  Adaptor3d_Curve *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Boolean arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = (bool)larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Initialize((Adaptor3d_Curve const &)*arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: CPnts_UniformDeflection_Initialize\n  * wrapname: _wrap_CPnts_UniformDeflection_Initialize__SWIG_0\n  * fulldecl: void CPnts_UniformDeflection::Initialize(Adaptor3d_Curve const &,Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_CPnts_UniformDeflection_Initialize__SWIG_1 (CPnts_UniformDeflection *larg1, Adaptor2d_Curve2d *larg2, Standard_Real larg3, Standard_Real larg4, bool larg5) {
  CPnts_UniformDeflection *arg1 = (CPnts_UniformDeflection *) 0 ;
  Adaptor2d_Curve2d *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Boolean arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = (bool)larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Initialize((Adaptor2d_Curve2d const &)*arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: CPnts_UniformDeflection_Initialize\n  * wrapname: _wrap_CPnts_UniformDeflection_Initialize__SWIG_1\n  * fulldecl: void CPnts_UniformDeflection::Initialize(Adaptor2d_Curve2d const &,Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_CPnts_UniformDeflection_Initialize__SWIG_2 (CPnts_UniformDeflection *larg1, Adaptor3d_Curve *larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5, Standard_Real larg6, bool larg7) {
  CPnts_UniformDeflection *arg1 = (CPnts_UniformDeflection *) 0 ;
  Adaptor3d_Curve *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  Standard_Real arg6 ;
  Standard_Boolean arg7 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = (bool)larg7;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Initialize((Adaptor3d_Curve const &)*arg2,arg3,arg4,arg5,arg6,arg7);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: CPnts_UniformDeflection_Initialize\n  * wrapname: _wrap_CPnts_UniformDeflection_Initialize__SWIG_2\n  * fulldecl: void CPnts_UniformDeflection::Initialize(Adaptor3d_Curve const &,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_CPnts_UniformDeflection_Initialize__SWIG_3 (CPnts_UniformDeflection *larg1, Adaptor2d_Curve2d *larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5, Standard_Real larg6, bool larg7) {
  CPnts_UniformDeflection *arg1 = (CPnts_UniformDeflection *) 0 ;
  Adaptor2d_Curve2d *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  Standard_Real arg6 ;
  Standard_Boolean arg7 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = (bool)larg7;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Initialize((Adaptor2d_Curve2d const &)*arg2,arg3,arg4,arg5,arg6,arg7);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: CPnts_UniformDeflection_Initialize\n  * wrapname: _wrap_CPnts_UniformDeflection_Initialize__SWIG_3\n  * fulldecl: void CPnts_UniformDeflection::Initialize(Adaptor2d_Curve2d const &,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_CPnts_UniformDeflection_IsAllDone (CPnts_UniformDeflection *larg1) {
  bool lresult = (bool)0 ;
  CPnts_UniformDeflection *arg1 = (CPnts_UniformDeflection *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((CPnts_UniformDeflection const *)arg1)->IsAllDone();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: CPnts_UniformDeflection_IsAllDone\n  * wrapname: _wrap_CPnts_UniformDeflection_IsAllDone\n  * fulldecl: Standard_Boolean CPnts_UniformDeflection::IsAllDone() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_CPnts_UniformDeflection_Next (CPnts_UniformDeflection *larg1) {
  CPnts_UniformDeflection *arg1 = (CPnts_UniformDeflection *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Next();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: CPnts_UniformDeflection_Next\n  * wrapname: _wrap_CPnts_UniformDeflection_Next\n  * fulldecl: void CPnts_UniformDeflection::Next()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_CPnts_UniformDeflection_More (CPnts_UniformDeflection *larg1) {
  bool lresult = (bool)0 ;
  CPnts_UniformDeflection *arg1 = (CPnts_UniformDeflection *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->More();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: CPnts_UniformDeflection_More\n  * wrapname: _wrap_CPnts_UniformDeflection_More\n  * fulldecl: Standard_Boolean CPnts_UniformDeflection::More()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT Standard_Real _wrap_CPnts_UniformDeflection_Value (CPnts_UniformDeflection *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  CPnts_UniformDeflection *arg1 = (CPnts_UniformDeflection *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((CPnts_UniformDeflection const *)arg1)->Value();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: CPnts_UniformDeflection_Value\n  * wrapname: _wrap_CPnts_UniformDeflection_Value\n  * fulldecl: Standard_Real CPnts_UniformDeflection::Value() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT gp_Pnt *_wrap_CPnts_UniformDeflection_Point (CPnts_UniformDeflection *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  CPnts_UniformDeflection *arg1 = (CPnts_UniformDeflection *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((CPnts_UniformDeflection const *)arg1)->Point();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: CPnts_UniformDeflection_Point\n  * wrapname: _wrap_CPnts_UniformDeflection_Point\n  * fulldecl: gp_Pnt CPnts_UniformDeflection::Point() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT void _wrap_delete_CPnts_UniformDeflection (CPnts_UniformDeflection *larg1) {
  CPnts_UniformDeflection *arg1 = (CPnts_UniformDeflection *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_CPnts_UniformDeflection\n  * wrapname: _wrap_delete_CPnts_UniformDeflection\n  * fulldecl: CPnts_UniformDeflection::~CPnts_UniformDeflection()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}



#include <TopExp.hxx>
  
EXPORT TopLoc_Location *_wrap_new_TopLoc_Location__SWIG_0 () {
  TopLoc_Location * lresult = (TopLoc_Location *)0 ;
  TopLoc_Location *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopLoc_Location *)new TopLoc_Location();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TopLoc_Location\n  * wrapname: _wrap_new_TopLoc_Location__SWIG_0\n  * fulldecl: TopLoc_Location::TopLoc_Location()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopLoc_Location *)0;
  }
}


EXPORT TopLoc_Location *_wrap_new_TopLoc_Location__SWIG_1 (gp_Trsf *larg1) {
  TopLoc_Location * lresult = (TopLoc_Location *)0 ;
  gp_Trsf *arg1 = 0 ;
  TopLoc_Location *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopLoc_Location *)new TopLoc_Location((gp_Trsf const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TopLoc_Location\n  * wrapname: _wrap_new_TopLoc_Location__SWIG_1\n  * fulldecl: TopLoc_Location::TopLoc_Location(gp_Trsf const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopLoc_Location *)0;
  }
}


EXPORT bool _wrap_TopLoc_Location_IsIdentity (TopLoc_Location *larg1) {
  bool lresult = (bool)0 ;
  TopLoc_Location *arg1 = (TopLoc_Location *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)(arg1)->IsIdentity();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopLoc_Location_IsIdentity\n  * wrapname: _wrap_TopLoc_Location_IsIdentity\n  * fulldecl: Standard_Boolean TopLoc_Location::IsIdentity()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT gp_Trsf *_wrap_TopLoc_Location_Transformation (TopLoc_Location *larg1) {
  gp_Trsf * lresult = (gp_Trsf *)0 ;
  TopLoc_Location *arg1 = (TopLoc_Location *) 0 ;
  gp_Trsf *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (gp_Trsf *) &(arg1)->Transformation();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopLoc_Location_Transformation\n  * wrapname: _wrap_TopLoc_Location_Transformation\n  * fulldecl: gp_Trsf const & TopLoc_Location::Transformation()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (gp_Trsf *)0;
  }
}


EXPORT void _wrap_delete_TopLoc_Location (TopLoc_Location *larg1) {
  TopLoc_Location *arg1 = (TopLoc_Location *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopLoc_Location\n  * wrapname: _wrap_delete_TopLoc_Location\n  * fulldecl: TopLoc_Location::~TopLoc_Location()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopExp_Vertices__SWIG_0 (TopoDS_Edge *larg1, TopoDS_Vertex *larg2, TopoDS_Vertex *larg3, bool larg4) {
  TopoDS_Edge *arg1 = 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  TopoDS_Vertex *arg3 = 0 ;
  Standard_Boolean arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        TopExp::Vertices((TopoDS_Edge const &)*arg1,*arg2,*arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopExp_Vertices\n  * wrapname: _wrap_TopExp_Vertices__SWIG_0\n  * fulldecl: void TopExp::Vertices(TopoDS_Edge const &,TopoDS_Vertex &,TopoDS_Vertex &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopExp_Vertices__SWIG_1 (TopoDS_Edge *larg1, TopoDS_Vertex *larg2, TopoDS_Vertex *larg3) {
  TopoDS_Edge *arg1 = 0 ;
  TopoDS_Vertex *arg2 = 0 ;
  TopoDS_Vertex *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        TopExp::Vertices((TopoDS_Edge const &)*arg1,*arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopExp_Vertices\n  * wrapname: _wrap_TopExp_Vertices__SWIG_1\n  * fulldecl: void TopExp::Vertices(TopoDS_Edge const &,TopoDS_Vertex &,TopoDS_Vertex &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_TopExp_CommonVertex (TopoDS_Edge *larg1, TopoDS_Edge *larg2, TopoDS_Vertex *larg3) {
  bool lresult = (bool)0 ;
  TopoDS_Edge *arg1 = 0 ;
  TopoDS_Edge *arg2 = 0 ;
  TopoDS_Vertex *arg3 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)TopExp::CommonVertex((TopoDS_Edge const &)*arg1,(TopoDS_Edge const &)*arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopExp_CommonVertex\n  * wrapname: _wrap_TopExp_CommonVertex\n  * fulldecl: Standard_Boolean TopExp::CommonVertex(TopoDS_Edge const &,TopoDS_Edge const &,TopoDS_Vertex &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_delete_TopExp (TopExp *larg1) {
  TopExp *arg1 = (TopExp *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopExp\n  * wrapname: _wrap_delete_TopExp\n  * fulldecl: TopExp::~TopExp()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include "TopExp_Explorer.hxx"
EXPORT TopExp_Explorer *_wrap_new_TopExp_Explorer__SWIG_0 () {
  TopExp_Explorer * lresult = (TopExp_Explorer *)0 ;
  TopExp_Explorer *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopExp_Explorer *)new TopExp_Explorer();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TopExp_Explorer\n  * wrapname: _wrap_new_TopExp_Explorer__SWIG_0\n  * fulldecl: TopExp_Explorer::TopExp_Explorer()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopExp_Explorer *)0;
  }
}


EXPORT TopExp_Explorer *_wrap_new_TopExp_Explorer__SWIG_1 (TopoDS_Shape *larg1, TopAbs_ShapeEnum larg2, TopAbs_ShapeEnum larg3) {
  TopExp_Explorer * lresult = (TopExp_Explorer *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  TopAbs_ShapeEnum arg2 ;
  TopAbs_ShapeEnum arg3 ;
  TopExp_Explorer *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopExp_Explorer *)new TopExp_Explorer((TopoDS_Shape const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TopExp_Explorer\n  * wrapname: _wrap_new_TopExp_Explorer__SWIG_1\n  * fulldecl: TopExp_Explorer::TopExp_Explorer(TopoDS_Shape const &,TopAbs_ShapeEnum const,TopAbs_ShapeEnum const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopExp_Explorer *)0;
  }
}


EXPORT TopExp_Explorer *_wrap_new_TopExp_Explorer__SWIG_2 (TopoDS_Shape *larg1, TopAbs_ShapeEnum larg2) {
  TopExp_Explorer * lresult = (TopExp_Explorer *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  TopAbs_ShapeEnum arg2 ;
  TopExp_Explorer *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopExp_Explorer *)new TopExp_Explorer((TopoDS_Shape const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_TopExp_Explorer\n  * wrapname: _wrap_new_TopExp_Explorer__SWIG_2\n  * fulldecl: TopExp_Explorer::TopExp_Explorer(TopoDS_Shape const &,TopAbs_ShapeEnum const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopExp_Explorer *)0;
  }
}


EXPORT void _wrap_TopExp_Explorer_Init__SWIG_0 (TopExp_Explorer *larg1, TopoDS_Shape *larg2, TopAbs_ShapeEnum larg3, TopAbs_ShapeEnum larg4) {
  TopExp_Explorer *arg1 = (TopExp_Explorer *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopAbs_ShapeEnum arg3 ;
  TopAbs_ShapeEnum arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init((TopoDS_Shape const &)*arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopExp_Explorer_Init\n  * wrapname: _wrap_TopExp_Explorer_Init__SWIG_0\n  * fulldecl: void TopExp_Explorer::Init(TopoDS_Shape const &,TopAbs_ShapeEnum const,TopAbs_ShapeEnum const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_TopExp_Explorer_Init__SWIG_1 (TopExp_Explorer *larg1, TopoDS_Shape *larg2, TopAbs_ShapeEnum larg3) {
  TopExp_Explorer *arg1 = (TopExp_Explorer *) 0 ;
  TopoDS_Shape *arg2 = 0 ;
  TopAbs_ShapeEnum arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init((TopoDS_Shape const &)*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopExp_Explorer_Init\n  * wrapname: _wrap_TopExp_Explorer_Init__SWIG_1\n  * fulldecl: void TopExp_Explorer::Init(TopoDS_Shape const &,TopAbs_ShapeEnum const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_TopExp_Explorer_More (TopExp_Explorer *larg1) {
  bool lresult = (bool)0 ;
  TopExp_Explorer *arg1 = (TopExp_Explorer *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((TopExp_Explorer const *)arg1)->More();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopExp_Explorer_More\n  * wrapname: _wrap_TopExp_Explorer_More\n  * fulldecl: Standard_Boolean TopExp_Explorer::More() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_TopExp_Explorer_Next (TopExp_Explorer *larg1) {
  TopExp_Explorer *arg1 = (TopExp_Explorer *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Next();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopExp_Explorer_Next\n  * wrapname: _wrap_TopExp_Explorer_Next\n  * fulldecl: void TopExp_Explorer::Next()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT TopoDS_Shape *_wrap_TopExp_Explorer_Current (TopExp_Explorer *larg1) {
  TopoDS_Shape * lresult = (TopoDS_Shape *)0 ;
  TopExp_Explorer *arg1 = (TopExp_Explorer *) 0 ;
  TopoDS_Shape *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Shape *) &(arg1)->Current();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: TopExp_Explorer_Current\n  * wrapname: _wrap_TopExp_Explorer_Current\n  * fulldecl: TopoDS_Shape const & TopExp_Explorer::Current()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Shape *)0;
  }
}


EXPORT void _wrap_delete_TopExp_Explorer (TopExp_Explorer *larg1) {
  TopExp_Explorer *arg1 = (TopExp_Explorer *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_TopExp_Explorer\n  * wrapname: _wrap_delete_TopExp_Explorer\n  * fulldecl: TopExp_Explorer::~TopExp_Explorer()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include "Bnd_Box.hxx"
EXPORT Bnd_Box *_wrap_new_Bnd_Box () {
  Bnd_Box * lresult = (Bnd_Box *)0 ;
  Bnd_Box *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Bnd_Box *)new Bnd_Box();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_Bnd_Box\n  * wrapname: _wrap_new_Bnd_Box\n  * fulldecl: Bnd_Box::Bnd_Box()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Bnd_Box *)0;
  }
}


EXPORT bool _wrap_Bnd_Box_IsVoid (Bnd_Box *larg1) {
  bool lresult = (bool)0 ;
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((Bnd_Box const *)arg1)->IsVoid();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_IsVoid\n  * wrapname: _wrap_Bnd_Box_IsVoid\n  * fulldecl: Standard_Boolean Bnd_Box::IsVoid() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


SWIGINTERN void Bnd_Box_get(Bnd_Box *self,double box[6]){
		if(!self->IsVoid())
			self->Get(box[0], box[1], box[2], box[3], box[4], box[5]);
	}
EXPORT void _wrap_Bnd_Box_get (Bnd_Box *larg1, double *larg2) {
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  double *arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        Bnd_Box_get(arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: Bnd_Box_get\n  * wrapname: _wrap_Bnd_Box_get\n  * fulldecl: void Bnd_Box::get(double [6])";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_Bnd_Box (Bnd_Box *larg1) {
  Bnd_Box *arg1 = (Bnd_Box *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_Bnd_Box\n  * wrapname: _wrap_delete_Bnd_Box\n  * fulldecl: Bnd_Box::~Bnd_Box()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include "BRepBndLib.hxx"
EXPORT void _wrap_BRepBndLib_Add (TopoDS_Shape *larg1, Bnd_Box *larg2) {
  TopoDS_Shape *arg1 = 0 ;
  Bnd_Box *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepBndLib::Add((TopoDS_Shape const &)*arg1,*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepBndLib_Add\n  * wrapname: _wrap_BRepBndLib_Add\n  * fulldecl: void BRepBndLib::Add(TopoDS_Shape const &,Bnd_Box &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_BRepBndLib (BRepBndLib *larg1) {
  BRepBndLib *arg1 = (BRepBndLib *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepBndLib\n  * wrapname: _wrap_delete_BRepBndLib\n  * fulldecl: BRepBndLib::~BRepBndLib()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include "GProp_GProps.hxx"
EXPORT GProp_GProps *_wrap_new_GProp_GProps () {
  GProp_GProps * lresult = (GProp_GProps *)0 ;
  GProp_GProps *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GProp_GProps *)new GProp_GProps();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GProp_GProps\n  * wrapname: _wrap_new_GProp_GProps\n  * fulldecl: GProp_GProps::GProp_GProps()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GProp_GProps *)0;
  }
}


EXPORT Standard_Real _wrap_GProp_GProps_Mass (GProp_GProps *larg1) {
  Standard_Real lresult = (Standard_Real)0 ;
  GProp_GProps *arg1 = (GProp_GProps *) 0 ;
  Standard_Real result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((GProp_GProps const *)arg1)->Mass();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GProp_GProps_Mass\n  * wrapname: _wrap_GProp_GProps_Mass\n  * fulldecl: Standard_Real GProp_GProps::Mass() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_delete_GProp_GProps (GProp_GProps *larg1) {
  GProp_GProps *arg1 = (GProp_GProps *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_GProp_GProps\n  * wrapname: _wrap_delete_GProp_GProps\n  * fulldecl: GProp_GProps::~GProp_GProps()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include "BRepGProp.hxx"
EXPORT void _wrap_BRepGProp_LinearProperties (TopoDS_Shape *larg1, GProp_GProps *larg2) {
  TopoDS_Shape *arg1 = 0 ;
  GProp_GProps *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepGProp::LinearProperties((TopoDS_Shape const &)*arg1,*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepGProp_LinearProperties\n  * wrapname: _wrap_BRepGProp_LinearProperties\n  * fulldecl: void BRepGProp::LinearProperties(TopoDS_Shape const &,GProp_GProps &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepGProp_VolumeProperties__SWIG_0 (TopoDS_Shape *larg1, GProp_GProps *larg2, bool larg3) {
  TopoDS_Shape *arg1 = 0 ;
  GProp_GProps *arg2 = 0 ;
  Standard_Boolean arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepGProp::VolumeProperties((TopoDS_Shape const &)*arg1,*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepGProp_VolumeProperties\n  * wrapname: _wrap_BRepGProp_VolumeProperties__SWIG_0\n  * fulldecl: void BRepGProp::VolumeProperties(TopoDS_Shape const &,GProp_GProps &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_BRepGProp_VolumeProperties__SWIG_1 (TopoDS_Shape *larg1, GProp_GProps *larg2) {
  TopoDS_Shape *arg1 = 0 ;
  GProp_GProps *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepGProp::VolumeProperties((TopoDS_Shape const &)*arg1,*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepGProp_VolumeProperties\n  * wrapname: _wrap_BRepGProp_VolumeProperties__SWIG_1\n  * fulldecl: void BRepGProp::VolumeProperties(TopoDS_Shape const &,GProp_GProps &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Real _wrap_BRepGProp_VolumeProperties__SWIG_2 (TopoDS_Shape *larg1, GProp_GProps *larg2, Standard_Real larg3, bool larg4) {
  Standard_Real lresult = (Standard_Real)0 ;
  TopoDS_Shape *arg1 = 0 ;
  GProp_GProps *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Boolean arg4 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)BRepGProp::VolumeProperties((TopoDS_Shape const &)*arg1,*arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepGProp_VolumeProperties\n  * wrapname: _wrap_BRepGProp_VolumeProperties__SWIG_2\n  * fulldecl: Standard_Real BRepGProp::VolumeProperties(TopoDS_Shape const &,GProp_GProps &,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT Standard_Real _wrap_BRepGProp_VolumeProperties__SWIG_3 (TopoDS_Shape *larg1, GProp_GProps *larg2, Standard_Real larg3) {
  Standard_Real lresult = (Standard_Real)0 ;
  TopoDS_Shape *arg1 = 0 ;
  GProp_GProps *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)BRepGProp::VolumeProperties((TopoDS_Shape const &)*arg1,*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepGProp_VolumeProperties\n  * wrapname: _wrap_BRepGProp_VolumeProperties__SWIG_3\n  * fulldecl: Standard_Real BRepGProp::VolumeProperties(TopoDS_Shape const &,GProp_GProps &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_BRepGProp_SurfaceProperties__SWIG_0 (TopoDS_Shape *larg1, GProp_GProps *larg2) {
  TopoDS_Shape *arg1 = 0 ;
  GProp_GProps *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        BRepGProp::SurfaceProperties((TopoDS_Shape const &)*arg1,*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepGProp_SurfaceProperties\n  * wrapname: _wrap_BRepGProp_SurfaceProperties__SWIG_0\n  * fulldecl: void BRepGProp::SurfaceProperties(TopoDS_Shape const &,GProp_GProps &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Real _wrap_BRepGProp_SurfaceProperties__SWIG_1 (TopoDS_Shape *larg1, GProp_GProps *larg2, Standard_Real larg3) {
  Standard_Real lresult = (Standard_Real)0 ;
  TopoDS_Shape *arg1 = 0 ;
  GProp_GProps *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)BRepGProp::SurfaceProperties((TopoDS_Shape const &)*arg1,*arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepGProp_SurfaceProperties\n  * wrapname: _wrap_BRepGProp_SurfaceProperties__SWIG_1\n  * fulldecl: Standard_Real BRepGProp::SurfaceProperties(TopoDS_Shape const &,GProp_GProps &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_delete_BRepGProp (BRepGProp *larg1) {
  BRepGProp *arg1 = (BRepGProp *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepGProp\n  * wrapname: _wrap_delete_BRepGProp\n  * fulldecl: BRepGProp::~BRepGProp()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include <ShapeAnalysis_FreeBounds.hxx>
EXPORT ShapeAnalysis_FreeBounds *_wrap_new_ShapeAnalysis_FreeBounds__SWIG_0 (TopoDS_Shape *larg1, bool larg2, bool larg3) {
  ShapeAnalysis_FreeBounds * lresult = (ShapeAnalysis_FreeBounds *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Boolean arg2 ;
  Standard_Boolean arg3 ;
  ShapeAnalysis_FreeBounds *result = 0 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (ShapeAnalysis_FreeBounds *)new ShapeAnalysis_FreeBounds((TopoDS_Shape const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_ShapeAnalysis_FreeBounds\n  * wrapname: _wrap_new_ShapeAnalysis_FreeBounds__SWIG_0\n  * fulldecl: ShapeAnalysis_FreeBounds::ShapeAnalysis_FreeBounds(TopoDS_Shape const &,Standard_Boolean const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (ShapeAnalysis_FreeBounds *)0;
  }
}


EXPORT ShapeAnalysis_FreeBounds *_wrap_new_ShapeAnalysis_FreeBounds__SWIG_1 (TopoDS_Shape *larg1, bool larg2) {
  ShapeAnalysis_FreeBounds * lresult = (ShapeAnalysis_FreeBounds *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Boolean arg2 ;
  ShapeAnalysis_FreeBounds *result = 0 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (ShapeAnalysis_FreeBounds *)new ShapeAnalysis_FreeBounds((TopoDS_Shape const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_ShapeAnalysis_FreeBounds\n  * wrapname: _wrap_new_ShapeAnalysis_FreeBounds__SWIG_1\n  * fulldecl: ShapeAnalysis_FreeBounds::ShapeAnalysis_FreeBounds(TopoDS_Shape const &,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (ShapeAnalysis_FreeBounds *)0;
  }
}


EXPORT ShapeAnalysis_FreeBounds *_wrap_new_ShapeAnalysis_FreeBounds__SWIG_2 (TopoDS_Shape *larg1) {
  ShapeAnalysis_FreeBounds * lresult = (ShapeAnalysis_FreeBounds *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  ShapeAnalysis_FreeBounds *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (ShapeAnalysis_FreeBounds *)new ShapeAnalysis_FreeBounds((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_ShapeAnalysis_FreeBounds\n  * wrapname: _wrap_new_ShapeAnalysis_FreeBounds__SWIG_2\n  * fulldecl: ShapeAnalysis_FreeBounds::ShapeAnalysis_FreeBounds(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (ShapeAnalysis_FreeBounds *)0;
  }
}


EXPORT TopoDS_Compound *_wrap_ShapeAnalysis_FreeBounds_GetClosedWires (ShapeAnalysis_FreeBounds *larg1) {
  TopoDS_Compound * lresult = (TopoDS_Compound *)0 ;
  ShapeAnalysis_FreeBounds *arg1 = (ShapeAnalysis_FreeBounds *) 0 ;
  TopoDS_Compound *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Compound *) &((ShapeAnalysis_FreeBounds const *)arg1)->GetClosedWires();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeAnalysis_FreeBounds_GetClosedWires\n  * wrapname: _wrap_ShapeAnalysis_FreeBounds_GetClosedWires\n  * fulldecl: TopoDS_Compound const & ShapeAnalysis_FreeBounds::GetClosedWires() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Compound *)0;
  }
}


EXPORT TopoDS_Compound *_wrap_ShapeAnalysis_FreeBounds_GetOpenWires (ShapeAnalysis_FreeBounds *larg1) {
  TopoDS_Compound * lresult = (TopoDS_Compound *)0 ;
  ShapeAnalysis_FreeBounds *arg1 = (ShapeAnalysis_FreeBounds *) 0 ;
  TopoDS_Compound *result = 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (TopoDS_Compound *) &((ShapeAnalysis_FreeBounds const *)arg1)->GetOpenWires();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: ShapeAnalysis_FreeBounds_GetOpenWires\n  * wrapname: _wrap_ShapeAnalysis_FreeBounds_GetOpenWires\n  * fulldecl: TopoDS_Compound const & ShapeAnalysis_FreeBounds::GetOpenWires() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (TopoDS_Compound *)0;
  }
}


EXPORT void _wrap_delete_ShapeAnalysis_FreeBounds (ShapeAnalysis_FreeBounds *larg1) {
  ShapeAnalysis_FreeBounds *arg1 = (ShapeAnalysis_FreeBounds *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_ShapeAnalysis_FreeBounds\n  * wrapname: _wrap_delete_ShapeAnalysis_FreeBounds\n  * fulldecl: ShapeAnalysis_FreeBounds::~ShapeAnalysis_FreeBounds()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include <GCPnts_UniformDeflection.hxx>
EXPORT GCPnts_UniformDeflection *_wrap_new_GCPnts_UniformDeflection () {
  GCPnts_UniformDeflection * lresult = (GCPnts_UniformDeflection *)0 ;
  GCPnts_UniformDeflection *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GCPnts_UniformDeflection *)new GCPnts_UniformDeflection();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GCPnts_UniformDeflection\n  * wrapname: _wrap_new_GCPnts_UniformDeflection\n  * fulldecl: GCPnts_UniformDeflection::GCPnts_UniformDeflection()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GCPnts_UniformDeflection *)0;
  }
}


EXPORT void _wrap_GCPnts_UniformDeflection_Initialize__SWIG_0 (GCPnts_UniformDeflection *larg1, Adaptor3d_Curve *larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5, bool larg6) {
  GCPnts_UniformDeflection *arg1 = (GCPnts_UniformDeflection *) 0 ;
  Adaptor3d_Curve *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  Standard_Boolean arg6 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = (bool)larg6;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Initialize(*arg2,arg3,arg4,arg5,arg6);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GCPnts_UniformDeflection_Initialize\n  * wrapname: _wrap_GCPnts_UniformDeflection_Initialize__SWIG_0\n  * fulldecl: void GCPnts_UniformDeflection::Initialize(Adaptor3d_Curve &,Standard_Real const,Standard_Real const,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_GCPnts_UniformDeflection_Initialize__SWIG_1 (GCPnts_UniformDeflection *larg1, Adaptor3d_Curve *larg2, Standard_Real larg3, Standard_Real larg4, Standard_Real larg5) {
  GCPnts_UniformDeflection *arg1 = (GCPnts_UniformDeflection *) 0 ;
  Adaptor3d_Curve *arg2 = 0 ;
  Standard_Real arg3 ;
  Standard_Real arg4 ;
  Standard_Real arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Initialize(*arg2,arg3,arg4,arg5);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GCPnts_UniformDeflection_Initialize\n  * wrapname: _wrap_GCPnts_UniformDeflection_Initialize__SWIG_1\n  * fulldecl: void GCPnts_UniformDeflection::Initialize(Adaptor3d_Curve &,Standard_Real const,Standard_Real const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Integer _wrap_GCPnts_UniformDeflection_NbPoints (GCPnts_UniformDeflection *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  GCPnts_UniformDeflection *arg1 = (GCPnts_UniformDeflection *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((GCPnts_UniformDeflection const *)arg1)->NbPoints();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GCPnts_UniformDeflection_NbPoints\n  * wrapname: _wrap_GCPnts_UniformDeflection_NbPoints\n  * fulldecl: Standard_Integer GCPnts_UniformDeflection::NbPoints() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT Standard_Real _wrap_GCPnts_UniformDeflection_Parameter (GCPnts_UniformDeflection *larg1, Standard_Integer larg2) {
  Standard_Real lresult = (Standard_Real)0 ;
  GCPnts_UniformDeflection *arg1 = (GCPnts_UniformDeflection *) 0 ;
  Standard_Integer arg2 ;
  Standard_Real result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Real)((GCPnts_UniformDeflection const *)arg1)->Parameter(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GCPnts_UniformDeflection_Parameter\n  * wrapname: _wrap_GCPnts_UniformDeflection_Parameter\n  * fulldecl: Standard_Real GCPnts_UniformDeflection::Parameter(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Real)0;
  }
}


EXPORT void _wrap_delete_GCPnts_UniformDeflection (GCPnts_UniformDeflection *larg1) {
  GCPnts_UniformDeflection *arg1 = (GCPnts_UniformDeflection *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_GCPnts_UniformDeflection\n  * wrapname: _wrap_delete_GCPnts_UniformDeflection\n  * fulldecl: GCPnts_UniformDeflection::~GCPnts_UniformDeflection()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include <BRepMesh_DiscretRoot.hxx>
EXPORT void _wrap_BRepMesh_DiscretRoot_Perform (BRepMesh_DiscretRoot *larg1) {
  BRepMesh_DiscretRoot *arg1 = (BRepMesh_DiscretRoot *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Perform();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepMesh_DiscretRoot_Perform\n  * wrapname: _wrap_BRepMesh_DiscretRoot_Perform\n  * fulldecl: void BRepMesh_DiscretRoot::Perform()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_BRepMesh_DiscretRoot (BRepMesh_DiscretRoot *larg1) {
  BRepMesh_DiscretRoot *arg1 = (BRepMesh_DiscretRoot *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepMesh_DiscretRoot\n  * wrapname: _wrap_delete_BRepMesh_DiscretRoot\n  * fulldecl: BRepMesh_DiscretRoot::~BRepMesh_DiscretRoot()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include <BRepMesh_IncrementalMesh.hxx>
EXPORT BRepMesh_IncrementalMesh *_wrap_new_BRepMesh_IncrementalMesh__SWIG_0 () {
  BRepMesh_IncrementalMesh * lresult = (BRepMesh_IncrementalMesh *)0 ;
  BRepMesh_IncrementalMesh *result = 0 ;
  
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepMesh_IncrementalMesh *)new BRepMesh_IncrementalMesh();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepMesh_IncrementalMesh\n  * wrapname: _wrap_new_BRepMesh_IncrementalMesh__SWIG_0\n  * fulldecl: BRepMesh_IncrementalMesh::BRepMesh_IncrementalMesh()";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepMesh_IncrementalMesh *)0;
  }
}


EXPORT BRepMesh_IncrementalMesh *_wrap_new_BRepMesh_IncrementalMesh__SWIG_1 (TopoDS_Shape *larg1, Standard_Real larg2, bool larg3, Standard_Real larg4) {
  BRepMesh_IncrementalMesh * lresult = (BRepMesh_IncrementalMesh *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Boolean arg3 ;
  Standard_Real arg4 ;
  BRepMesh_IncrementalMesh *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepMesh_IncrementalMesh *)new BRepMesh_IncrementalMesh((TopoDS_Shape const &)*arg1,arg2,arg3,arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepMesh_IncrementalMesh\n  * wrapname: _wrap_new_BRepMesh_IncrementalMesh__SWIG_1\n  * fulldecl: BRepMesh_IncrementalMesh::BRepMesh_IncrementalMesh(TopoDS_Shape const &,Standard_Real const,Standard_Boolean const,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepMesh_IncrementalMesh *)0;
  }
}


EXPORT BRepMesh_IncrementalMesh *_wrap_new_BRepMesh_IncrementalMesh__SWIG_2 (TopoDS_Shape *larg1, Standard_Real larg2, bool larg3) {
  BRepMesh_IncrementalMesh * lresult = (BRepMesh_IncrementalMesh *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  Standard_Boolean arg3 ;
  BRepMesh_IncrementalMesh *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepMesh_IncrementalMesh *)new BRepMesh_IncrementalMesh((TopoDS_Shape const &)*arg1,arg2,arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepMesh_IncrementalMesh\n  * wrapname: _wrap_new_BRepMesh_IncrementalMesh__SWIG_2\n  * fulldecl: BRepMesh_IncrementalMesh::BRepMesh_IncrementalMesh(TopoDS_Shape const &,Standard_Real const,Standard_Boolean const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepMesh_IncrementalMesh *)0;
  }
}


EXPORT BRepMesh_IncrementalMesh *_wrap_new_BRepMesh_IncrementalMesh__SWIG_3 (TopoDS_Shape *larg1, Standard_Real larg2) {
  BRepMesh_IncrementalMesh * lresult = (BRepMesh_IncrementalMesh *)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Real arg2 ;
  BRepMesh_IncrementalMesh *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (BRepMesh_IncrementalMesh *)new BRepMesh_IncrementalMesh((TopoDS_Shape const &)*arg1,arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_BRepMesh_IncrementalMesh\n  * wrapname: _wrap_new_BRepMesh_IncrementalMesh__SWIG_3\n  * fulldecl: BRepMesh_IncrementalMesh::BRepMesh_IncrementalMesh(TopoDS_Shape const &,Standard_Real const)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (BRepMesh_IncrementalMesh *)0;
  }
}


EXPORT void _wrap_BRepMesh_IncrementalMesh_Perform (BRepMesh_IncrementalMesh *larg1) {
  BRepMesh_IncrementalMesh *arg1 = (BRepMesh_IncrementalMesh *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Perform();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepMesh_IncrementalMesh_Perform\n  * wrapname: _wrap_BRepMesh_IncrementalMesh_Perform\n  * fulldecl: void BRepMesh_IncrementalMesh::Perform()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT bool _wrap_BRepMesh_IncrementalMesh_IsModified (BRepMesh_IncrementalMesh *larg1) {
  bool lresult = (bool)0 ;
  BRepMesh_IncrementalMesh *arg1 = (BRepMesh_IncrementalMesh *) 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)((BRepMesh_IncrementalMesh const *)arg1)->IsModified();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepMesh_IncrementalMesh_IsModified\n  * wrapname: _wrap_BRepMesh_IncrementalMesh_IsModified\n  * fulldecl: Standard_Boolean BRepMesh_IncrementalMesh::IsModified() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_delete_BRepMesh_IncrementalMesh (BRepMesh_IncrementalMesh *larg1) {
  BRepMesh_IncrementalMesh *arg1 = (BRepMesh_IncrementalMesh *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepMesh_IncrementalMesh\n  * wrapname: _wrap_delete_BRepMesh_IncrementalMesh\n  * fulldecl: BRepMesh_IncrementalMesh::~BRepMesh_IncrementalMesh()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include <GeomAPI_ProjectPointOnSurf.hxx>
EXPORT GeomAPI_ProjectPointOnSurf *_wrap_new_GeomAPI_ProjectPointOnSurf (gp_Pnt *larg1, Handle_Geom_Surface *larg2) {
  GeomAPI_ProjectPointOnSurf * lresult = (GeomAPI_ProjectPointOnSurf *)0 ;
  gp_Pnt *arg1 = 0 ;
  Handle_Geom_Surface *arg2 = 0 ;
  GeomAPI_ProjectPointOnSurf *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (GeomAPI_ProjectPointOnSurf *)new GeomAPI_ProjectPointOnSurf((gp_Pnt const &)*arg1,(Handle_Geom_Surface const &)*arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: new_GeomAPI_ProjectPointOnSurf\n  * wrapname: _wrap_new_GeomAPI_ProjectPointOnSurf\n  * fulldecl: GeomAPI_ProjectPointOnSurf::GeomAPI_ProjectPointOnSurf(gp_Pnt const &,Handle_Geom_Surface const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (GeomAPI_ProjectPointOnSurf *)0;
  }
}


EXPORT void _wrap_GeomAPI_ProjectPointOnSurf_Init (GeomAPI_ProjectPointOnSurf *larg1, gp_Pnt *larg2, Handle_Geom_Surface *larg3) {
  GeomAPI_ProjectPointOnSurf *arg1 = (GeomAPI_ProjectPointOnSurf *) 0 ;
  gp_Pnt *arg2 = 0 ;
  Handle_Geom_Surface *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        (arg1)->Init((gp_Pnt const &)*arg2,(Handle_Geom_Surface const &)*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAPI_ProjectPointOnSurf_Init\n  * wrapname: _wrap_GeomAPI_ProjectPointOnSurf_Init\n  * fulldecl: void GeomAPI_ProjectPointOnSurf::Init(gp_Pnt const &,Handle_Geom_Surface const &)";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT Standard_Integer _wrap_GeomAPI_ProjectPointOnSurf_NbPoints (GeomAPI_ProjectPointOnSurf *larg1) {
  Standard_Integer lresult = (Standard_Integer)0 ;
  GeomAPI_ProjectPointOnSurf *arg1 = (GeomAPI_ProjectPointOnSurf *) 0 ;
  Standard_Integer result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Integer)((GeomAPI_ProjectPointOnSurf const *)arg1)->NbPoints();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAPI_ProjectPointOnSurf_NbPoints\n  * wrapname: _wrap_GeomAPI_ProjectPointOnSurf_NbPoints\n  * fulldecl: Standard_Integer GeomAPI_ProjectPointOnSurf::NbPoints() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Standard_Integer)0;
  }
}


EXPORT Quantity_Length _wrap_GeomAPI_ProjectPointOnSurf_LowerDistance (GeomAPI_ProjectPointOnSurf *larg1) {
  Quantity_Length lresult = (Quantity_Length)0 ;
  GeomAPI_ProjectPointOnSurf *arg1 = (GeomAPI_ProjectPointOnSurf *) 0 ;
  Quantity_Length result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Quantity_Length)((GeomAPI_ProjectPointOnSurf const *)arg1)->LowerDistance();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAPI_ProjectPointOnSurf_LowerDistance\n  * wrapname: _wrap_GeomAPI_ProjectPointOnSurf_LowerDistance\n  * fulldecl: Quantity_Length GeomAPI_ProjectPointOnSurf::LowerDistance() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = result;
    return lresult;
  } catch (...) {
    return (Quantity_Length)0;
  }
}


EXPORT gp_Pnt const *_wrap_GeomAPI_ProjectPointOnSurf_Point (GeomAPI_ProjectPointOnSurf *larg1, Standard_Integer larg2) {
  gp_Pnt const * lresult = (gp_Pnt const *)0 ;
  GeomAPI_ProjectPointOnSurf *arg1 = (GeomAPI_ProjectPointOnSurf *) 0 ;
  Standard_Integer arg2 ;
  gp_Pnt result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((GeomAPI_ProjectPointOnSurf const *)arg1)->Point(arg2);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAPI_ProjectPointOnSurf_Point\n  * wrapname: _wrap_GeomAPI_ProjectPointOnSurf_Point\n  * fulldecl: gp_Pnt const GeomAPI_ProjectPointOnSurf::Point(Standard_Integer const) const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt const(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt const *)0;
  }
}


EXPORT void _wrap_GeomAPI_ProjectPointOnSurf_LowerDistanceParameters (GeomAPI_ProjectPointOnSurf *larg1, Quantity_Parameter *larg2, Quantity_Parameter *larg3) {
  GeomAPI_ProjectPointOnSurf *arg1 = (GeomAPI_ProjectPointOnSurf *) 0 ;
  Quantity_Parameter *arg2 = 0 ;
  Quantity_Parameter *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((GeomAPI_ProjectPointOnSurf const *)arg1)->LowerDistanceParameters(*arg2,*arg3);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAPI_ProjectPointOnSurf_LowerDistanceParameters\n  * wrapname: _wrap_GeomAPI_ProjectPointOnSurf_LowerDistanceParameters\n  * fulldecl: void GeomAPI_ProjectPointOnSurf::LowerDistanceParameters(Quantity_Parameter &,Quantity_Parameter &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_GeomAPI_ProjectPointOnSurf_Parameters (GeomAPI_ProjectPointOnSurf *larg1, Standard_Integer larg2, Quantity_Parameter *larg3, Quantity_Parameter *larg4) {
  GeomAPI_ProjectPointOnSurf *arg1 = (GeomAPI_ProjectPointOnSurf *) 0 ;
  Standard_Integer arg2 ;
  Quantity_Parameter *arg3 = 0 ;
  Quantity_Parameter *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        ((GeomAPI_ProjectPointOnSurf const *)arg1)->Parameters(arg2,*arg3,*arg4);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAPI_ProjectPointOnSurf_Parameters\n  * wrapname: _wrap_GeomAPI_ProjectPointOnSurf_Parameters\n  * fulldecl: void GeomAPI_ProjectPointOnSurf::Parameters(Standard_Integer const,Quantity_Parameter &,Quantity_Parameter &) const";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


EXPORT gp_Pnt *_wrap_GeomAPI_ProjectPointOnSurf_NearestPoint (GeomAPI_ProjectPointOnSurf *larg1) {
  gp_Pnt * lresult = (gp_Pnt *)0 ;
  GeomAPI_ProjectPointOnSurf *arg1 = (GeomAPI_ProjectPointOnSurf *) 0 ;
  gp_Pnt result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = ((GeomAPI_ProjectPointOnSurf const *)arg1)->NearestPoint();
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: GeomAPI_ProjectPointOnSurf_NearestPoint\n  * wrapname: _wrap_GeomAPI_ProjectPointOnSurf_NearestPoint\n  * fulldecl: gp_Pnt GeomAPI_ProjectPointOnSurf::NearestPoint() const";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = new gp_Pnt(result);
    return lresult;
  } catch (...) {
    return (gp_Pnt *)0;
  }
}


EXPORT void _wrap_delete_GeomAPI_ProjectPointOnSurf (GeomAPI_ProjectPointOnSurf *larg1) {
  GeomAPI_ProjectPointOnSurf *arg1 = (GeomAPI_ProjectPointOnSurf *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_GeomAPI_ProjectPointOnSurf\n  * wrapname: _wrap_delete_GeomAPI_ProjectPointOnSurf\n  * fulldecl: GeomAPI_ProjectPointOnSurf::~GeomAPI_ProjectPointOnSurf()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


#include <BRepAlgo.hxx>
EXPORT bool _wrap_BRepAlgo_IsValid (TopoDS_Shape *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepAlgo::IsValid((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepAlgo_IsValid\n  * wrapname: _wrap_BRepAlgo_IsValid\n  * fulldecl: Standard_Boolean BRepAlgo::IsValid(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT bool _wrap_BRepAlgo_IsTopologicallyValid (TopoDS_Shape *larg1) {
  bool lresult = (bool)0 ;
  TopoDS_Shape *arg1 = 0 ;
  Standard_Boolean result;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        result = (Standard_Boolean)BRepAlgo::IsTopologicallyValid((TopoDS_Shape const &)*arg1);
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: BRepAlgo_IsTopologicallyValid\n  * wrapname: _wrap_BRepAlgo_IsTopologicallyValid\n  * fulldecl: Standard_Boolean BRepAlgo::IsTopologicallyValid(TopoDS_Shape const &)";
        signal_lisp_error(message.c_str());
      }
    }
    lresult = (bool)result;
    return lresult;
  } catch (...) {
    return (bool)0;
  }
}


EXPORT void _wrap_delete_BRepAlgo (BRepAlgo *larg1) {
  BRepAlgo *arg1 = (BRepAlgo *) 0 ;
  
  arg1 = larg1;
  try {
    {
      try
      {
        OCC_CATCH_SIGNALS
        delete arg1;
      }
      catch(Standard_Failure const& error)
      {
        char *error_name = (char*) error.DynamicType()->Name();
        char *error_message = (char*) error.GetMessageString();
        std::string message;
        if (error_name) message += std::string(error_name) + "\n";
        if (error_message) message += std::string(error_message);
        // log SWIG specific debug information
        message += "\nwrapper details:\n  * symname: delete_BRepAlgo\n  * wrapname: _wrap_delete_BRepAlgo\n  * fulldecl: BRepAlgo::~BRepAlgo()";
        signal_lisp_error(message.c_str());
      }
    }
    
  } catch (...) {
    
  }
}


