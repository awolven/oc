(in-package :gp)

(defun mat2d (&rest args)
  (let* ((pointer (foreign-alloc 'gp-mat2d))
	 (struct (make-mat2d :ptr pointer)))
    (cond ((null args)
	   (setf (mem-aref pointer :double 0) 0.0d0
		 (mem-aref pointer :double 1) 0.0d0
		 (mem-aref pointer :double 2) 0.0d0
		 (mem-aref pointer :double 3) 0.0d0))

	  ((and (cdr args) (xy-p (car args)) (xy-p (cadr args))
		(null (cddr args)))
	   (let ((p-col1 (ptr (car args)))
		 (p-col2 (ptr (cadr args))))
	     (setf (mem-aref pointer :double 0) (gp-xy-x p-col1)
		   (mem-aref pointer :double 1) (gp-xy-x p-col2)
		   (mem-aref pointer :double 2) (gp-xy-y p-col1)
		   (mem-aref pointer :double 3) (gp-xy-y p-col2))))

	  (t (destructuring-bind (&key col1 col2) args
	       (cond ((and (xy-p col1) (xy-p col2))
		      (let ((p-col1 (ptr col1))
			    (p-col2 (ptr col2)))
			(setf (mem-aref pointer :double 0) (gp-xy-x p-col1)
			      (mem-aref pointer :double 1) (gp-xy-x p-col2)
			      (mem-aref pointer :double 2) (gp-xy-y p-col1)
			      (mem-aref pointer :double 3) (gp-xy-y p-col2))))))))

    (finalize struct (lambda () (foreign-free pointer)) :dont-save t)
    struct))

(declaim (inline gp-mat2d-get-value2))
(defun gp-mat2d-get-value2 (p-mat row col)
  (let ((offset (+ (* (1- row) 2) (1- col))))
    (mem-aref p-mat :double offset)))

(defmethod gp:get-value2 ((mat mat2d) (row integer) (col integer))
  (assert (and (<= 1 row 2) (<= 1 col 2)))
  (gp-mat2d-get-value2 (ptr mat) row col))

(defmethod oc:get-value2 ((mat mat2d) (row integer) (col integer))
  (oc::_wrap_gp_Mat2d_Value (ptr mat) row col))

(defmethod gp:set-value2 ((mat mat2d) (row integer) (col integer) (value real))
  (assert (and (<= 1 row 2) (<= 1 col 2)))
  (let ((offset (+ (* (1- row) 2) (1- col)))
	(dval (coerce value 'double-float)))
    (setf (mem-aref (ptr mat) :double offset) dval)
    dval))

(defmethod oc:set-value2 ((mat mat2d) (row integer) (col integer) (value real))
  (let ((result (coerce value 'double-float)))
    (oc::_wrap_gp_Mat2d_SetValue (ptr mat) row col result)
    result))

(defmethod (setf gp:diagonal) ((xy xy) (matrix mat2d))
  (let ((p (ptr matrix))
	(p-xy (ptr xy)))
    (setf (mem-aref p :double 0) (gp-xy-x p-xy)
	  (mem-aref p :double 3) (gp-xy-y p-xy))
    xy))

(defmethod (setf oc:diagonal) ((xy xy) (matrix mat2d))
  (let ((p-xy (ptr xy)))
    (oc::_wrap_gp_Mat2d_SetDiagonal (ptr matrix) (gp-xy-x p-xy) (gp-xy-y p-xy))
    xy))

(declaim (inline gp-mat2d-identity!))
(defun gp-mat2d-identity! (p)
  (setf (mem-aref p :double 0) 1.0d0
	(mem-aref p :double 1) 0.0d0
	(mem-aref p :double 2) 0.0d0
	(mem-aref p :double 3) 1.0d0))

(defmethod gp:identity! ((mat mat2d))
  (gp-mat2d-identity! (ptr mat))
  (values))

(defmethod oc:identity! ((mat mat2d))
  (oc::_wrap_gp_Mat2d_SetIdentity (ptr mat)))

(declaim (inline gp-mat2d-rotate!))
(defun gp-mat2d-rotate! (p ang)
  (let ((sin (sin ang))
	(cos (cos ang)))
    (setf (mem-aref p :double 0) cos
	  (mem-aref p :double 1) (- sin)
	  (mem-aref p :double 2) sin
	  (mem-aref p :double 3) cos)
    ang))

(defmethod (setf gp:rotation) ((ang real) (matrix mat2d))
  (let ((p (ptr matrix)))
    (gp-mat2d-rotate! p ang)))

(defmethod (setf oc:rotation) ((ang real) (matrix mat2d))
  (let ((dval (coerce ang 'double-float)))
    (oc::_wrap_gp_Mat2d_SetRotation (ptr matrix) dval)
    dval))    

(defmethod (setf gp:scale) ((s real) (matrix mat2d))
  (let ((p (ptr matrix))
	(scale (coerce s 'double-float)))
    (setf (mem-aref p :double 0) scale
	  (mem-aref p :double 1) 0.0d0
	  (mem-aref p :double 2) 0.0d0
	  (mem-aref p :double 3) scale)
    (values)))

(defmethod (setf oc:scale) ((s real) (matrix mat2d))
  (let ((dval (coerce s 'double-float)))
    (oc::_wrap_gp_Mat2d_SetScale (ptr matrix) dval)
    dval))

(declaim (inline gp-mat2d-determinant))
(defun gp-mat2d-determinant (p)
  (- (* (mem-aref p :double 0)
	(mem-aref p :double 3))
     (* (mem-aref p :double 2)
	(mem-aref p :double 1))))

(defmethod gp:determinant ((matrix mat2d))
  (gp-mat2d-determinant (ptr matrix)))

(defmethod oc:determinant ((matrix mat2d))
  (oc::_wrap_gp_Mat2d_Determinant (ptr matrix)))

(defmethod (setf gp:column) ((xy xy) (matrix mat2d) (index integer))
  (assert (<= 1 index 2))
  (let ((p-xy (ptr xy))
	(p-mat (ptr matrix)))
    (setf (mem-aref p-mat :double (- index 1)) (gp-xy-x p-xy)
	  (mem-aref p-mat :double (+ index 1)) (gp-xy-y p-xy))
    xy))

(defmethod (setf oc:column) ((xy xy) (matrix mat2d) (index integer))
  (oc::_wrap_gp_Mat2d_SetCol (ptr matrix) index (ptr xy))
  xy)

(defmethod (setf gp:row) ((xy xy) (matrix mat2d) (index integer))
  (assert (<= 1 index 2))
  (let ((p-xy (ptr xy))
	(p-mat (ptr matrix)))
    (if (eq index 1)
	(setf (mem-aref p-mat :double (- index 1)) (gp-xy-x p-xy)
	      (mem-aref p-mat :double index) (gp-xy-y p-xy))
	(setf (mem-aref p-mat :double index) (gp-xy-x p-xy)
	      (mem-aref p-mat :double (+ index 1)) (gp-xy-y p-xy)))
    (values)))

(defmethod (setf oc:row) ((xy xy) (matrix mat2d) (index integer))
  (oc::_wrap_gp_Mat2d_SetRow (ptr matrix) index (ptr xy))
  xy)

(defmethod gp:column ((matrix mat2d) (index integer))
  (assert (<= 1 index 2))
  (if (eq index 1)
      (xy (mem-aref (ptr matrix) :double 0)
	  (mem-aref (ptr matrix) :double 2))
      (xy (mem-aref (ptr matrix) :double 1)
	  (mem-aref (ptr matrix) :double 3))))

(defmethod oc:column ((matrix mat2d) (index integer))
  (let* ((p-result (oc::_wrap_gp_Mat2d_Column (ptr matrix) index))
	 (result (make-xy :ptr p-result)))
    (finalize result (lambda () (oc::_wrap_delete_gp_XY p-result)) :dont-save t)
    result))

(defmethod gp:diagonal ((matrix mat2d))
  (xy (mem-aref (ptr matrix) :double 0)
      (mem-aref (ptr matrix) :double 3)))

(defmethod oc:diagonal ((matrix mat2d))
  (let* ((p-result (oc::_wrap_gp_Mat2d_Diagonal (ptr matrix)))
	 (result (make-xy :ptr p-result)))
    (finalize result (lambda () (oc::_wrap_delete_gp_XY p-result)) :dont-save t)
    result))

(defmethod gp:row ((matrix mat2d) (index integer))
  (assert (<= 1 index 2))
  (if (eq index 1)
      (xy (mem-aref (ptr matrix) :double 0)
	  (mem-aref (ptr matrix) :double 1))
      (xy (mem-aref (ptr matrix) :double 2)
	  (mem-aref (ptr matrix) :double 3))))

(defmethod oc:row ((matrix mat2d) (index integer))
  (let* ((p-result (oc::_wrap_gp_Mat2d_Row (ptr matrix) index))
	 (result (make-xy :ptr p-result)))
    (finalize result (lambda () (oc::_wrap_delete_gp_XY p-result)) :dont-save t)
    result))
  
(defmethod gp:invert! ((mat mat2d))
  (let ((n00)
	(n01)
	(n10)
	(n11)
	(p (ptr mat)))
    (setq n00 (mem-aref p :double 3)
	  n01 (- (mem-aref p :double 1))
	  n10 (- (mem-aref p :double 2))
	  n11 (mem-aref p :double 0))
    (let ((det (- (* n00 n11) (* n01 n10))))
      (assert (> (abs det) +resolution+))
      (setq det (/ 1.0d0 det))
      (setf (mem-aref p :double 0) (* n00 det)
	    (mem-aref p :double 1) (* n01 det)
	    (mem-aref p :double 2) (* n10 det)
	    (mem-aref p :double 3) (* n11 det))
      (values))))

(defmethod oc:invert! ((mat mat2d))
  (oc::_wrap_gp_Mat2d_Invert (ptr mat)))

(defmethod gp:copy ((matrix mat2d))
  (let* ((p-src (ptr matrix))
	 (p-dst (foreign-alloc 'gp-mat2d))
	 (new-mat (make-mat2d :ptr p-dst)))
    (setf (mem-aref p-dst :double 0) (mem-aref p-src :double 0)
	  (mem-aref p-dst :double 1) (mem-aref p-src :double 1)
	  (mem-aref p-dst :double 2) (mem-aref p-src :double 2)
	  (mem-aref p-dst :double 3) (mem-aref p-src :double 3))
    (finalize new-mat (lambda () (foreign-free p-dst)) :dont-save t)
    new-mat))

(defmethod gp:exponentiate! ((mat mat2d) (power integer))
  ;; suspect.
  (case power
    (1 (values))
    (0 (gp-mat2d-identity! (ptr mat)))
    (-1 (oc:invert! mat))
    (t (when (minusp power)
	 (oc:invert! mat))
       (let ((count (1- (abs power)))
	     (temp (oc:copy mat)))
	 (loop
	    when (oddp count)
	    do (oc:multiply! mat temp)
	    when (eq count 1)
	    do (return (values))
	    when (evenp count)
	    do (oc:multiply! temp temp)
	      (setq count (/ count 2)))))))

(defmethod oc:exponentiate! ((mat mat2d) (power integer))
  (oc::_wrap_gp_Mat2d_Power (ptr mat) power))

(defmethod gp:singular? ((mat mat2d))
  (<= (abs (gp-mat2d-determinant (ptr mat))) +resolution+))

(defmethod oc:singular? ((mat mat2d))
  (oc::_wrap_gp_Mat2d_IsSingular (ptr mat)))

(defmethod gp:add! ((mat1 mat2d) (mat2 mat2d))
  (let ((p1 (ptr mat1))
	(p2 (ptr mat2)))
    (setf (mem-aref p1 :double 0) (+ (mem-aref p1 :double 0) (mem-aref p2 :double 0))
	  (mem-aref p1 :double 1) (+ (mem-aref p1 :double 1) (mem-aref p2 :double 1))
	  (mem-aref p1 :double 2) (+ (mem-aref p1 :double 2) (mem-aref p2 :double 2))
	  (mem-aref p1 :double 3) (+ (mem-aref p1 :double 3) (mem-aref p2 :double 3)))
    (values)))

(defmethod oc:add! ((mat1 mat2d) (mat2 mat2d))
  (oc::_wrap_gp_Mat2d_Add (ptr mat1) (ptr mat2)))

(defmethod gp:added ((mat1 mat2d) (mat2 mat2d))
  (let ((p1 (ptr mat1))
	(p2 (ptr mat2))
	(p3 (foreign-alloc 'gp-mat2d)))
    (setf (mem-aref p3 :double 0) (+ (mem-aref p1 :double 0) (mem-aref p2 :double 0))
	  (mem-aref p3 :double 1) (+ (mem-aref p1 :double 1) (mem-aref p2 :double 1))
	  (mem-aref p3 :double 2) (+ (mem-aref p1 :double 2) (mem-aref p2 :double 2))
	  (mem-aref p3 :double 3) (+ (mem-aref p1 :double 3) (mem-aref p2 :double 3)))
    (let ((result (make-mat2d :ptr p3)))
      (finalize result (lambda () (foreign-free p3)) :dont-save t)
      result)))

(defmethod oc:added ((mat1 mat2d) (mat2 mat2d))
  (let* ((p-result (oc::_wrap_gp_Mat2d_Added (ptr mat1) (ptr mat2)))
	 (result (make-mat2d :ptr p-result)))
    (finalize result (lambda () (oc::_wrap_delete_gp_Mat2d p-result)) :dont-save t)
    result))

(defmethod gp:divide! ((mat mat2d) (scalar real))
  (let ((p1 (ptr mat))
	(divisor (coerce scalar 'double-float)))
    (setf (mem-aref p1 :double 0) (/ (mem-aref p1 :double 0) divisor)
	  (mem-aref p1 :double 1) (/ (mem-aref p1 :double 1) divisor)
	  (mem-aref p1 :double 2) (/ (mem-aref p1 :double 2) divisor)
	  (mem-aref p1 :double 3) (/ (mem-aref p1 :double 3) divisor))
    (values)))

(defmethod oc:divide! ((mat mat2d) (scalar real))
  (oc::_wrap_gp_Mat2d_Divide (ptr mat) (coerce scalar 'double-float)))

(defmethod oc:divided ((mat mat2d) (scalar real))
  (let ((p1 (ptr mat))
	(p2 (foreign-alloc 'gp-mat2d))
	(divisor (coerce scalar 'double-float)))
    (setf (mem-aref p2 :double 0) (/ (mem-aref p1 :double 0) divisor)
	  (mem-aref p2 :double 1) (/ (mem-aref p1 :double 1) divisor)
	  (mem-aref p2 :double 2) (/ (mem-aref p1 :double 2) divisor)
	  (mem-aref p2 :double 3) (/ (mem-aref p1 :double 3) divisor))
    (let ((result (make-mat2d :ptr p2)))
      (finalize result (lambda () (foreign-free p2)) :dont-save t)
      result)))

(defmethod oc:divided ((mat mat2d) (scalar real))
  (let* ((p-result (oc::_wrap_gp_Mat2d_Divided (ptr mat) (coerce scalar 'double-float)))
	 (result (make-mat2d :ptr p-result)))
    (finalize result (lambda () (oc::_wrap_delete_gp_Mat2d p-result)) :dont-save t)
    result))

(defmethod gp:inverted ((mat mat2d))
  (let ((new-mat (gp:copy mat)))
    (gp:invert! new-mat)
    new-mat))

(defmethod oc:inverted ((mat mat2d))
  (let* ((p-result (oc::_wrap_gp_Mat2d_Inverted (ptr mat)))
	 (result (make-mat2d :ptr p-result)))
    (finalize result (lambda () (oc::_wrap_delete_gp_Mat2d p-result)) :dont-save t)
    result))

(defmethod gp:multiply! ((mat mat2d) (other mat2d))
  (let ((p1 (ptr mat))
	(p2 (ptr other)))
    (let ((m00 (mem-aref p1 :double 0))
	  (m01 (mem-aref p1 :double 1))
	  (m10 (mem-aref p1 :double 2))
	  (m11 (mem-aref p1 :double 3))
	  (o00 (mem-aref p2 :double 0))
	  (o01 (mem-aref p2 :double 1))
	  (o10 (mem-aref p2 :double 2))
	  (o11 (mem-aref p2 :double 3)))
      (let ((t00 (+ (* m00 o00) (* m01 o10)))
	    (t10 (+ (* m10 o00) (* m11 o10))))
	(setf (mem-aref p1 :double 1) (+ (* m00 o01) (* m01 o11))
	      (mem-aref p1 :double 3) (+ (* m10 o01) (* m11 o11))
	      (mem-aref p1 :double 0) t00
	      (mem-aref p1 :double 2) t10)
	(values)))))

(defmethod oc:multiply! ((mat mat2d) (other mat2d))
  (oc::_wrap_gp_Mat2d_Multiply__SWIG_0 (ptr mat) (ptr other)))

(defmethod gp:multiplied ((mat mat2d) (other mat2d))
  (let ((result (gp:copy mat)))
    (gp:multiply! result other)
    result))

(defmethod oc:multiplied ((mat mat2d) (other mat2d))
  (let* ((p-result (oc::_wrap_gp_Mat2d_Multiplied__SWIG_0 (ptr mat) (ptr other)))
	 (result (make-mat2d :ptr p-result)))
    (finalize result (lambda () (oc::_wrap_delete_gp_Mat2d p-result)) :dont-save t)
    result))

(defmethod gp:pre-multiply! ((mat mat2d) (other mat2d))
  (let ((p1 (ptr mat))
	(p2 (ptr other)))
    (let ((m00 (mem-aref p1 :double 0))
	  (m01 (mem-aref p1 :double 1))
	  (m10 (mem-aref p1 :double 2))
	  (m11 (mem-aref p1 :double 3))
	  (o00 (mem-aref p2 :double 0))
	  (o01 (mem-aref p2 :double 1))
	  (o10 (mem-aref p2 :double 2))
	  (o11 (mem-aref p2 :double 3)))
      (let ((t00 (+ (* o00 m00) (* o01 m10)))
	    (t01 (+ (* o10 m00) (* o11 m10))))
	(setf (mem-aref p1 :double 1) (+ (* o00 m01) (* o01 m11))
	      (mem-aref p1 :double 3) (+ (* o10 m01) (* o11 m11))
	      (mem-aref p1 :double 0) t00
	      (mem-aref p1 :double 2) t01)
	(values)))))

(defmethod oc:pre-multiply! ((mat mat2d) (other mat2d))
  (oc::_wrap_gp_Mat2d_PreMultiply (ptr mat) (ptr other)))

(defmethod gp:multiplied ((mat mat2d) (scalar real))
  (let* ((result (oc:copy mat))
	 (p-result (ptr result))
	 (multiplier (coerce scalar 'double-float)))
    (setf (mem-aref p-result :double 0) (* (mem-aref p-result :double 0) multiplier)
	  (mem-aref p-result :double 1) (* (mem-aref p-result :double 1) multiplier)
	  (mem-aref p-result :double 2) (* (mem-aref p-result :double 2) multiplier)
	  (mem-aref p-result :double 3) (* (mem-aref p-result :double 3) multiplier))
    result))

(defmethod oc:multiplied ((mat mat2d) (scalar real))
  (let* ((p-result (oc::_wrap_gp_Mat2d_Multiplied__SWIG_1 (ptr mat) (coerce scalar 'double-float)))
	 (result (make-mat2d :ptr p-result)))
    (finalize result (lambda () (oc::_wrap_delete_gp_Mat2d p-result)) :dont-save t)
    result))

(defmethod gp:multiply! ((mat mat2d) (scalar real))
  (let ((p (ptr mat))
	(multiplier (coerce scalar 'double-float)))
    (setf (mem-aref p :double 0) (* (mem-aref p :double 0) multiplier)
	  (mem-aref p :double 1) (* (mem-aref p :double 1) multiplier)
	  (mem-aref p :double 2) (* (mem-aref p :double 2) multiplier)
	  (mem-aref p :double 3) (* (mem-aref p :double 3) multiplier))
    (values)))

(defmethod oc:multiply! ((mat mat2d) (scalar real))
  (oc::_wrap_gp_Mat2d_Multiply__SWIG_1 (ptr mat) (coerce scalar 'double-float)))

(defmethod gp:exponentiated ((mat mat2d) (power integer))
  (let* ((result (gp:copy mat)))
    (gp:exponentiate! result power)
    result))

(defmethod oc:exponentiated ((mat mat2d) (power integer))
  (let* ((p-result (oc::_wrap_gp_Mat2d_Powered (ptr mat) power))
	 (result (make-mat2d :ptr p-result)))
    (finalize result (lambda () (oc::_wrap_delete_gp_Mat2d p-result)) :dont-save t)
    result))

(defmethod gp:subtract! ((mat1 mat2d) (mat2 mat2d))
  (let ((p1 (ptr mat1))
	(p2 (ptr mat2)))
    (setf (mem-aref p1 :double 0) (- (mem-aref p1 :double 0) (mem-aref p2 :double 0))
	  (mem-aref p1 :double 1) (- (mem-aref p1 :double 1) (mem-aref p2 :double 1))
	  (mem-aref p1 :double 2) (- (mem-aref p1 :double 2) (mem-aref p2 :double 2))
	  (mem-aref p1 :double 3) (- (mem-aref p1 :double 3) (mem-aref p2 :double 3)))
    (values)))

(defmethod oc:subtract! ((mat1 mat2d) (mat2 mat2d))
  (oc::_wrap_gp_Mat2d_Subtract (ptr mat1) (ptr mat2)))

(defmethod gp:subtracted ((mat1 mat2d) (mat2 mat2d))
  (let ((p1 (ptr mat1))
	(p2 (ptr mat2))
	(p3 (foreign-alloc 'gp-mat2d)))
    (setf (mem-aref p3 :double 0) (- (mem-aref p1 :double 0) (mem-aref p2 :double 0))
	  (mem-aref p3 :double 1) (- (mem-aref p1 :double 1) (mem-aref p2 :double 1))
	  (mem-aref p3 :double 2) (- (mem-aref p1 :double 2) (mem-aref p2 :double 2))
	  (mem-aref p3 :double 3) (- (mem-aref p1 :double 3) (mem-aref p2 :double 3)))
    (let ((result (make-mat2d :ptr p3)))
      (finalize result (lambda () (foreign-free p3)) :dont-save t)
      result)))

(defmethod oc:subtracted ((mat1 mat2d) (mat2 mat2d))
  (let* ((p-result (oc::_wrap_gp_Mat2d_Subtracted (ptr mat1) (ptr mat2)))
	 (result (make-mat2d :ptr p-result)))
    (finalize result (lambda () (oc::_wrap_delete_gp_Mat2d p-result)) :dont-save t)
    result))

(defmethod gp:transpose! ((mat mat2d))
  (let* ((p (ptr mat))
	 (temp (mem-aref p :double 1)))
    (setf (mem-aref p :double 1) (mem-aref p :double 2)
	  (mem-aref p :double 2) temp)
    (values)))

(defmethod oc:transpose! ((mat mat2d))
  (oc::_wrap_gp_Mat2d_Transpose (ptr mat)))

(defmethod gp:transposed ((mat mat2d))
  (let* ((p-result (foreign-alloc 'gp-mat2d))
	 (p-mat (ptr mat)))
    (setf (mem-aref p-result :double 0) (mem-aref p-mat :double 0)
	  (mem-aref p-result :double 1) (mem-aref p-mat :double 2)
	  (mem-aref p-result :double 2) (mem-aref p-mat :double 1)
	  (mem-aref p-result :double 3) (mem-aref p-mat :double 3))
    (let ((result (make-mat2d :ptr p-result)))
      (finalize result (lambda () (foreign-free p-result)) :dont-save t)
      result)))

(defmethod oc:transposed ((mat mat2d))
  (let* ((p-result (oc::_wrap_gp_Mat2d_Transposed (ptr mat)))
	 (result (make-mat2d :ptr p-result)))
    (finalize result (lambda () (oc::_wrap_delete_gp_Mat2d p-result)) :dont-save t)
    result))

(defmethod print-object ((object mat2d) stream)
  (format stream "(~S ~S ~S)" (type-of object)
	  (oc:column object 1)
	  (oc:column object 2)))

(defmethod gp:location ((ax2d ax2d))
  (make-pnt2d :ptr (ptr ax2d) :own ax2d))
