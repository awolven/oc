(in-package :gp)

(defun pln (&rest args &key ax3 P V A B C D)
  (let ((pln-ptr (foreign-alloc '(:struct gp-pln))))
    (flet ((copy-ax3-into-pln (ax3-ptr pln-ptr)
	     (setf (gp-pln-pos-axis-loc-coord-x pln-ptr) (gp-ax3-axis-loc-coord-x ax3-ptr)
		   (gp-pln-pos-axis-loc-coord-y pln-ptr) (gp-ax3-axis-loc-coord-y ax3-ptr)
		   (gp-pln-pos-axis-loc-coord-z pln-ptr) (gp-ax3-axis-loc-coord-z ax3-ptr)
		   
		   (gp-pln-pos-axis-vdir-coord-x pln-ptr) (gp-ax3-axis-vdir-coord-x ax3-ptr)
		   (gp-pln-pos-axis-vdir-coord-y pln-ptr) (gp-ax3-axis-vdir-coord-y ax3-ptr)
		   (gp-pln-pos-axis-vdir-coord-z pln-ptr) (gp-ax3-axis-vdir-coord-z ax3-ptr)
		   
		   (gp-pln-pos-vydir-coord-x pln-ptr) (gp-ax3-vydir-coord-x ax3-ptr)
		   (gp-pln-pos-vydir-coord-y pln-ptr) (gp-ax3-vydir-coord-y ax3-ptr)
		   (gp-pln-pos-vydir-coord-z pln-ptr) (gp-ax3-vydir-coord-z ax3-ptr)
		   
		   (gp-pln-pos-vxdir-coord-x pln-ptr) (gp-ax3-vxdir-coord-x ax3-ptr)
		   (gp-pln-pos-vxdir-coord-y pln-ptr) (gp-ax3-vxdir-coord-y ax3-ptr)
		   (gp-pln-pos-vxdir-coord-z pln-ptr) (gp-ax3-vxdir-coord-z ax3-ptr))))
  
    (cond ((and ax3 (not (or P V A B C D)))
	   (let ((ax3-ptr (ptr ax3)))
	     (copy-ax3-into-pln ax3-ptr pln-ptr)))
	
	  ((and P V (not (or ax3 A B C D)))
	   (let ((pos))
	     (setq A (x V)
		   B (y V)
		   C (z V))
	     (let ((A-abs (abs A))
		   (B-abs (abs B))
		   (C-abs (abs C)))
	       (if (and (<= B-abs A-abs) (<= B-abs C-abs))
		   (if (> A-abs C-abs)
		       (setq pos (ax3 :P P :N V :Vx (dir (- C) 0.0d0 A)))
		       (setq pos (ax3 :P P :N V :Vx (dir C 0.0d0 (- A)))))
		   (if (and (<= A-abs B-abs) (<= A-abs C-abs))
		       (if (> B-abs C-abs)
			   (setq pos (ax3 :P P :N V :Vx (dir 0.0d0 (- C) B)))
			   (setq pos (ax3 :P P :N V :Vx (dir 0.0d0 C (- B)))))
		       (if (> A-abs B-abs)
			   (setq pos (ax3 :P P :N V :Vx (dir (- B) A 0.0d0)))
			   (setq pos (ax3 :P P :N V :Vx (dir B (- A) 0.0d0))))))

	       (copy-ax3-into-pln (ptr pos) pln-ptr))))
	  ((and A B C D (not (or ax3 P V)))
	   (let ((A-abs (abs A))
		 (B-abs (abs B))
		 (C-abs (abs C))
		 (pos))
	     (if (and (<= B-abs A-abs) (<= B-abs C-abs))
		 (if (> A-abs C-abs)
		     (setq pos (ax3 :P (pnt (- (/ D A)) 0.0d0 0.0d0)
				    :N (dir A B C)
				    :Vx (dir (- C) 0.0d0 A)))
		     (setq pos (ax3 :P (pnt 0.0d0 0.0d0 (- (/ D C)))
				    :N (dir A B C)
				    :Vx (dir (- C) 0.0d0 A))))
		 (if (and (<= A-abs B-abs) (<= A-abs C-abs))
		     (if (> B-abs C-abs)
			 (setq pos (ax3 :P (pnt 0.0d0 (- (/ D B)) 0.0d0)
					:N (dir A B C)
					:Vx (dir 0.0d0 (- C) B)))
			 (setq pos (ax3 :P (pnt 0.0d0 0.0d0 (- (/ D C)))
					:N (dir A B C)
					:Vx (dir 0.0d0 C (- B)))))
		     (if (> A-abs B-abs)
			 (setq pos (ax3 :P (pnt (- (/ D A)) 0.0d0 0.0d0)
					:N (dir A B C)
					:Vx (dir (- B) A 0.0d0)))
			 (setq pos (ax3 :P (pnt 0.0d0 (- (/ D B)) 0.0d0)
					:N (dir A B C)
					:Vx (dir B (- A) 0.0d0))))))
	     (copy-ax3-into-pln (ptr pos) pln-ptr)))
	  (t "Invalid arguments to pln: ~S" args)))
    (let ((struct (make-pln :ptr pln-ptr)))
      (oc:finalize struct :native)
      struct)))


(defmethod pos ((pln pln))
  (make-ax3 :ptr (ptr pln) :own pln))

(defmethod gp:position ((pln pln))
  (make-ax3 :ptr (ptr pln) :own pln))

(defun gp:coefficients (pln)
  (let* ((pos (oc:position pln))
	 (dir (oc:direction pos))
	 (a) (b) (c) (d))
    (if (gp:direct? pos)
	(setq a (x dir)
	      b (y dir)
	      c (z dir))
	(setq a (- (x dir))
	      b (- (y dir))
	      c (- (z dir))))
    (let ((p (oc:location pos)))
      (setq d (- (+ (* a (x p)) (* b (y p)) (* c (z p))))))
    (values a b c d)))
