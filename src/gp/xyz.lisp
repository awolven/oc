(in-package :gp)

(defun xyz (&optional (x 0.0d0) (y 0.0d0) (z 0.0d0))
  (let* ((pointer (foreign-alloc '(:struct gp-xyz)))
	 (struct (make-xyz :ptr pointer)))
    (setf (gp-xy-x pointer) (coerce x 'double-float)
	  (gp-xy-y pointer) (coerce y 'double-float)
	  (gp-xyz-z pointer) (coerce z 'double-float))
    (finalize struct (lambda () (print 'freeing-xyz) (foreign-free pointer)) :dont-save t)
    struct))

(defmethod print-object ((object xyz) stream)
  (format stream "(~S ~A ~A ~A)" (type-of object) (x object) (y object) (z object)))

(defmethod gp:coord ((xyz xyz))
  xyz)

(declaim (inline gp-xyz-set-coord))
(defun gp-xyz-set-coord (p-src p-dst)
  (setf (gp-xy-x p-dst) (gp-xy-x p-src)
	(gp-xy-y p-dst) (gp-xy-y p-src)
	(gp-xyz-z p-dst) (gp-xyz-z p-src))
  (values))

(defmethod (setf gp:coord) ((src xyz) (dst xyz))
  (let ((p-src (ptr src))
	(p-dst (ptr dst)))
    (gp-xyz-set-coord p-src p-dst)
    dst))

(defmethod x ((xyz xyz))
  (gp-xy-x (ptr xyz)))

(defmethod y ((xyz xyz))
  (gp-xy-y (ptr xyz)))

(defmethod z ((xyz xyz))
  (gp-xyz-z (ptr xyz)))

(defmethod (setf x) ((x real) (xyz xyz))
  (setf (gp-xy-x (ptr xyz)) (coerce x 'double-float)))

(defmethod (setf y) ((y real) (xyz xyz))
  (setf (gp-xy-y (ptr xyz)) (coerce y 'double-float)))

(defmethod (setf z) ((z real) (xyz xyz))
  (setf (gp-xyz-z (ptr xyz)) (coerce z 'double-float)))

(declaim (inline gp-xyz-square-modulus))
(defun gp-xyz-square-modulus (p-xyz)
  (let* ((x (gp-xy-x p-xyz))
	 (y (gp-xy-y p-xyz))
	 (z (gp-xyz-z p-xyz)))
    (print (+ (* x x)  (* y y) (* z z)))))

(defmethod gp:square-modulus ((xyz xyz))
  (gp-xyz-square-modulus (ptr xyz)))

(defmethod oc:square-modulus ((xyz xyz))
  (oc::_wrap_gp_XYZ_SquareModulus (ptr xyz)))

(defmethod gp:modulus ((xyz xyz))
  (sqrt (gp-xyz-square-modulus (ptr xyz))))

(defmethod oc:modulus ((xyz xyz))
  (oc::_wrap_gp_XYZ_Modulus (ptr xyz)))

(defmethod gp:equal? ((xyz1 xyz) (xyz2 xyz) &rest args
		      &key (tolerance 1.0d-36)
			&allow-other-keys)
  (declare (ignore args))
  (let ((p1 (ptr xyz1))
	(p2 (ptr xyz2))
	(tol (coerce tolerance 'double-float)))
    (and (<= (abs (- (gp-xy-x p1) (gp-xy-x p2))) tol)
	 (<= (abs (- (gp-xy-y p1) (gp-xy-y p2))) tol)
	 (<= (abs (- (gp-xyz-z p1) (gp-xyz-z p2))) tol))))

(defmethod oc:equal? ((xyz1 xyz) (xyz2 xyz) &rest args
		      &key (tolerance 1.0d-36)
			&allow-other-keys)
  (declare (ignore args))
  (oc::_wrap_gp_XYZ_IsEqual (ptr xyz1) (ptr xyz2) (coerce tolerance 'double-float)))

(declaim (inline gp-xy-add!))
(defun gp-xyz-add! (p1 p2)
  (setf (gp-xy-x p1) (+ (gp-xy-x p1) (gp-xy-x p2))
	(gp-xy-y p1) (+ (gp-xy-y p1) (gp-xy-y p2))
	(gp-xyz-z p1) (+ (gp-xyz-z p1) (gp-xyz-z p2)))
  (values))

(defmethod gp:add! ((xyz1 xyz) (xyz2 xyz))
  (gp-xyz-add! (ptr xyz1) (ptr xyz2)))

(defmethod oc:add! ((xyz1 xyz) (xyz2 xyz))
  (oc::_wrap_gp_XYZ_Add (ptr xyz1) (ptr xyz2)))

(declaim (inline gp-xyz-added))
(defun gp-xyz-added (p1 p2 result-constructor result-foreign-type)
  (let* ((p3 (foreign-alloc result-foreign-type))
	 (xyz3 (funcall result-constructor :ptr p3)))
    (setf (gp-xy-x p3) (+ (gp-xy-x p1) (gp-xy-x p2))
	  (gp-xy-y p3) (+ (gp-xy-y p1) (gp-xy-y p2))
	  (gp-xyz-z p3) (+ (gp-xyz-z p1) (gp-xyz-z p2)))
    (finalize xyz3 (lambda () (foreign-free p3)) :dont-save t)
    xyz3))

(defmethod gp:added ((xyz1 xyz) (xyz2 xyz))
  (gp-xyz-added (ptr xyz1) (ptr xyz2) #'make-xyz '(:struct gp-xyz)))

(defmethod oc:added ((xyz1 xyz) (xyz2 xyz))
  (let* ((p-result (oc::_wrap_gp_XYZ_Added (ptr xyz1) (ptr xyz2)))
	 (result (make-xyz :ptr p-result)))
    (finalize result (lambda ()
		       (oc::_wrap_delete_gp_XYZ p-result)) :dont-save t)
    result))

(declaim (inline gp-xyz-dot))
(defun gp-xyz-dot (p1 p2)
  (+ (* (gp-xy-x p1) (gp-xy-x p2))
     (* (gp-xy-y p1) (gp-xy-y p2))
     (* (gp-xyz-z p1) (gp-xyz-z p2))))

(defmethod gp:dot ((v1 xyz) (v2 xyz))
  (gp-xyz-dot (ptr v1) (ptr v2)))

(defmethod oc:dot ((xyz1 xyz) (xyz2 xyz))
  (oc::_wrap_gp_XYZ_Dot (ptr xyz1) (ptr xyz2)))

(defmethod gp:cross! ((xyz1 xyz) (xyz2 xyz))
  (let ((p1 (ptr xyz1))
	(p2 (ptr xyz2)))
    (let ((x-result (- (* (gp-xy-y p1) (gp-xyz-z p2))
		       (* (gp-xyz-z p1) (gp-xy-y p2))))
	  (y-result (- (* (gp-xyz-z p1) (gp-xy-x p2))
		       (* (gp-xy-x p1) (gp-xyz-z p2)))))
      (setf (gp-xyz-z p1) (- (* (gp-xy-x p1) (gp-xy-y p2))
			     (* (gp-xy-y p1) (gp-xy-x p2)))
	    (gp-xy-x p1) x-result
	    (gp-xy-y p1) y-result))
    (values)))

(defmethod oc:cross! ((xyz1 xyz) (xyz2 xyz))
  (oc::_wrap_gp_XYZ_Cross (ptr xyz1) (ptr xyz2)))

(declaim (inline gp-xy-crossed))
(defun gp-xyz-crossed (p1 p2 result-constructor result-foreign-type)
  (let* ((p3 (foreign-alloc result-foreign-type))
	 (xyz3 (funcall result-constructor :ptr p3)))
    (setf (gp-xy-x p3) (- (* (gp-xy-y p1) (gp-xyz-z p2))
			  (* (gp-xyz-z p1) (gp-xy-y p2)))
	  (gp-xy-y p3) (- (* (gp-xyz-z p1) (gp-xy-x p2))
			  (* (gp-xy-x p1) (gp-xyz-z p2)))
	  (gp-xyz-z p3) (- (* (gp-xy-x p1) (gp-xy-y p2))
			   (* (gp-xy-y p1) (gp-xy-x p2))))
    (finalize xyz3 (lambda () (foreign-free p3)) :dont-save t)
    xyz3))

(defmethod oc:crossed ((xyz1 xyz) (xyz2 xyz))
  (let ((p1 (ptr xyz1))
	(p2 (ptr xyz2)))
    (gp-xyz-crossed p1 p2 #'make-xyz '(:struct xyz))))

(defmethod oc:crossed ((xyz1 xyz) (xyz2 xyz))
  (let* ((p-result (oc::_wrap_gp_XYZ_Crossed (ptr xyz1) (ptr xyz2)))
	 (result (make-xyz :ptr p-result)))
    (finalize result (lambda ()
		       (oc::_wrap_delete_gp_XYZ p-result)) :dont-save t)
    result))

(declaim (inline gp-xyz-cross-square-magnitude))
(defun gp-xyz-cross-square-magnitude (p1 p2)
  (let ((x1 (gp-xy-x p1))
	(y1 (gp-xy-y p1))
	(z1 (gp-xyz-z p1))
	(x2 (gp-xy-x p2))
	(y2 (gp-xy-y p2))
	(z2 (gp-xyz-z p2)))
    (let ((x-result (- (* y1 z2) (* z1 y2)))
	  (y-result (- (* z1 x2) (* x1 z2)))
	  (z-result (- (* x1 y2) (* y1 x2))))
      (+ (* x-result x-result)
	 (* y-result y-result)
	 (* z-result z-result)))))

(defmethod gp:cross-square-magnitude ((xyz1 xyz) (xyz2 xyz))
  (gp-xyz-cross-square-magnitude (ptr xyz1) (ptr xyz2)))

(defmethod oc:cross-square-magnitude ((xyz1 xyz) (xyz2 xyz))
  (oc::_wrap_gp_XYZ_CrossSquareMagnitude (ptr xyz1) (ptr xyz2)))

(defmethod gp:cross-magnitude ((xyz1 xyz) (xyz2 xyz))
  (sqrt (gp-xyz-cross-square-magnitude (ptr xyz1) (ptr xyz2))))

(defmethod oc:cross-magnitude ((xyz1 xyz) (xyz2 xyz))
  (oc::_wrap_gp_XYZ_CrossMagnitude (ptr xyz1) (ptr xyz2)))

(defun gp-xyz-cross-crossed (p0 p1 p2 p3)
  (let ((x1 (gp-xy-x p1))
	(y1 (gp-xy-y p1))
	(z1 (gp-xyz-z p1))
	(x2 (gp-xy-x p2))
	(y2 (gp-xy-y p2))
	(z2 (gp-xyz-z p2))
	(x3 (gp-xy-x p3))
	(y3 (gp-xy-y p3))
	(z3 (gp-xyz-z p3)))
    (setf (gp-xy-x p0) (- (* y1 (- (* x2 y3) (* y2 x3)))
			  (* z1 (- (* z2 x3) (* x2 z3))))
	  (gp-xy-y p0) (- (* z1 (- (* y2 z3) (* z2 y3)))
			  (* x1 (- (* x2 y3) (* y2 x3))))
	  (gp-xyz-z p0) (- (* x1 (- (* z2 x3) (* x2 z3)))
			   (* y1 (- (* y2 z3) (* z2 y3)))))
    (values)))

(defmethod gp:cross-cross! ((xyz1 xyz) (xyz2 xyz) (xyz3 xyz))
  (gp-xyz-cross-crossed (ptr xyz1) (ptr xyz1) (ptr xyz2) (ptr xyz3)))

(defmethod oc:cross-cross! ((xyz1 xyz) (xyz2 xyz) (xyz3 xyz))
  (oc::_wrap_gp_XYZ_CrossCross (ptr xyz1) (ptr xyz2) (ptr xyz3)))

(defmethod gp:cross-crossed ((xyz1 xyz) (xyz2 xyz) (xyz3 xyz))
  (let* ((p0 (foreign-alloc '(:struct gp-xyz)))
	 (xyz (make-xyz :ptr p0)))
    (gp-xyz-cross-crossed p0 (ptr xyz1) (ptr xyz2) (ptr xyz3))
    (sb-ext:finalize xyz (lambda () (foreign-free p0)) :dont-save t)
    xyz))

(defmethod oc:cross-crossed ((xyz1 xyz) (xyz2 xyz) (xyz3 xyz))
  (let* ((p-result (oc::_wrap_gp_XYZ_CrossCrossed (ptr xyz1) (ptr xyz2) (ptr xyz3)))
	 (result (make-xyz :ptr p-result)))
    (finalize result (lambda ()
		       (oc::_wrap_delete_gp_XYZ p-result)) :dont-save t)
    result))
	     
(defun gp:dot-cross (v0 v1 v2)
  (let ((xresult (- (* (y v1) (z v2)) (* (z v1) (y v2))))
	(yresult (- (* (z v1) (x v2)) (* (x v1) (z v2))))
	(zresult (- (* (x v1) (y v2)) (* (y v1) (x v2)))))
    (+ (* (x v0) xresult) (* (y v0) yresult) (* (z v0) zresult))))

(defmethod oc:dot-cross ((xyz1 xyz) (xyz2 xyz) (xyz3 xyz))
  (oc::_wrap_gp_XYZ_DotCross (ptr xyz1) (ptr xyz2) (ptr xyz3)))

(declaim (inline gp-xyz-divide!))
(defun gp-xyz-divide! (p divisor)
  (declare (type double-float divisor))
  (setf (gp-xy-x p) (/ (gp-xy-x p) divisor)
	(gp-xy-y p) (/ (gp-xy-y p) divisor)
	(gp-xyz-z p) (/ (gp-xyz-z p) divisor))
  (values))

(declaim (inline gp-xyz-normalize!))
(defun gp-xyz-normalize! (p)
  (let ((d (sqrt (gp-xyz-square-modulus p))))
    (assert (> d +resolution+))
    (gp-xyz-divide! p (coerce d 'double-float))))

(defmethod oc:normalize! ((xyz xyz))
  (gp-xyz-normalize! (ptr xyz)))

(declaim (inline xyz-dot))
(defun xyz-dot (xyz1 xyz2)
  (let ((p1 (ptr xyz1))
	(p2 (ptr xyz2)))
    (+ (* (gp-xy-x p1) (gp-xy-x p2))
       (* (gp-xy-y p1) (gp-xy-y p2))
       (* (gp-xyz-z p1) (gp-xyz-z p2)))))
       
(defmethod oc:dot ((xyz1 xyz) (xyz2 xyz))
  (xyz-dot xyz1 xyz2))

(defmethod oc:subtracted ((xyz1 xyz) (xyz2 xyz))
  (let* ((p-result (oc::_wrap_gp_XYZ_Subtracted (ptr xyz1) (ptr xyz2)))
	 (result (make-xyz :ptr p-result)))
    (finalize result (lambda ()
		       (oc::_wrap_delete_gp_XYZ p-result)) :dont-save t)
    result))
